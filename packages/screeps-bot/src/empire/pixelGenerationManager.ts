/**
 * Pixel Generation Manager
 * 
 * Manages automatic pixel generation from CPU bucket when the bucket is full.
 * This converts excess CPU bucket capacity into pixels that can be used or sold.
 * 
 * Key Principles:
 * - Only generate pixels when bucket has been full (10,000) for 25+ consecutive ticks
 * - This ensures we have sustained CPU surplus before converting to pixels
 * - Generation costs 10,000 CPU from bucket per pixel
 * - Low priority operation - only runs when bot is performing well
 * 
 * Addresses Issue: Reimplement pixel generation when bucket is full for 25+ ticks
 */

import { LowFrequencyProcess, ProcessClass } from "../core/processDecorators";
import { ProcessPriority } from "../core/kernel";
import { logger } from "../core/logger";

/**
 * Pixel Generation Manager Configuration
 */
export interface PixelGenerationConfig {
  /** Enable/disable pixel generation */
  enabled: boolean;
  /** Number of consecutive ticks bucket must be full before generating */
  fullBucketTicksRequired: number;
  /** Maximum bucket level (Game.cpu.bucketMax or 10000) */
  bucketMax: number;
  /** CPU cost per pixel generation */
  cpuCostPerPixel: number;
  /** Minimum bucket level after generation (safety margin) */
  minBucketAfterGeneration: number;
}

const DEFAULT_CONFIG: PixelGenerationConfig = {
  enabled: true,
  fullBucketTicksRequired: 25,
  bucketMax: 10000,
  cpuCostPerPixel: 10000,
  minBucketAfterGeneration: 0 // Will be at 0 after generation, which is acceptable
};

/**
 * Pixel generation memory state
 */
export interface PixelGenerationMemory {
  /** Tick when bucket first became full in current streak */
  bucketFullSince: number;
  /** Total pixels generated by this manager */
  totalPixelsGenerated: number;
  /** Last tick when a pixel was generated */
  lastGenerationTick: number;
  /** Number of consecutive ticks bucket has been full */
  consecutiveFullTicks: number;
}

/**
 * Create default pixel generation memory
 */
export function createDefaultPixelGenerationMemory(): PixelGenerationMemory {
  return {
    bucketFullSince: 0,
    consecutiveFullTicks: 0,
    totalPixelsGenerated: 0,
    lastGenerationTick: 0
  };
}

/**
 * Pixel Generation Manager Class
 */
@ProcessClass()
export class PixelGenerationManager {
  private config: PixelGenerationConfig;

  public constructor(config: Partial<PixelGenerationConfig> = {}) {
    this.config = { ...DEFAULT_CONFIG, ...config };
  }

  /**
   * Main pixel generation tick
   * Registered as kernel process via decorator
   */
  @LowFrequencyProcess("empire:pixelGeneration", "Pixel Generation Manager", {
    priority: ProcessPriority.IDLE, // Very low priority - only when everything else is fine
    interval: 1, // Check every tick since we're tracking consecutive ticks
    minBucket: 0,
    cpuBudget: 0.01
  })
  public run(): void {
    if (!this.config.enabled) {
      return;
    }

    // Ensure pixel generation memory exists
    this.ensurePixelGenerationMemory();

    const memory = this.getPixelGenerationMemory();
    if (!memory) return;

    const currentBucket = Game.cpu.bucket;
    const isBucketFull = currentBucket >= this.config.bucketMax;

    // Track consecutive full bucket ticks
    if (isBucketFull) {
      if (memory.consecutiveFullTicks === 0) {
        // Bucket just became full
        memory.bucketFullSince = Game.time;
      }
      memory.consecutiveFullTicks++;
    } else {
      // Bucket is not full - reset tracking
      memory.consecutiveFullTicks = 0;
      memory.bucketFullSince = 0;
    }

    // Check if we should generate a pixel
    if (this.shouldGeneratePixel(memory)) {
      this.generatePixel(memory);
    }
  }

  /**
   * Ensure pixel generation memory exists
   */
  private ensurePixelGenerationMemory(): void {
    // Use global memory to persist across global resets
    // This is similar to how kernel processes store state
    const g = global as any;
    if (!g._pixelGenerationMemory) {
      g._pixelGenerationMemory = createDefaultPixelGenerationMemory();
    }
  }

  /**
   * Get pixel generation memory
   */
  private getPixelGenerationMemory(): PixelGenerationMemory | undefined {
    const g = global as any;
    return g._pixelGenerationMemory as PixelGenerationMemory | undefined;
  }

  /**
   * Check if we should generate a pixel
   */
  private shouldGeneratePixel(memory: PixelGenerationMemory): boolean {
    // Must have bucket full for required number of ticks
    if (memory.consecutiveFullTicks < this.config.fullBucketTicksRequired) {
      return false;
    }

    // Bucket must still be full
    if (Game.cpu.bucket < this.config.bucketMax) {
      return false;
    }

    // Check if we have enough CPU in bucket to generate
    // (bucket must be able to support the generation cost)
    if (Game.cpu.bucket < this.config.cpuCostPerPixel) {
      return false;
    }

    return true;
  }

  /**
   * Generate a pixel from CPU bucket
   */
  private generatePixel(memory: PixelGenerationMemory): void {
    const result = Game.cpu.generatePixel();

    if (result === OK) {
      memory.totalPixelsGenerated++;
      memory.lastGenerationTick = Game.time;
      
      // Reset consecutive counter after generation
      // This ensures we wait another 25 ticks before next generation
      memory.consecutiveFullTicks = 0;
      memory.bucketFullSince = 0;

      logger.info(
        `Generated pixel from CPU bucket (total generated: ${memory.totalPixelsGenerated})`,
        { 
          subsystem: "PixelGeneration",
          meta: {
            bucket: Game.cpu.bucket,
            ticksWaited: Game.time - memory.bucketFullSince
          }
        }
      );
    } else {
      logger.warn(
        `Failed to generate pixel: error code ${result}`,
        { 
          subsystem: "PixelGeneration",
          meta: {
            bucket: Game.cpu.bucket,
            result
          }
        }
      );
    }
  }

  /**
   * Get pixel generation statistics
   */
  public getStats(): {
    enabled: boolean;
    totalGenerated: number;
    lastGenerationTick: number;
    bucketFullSince: number;
    consecutiveFullTicks: number;
    canGenerate: boolean;
    ticksUntilGeneration: number;
  } {
    const memory = this.getPixelGenerationMemory();
    const canGenerate = memory ? this.shouldGeneratePixel(memory) : false;
    const ticksUntilGeneration = memory 
      ? Math.max(0, this.config.fullBucketTicksRequired - memory.consecutiveFullTicks)
      : this.config.fullBucketTicksRequired;

    return {
      enabled: this.config.enabled,
      totalGenerated: memory?.totalPixelsGenerated ?? 0,
      lastGenerationTick: memory?.lastGenerationTick ?? 0,
      bucketFullSince: memory?.bucketFullSince ?? 0,
      consecutiveFullTicks: memory?.consecutiveFullTicks ?? 0,
      canGenerate,
      ticksUntilGeneration
    };
  }

  /**
   * Enable pixel generation
   */
  public enable(): void {
    this.config.enabled = true;
    logger.info("Pixel generation enabled", { subsystem: "PixelGeneration" });
  }

  /**
   * Disable pixel generation
   */
  public disable(): void {
    this.config.enabled = false;
    logger.info("Pixel generation disabled", { subsystem: "PixelGeneration" });
  }

  /**
   * Update configuration
   */
  public updateConfig(config: Partial<PixelGenerationConfig>): void {
    this.config = { ...this.config, ...config };
  }

  /**
   * Get current configuration
   */
  public getConfig(): PixelGenerationConfig {
    return { ...this.config };
  }
}

/**
 * Global pixel generation manager instance
 */
export const pixelGenerationManager = new PixelGenerationManager();
