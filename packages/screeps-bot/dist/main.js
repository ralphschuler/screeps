"use strict";Object.defineProperty(exports,"__esModule",{value:1});var e={},t={},r={},o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");r.encode=function(e){if(e>=0&&e<o.length)return o[e];throw new TypeError("Must be between 0 and 63: "+e)},r.decode=function(e){return 65>e||e>90?97>e||e>122?48>e||e>57?43==e?62:47==e?63:-1:e-48+52:e-97+26:e-65};var s=r;t.encode=function(e){var t,r="",o=function(e){return 0>e?1+(-e<<1):0+(e<<1)}(e);do{t=31&o,(o>>>=5)>0&&(t|=32),r+=s.encode(t)}while(o>0);return r},t.decode=function(e,t,r){var o,n,i,a,c=e.length,u=0,l=0;do{if(t>=c)throw Error("Expected more digits in base 64 VLQ value.");if(-1===(n=s.decode(e.charCodeAt(t++))))throw Error("Invalid base64 digit: "+e.charAt(t-1));o=!!(32&n),u+=(n&=31)<<l,l+=5}while(o);r.value=(a=(i=u)>>1,1&~i?a:-a),r.rest=t};var n={};!function(e){e.getArg=function(e,t,r){if(t in e)return e[t];if(3===arguments.length)return r;throw Error('"'+t+'" is a required argument.')};var t=/^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/,r=/^data:.+\,.+$/;function o(e){var r=e.match(t);return r?{scheme:r[1],auth:r[2],host:r[3],port:r[4],path:r[5]}:null}function s(e){var t="";return e.scheme&&(t+=e.scheme+":"),t+="//",e.auth&&(t+=e.auth+"@"),e.host&&(t+=e.host),e.port&&(t+=":"+e.port),e.path&&(t+=e.path),t}function n(t){var r=t,n=o(t);if(n){if(!n.path)return t;r=n.path}for(var i,a=e.isAbsolute(r),c=r.split(/\/+/),u=0,l=c.length-1;l>=0;l--)"."===(i=c[l])?c.splice(l,1):".."===i?u++:u>0&&(""===i?(c.splice(l+1,u),u=0):(c.splice(l,2),u--));return""===(r=c.join("/"))&&(r=a?"/":"."),n?(n.path=r,s(n)):r}function i(e,t){""===e&&(e="."),""===t&&(t=".");var i=o(t),a=o(e);if(a&&(e=a.path||"/"),i&&!i.scheme)return a&&(i.scheme=a.scheme),s(i);if(i||t.match(r))return t;if(a&&!a.host&&!a.path)return a.host=t,s(a);var c="/"===t.charAt(0)?t:n(e.replace(/\/+$/,"")+"/"+t);return a?(a.path=c,s(a)):c}e.urlParse=o,e.urlGenerate=s,e.normalize=n,e.join=i,e.isAbsolute=function(e){return"/"===e.charAt(0)||t.test(e)},e.relative=function(e,t){""===e&&(e="."),e=e.replace(/\/$/,"");for(var r=0;0!==t.indexOf(e+"/");){var o=e.lastIndexOf("/");if(0>o)return t;if((e=e.slice(0,o)).match(/^([^\/]+:\/)?\/*$/))return t;++r}return Array(r+1).join("../")+t.substr(e.length+1)};var a=!("__proto__"in Object.create(null));function c(e){return e}function u(e){if(!e)return 0;var t=e.length;if(9>t)return 0;if(95!==e.charCodeAt(t-1)||95!==e.charCodeAt(t-2)||111!==e.charCodeAt(t-3)||116!==e.charCodeAt(t-4)||111!==e.charCodeAt(t-5)||114!==e.charCodeAt(t-6)||112!==e.charCodeAt(t-7)||95!==e.charCodeAt(t-8)||95!==e.charCodeAt(t-9))return 0;for(var r=t-10;r>=0;r--)if(36!==e.charCodeAt(r))return 0;return 1}function l(e,t){return e===t?0:null===e?1:null===t?-1:e>t?1:-1}e.toSetString=a?c:function(e){return u(e)?"$"+e:e},e.fromSetString=a?c:function(e){return u(e)?e.slice(1):e},e.compareByOriginalPositions=function(e,t,r){var o=l(e.source,t.source);return 0!==o||0!==(o=e.originalLine-t.originalLine)||0!==(o=e.originalColumn-t.originalColumn)||r||0!==(o=e.generatedColumn-t.generatedColumn)||0!==(o=e.generatedLine-t.generatedLine)?o:l(e.name,t.name)},e.compareByGeneratedPositionsDeflated=function(e,t,r){var o=e.generatedLine-t.generatedLine;return 0!==o||0!==(o=e.generatedColumn-t.generatedColumn)||r||0!==(o=l(e.source,t.source))||0!==(o=e.originalLine-t.originalLine)||0!==(o=e.originalColumn-t.originalColumn)?o:l(e.name,t.name)},e.compareByGeneratedPositionsInflated=function(e,t){var r=e.generatedLine-t.generatedLine;return 0!==r||0!==(r=e.generatedColumn-t.generatedColumn)||0!==(r=l(e.source,t.source))||0!==(r=e.originalLine-t.originalLine)||0!==(r=e.originalColumn-t.originalColumn)?r:l(e.name,t.name)},e.parseSourceMapInput=function(e){return JSON.parse(e.replace(/^\)]}'[^\n]*\n/,""))},e.computeSourceURL=function(e,t,r){if(t=t||"",e&&("/"!==e[e.length-1]&&"/"!==t[0]&&(e+="/"),t=e+t),r){var a=o(r);if(!a)throw Error("sourceMapURL could not be parsed");if(a.path){var c=a.path.lastIndexOf("/");0>c||(a.path=a.path.substring(0,c+1))}t=i(s(a),t)}return n(t)}}(n);var i={},a=n,c={}.hasOwnProperty,u="undefined"!=typeof Map;function l(){this._array=[],this._set=u?new Map:Object.create(null)}l.fromArray=function(e,t){for(var r=new l,o=0,s=e.length;s>o;o++)r.add(e[o],t);return r},l.prototype.size=function(){return u?this._set.size:Object.getOwnPropertyNames(this._set).length},l.prototype.add=function(e,t){var r=u?e:a.toSetString(e),o=u?this.has(e):c.call(this._set,r),s=this._array.length;o&&!t||this._array.push(e),o||(u?this._set.set(e,s):this._set[r]=s)},l.prototype.has=function(e){if(u)return this._set.has(e);var t=a.toSetString(e);return c.call(this._set,t)},l.prototype.indexOf=function(e){if(u){var t=this._set.get(e);if(t>=0)return t}else{var r=a.toSetString(e);if(c.call(this._set,r))return this._set[r]}throw Error('"'+e+'" is not in the set.')},l.prototype.at=function(e){if(e>=0&&e<this._array.length)return this._array[e];throw Error("No element indexed by "+e)},l.prototype.toArray=function(){return this._array.slice()},i.ArraySet=l;var m={},p=n;function d(){this._array=[],this._sorted=1,this._last={generatedLine:-1,generatedColumn:0}}d.prototype.unsortedForEach=function(e,t){this._array.forEach(e,t)},d.prototype.add=function(e){var t,r,o,s,n,i;r=e,o=(t=this._last).generatedLine,s=r.generatedLine,n=t.generatedColumn,i=r.generatedColumn,s>o||s==o&&i>=n||0>=p.compareByGeneratedPositionsInflated(t,r)?(this._last=e,this._array.push(e)):(this._sorted=0,this._array.push(e))},d.prototype.toArray=function(){return this._sorted||(this._array.sort(p.compareByGeneratedPositionsInflated),this._sorted=1),this._array},m.MappingList=d;var g=t,f=n,R=i.ArraySet,h=m.MappingList;function y(e){e||(e={}),this._file=f.getArg(e,"file",null),this._sourceRoot=f.getArg(e,"sourceRoot",null),this._skipValidation=f.getArg(e,"skipValidation",0),this._sources=new R,this._names=new R,this._mappings=new h,this._sourcesContents=null}y.prototype._version=3,y.fromSourceMap=function(e){var t=e.sourceRoot,r=new y({file:e.file,sourceRoot:t});return e.eachMapping(function(e){var o={generated:{line:e.generatedLine,column:e.generatedColumn}};null!=e.source&&(o.source=e.source,null!=t&&(o.source=f.relative(t,o.source)),o.original={line:e.originalLine,column:e.originalColumn},null!=e.name&&(o.name=e.name)),r.addMapping(o)}),e.sources.forEach(function(o){var s=o;null!==t&&(s=f.relative(t,o)),r._sources.has(s)||r._sources.add(s);var n=e.sourceContentFor(o);null!=n&&r.setSourceContent(o,n)}),r},y.prototype.addMapping=function(e){var t=f.getArg(e,"generated"),r=f.getArg(e,"original",null),o=f.getArg(e,"source",null),s=f.getArg(e,"name",null);this._skipValidation||this._validateMapping(t,r,o,s),null!=o&&(o+="",this._sources.has(o)||this._sources.add(o)),null!=s&&(s+="",this._names.has(s)||this._names.add(s)),this._mappings.add({generatedLine:t.line,generatedColumn:t.column,originalLine:null!=r&&r.line,originalColumn:null!=r&&r.column,source:o,name:s})},y.prototype.setSourceContent=function(e,t){var r=e;null!=this._sourceRoot&&(r=f.relative(this._sourceRoot,r)),null!=t?(this._sourcesContents||(this._sourcesContents=Object.create(null)),this._sourcesContents[f.toSetString(r)]=t):this._sourcesContents&&(delete this._sourcesContents[f.toSetString(r)],0===Object.keys(this._sourcesContents).length&&(this._sourcesContents=null))},y.prototype.applySourceMap=function(e,t,r){var o=t;if(null==t){if(null==e.file)throw Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');o=e.file}var s=this._sourceRoot;null!=s&&(o=f.relative(s,o));var n=new R,i=new R;this._mappings.unsortedForEach(function(t){if(t.source===o&&null!=t.originalLine){var a=e.originalPositionFor({line:t.originalLine,column:t.originalColumn});null!=a.source&&(t.source=a.source,null!=r&&(t.source=f.join(r,t.source)),null!=s&&(t.source=f.relative(s,t.source)),t.originalLine=a.line,t.originalColumn=a.column,null!=a.name&&(t.name=a.name))}var c=t.source;null==c||n.has(c)||n.add(c);var u=t.name;null==u||i.has(u)||i.add(u)},this),this._sources=n,this._names=i,e.sources.forEach(function(t){var o=e.sourceContentFor(t);null!=o&&(null!=r&&(t=f.join(r,t)),null!=s&&(t=f.relative(s,t)),this.setSourceContent(t,o))},this)},y.prototype._validateMapping=function(e,t,r,o){if(t&&"number"!=typeof t.line&&"number"!=typeof t.column)throw Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");if(!(e&&"line"in e&&"column"in e&&e.line>0)||0>e.column||t||r||o){if(e&&"line"in e&&"column"in e&&t&&"line"in t&&"column"in t&&e.line>0&&e.column>=0&&t.line>0&&t.column>=0&&r)return;throw Error("Invalid mapping: "+JSON.stringify({generated:e,source:r,original:t,name:o}))}},y.prototype._serializeMappings=function(){for(var e,t,r,o,s=0,n=1,i=0,a=0,c=0,u=0,l="",m=this._mappings.toArray(),p=0,d=m.length;d>p;p++){if(e="",(t=m[p]).generatedLine!==n)for(s=0;t.generatedLine!==n;)e+=";",n++;else if(p>0){if(!f.compareByGeneratedPositionsInflated(t,m[p-1]))continue;e+=","}e+=g.encode(t.generatedColumn-s),s=t.generatedColumn,null!=t.source&&(o=this._sources.indexOf(t.source),e+=g.encode(o-u),u=o,e+=g.encode(t.originalLine-1-a),a=t.originalLine-1,e+=g.encode(t.originalColumn-i),i=t.originalColumn,null!=t.name&&(r=this._names.indexOf(t.name),e+=g.encode(r-c),c=r)),l+=e}return l},y.prototype._generateSourcesContent=function(e,t){return e.map(function(e){if(!this._sourcesContents)return null;null!=t&&(e=f.relative(t,e));var r=f.toSetString(e);return{}.hasOwnProperty.call(this._sourcesContents,r)?this._sourcesContents[r]:null},this)},y.prototype.toJSON=function(){var e={version:this._version,sources:this._sources.toArray(),names:this._names.toArray(),mappings:this._serializeMappings()};return null!=this._file&&(e.file=this._file),null!=this._sourceRoot&&(e.sourceRoot=this._sourceRoot),this._sourcesContents&&(e.sourcesContent=this._generateSourcesContent(e.sources,e.sourceRoot)),e},y.prototype.toString=function(){return JSON.stringify(this.toJSON())},e.SourceMapGenerator=y;var E={},T={};!function(e){function t(r,o,s,n,i,a){var c=Math.floor((o-r)/2)+r,u=i(s,n[c],1);return 0===u?c:u>0?o-c>1?t(c,o,s,n,i,a):a==e.LEAST_UPPER_BOUND?o<n.length?o:-1:c:c-r>1?t(r,c,s,n,i,a):a==e.LEAST_UPPER_BOUND?c:0>r?-1:r}e.GREATEST_LOWER_BOUND=1,e.LEAST_UPPER_BOUND=2,e.search=function(r,o,s,n){if(0===o.length)return-1;var i=t(-1,o.length,r,o,s,n||e.GREATEST_LOWER_BOUND);if(0>i)return-1;for(;i-1>=0&&0===s(o[i],o[i-1],1);)--i;return i}}(T);var C={};function v(e,t,r){var o=e[t];e[t]=e[r],e[r]=o}function S(e,t,r,o){if(o>r){var s=r-1;v(e,(u=o,Math.round((c=r)+Math.random()*(u-c))),o);for(var n=e[o],i=r;o>i;i++)t(e[i],n)>0||v(e,s+=1,i);v(e,s+1,i);var a=s+1;S(e,t,r,a-1),S(e,t,a+1,o)}var c,u}C.quickSort=function(e,t){S(e,t,0,e.length-1)};var U=n,O=T,_=i.ArraySet,A=t,M=C.quickSort;function N(e,t){var r=e;return"string"==typeof e&&(r=U.parseSourceMapInput(e)),null!=r.sections?new I(r,t):new b(r,t)}function b(e,t){var r=e;"string"==typeof e&&(r=U.parseSourceMapInput(e));var o=U.getArg(r,"version"),s=U.getArg(r,"sources"),n=U.getArg(r,"names",[]),i=U.getArg(r,"sourceRoot",null),a=U.getArg(r,"sourcesContent",null),c=U.getArg(r,"mappings"),u=U.getArg(r,"file",null);if(o!=this._version)throw Error("Unsupported version: "+o);i&&(i=U.normalize(i)),s=s.map(String).map(U.normalize).map(function(e){return i&&U.isAbsolute(i)&&U.isAbsolute(e)?U.relative(i,e):e}),this._names=_.fromArray(n.map(String),1),this._sources=_.fromArray(s,1),this._absoluteSources=this._sources.toArray().map(function(e){return U.computeSourceURL(i,e,t)}),this.sourceRoot=i,this.sourcesContent=a,this._mappings=c,this._sourceMapURL=t,this.file=u}function w(){this.generatedLine=0,this.generatedColumn=0,this.source=null,this.originalLine=null,this.originalColumn=null,this.name=null}function I(e,t){var r=e;"string"==typeof e&&(r=U.parseSourceMapInput(e));var o=U.getArg(r,"version"),s=U.getArg(r,"sections");if(o!=this._version)throw Error("Unsupported version: "+o);this._sources=new _,this._names=new _;var n={line:-1,column:0};this._sections=s.map(function(e){if(e.url)throw Error("Support for url field in sections not implemented.");var r=U.getArg(e,"offset"),o=U.getArg(r,"line"),s=U.getArg(r,"column");if(o<n.line||o===n.line&&s<n.column)throw Error("Section offsets must be ordered and non-overlapping.");return n=r,{generatedOffset:{generatedLine:o+1,generatedColumn:s+1},consumer:new N(U.getArg(e,"map"),t)}})}N.fromSourceMap=function(e,t){return b.fromSourceMap(e,t)},N.prototype._version=3,N.prototype.__generatedMappings=null,Object.defineProperty(N.prototype,"_generatedMappings",{configurable:1,enumerable:1,get:function(){return this.__generatedMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__generatedMappings}}),N.prototype.__originalMappings=null,Object.defineProperty(N.prototype,"_originalMappings",{configurable:1,enumerable:1,get:function(){return this.__originalMappings||this._parseMappings(this._mappings,this.sourceRoot),this.__originalMappings}}),N.prototype._charIsMappingSeparator=function(e,t){var r=e.charAt(t);return";"===r||","===r},N.prototype._parseMappings=function(e,t){throw Error("Subclasses must implement _parseMappings")},N.GENERATED_ORDER=1,N.ORIGINAL_ORDER=2,N.GREATEST_LOWER_BOUND=1,N.LEAST_UPPER_BOUND=2,N.prototype.eachMapping=function(e,t,r){var o,s=t||null;switch(r||N.GENERATED_ORDER){case N.GENERATED_ORDER:o=this._generatedMappings;break;case N.ORIGINAL_ORDER:o=this._originalMappings;break;default:throw Error("Unknown order of iteration.")}var n=this.sourceRoot;o.map(function(e){var t=null===e.source?null:this._sources.at(e.source);return{source:t=U.computeSourceURL(n,t,this._sourceMapURL),generatedLine:e.generatedLine,generatedColumn:e.generatedColumn,originalLine:e.originalLine,originalColumn:e.originalColumn,name:null===e.name?null:this._names.at(e.name)}},this).forEach(e,s)},N.prototype.allGeneratedPositionsFor=function(e){var t=U.getArg(e,"line"),r={source:U.getArg(e,"source"),originalLine:t,originalColumn:U.getArg(e,"column",0)};if(r.source=this._findSourceIndex(r.source),0>r.source)return[];var o=[],s=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",U.compareByOriginalPositions,O.LEAST_UPPER_BOUND);if(s>=0){var n=this._originalMappings[s];if(void 0===e.column)for(var i=n.originalLine;n&&n.originalLine===i;)o.push({line:U.getArg(n,"generatedLine",null),column:U.getArg(n,"generatedColumn",null),lastColumn:U.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++s];else for(var a=n.originalColumn;n&&n.originalLine===t&&n.originalColumn==a;)o.push({line:U.getArg(n,"generatedLine",null),column:U.getArg(n,"generatedColumn",null),lastColumn:U.getArg(n,"lastGeneratedColumn",null)}),n=this._originalMappings[++s]}return o},E.SourceMapConsumer=N,b.prototype=Object.create(N.prototype),b.prototype.consumer=N,b.prototype._findSourceIndex=function(e){var t,r=e;if(null!=this.sourceRoot&&(r=U.relative(this.sourceRoot,r)),this._sources.has(r))return this._sources.indexOf(r);for(t=0;t<this._absoluteSources.length;++t)if(this._absoluteSources[t]==e)return t;return-1},b.fromSourceMap=function(e,t){var r=Object.create(b.prototype),o=r._names=_.fromArray(e._names.toArray(),1),s=r._sources=_.fromArray(e._sources.toArray(),1);r.sourceRoot=e._sourceRoot,r.sourcesContent=e._generateSourcesContent(r._sources.toArray(),r.sourceRoot),r.file=e._file,r._sourceMapURL=t,r._absoluteSources=r._sources.toArray().map(function(e){return U.computeSourceURL(r.sourceRoot,e,t)});for(var n=e._mappings.toArray().slice(),i=r.__generatedMappings=[],a=r.__originalMappings=[],c=0,u=n.length;u>c;c++){var l=n[c],m=new w;m.generatedLine=l.generatedLine,m.generatedColumn=l.generatedColumn,l.source&&(m.source=s.indexOf(l.source),m.originalLine=l.originalLine,m.originalColumn=l.originalColumn,l.name&&(m.name=o.indexOf(l.name)),a.push(m)),i.push(m)}return M(r.__originalMappings,U.compareByOriginalPositions),r},b.prototype._version=3,Object.defineProperty(b.prototype,"sources",{get:function(){return this._absoluteSources.slice()}}),b.prototype._parseMappings=function(e,t){for(var r,o,s,n,i,a=1,c=0,u=0,l=0,m=0,p=0,d=e.length,g=0,f={},R={},h=[],y=[];d>g;)if(";"===e.charAt(g))a++,g++,c=0;else if(","===e.charAt(g))g++;else{for((r=new w).generatedLine=a,n=g;d>n&&!this._charIsMappingSeparator(e,n);n++);if(s=f[o=e.slice(g,n)])g+=o.length;else{for(s=[];n>g;)A.decode(e,g,R),i=R.value,g=R.rest,s.push(i);if(2===s.length)throw Error("Found a source, but no line and column");if(3===s.length)throw Error("Found a source and line, but no column");f[o]=s}r.generatedColumn=c+s[0],c=r.generatedColumn,s.length>1&&(r.source=m+s[1],m+=s[1],r.originalLine=u+s[2],u=r.originalLine,r.originalLine+=1,r.originalColumn=l+s[3],l=r.originalColumn,s.length>4&&(r.name=p+s[4],p+=s[4])),y.push(r),"number"==typeof r.originalLine&&h.push(r)}M(y,U.compareByGeneratedPositionsDeflated),this.__generatedMappings=y,M(h,U.compareByOriginalPositions),this.__originalMappings=h},b.prototype._findMapping=function(e,t,r,o,s,n){if(0>=e[r])throw new TypeError("Line must be greater than or equal to 1, got "+e[r]);if(0>e[o])throw new TypeError("Column must be greater than or equal to 0, got "+e[o]);return O.search(e,t,s,n)},b.prototype.computeColumnSpans=function(){for(var e=0;e<this._generatedMappings.length;++e){var t=this._generatedMappings[e];if(e+1<this._generatedMappings.length){var r=this._generatedMappings[e+1];if(t.generatedLine===r.generatedLine){t.lastGeneratedColumn=r.generatedColumn-1;continue}}t.lastGeneratedColumn=1/0}},b.prototype.originalPositionFor=function(e){var t={generatedLine:U.getArg(e,"line"),generatedColumn:U.getArg(e,"column")},r=this._findMapping(t,this._generatedMappings,"generatedLine","generatedColumn",U.compareByGeneratedPositionsDeflated,U.getArg(e,"bias",N.GREATEST_LOWER_BOUND));if(r>=0){var o=this._generatedMappings[r];if(o.generatedLine===t.generatedLine){var s=U.getArg(o,"source",null);null!==s&&(s=this._sources.at(s),s=U.computeSourceURL(this.sourceRoot,s,this._sourceMapURL));var n=U.getArg(o,"name",null);return null!==n&&(n=this._names.at(n)),{source:s,line:U.getArg(o,"originalLine",null),column:U.getArg(o,"originalColumn",null),name:n}}}return{source:null,line:null,column:null,name:null}},b.prototype.hasContentsOfAllSources=function(){return this.sourcesContent?this.sourcesContent.length>=this._sources.size()&&!this.sourcesContent.some(function(e){return null==e}):0},b.prototype.sourceContentFor=function(e,t){if(!this.sourcesContent)return null;var r=this._findSourceIndex(e);if(r>=0)return this.sourcesContent[r];var o,s=e;if(null!=this.sourceRoot&&(s=U.relative(this.sourceRoot,s)),null!=this.sourceRoot&&(o=U.urlParse(this.sourceRoot))){var n=s.replace(/^file:\/\//,"");if("file"==o.scheme&&this._sources.has(n))return this.sourcesContent[this._sources.indexOf(n)];if((!o.path||"/"==o.path)&&this._sources.has("/"+s))return this.sourcesContent[this._sources.indexOf("/"+s)]}if(t)return null;throw Error('"'+s+'" is not in the SourceMap.')},b.prototype.generatedPositionFor=function(e){var t=U.getArg(e,"source");if(0>(t=this._findSourceIndex(t)))return{line:null,column:null,lastColumn:null};var r={source:t,originalLine:U.getArg(e,"line"),originalColumn:U.getArg(e,"column")},o=this._findMapping(r,this._originalMappings,"originalLine","originalColumn",U.compareByOriginalPositions,U.getArg(e,"bias",N.GREATEST_LOWER_BOUND));if(o>=0){var s=this._originalMappings[o];if(s.source===r.source)return{line:U.getArg(s,"generatedLine",null),column:U.getArg(s,"generatedColumn",null),lastColumn:U.getArg(s,"lastGeneratedColumn",null)}}return{line:null,column:null,lastColumn:null}},E.BasicSourceMapConsumer=b,I.prototype=Object.create(N.prototype),I.prototype.constructor=N,I.prototype._version=3,Object.defineProperty(I.prototype,"sources",{get:function(){for(var e=[],t=0;t<this._sections.length;t++)for(var r=0;r<this._sections[t].consumer.sources.length;r++)e.push(this._sections[t].consumer.sources[r]);return e}}),I.prototype.originalPositionFor=function(e){var t={generatedLine:U.getArg(e,"line"),generatedColumn:U.getArg(e,"column")},r=O.search(t,this._sections,function(e,t){return e.generatedLine-t.generatedOffset.generatedLine||e.generatedColumn-t.generatedOffset.generatedColumn}),o=this._sections[r];return o?o.consumer.originalPositionFor({line:t.generatedLine-(o.generatedOffset.generatedLine-1),column:t.generatedColumn-(o.generatedOffset.generatedLine===t.generatedLine?o.generatedOffset.generatedColumn-1:0),bias:e.bias}):{source:null,line:null,column:null,name:null}},I.prototype.hasContentsOfAllSources=function(){return this._sections.every(function(e){return e.consumer.hasContentsOfAllSources()})},I.prototype.sourceContentFor=function(e,t){for(var r=0;r<this._sections.length;r++){var o=this._sections[r].consumer.sourceContentFor(e,1);if(o)return o}if(t)return null;throw Error('"'+e+'" is not in the SourceMap.')},I.prototype.generatedPositionFor=function(e){for(var t=0;t<this._sections.length;t++){var r=this._sections[t];if(-1!==r.consumer._findSourceIndex(U.getArg(e,"source"))){var o=r.consumer.generatedPositionFor(e);if(o)return{line:o.line+(r.generatedOffset.generatedLine-1),column:o.column+(r.generatedOffset.generatedLine===o.line?r.generatedOffset.generatedColumn-1:0)}}}return{line:null,column:null}},I.prototype._parseMappings=function(e,t){this.__generatedMappings=[],this.__originalMappings=[];for(var r=0;r<this._sections.length;r++)for(var o=this._sections[r],s=o.consumer._generatedMappings,n=0;n<s.length;n++){var i=s[n],a=o.consumer._sources.at(i.source);a=U.computeSourceURL(o.consumer.sourceRoot,a,this._sourceMapURL),this._sources.add(a),a=this._sources.indexOf(a);var c=null;i.name&&(c=o.consumer._names.at(i.name),this._names.add(c),c=this._names.indexOf(c));var u={source:a,generatedLine:i.generatedLine+(o.generatedOffset.generatedLine-1),generatedColumn:i.generatedColumn+(o.generatedOffset.generatedLine===i.generatedLine?o.generatedOffset.generatedColumn-1:0),originalLine:i.originalLine,originalColumn:i.originalColumn,name:c};this.__generatedMappings.push(u),"number"==typeof u.originalLine&&this.__originalMappings.push(u)}M(this.__generatedMappings,U.compareByGeneratedPositionsDeflated),M(this.__originalMappings,U.compareByOriginalPositions)},E.IndexedSourceMapConsumer=I;var x=e.SourceMapGenerator,G=n,P=/(\r?\n)/,k="$$$isSourceNode$$$";function L(e,t,r,o,s){this.children=[],this.sourceContents={},this.line=null==e?null:e,this.column=null==t?null:t,this.source=null==r?null:r,this.name=null==s?null:s,this[k]=1,null!=o&&this.add(o)}L.fromStringWithSourceMap=function(e,t,r){var o=new L,s=e.split(P),n=0,i=function(){return e()+(e()||"");function e(){return n<s.length?s[n++]:void 0}},a=1,c=0,u=null;return t.eachMapping(function(e){if(null!==u){if(a>=e.generatedLine){var t=(r=s[n]||"").substr(0,e.generatedColumn-c);return s[n]=r.substr(e.generatedColumn-c),c=e.generatedColumn,l(u,t),void(u=e)}l(u,i()),a++,c=0}for(;a<e.generatedLine;)o.add(i()),a++;if(c<e.generatedColumn){var r=s[n]||"";o.add(r.substr(0,e.generatedColumn)),s[n]=r.substr(e.generatedColumn),c=e.generatedColumn}u=e},this),n<s.length&&(u&&l(u,i()),o.add(s.splice(n).join(""))),t.sources.forEach(function(e){var s=t.sourceContentFor(e);null!=s&&(null!=r&&(e=G.join(r,e)),o.setSourceContent(e,s))}),o;function l(e,t){if(null===e||void 0===e.source)o.add(t);else{var s=r?G.join(r,e.source):e.source;o.add(new L(e.originalLine,e.originalColumn,s,t,e.name))}}},L.prototype.add=function(e){if(Array.isArray(e))e.forEach(function(e){this.add(e)},this);else{if(!e[k]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);e&&this.children.push(e)}return this},L.prototype.prepend=function(e){if(Array.isArray(e))for(var t=e.length-1;t>=0;t--)this.prepend(e[t]);else{if(!e[k]&&"string"!=typeof e)throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got "+e);this.children.unshift(e)}return this},L.prototype.walk=function(e){for(var t,r=0,o=this.children.length;o>r;r++)(t=this.children[r])[k]?t.walk(e):""!==t&&e(t,{source:this.source,line:this.line,column:this.column,name:this.name})},L.prototype.join=function(e){var t,r,o=this.children.length;if(o>0){for(t=[],r=0;o-1>r;r++)t.push(this.children[r]),t.push(e);t.push(this.children[r]),this.children=t}return this},L.prototype.replaceRight=function(e,t){var r=this.children[this.children.length-1];return r[k]?r.replaceRight(e,t):"string"==typeof r?this.children[this.children.length-1]=r.replace(e,t):this.children.push("".replace(e,t)),this},L.prototype.setSourceContent=function(e,t){this.sourceContents[G.toSetString(e)]=t},L.prototype.walkSourceContents=function(e){for(var t=0,r=this.children.length;r>t;t++)this.children[t][k]&&this.children[t].walkSourceContents(e);var o=Object.keys(this.sourceContents);for(t=0,r=o.length;r>t;t++)e(G.fromSetString(o[t]),this.sourceContents[o[t]])},L.prototype.toString=function(){var e="";return this.walk(function(t){e+=t}),e},L.prototype.toStringWithSourceMap=function(e){var t={code:"",line:1,column:0},r=new x(e),o=0,s=null,n=null,i=null,a=null;return this.walk(function(e,c){t.code+=e,null!==c.source&&null!==c.line&&null!==c.column?(s===c.source&&n===c.line&&i===c.column&&a===c.name||r.addMapping({source:c.source,original:{line:c.line,column:c.column},generated:{line:t.line,column:t.column},name:c.name}),s=c.source,n=c.line,i=c.column,a=c.name,o=1):o&&(r.addMapping({generated:{line:t.line,column:t.column}}),s=null,o=0);for(var u=0,l=e.length;l>u;u++)10===e.charCodeAt(u)?(t.line++,t.column=0,u+1===l?(s=null,o=0):o&&r.addMapping({source:c.source,original:{line:c.line,column:c.column},generated:{line:t.line,column:t.column},name:c.name})):t.column++}),this.walkSourceContents(function(e,t){r.setSourceContent(e,t)}),{code:t.code,map:r}};var D,$=E.SourceMapConsumer;function Y(e){return null==e?"":(e+"").replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;").replace(/'/g,"&#39;")}class K{static get consumer(){if(null==this._consumer){const e=require("main.js.map");let t;if("string"==typeof e)try{t=JSON.parse(e)}catch(e){throw Error("Failed to parse source map JSON: "+(e instanceof Error?e.message:e+""))}else t=e;this._consumer=new $(t)}return this._consumer}static sourceMappedStackTrace(e){const t=e instanceof Error?e.stack:e;if({}.hasOwnProperty.call(this.cache,t))return this.cache[t];const r=/^\s+at\s+(.+?\s+)?\(?([0-z._\-\\\/]+):(\d+):(\d+)\)?$/gm;let o,s=e.toString();for(;(o=r.exec(t))&&"main"===o[2];){const e=this.consumer.originalPositionFor({column:parseInt(o[4],10),line:parseInt(o[3],10)});if(null==e.line)break;e.name?s+=`\n    at ${e.name} (${e.source}:${e.line}:${e.column})`:o[1]?s+=`\n    at ${o[1]} (${e.source}:${e.line}:${e.column})`:s+=`\n    at ${e.source}:${e.line}:${e.column}`}return this.cache[t]=s,s}static wrapLoop(e){return()=>{try{e()}catch(e){if(!(e instanceof Error))throw e;"sim"in Game.rooms?console.log(`<span style='color:red'>Source maps don't work in the simulator - displaying original error<br>${Y(e.stack)}</span>`):console.log(`<span style='color:red'>${Y(this.sourceMappedStackTrace(e))}</span>`)}}}}function H(e,t,r,o){var s,n=arguments.length,i=3>n?t:null===o?o=Object.getOwnPropertyDescriptor(t,r):o;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)i=Reflect.decorate(e,t,r,o);else for(var a=e.length-1;a>=0;a--)(s=e[a])&&(i=(3>n?s(i):n>3?s(t,r,i):s(t,r))||i);return n>3&&i&&Object.defineProperty(t,r,i),i}K.cache={},"function"==typeof SuppressedError&&SuppressedError,function(e){e[e.DEBUG=0]="DEBUG",e[e.INFO=1]="INFO",e[e.WARN=2]="WARN",e[e.ERROR=3]="ERROR",e[e.NONE=4]="NONE"}(D||(D={}));let F={level:D.INFO,showTimestamp:1,showRoom:1,cpuLogging:0,outputFormat:"json"};function W(e){F={...F,...e}}function B(){return{...F}}function V(e,t,r,o="log"){if("json"===F.outputFormat){const s={type:o,level:e,message:t,tick:Game.time};return(null==r?void 0:r.subsystem)&&(s.subsystem=r.subsystem),(null==r?void 0:r.room)&&(s.room=r.room),JSON.stringify(s)}const s=[];return F.showTimestamp&&s.push(`[${Game.time}]`),s.push(`[${e}]`),(null==r?void 0:r.subsystem)&&s.push(`[${r.subsystem}]`),F.showRoom&&(null==r?void 0:r.room)&&s.push(`[${r.room}]`),s.push(t),s.join(" ")}function q(e,t){F.level>D.DEBUG||console.log(V("DEBUG",e,t))}function j(e,t){F.level>D.INFO||console.log(V("INFO",e,t))}function X(e,t){F.level>D.WARN||console.log(V("WARN",e,t))}function z(e,t){F.level>D.ERROR||console.log(V("ERROR",e,t))}function Z(e,t,r){if(!F.cpuLogging)return t();const o=Game.cpu.getUsed(),s=t();return q(`${e}: ${(Game.cpu.getUsed()-o).toFixed(3)} CPU`,r),s}const Q={debug:q,info:j,warn:X,error:z,stat:function(e,t,r){if("json"===F.outputFormat){const o={type:"stat",key:e,value:t,tick:Game.time};r&&(o.unit=r),console.log(JSON.stringify(o))}else{const o=["stats:",e,t.toString()];r&&o.push(r),console.log(o.join(" "))}},measureCpu:Z,configure:W,getConfig:B,createLogger:function(e){return{debug:(t,r)=>q(t,{subsystem:e,room:r}),info:(t,r)=>j(t,{subsystem:e,room:r}),warn:(t,r)=>X(t,{subsystem:e,room:r}),error:(t,r)=>z(t,{subsystem:e,room:r}),measureCpu:(t,r,o)=>Z(t,r,{subsystem:e,room:o})}}},J=[],ee=new class{constructor(){this.commands=new Map,this.initialized=0}register(e,t){var r;this.commands.has(e.name)&&Q.warn(`Command "${e.name}" is already registered, overwriting`,{subsystem:"CommandRegistry"}),this.commands.set(e.name,{metadata:{...e,category:null!==(r=e.category)&&void 0!==r?r:"General"},handler:t}),Q.debug(`Registered command "${e.name}"`,{subsystem:"CommandRegistry"})}unregister(e){const t=this.commands.delete(e);return t&&Q.debug(`Unregistered command "${e}"`,{subsystem:"CommandRegistry"}),t}getCommand(e){return this.commands.get(e)}getCommands(){return Array.from(this.commands.values())}getCommandsByCategory(){var e,t;const r=new Map;for(const o of this.commands.values()){const s=null!==(e=o.metadata.category)&&void 0!==e?e:"General",n=null!==(t=r.get(s))&&void 0!==t?t:[];n.push(o),r.set(s,n)}for(const[e,t]of r)r.set(e,t.sort((e,t)=>e.metadata.name.localeCompare(t.metadata.name)));return r}execute(e,...t){const r=this.commands.get(e);if(!r)return`Command "${e}" not found. Use help() to see available commands.`;try{return r.handler(...t)}catch(t){const r=t instanceof Error?t.message:t+"";return Q.error(`Error executing command "${e}": ${r}`,{subsystem:"CommandRegistry"}),"Error: "+r}}generateHelp(){var e;const t=this.getCommandsByCategory(),r=["=== Available Console Commands ===",""],o=Array.from(t.keys()).sort((e,t)=>"General"===e?-1:"General"===t?1:e.localeCompare(t));for(const s of o){const o=t.get(s);if(o&&0!==o.length){r.push(`--- ${s} ---`);for(const t of o){const o=null!==(e=t.metadata.usage)&&void 0!==e?e:t.metadata.name+"()";if(r.push("  "+o),r.push("    "+t.metadata.description),t.metadata.examples&&t.metadata.examples.length>0){r.push("    Examples:");for(const e of t.metadata.examples)r.push("      "+e)}r.push("")}}}return r.join("\n")}generateCommandHelp(e){var t,r;const o=this.commands.get(e);if(!o)return`Command "${e}" not found. Use help() to see available commands.`;const s=[`=== ${o.metadata.name} ===`,"","Description: "+o.metadata.description,"Usage: "+(null!==(t=o.metadata.usage)&&void 0!==t?t:o.metadata.name+"()"),"Category: "+(null!==(r=o.metadata.category)&&void 0!==r?r:"General")];if(o.metadata.examples&&o.metadata.examples.length>0){s.push(""),s.push("Examples:");for(const e of o.metadata.examples)s.push("  "+e)}return s.join("\n")}exposeToGlobal(){const e=global;for(const[t,r]of this.commands)e[t]=r.handler;e.help=e=>e?this.generateCommandHelp(e):this.generateHelp(),Q.debug(`Exposed ${this.commands.size} commands to global scope`,{subsystem:"CommandRegistry"})}initialize(){this.initialized||(this.register({name:"help",description:"Show available commands and their descriptions",usage:"help() or help('commandName')",examples:["help()","help('setLogLevel')"],category:"System"},(...e)=>{const t=e[0];return void 0!==t?this.generateCommandHelp(t+""):this.generateHelp()}),this.initialized=1,Q.info("Command registry initialized",{subsystem:"CommandRegistry"}))}getCommandCount(){return this.commands.size}isInitialized(){return this.initialized}reset(){this.commands.clear(),this.initialized=0}};function te(e){return function(t,r,o){J.push({metadata:e,methodName:r+"",target:t})}}function re(e){const t=Object.getPrototypeOf(e);for(const r of J)if(oe(r.target,t)){const t=e[r.methodName];if("function"==typeof t){const o=t.bind(e);ee.register(r.metadata,o),Q.debug(`Registered decorated command "${r.metadata.name}"`,{subsystem:"CommandRegistry"})}}}function oe(e,t){return null===t?0:e===t||Object.getPrototypeOf(e)===t||e===Object.getPrototypeOf(t)}var se;!function(e){e[e.CRITICAL=100]="CRITICAL",e[e.HIGH=75]="HIGH",e[e.NORMAL=50]="NORMAL",e[e.LOW=25]="LOW",e[e.BACKGROUND=10]="BACKGROUND"}(se||(se={}));const ne={"hostile.detected":se.CRITICAL,"nuke.detected":se.CRITICAL,"safemode.activated":se.CRITICAL,"structure.destroyed":se.HIGH,"hostile.cleared":se.HIGH,"creep.died":se.HIGH,"energy.critical":se.HIGH,"spawn.emergency":se.HIGH,"posture.change":se.HIGH,"spawn.completed":se.NORMAL,"rcl.upgrade":se.NORMAL,"construction.complete":se.NORMAL,"remote.lost":se.NORMAL,"squad.formed":se.NORMAL,"squad.dissolved":se.NORMAL,"market.transaction":se.LOW,"pheromone.update":se.LOW,"cluster.update":se.LOW,"expansion.candidate":se.LOW,"powerbank.discovered":se.LOW,"cpu.spike":se.BACKGROUND,"bucket.modeChange":se.BACKGROUND},ie={maxEventsPerTick:50,maxQueueSize:200,lowBucketThreshold:2e3,criticalBucketThreshold:1e3,maxEventAge:100,enableLogging:0,statsLogInterval:100},ae=new class{constructor(e={}){this.handlers=new Map,this.eventQueue=[],this.handlerIdCounter=0,this.stats={eventsEmitted:0,eventsProcessed:0,eventsDeferred:0,eventsDropped:0,handlersInvoked:0},this.config={...ie,...e}}on(e,t,r={}){var o,s,n,i;const a={handler:t,priority:null!==(o=r.priority)&&void 0!==o?o:se.NORMAL,minBucket:null!==(s=r.minBucket)&&void 0!==s?s:0,once:null!==(n=r.once)&&void 0!==n?n:0,id:"handler_"+ ++this.handlerIdCounter},c=null!==(i=this.handlers.get(e))&&void 0!==i?i:[];return c.push(a),c.sort((e,t)=>t.priority-e.priority),this.handlers.set(e,c),this.config.enableLogging&&Q.debug(`EventBus: Registered handler for "${e}" (id: ${a.id})`,{subsystem:"EventBus"}),()=>this.off(e,a.id)}once(e,t,r={}){return this.on(e,t,{...r,once:1})}off(e,t){const r=this.handlers.get(e);if(r){const o=r.findIndex(e=>e.id===t);-1!==o&&(r.splice(o,1),this.config.enableLogging&&Q.debug(`EventBus: Unregistered handler "${t}" from "${e}"`,{subsystem:"EventBus"}))}}offAll(e){this.handlers.delete(e),this.config.enableLogging&&Q.debug(`EventBus: Removed all handlers for "${e}"`,{subsystem:"EventBus"})}emit(e,t,r={}){var o,s,n;const i={...t,tick:Game.time},a=null!==(s=null!==(o=r.priority)&&void 0!==o?o:ne[e])&&void 0!==s?s:se.NORMAL,c=null!==(n=r.immediate)&&void 0!==n?n:a>=se.CRITICAL;this.stats.eventsEmitted++,this.config.enableLogging&&Q.debug(`EventBus: Emitting "${e}" (priority: ${a}, immediate: ${c+""})`,{subsystem:"EventBus"});const u=Game.cpu.bucket;c||u>=this.config.lowBucketThreshold?this.processEvent(e,i):u<this.config.criticalBucketThreshold?a<se.CRITICAL?(this.stats.eventsDropped++,this.config.enableLogging&&Q.warn(`EventBus: Dropped event "${e}" due to critical bucket`,{subsystem:"EventBus"})):this.processEvent(e,i):this.queueEvent(e,i,a)}processEvent(e,t){const r=this.handlers.get(e);if(!r||0===r.length)return;const o=Game.cpu.bucket,s=[];for(const n of r)if(o>=n.minBucket)try{n.handler(t),this.stats.handlersInvoked++,n.once&&s.push(n.id)}catch(t){const r=t instanceof Error?t.message:t+"";Q.error(`EventBus: Handler error for "${e}": ${r}`,{subsystem:"EventBus"})}for(const t of s)this.off(e,t);this.stats.eventsProcessed++}queueEvent(e,t,r){if(this.eventQueue.length>=this.config.maxQueueSize){const e=this.eventQueue.map((e,t)=>({event:e,index:t})).filter(({event:e})=>e.priority<se.HIGH).sort((e,t)=>e.event.queuedAt-t.event.queuedAt)[0];if(!e||e.event.priority>=r)return void this.stats.eventsDropped++;this.eventQueue.splice(e.index,1),this.stats.eventsDropped++}const o={name:e,payload:t,priority:r,queuedAt:Game.time};this.eventQueue.push(o),this.eventQueue.sort((e,t)=>t.priority!==e.priority?t.priority-e.priority:e.queuedAt-t.queuedAt),this.stats.eventsDeferred++}processQueue(){const e=Game.cpu.bucket;if(e<this.config.criticalBucketThreshold)return;let t=this.config.maxEventsPerTick;e<this.config.lowBucketThreshold&&(t=Math.floor(t/2));const r=Game.time;this.eventQueue=this.eventQueue.filter(e=>r-e.queuedAt>this.config.maxEventAge?(this.stats.eventsDropped++,0):1);let o=0;for(;this.eventQueue.length>0&&t>o;){const e=this.eventQueue.shift();e&&(this.processEvent(e.name,e.payload),o++)}}getStats(){let e=0;for(const t of this.handlers.values())e+=t.length;return{...this.stats,queueSize:this.eventQueue.length,handlerCount:e}}resetStats(){this.stats={eventsEmitted:0,eventsProcessed:0,eventsDeferred:0,eventsDropped:0,handlersInvoked:0}}getConfig(){return{...this.config}}updateConfig(e){this.config={...this.config,...e}}clear(){this.handlers.clear(),this.eventQueue=[],this.resetStats()}getHandlerCount(e){var t,r;return null!==(r=null===(t=this.handlers.get(e))||void 0===t?void 0:t.length)&&void 0!==r?r:0}hasHandlers(e){return this.getHandlerCount(e)>0}logStats(){if(Game.time%this.config.statsLogInterval===0){const e=this.getStats();Q.debug(`EventBus stats: ${e.eventsEmitted} emitted, ${e.eventsProcessed} processed, ${e.eventsDeferred} deferred, ${e.eventsDropped} dropped, ${e.queueSize} queued, ${e.handlerCount} handlers`,{subsystem:"EventBus"})}}};let ce={pheromone:{updateInterval:5,decayFactors:{expand:.95,harvest:.9,build:.92,upgrade:.93,defense:.97,war:.98,siege:.99,logistics:.91,nukeTarget:.99},diffusionRates:{expand:.3,harvest:.1,build:.15,upgrade:.1,defense:.4,war:.5,siege:.6,logistics:.2,nukeTarget:.1},maxValue:100,minValue:0},war:{dangerThresholds:{level1HostileCount:1,level2HostileCount:3,level2DamageThreshold:100,level3DamageThreshold:500},postureThresholds:{defensivePosture:30,warPosture:50,expandPosture:40},economyStabilityRatio:1.2,warSustainedTicks:100},nuke:{minEnemyRCL:5,minThreatLevel:2,minNukeScore:35,scoring:{enemyRCLWeight:2,hostileStructuresWeight:3,warPheromoneWeight:1.5,distancePenalty:.5},evaluationInterval:200},expansion:{minEnergySurplus:1e3,minBucketForClaim:8e3,maxRemoteDistance:2,maxClaimDistance:5,scoring:{sourcesWeight:20,mineralWeight:10,distancePenalty:5,hostilePenalty:30,terrainPenalty:2,highwayBonus:15}},cpu:{bucketThresholds:{lowMode:2e3,highMode:9e3},budgets:{rooms:.4,creeps:.3,strategic:.1,market:.1,visualization:.1},taskFrequencies:{pheromoneUpdate:5,clusterLogic:10,strategicDecisions:20,marketScan:100,nukeEvaluation:200,memoryCleanup:50}},market:{maxCreditsPerTick:1e5,minCreditReserve:5e4,safetyBuffer:{energy:5e4,baseMinerals:5e3},priceTolerance:{buy:.1,sell:.1,emergency:.5},scanInterval:100,tradeCooldown:10},spawn:{bodyCosts:{[MOVE]:50,[WORK]:100,[CARRY]:50,[ATTACK]:80,[RANGED_ATTACK]:150,[HEAL]:250,[CLAIM]:600,[TOUGH]:10},minCreepCounts:{harvester:2,hauler:2,upgrader:1,builder:1},rolePriorities:{harvester:100,hauler:90,queenCarrier:85,builder:70,upgrader:60,guard:80,healer:75,scout:40,claimer:50}},boost:{roleBoosts:{harvester:["UO"],upgrader:["GH","GH2O","XGH2O"],guard:["UH","LO"],healer:["LO","LHO2","XLHO2"],soldier:["UH","KO","XZHO2"]},boostPriority:["XLHO2","XUH2O","XZHO2","XGH2O"],minBoostAmount:30},debug:0,profiling:1,visualizations:1};function ue(){return ce}function le(e){ce={...ce,...e}}var me;!function(e){e[e.CRITICAL=100]="CRITICAL",e[e.HIGH=75]="HIGH",e[e.MEDIUM=50]="MEDIUM",e[e.LOW=25]="LOW",e[e.IDLE=10]="IDLE"}(me||(me={}));const pe={targetCpuUsage:.85,reservedCpu:5,enableStats:1,statsLogInterval:100,pixelGenerationEnabled:1,pixelRecoveryTicks:100,budgetWarningThreshold:1.5,budgetWarningInterval:500};function de(e){const t=e.bucketThresholds.highMode,r=e.bucketThresholds.lowMode,o=function(e){return Math.max(0,Math.floor(e/2))}(r),s=(n=e.taskFrequencies,{high:1,medium:Math.max(1,Math.min(n.clusterLogic,n.pheromoneUpdate)),low:Math.max(n.marketScan,n.nukeEvaluation,n.memoryCleanup)});var n;const i=function(e,t){return{high:Math.max(0,Math.floor(.25*e.lowMode)),medium:e.lowMode,low:Math.max(e.lowMode,Math.floor((e.lowMode+t)/2))}}(e.bucketThresholds,t),a={high:(c=e.budgets).rooms,medium:c.strategic,low:Math.max(c.market,c.visualization)};var c;return{...pe,lowBucketThreshold:r,highBucketThreshold:t,criticalBucketThreshold:o,frequencyIntervals:s,frequencyMinBucket:i,frequencyCpuBudgets:a}}const ge=new class{constructor(e){this.processes=new Map,this.bucketMode="normal",this.tickCpuUsed=0,this.initialized=0,this.lastPixelGenerationTick=0,this.lastExecutedIndex=-1,this.processQueue=[],this.queueDirty=1,this.config={...e},this.validateConfig(),this.frequencyDefaults=this.buildFrequencyDefaults()}registerProcess(e){var t,r,o,s,n;const i=null!==(t=e.frequency)&&void 0!==t?t:"medium",a=this.frequencyDefaults[i],c={id:e.id,name:e.name,priority:null!==(r=e.priority)&&void 0!==r?r:me.MEDIUM,frequency:i,minBucket:null!==(o=e.minBucket)&&void 0!==o?o:a.minBucket,cpuBudget:null!==(s=e.cpuBudget)&&void 0!==s?s:a.cpuBudget,interval:null!==(n=e.interval)&&void 0!==n?n:a.interval,execute:e.execute,state:"idle",stats:{totalCpu:0,runCount:0,avgCpu:0,maxCpu:0,lastRunTick:0,skippedCount:0,errorCount:0}};this.processes.set(e.id,c),this.queueDirty=1,Q.debug(`Kernel: Registered process "${c.name}" (${c.id})`,{subsystem:"Kernel"})}unregisterProcess(e){const t=this.processes.delete(e);return t&&(this.queueDirty=1,Q.debug("Kernel: Unregistered process "+e,{subsystem:"Kernel"})),t}getProcess(e){return this.processes.get(e)}getProcesses(){return Array.from(this.processes.values())}initialize(){this.initialized||(Q.info(`Kernel initialized with ${this.processes.size} processes`,{subsystem:"Kernel"}),this.initialized=1)}updateBucketMode(){const e=Game.cpu.bucket;let t;const r=this.isInPixelRecoveryPeriod();t=e<this.config.criticalBucketThreshold&&!r?"critical":e<this.config.lowBucketThreshold&&!r?"low":e>this.config.highBucketThreshold?"high":"normal",t!==this.bucketMode&&(Q.info(`Kernel: Bucket mode changed from ${this.bucketMode} to ${t} (bucket: ${e}${r?", recovering from pixel":""})`,{subsystem:"Kernel"}),this.bucketMode=t)}validateConfig(){this.config.criticalBucketThreshold<this.config.lowBucketThreshold||(Q.warn(`Kernel: Adjusting critical bucket threshold ${this.config.criticalBucketThreshold} to stay below low threshold ${this.config.lowBucketThreshold}`,{subsystem:"Kernel"}),this.config.criticalBucketThreshold=Math.max(0,this.config.lowBucketThreshold-1)),this.config.lowBucketThreshold<this.config.highBucketThreshold||(Q.warn(`Kernel: Adjusting high bucket threshold ${this.config.highBucketThreshold} to stay above low threshold ${this.config.lowBucketThreshold}`,{subsystem:"Kernel"}),this.config.highBucketThreshold=this.config.lowBucketThreshold+1)}buildFrequencyDefaults(){return{high:{interval:this.config.frequencyIntervals.high,minBucket:this.config.frequencyMinBucket.high,cpuBudget:this.config.frequencyCpuBudgets.high},medium:{interval:this.config.frequencyIntervals.medium,minBucket:this.config.frequencyMinBucket.medium,cpuBudget:this.config.frequencyCpuBudgets.medium},low:{interval:this.config.frequencyIntervals.low,minBucket:this.config.frequencyMinBucket.low,cpuBudget:this.config.frequencyCpuBudgets.low}}}isInPixelRecoveryPeriod(){return this.config.pixelGenerationEnabled?0===this.lastPixelGenerationTick?0:Game.time-this.lastPixelGenerationTick<this.config.pixelRecoveryTicks:0}notifyPixelGenerated(){this.lastPixelGenerationTick=Game.time,Q.debug(`Kernel: Pixel generated at tick ${Game.time}, recovery period started`,{subsystem:"Kernel"})}getBucketMode(){return this.updateBucketMode(),this.bucketMode}getCpuLimit(){const e=Game.cpu.limit;switch(this.bucketMode){case"critical":return.3*e;case"low":return.5*e;default:return e*this.config.targetCpuUsage}}hasCpuBudget(){const e=Game.cpu.getUsed();return this.getCpuLimit()-e>this.config.reservedCpu}getRemainingCpu(){return Math.max(0,this.getCpuLimit()-Game.cpu.getUsed()-this.config.reservedCpu)}rebuildProcessQueue(){this.processQueue=Array.from(this.processes.values()).sort((e,t)=>t.priority-e.priority),this.queueDirty=0,this.lastExecutedIndex=-1}shouldRunProcess(e){return Game.cpu.bucket<e.minBucket||e.stats.runCount>0&&Game.time-e.stats.lastRunTick<e.interval?0:"critical"===this.bucketMode?e.priority>=me.CRITICAL:"low"===this.bucketMode?e.priority>=me.HIGH:"suspended"===e.state?0:1}executeProcess(e){const t=Game.cpu.getUsed();e.state="running";try{e.execute(),e.state="idle"}catch(t){e.state="error",e.stats.errorCount++;const r=t instanceof Error?t.message:t+"";Q.error(`Kernel: Process "${e.name}" error: ${r}`,{subsystem:"Kernel"}),t instanceof Error&&t.stack&&Q.error(t.stack,{subsystem:"Kernel"})}const r=Game.cpu.getUsed()-t;this.config.enableStats&&(e.stats.totalCpu+=r,e.stats.runCount++,e.stats.avgCpu=e.stats.totalCpu/e.stats.runCount,e.stats.maxCpu=Math.max(e.stats.maxCpu,r),e.stats.lastRunTick=Game.time),this.tickCpuUsed+=r;const o=this.getCpuLimit()*e.cpuBudget,s=r/o;s>this.config.budgetWarningThreshold&&Game.time%this.config.budgetWarningInterval===0&&Q.warn(`Kernel: Process "${e.name}" exceeded CPU budget: ${r.toFixed(3)} > ${o.toFixed(3)} (${(100*s).toFixed(0)}%)`,{subsystem:"Kernel"})}run(){if(this.updateBucketMode(),this.tickCpuUsed=0,ae.processQueue(),this.queueDirty&&this.rebuildProcessQueue(),0===this.processQueue.length)return;let e=0,t=-1;const r=(this.lastExecutedIndex+1)%this.processQueue.length;for(let o=0;o<this.processQueue.length;o++){const s=(r+o)%this.processQueue.length,n=this.processQueue[s];if(this.shouldRunProcess(n)){if(!this.hasCpuBudget())break;this.executeProcess(n),e++,t=s}}-1!==t&&(this.lastExecutedIndex=t),this.config.enableStats&&Game.time%this.config.statsLogInterval===0&&(this.logStats(e),ae.logStats())}logStats(e){Q.debug(`Kernel stats: ${e} processes ran, ${this.tickCpuUsed.toFixed(2)} CPU, mode: ${this.bucketMode}`,{subsystem:"Kernel"})}getTickCpuUsed(){return this.tickCpuUsed}suspendProcess(e){const t=this.processes.get(e);return t?(t.state="suspended",Q.info(`Kernel: Suspended process "${t.name}"`,{subsystem:"Kernel"}),1):0}resumeProcess(e){const t=this.processes.get(e);return t&&"suspended"===t.state?(t.state="idle",Q.info(`Kernel: Resumed process "${t.name}"`,{subsystem:"Kernel"}),1):0}getStatsSummary(){const e=Array.from(this.processes.values()),t=e.filter(e=>"suspended"!==e.state),r=e.filter(e=>"suspended"===e.state),o=e.reduce((e,t)=>e+t.stats.totalCpu,0),s=e.length>0?o/e.length:0,n=[...e].sort((e,t)=>t.stats.avgCpu-e.stats.avgCpu).slice(0,5).map(e=>({name:e.name,avgCpu:e.stats.avgCpu}));return{totalProcesses:e.length,activeProcesses:t.length,suspendedProcesses:r.length,totalCpuUsed:o,avgCpuPerProcess:s,topCpuProcesses:n}}resetStats(){for(const e of this.processes.values())e.stats={totalCpu:0,runCount:0,avgCpu:0,maxCpu:0,lastRunTick:0,skippedCount:0,errorCount:0};Q.info("Kernel: Reset all process statistics",{subsystem:"Kernel"})}getConfig(){return{...this.config}}getFrequencyDefaults(e){return{...this.frequencyDefaults[e]}}updateConfig(e){this.config={...this.config,...e},this.validateConfig(),this.frequencyDefaults=this.buildFrequencyDefaults()}updateFromCpuConfig(e){this.updateConfig(de(e))}on(e,t,r={}){return ae.on(e,t,r)}once(e,t,r={}){return ae.once(e,t,r)}emit(e,t,r={}){ae.emit(e,t,r)}offAll(e){ae.offAll(e)}processEvents(){ae.processQueue()}getEventStats(){return ae.getStats()}hasEventHandlers(e){return ae.hasHandlers(e)}getEventBus(){return ae}}(de(ue().cpu)),fe=-1;function Re(){const e=global;return e._heapCache&&e._heapCache.tick===Game.time||(e._heapCache?e._heapCache.tick=Game.time:e._heapCache={tick:Game.time,entries:new Map,rehydrated:0}),e._heapCache}function he(){return Memory._heapCache||(Memory._heapCache={version:1,lastSync:Game.time,data:{}}),Memory._heapCache}const ye=new class{constructor(){this.lastPersistenceTick=0}initialize(){const e=Re();e.rehydrated||(this.rehydrateFromMemory(),e.rehydrated=1)}rehydrateFromMemory(){const e=Re(),t=he();let r=0,o=0;for(const[s,n]of Object.entries(t.data))void 0!==n.ttl&&n.ttl!==fe&&Game.time-n.lastModified>n.ttl?o++:(e.entries.set(s,{value:n.value,lastModified:n.lastModified,dirty:0,ttl:n.ttl}),r++);r>0&&Game.time%100==0&&console.log(`[HeapCache] Rehydrated ${r} entries from Memory (${o} expired)`)}get(e){const t=Re(),r=t.entries.get(e);if(r)return void 0!==r.ttl&&r.ttl!==fe&&Game.time-r.lastModified>r.ttl?void t.entries.delete(e):r.value;const o=he(),s=o.data[e];return s?void 0!==s.ttl&&s.ttl!==fe&&Game.time-s.lastModified>s.ttl?void delete o.data[e]:(t.entries.set(e,{value:s.value,lastModified:s.lastModified,dirty:0,ttl:s.ttl}),s.value):void 0}set(e,t,r){Re().entries.set(e,{value:t,lastModified:Game.time,dirty:1,ttl:null!=r?r:1e3})}delete(e){Re().entries.delete(e),delete he().data[e]}has(e){return void 0!==this.get(e)}clear(){Re().entries.clear(),he().data={}}persist(e=0){if(!e&&10>Game.time-this.lastPersistenceTick)return 0;const t=Re(),r=he();let o=0;for(const[e,s]of t.entries)s.dirty&&(r.data[e]={value:s.value,lastModified:s.lastModified,ttl:s.ttl},s.dirty=0,o++);return r.lastSync=Game.time,this.lastPersistenceTick=Game.time,o}getStats(){const e=Re(),t=he();let r=0;for(const t of e.entries.values())t.dirty&&r++;return{heapSize:e.entries.size,memorySize:Object.keys(t.data).length,dirtyEntries:r,lastSync:t.lastSync}}keys(){const e=Re();return Array.from(e.entries.keys())}values(){const e=Re();return Array.from(e.entries.values()).map(e=>e.value)}cleanExpired(){const e=Re(),t=he();let r=0;for(const[t,o]of e.entries)void 0!==o.ttl&&o.ttl!==fe&&Game.time-o.lastModified>o.ttl&&(e.entries.delete(t),r++);for(const[e,o]of Object.entries(t.data))void 0!==o.ttl&&o.ttl!==fe&&Game.time-o.lastModified>o.ttl&&(delete t.data[e],r++);return r}},Ee="overmind",Te="clusters",Ce=new class{constructor(){this.lastInitializeTick=null,this.lastCleanupTick=0}initialize(){this.lastInitializeTick!==Game.time&&(this.lastInitializeTick=Game.time,ye.initialize(),this.runMemoryMigration(),this.ensureOvermindMemory(),this.ensureClustersMemory(),10>Game.time-this.lastCleanupTick||(this.cleanDeadCreeps(),this.lastCleanupTick=Game.time))}runMemoryMigration(){var e;const t=Memory,r=null!==(e=t.memoryVersion)&&void 0!==e?e:0;1>r&&(console.log(`[MemoryManager] Migrating memory from version ${r} to 1`),1>r&&this.migrateToV1(),t.memoryVersion=1,console.log("[MemoryManager] Memory migration complete"))}migrateToV1(){for(const e in Memory.creeps){const t=Memory.creeps[e];t&&void 0===t.version&&(t.version=1)}}ensureOvermindMemory(){const e=Memory;e[Ee]||(e[Ee]={roomsSeen:{},roomIntel:{},claimQueue:[],warTargets:[],nukeCandidates:[],powerBanks:[],market:{resources:{},lastScan:0},objectives:{targetPowerLevel:0,targetRoomCount:1,warMode:0,expansionPaused:0},lastRun:0})}ensureClustersMemory(){const e=Memory;e[Te]||(e[Te]={})}getOvermind(){const e="memory:"+Ee;let t=ye.get(e);if(!t){this.ensureOvermindMemory();const r=Memory;ye.set(e,r[Ee],fe),t=r[Ee]}return t}getClusters(){const e="memory:"+Te;let t=ye.get(e);if(!t){this.ensureClustersMemory();const r=Memory;ye.set(e,r[Te],fe),t=r[Te]}return t}getCluster(e,t){const r=this.getClusters();return!r[e]&&t&&(r[e]=function(e,t){return{id:e,coreRoom:t,memberRooms:[t],remoteRooms:[],forwardBases:[],role:"economic",metrics:{energyIncome:0,energyConsumption:0,energyBalance:0,warIndex:0,economyIndex:50},squads:[],rallyPoints:[],defenseRequests:[],resourceRequests:[],lastUpdate:0}}(e,t)),r[e]}getSwarmState(e){var t;const r=`memory:room:${e}:swarm`;let o=ye.get(r);if(!o){const s=null===(t=Memory.rooms)||void 0===t?void 0:t[e];if(!s)return;const n=s.swarm;n&&(ye.set(r,n,fe),o=n)}return o}initSwarmState(e){const t=`memory:room:${e}:swarm`;Memory.rooms||(Memory.rooms={}),Memory.rooms[e]||(Memory.rooms[e]={});const r=Memory.rooms[e];return r.swarm||(r.swarm={colonyLevel:"seedNest",posture:"eco",danger:0,pheromones:{expand:0,harvest:10,build:5,upgrade:5,defense:0,war:0,siege:0,logistics:5,nukeTarget:0},nextUpdateTick:0,eventLog:[],missingStructures:{spawn:1,storage:1,terminal:1,labs:1,nuker:1,factory:1,extractor:1,powerSpawn:1,observer:1},role:"secondaryCore",remoteAssignments:[],metrics:{energyHarvested:0,energySpawning:0,energyConstruction:0,energyRepair:0,energyTower:0,controllerProgress:0,hostileCount:0,damageReceived:0,constructionSites:0,energyAvailable:0,energyCapacity:0,energyNeed:0},lastUpdate:0}),ye.set(t,r.swarm,fe),r.swarm}getOrInitSwarmState(e){var t;return null!==(t=this.getSwarmState(e))&&void 0!==t?t:this.initSwarmState(e)}getCreepMemory(e){const t=Game.creeps[e];if(t)return t.memory}cleanDeadCreeps(){let e=0;for(const t in Memory.creeps)t in Game.creeps||(delete Memory.creeps[t],e++);return e}recordRoomSeen(e){this.getOvermind().roomsSeen[e]=Game.time}addRoomEvent(e,t,r){const o=this.getSwarmState(e);if(!o)return;const s={type:t,time:Game.time};for(void 0!==r&&(s.details=r),o.eventLog.push(s);o.eventLog.length>20;)o.eventLog.shift()}getMemorySize(){return JSON.stringify(Memory).length}isMemoryNearLimit(){return this.getMemorySize()>1887436.8}persistHeapCache(){ye.persist()}getHeapCache(){return ye}isRoomHostile(e){var t,r,o;const s=`memory:room:${e}:hostile`,n=ye.get(s);if(void 0!==n)return 1==n;const i=null!==(o=null===(r=null===(t=Memory.rooms)||void 0===t?void 0:t[e])||void 0===r?void 0:r.hostile)&&void 0!==o?o:0;return ye.set(s,i?1:null,100),i}setRoomHostile(e,t){Memory.rooms||(Memory.rooms={}),Memory.rooms[e]||(Memory.rooms[e]={}),Memory.rooms[e].hostile=t;const r=`memory:room:${e}:hostile`;ye.set(r,t?1:null,100)}},ve={primarySegment:90,backupSegment:91,retentionPeriod:1e4,updateInterval:10,maxDataPoints:1e3},Se=new class{constructor(e={}){this.statsData=null,this.segmentRequested=0,this.lastUpdate=0,this.config={...ve,...e}}initialize(){RawMemory.setActiveSegments([this.config.primarySegment]),this.segmentRequested=1}run(){this.segmentRequested&&void 0!==RawMemory.segments[this.config.primarySegment]&&(this.loadFromSegment(),this.segmentRequested=0),Game.time-this.lastUpdate<this.config.updateInterval||(this.updateStats(),this.lastUpdate=Game.time)}loadFromSegment(){const e=RawMemory.segments[this.config.primarySegment];if(e&&0!==e.length)try{this.statsData=JSON.parse(e),Q.debug("Loaded stats from segment",{subsystem:"Stats"})}catch(e){const t=e instanceof Error?e.message:e+"";Q.error("Failed to parse stats segment: "+t,{subsystem:"Stats"}),this.statsData=this.createDefaultStatsData()}else this.statsData=this.createDefaultStatsData()}createDefaultStatsData(){return{version:1,lastUpdate:Game.time,history:[],series:{}}}updateStats(){this.statsData||(this.statsData=this.createDefaultStatsData());const e=this.collectGlobalStats();for(this.statsData.history.push(e);this.statsData.history.length>this.config.maxDataPoints;)this.statsData.history.shift();const t=Game.time-this.config.retentionPeriod;this.statsData.history=this.statsData.history.filter(e=>e.tick>=t),this.updateMetricSeries("cpu",e.cpuUsed),this.updateMetricSeries("bucket",e.cpuBucket),this.updateMetricSeries("creeps",e.totalCreeps),this.updateMetricSeries("rooms",e.totalRooms),this.publishStatsToMemory(e),this.saveToSegment()}publishStatsToMemory(e){const t=Memory;t.stats&&"object"==typeof t.stats||(t.stats={});const r=t.stats;r["stats.cpu.used"]=e.cpuUsed,r["stats.cpu.limit"]=e.cpuLimit,r["stats.cpu.bucket"]=e.cpuBucket,r["stats.cpu.percent"]=e.cpuLimit>0?e.cpuUsed/e.cpuLimit*100:0,r["stats.gcl.level"]=e.gclLevel,r["stats.gcl.progress"]=e.gclProgress,r["stats.gcl.progress_total"]=e.gclProgressTotal,r["stats.gpl.level"]=e.gplLevel,r["stats.empire.creeps"]=e.totalCreeps,r["stats.empire.rooms"]=e.totalRooms;const o=e.rooms.reduce((e,t)=>({storage:e.storage+t.storageEnergy,terminal:e.terminal+t.terminalEnergy,available:e.available+t.energyAvailable,capacity:e.capacity+t.energyCapacity}),{storage:0,terminal:0,available:0,capacity:0});r["stats.empire.energy.storage"]=o.storage,r["stats.empire.energy.terminal"]=o.terminal,r["stats.empire.energy.available"]=o.available,r["stats.empire.energy.capacity"]=o.capacity;for(const t of e.rooms){const e="stats.room."+t.roomName;r[e+".rcl"]=t.rcl,r[e+".energy.available"]=t.energyAvailable,r[e+".energy.capacity"]=t.energyCapacity,r[e+".storage.energy"]=t.storageEnergy,r[e+".terminal.energy"]=t.terminalEnergy,r[e+".creeps"]=t.creepCount,r[e+".controller.progress"]=t.controllerProgress,r[e+".controller.progress_total"]=t.controllerProgressTotal,r[e+".controller.progress_percent"]=t.controllerProgressTotal>0?t.controllerProgress/t.controllerProgressTotal*100:0;const o=Ce.getSwarmState(t.roomName);if(o){r[e+".brain.danger"]=o.danger,r[e+".brain.posture_code"]=this.postureToCode(o.posture),r[e+".brain.colony_level_code"]=this.colonyLevelToCode(o.colonyLevel);for(const[t,s]of Object.entries(o.pheromones))r[`${e}.pheromone.${t}`]=s;const t=o.metrics;r[e+".metrics.energy.harvested"]=t.energyHarvested,r[e+".metrics.energy.spawning"]=t.energySpawning,r[e+".metrics.energy.construction"]=t.energyConstruction,r[e+".metrics.energy.repair"]=t.energyRepair,r[e+".metrics.energy.tower"]=t.energyTower,r[e+".metrics.energy.available_for_sharing"]=t.energyAvailable,r[e+".metrics.energy.capacity_total"]=t.energyCapacity,r[e+".metrics.energy.need"]=t.energyNeed,r[e+".metrics.controller_progress"]=t.controllerProgress,r[e+".metrics.hostile_count"]=t.hostileCount,r[e+".metrics.damage_received"]=t.damageReceived,r[e+".metrics.construction_sites"]=t.constructionSites}}r["stats.system.tick"]=e.tick,r["stats.system.timestamp"]=Date.now()}collectGlobalStats(){var e,t,r,o;const s=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),n=new Map;for(const r in Game.creeps){const o=Game.creeps[r];if(!o.spawning&&(null===(e=o.room.controller)||void 0===e?void 0:e.my)){const e=null!==(t=n.get(o.room.name))&&void 0!==t?t:0;n.set(o.room.name,e+1)}}const i=s.map(e=>{var t,r,o,s,i,a,c,u,l,m,p;return{roomName:e.name,rcl:null!==(r=null===(t=e.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0,energyAvailable:e.energyAvailable,energyCapacity:e.energyCapacityAvailable,storageEnergy:null!==(s=null===(o=e.storage)||void 0===o?void 0:o.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==s?s:0,terminalEnergy:null!==(a=null===(i=e.terminal)||void 0===i?void 0:i.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==a?a:0,creepCount:null!==(c=n.get(e.name))&&void 0!==c?c:0,controllerProgress:null!==(l=null===(u=e.controller)||void 0===u?void 0:u.progress)&&void 0!==l?l:0,controllerProgressTotal:null!==(p=null===(m=e.controller)||void 0===m?void 0:m.progressTotal)&&void 0!==p?p:1}});return{tick:Game.time,cpuUsed:Game.cpu.getUsed(),cpuLimit:Game.cpu.limit,cpuBucket:Game.cpu.bucket,gclLevel:Game.gcl.level,gclProgress:Game.gcl.progress,gclProgressTotal:Game.gcl.progressTotal,gplLevel:null!==(o=null===(r=Game.gpl)||void 0===r?void 0:r.level)&&void 0!==o?o:0,totalCreeps:Object.keys(Game.creeps).length,totalRooms:s.length,rooms:i,metrics:{}}}updateMetricSeries(e,t){if(!this.statsData)return;let r=this.statsData.series[e];r||(r={name:e,data:[],lastUpdate:Game.time,min:t,max:t,avg:t},this.statsData.series[e]=r),r.data.push({tick:Game.time,value:t}),r.lastUpdate=Game.time;const o=Game.time-this.config.retentionPeriod;for(r.data=r.data.filter(e=>e.tick>=o);r.data.length>this.config.maxDataPoints;)r.data.shift();r.data.length>0&&(r.min=Math.min(...r.data.map(e=>e.value)),r.max=Math.max(...r.data.map(e=>e.value)),r.avg=r.data.reduce((e,t)=>e+t.value,0)/r.data.length)}saveToSegment(){if(!this.statsData)return;const e=102400;try{this.statsData.lastUpdate=Game.time;let t=JSON.stringify(this.statsData);if(t.length>e){for(Q.warn(`Stats data exceeds segment limit: ${t.length} bytes, trimming...`,{subsystem:"Stats"});t.length>e&&this.statsData.history.length>10;)this.statsData.history.shift(),t=JSON.stringify(this.statsData);if(t.length>e)for(const r of Object.keys(this.statsData.series)){const o=this.statsData.series[r];for(;o.data.length>10&&t.length>e;)o.data.shift(),t=JSON.stringify(this.statsData)}if(t.length>e){Q.warn("Stats data still exceeds limit after trimming, clearing history",{subsystem:"Stats"}),this.statsData.history=this.statsData.history.slice(-5);for(const e of Object.keys(this.statsData.series))this.statsData.series[e].data=this.statsData.series[e].data.slice(-5);t=JSON.stringify(this.statsData)}}RawMemory.segments[this.config.primarySegment]=t}catch(e){const t=e instanceof Error?e.message:e+"";Q.error("Failed to save stats segment: "+t,{subsystem:"Stats"})}}recordMetric(e,t){this.updateMetricSeries(e,t)}getLatestStats(){var e;return this.statsData&&0!==this.statsData.history.length&&null!==(e=this.statsData.history[this.statsData.history.length-1])&&void 0!==e?e:null}getMetricSeries(e){var t,r;return null!==(r=null===(t=this.statsData)||void 0===t?void 0:t.series[e])&&void 0!==r?r:null}getMetricNames(){var e,t;return Object.keys(null!==(t=null===(e=this.statsData)||void 0===e?void 0:e.series)&&void 0!==t?t:{})}getHistory(e){if(!this.statsData)return[];const t=this.statsData.history;return e?t.slice(-e):t}getRoomHistory(e,t){if(!this.statsData)return[];const r=this.statsData.history.map(t=>t.rooms.find(t=>t.roomName===e)).filter(e=>void 0!==e);return t?r.slice(-t):r}exportForGraphana(){const e=this.getLatestStats();if(!e)return"{}";const t={timestamp:(new Date).toISOString(),tick:e.tick,cpu:{used:e.cpuUsed,limit:e.cpuLimit,bucket:e.cpuBucket},gcl:{level:e.gclLevel,progress:e.gclProgress,progressTotal:e.gclProgressTotal},gpl:{level:e.gplLevel},empire:{totalCreeps:e.totalCreeps,totalRooms:e.totalRooms},rooms:{}};for(const r of e.rooms)t.rooms[r.roomName]={rcl:r.rcl,energyAvailable:r.energyAvailable,energyCapacity:r.energyCapacity,storageEnergy:r.storageEnergy,terminalEnergy:r.terminalEnergy,creepCount:r.creepCount,controllerProgress:r.controllerProgress,controllerProgressTotal:r.controllerProgressTotal};return JSON.stringify(t,null,2)}clear(){this.statsData=this.createDefaultStatsData(),this.saveToSegment()}postureToCode(e){var t;return null!==(t={eco:0,expand:1,defensive:2,war:3,siege:4,evacuate:5,nukePrep:6}[e])&&void 0!==t?t:-1}colonyLevelToCode(e){var t;return null!==(t={seedNest:1,foragingExpansion:2,matureColony:3,fortifiedHive:4,empireDominance:5}[e])&&void 0!==t?t:0}},Ue={enabled:1,smoothingFactor:.1,trackNativeCalls:1,logInterval:100},Oe=new class{constructor(e={}){this.config={...Ue,...e},this.nativeCallsThisTick=this.createEmptyNativeCalls()}getStatsRoot(){const e=Memory;e.stats&&"object"==typeof e.stats||(e.stats=this.createEmptyStatsRoot());const t=e.stats;return t.subsystems&&"object"==typeof t.subsystems||(t.subsystems={}),t.roles&&"object"==typeof t.roles||(t.roles={}),t.rooms&&"object"==typeof t.rooms||(t.rooms={}),t.creeps&&"object"==typeof t.creeps||(t.creeps={}),t.pheromones&&"object"==typeof t.pheromones||(t.pheromones={}),t.empire&&"object"==typeof t.empire||(t.empire=this.createEmptyEmpireStats()),t.nativeCalls&&"object"==typeof t.nativeCalls||(t.nativeCalls=this.createEmptyNativeCalls()),t.processes&&"object"==typeof t.processes||(t.processes={}),t}createEmptyStatsRoot(){return{tick:Game.time,subsystems:{},roles:{},rooms:{},creeps:{},empire:this.createEmptyEmpireStats(),pheromones:{},nativeCalls:this.createEmptyNativeCalls(),processes:{}}}createEmptyEmpireStats(){return{ownedRooms:0,totalCreeps:0,totalStorageEnergy:0,gclProgress:0,gcl:0,gpl:0,cpuUsed:0,cpuLimit:0,cpuBucket:0,heapUsed:0,credits:0,rooms:[]}}createEmptyNativeCalls(){return{pathfinderSearch:0,moveTo:0,move:0,harvest:0,transfer:0,withdraw:0,build:0,repair:0,upgradeController:0,attack:0,rangedAttack:0,heal:0,dismantle:0,say:0,total:0}}recordSubsystem(e,t,r=1){if(!this.config.enabled)return;const o=this.getStatsRoot(),s=o.subsystems[e];s?(s.avgCpu=s.avgCpu*(1-this.config.smoothingFactor)+t*this.config.smoothingFactor,s.peakCpu=Math.max(s.peakCpu,t),s.calls=r,s.samples++):o.subsystems[e]={avgCpu:t,peakCpu:t,calls:r,samples:1}}recordRole(e,t,r,o=1,s){var n,i,a,c,u,l,m,p,d,g;if(!this.config.enabled)return;const f=this.getStatsRoot(),R=f.roles[e];R?(R.count=t,R.avgCpu=R.avgCpu*(1-this.config.smoothingFactor)+r*this.config.smoothingFactor,R.peakCpu=Math.max(R.peakCpu,r),R.calls=o,R.samples++,R.spawningCount=null!==(l=null==s?void 0:s.spawningCount)&&void 0!==l?l:0,R.idleCount=null!==(m=null==s?void 0:s.idleCount)&&void 0!==m?m:0,R.activeCount=null!==(p=null==s?void 0:s.activeCount)&&void 0!==p?p:t,R.avgTicksToLive=null!==(d=null==s?void 0:s.avgTicksToLive)&&void 0!==d?d:0,R.totalBodyParts=null!==(g=null==s?void 0:s.totalBodyParts)&&void 0!==g?g:0):f.roles[e]={count:t,avgCpu:r,peakCpu:r,calls:o,samples:1,spawningCount:null!==(n=null==s?void 0:s.spawningCount)&&void 0!==n?n:0,idleCount:null!==(i=null==s?void 0:s.idleCount)&&void 0!==i?i:0,activeCount:null!==(a=null==s?void 0:s.activeCount)&&void 0!==a?a:t,avgTicksToLive:null!==(c=null==s?void 0:s.avgTicksToLive)&&void 0!==c?c:0,totalBodyParts:null!==(u=null==s?void 0:s.totalBodyParts)&&void 0!==u?u:0}}recordRoom(e,t,r,o={}){var s,n,i,a,c,u,l,m,p,d,g;if(!this.config.enabled)return;const f=this.getStatsRoot(),R=Object.values(Game.creeps).filter(t=>t.room.name===e.name).length,h=e.find(FIND_HOSTILE_CREEPS),y={},E=e=>{var t;for(const r in e)if(e[r]>0){const o=r;y[o]=(null!==(t=y[o])&&void 0!==t?t:0)+e[o]}};e.storage&&E(e.storage.store),e.terminal&&E(e.terminal.store);const T=e.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY}).reduce((e,t)=>e+t.amount,0);f.rooms[e.name]={name:e.name,rcl:null!==(n=null===(s=e.controller)||void 0===s?void 0:s.level)&&void 0!==n?n:0,energyAvailable:e.energyAvailable,energyCapacity:e.energyCapacityAvailable,storageEnergy:null!==(a=null===(i=e.storage)||void 0===i?void 0:i.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==a?a:0,creepCount:R,hostileCount:h.length,avgCpu:t,peakCpu:r,controllerProgress:null!==(u=null===(c=e.controller)||void 0===c?void 0:c.progress)&&void 0!==u?u:0,controllerProgressTotal:null!==(m=null===(l=e.controller)||void 0===l?void 0:l.progressTotal)&&void 0!==m?m:1,energyHarvested:null!==(p=o.energyHarvested)&&void 0!==p?p:0,damageReceived:null!==(d=o.damageReceived)&&void 0!==d?d:0,danger:null!==(g=o.danger)&&void 0!==g?g:0,resources:y,droppedEnergy:T}}recordPheromones(e,t,r,o){this.config.enabled&&(this.getStatsRoot().pheromones[e]={room:e,expand:t.expand,harvest:t.harvest,build:t.build,upgrade:t.upgrade,defense:t.defense,war:t.war,siege:t.siege,logistics:t.logistics,dominant:o,intent:r})}recordNativeCall(e){this.config.enabled&&this.config.trackNativeCalls&&(this.nativeCallsThisTick[e]++,this.nativeCallsThisTick.total++)}recordCreep(e,t,r,o=0){var s,n,i;if(!this.config.enabled)return;const a=this.getStatsRoot(),c=e.memory;a.creeps[e.name]={name:e.name,role:null!==(s=c.role)&&void 0!==s?s:"unknown",homeRoom:null!==(n=c.homeRoom)&&void 0!==n?n:e.room.name,currentRoom:e.room.name,cpu:t,action:r,ticksToLive:null!==(i=e.ticksToLive)&&void 0!==i?i:0,hits:e.hits,hitsMax:e.hitsMax,bodyParts:e.body.length,fatigue:e.fatigue,actionsThisTick:o}}recordProcess(e){this.config.enabled&&(this.getStatsRoot().processes[e.id]={id:e.id,name:e.name,priority:e.priority,frequency:e.frequency,state:e.state,totalCpu:e.stats.totalCpu,runCount:e.stats.runCount,avgCpu:e.stats.avgCpu,maxCpu:e.stats.maxCpu,lastRunTick:e.stats.lastRunTick,skippedCount:e.stats.skippedCount,errorCount:e.stats.errorCount,cpuBudget:e.cpuBudget,minBucket:e.minBucket})}collectProcessStats(e){this.config.enabled&&e.forEach(e=>{this.recordProcess(e)})}updateEmpireStats(){var e,t,r,o,s,n;if(!this.config.enabled)return;const i=this.getStatsRoot(),a=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),c=Object.keys(Game.creeps).length,u=a.reduce((e,t)=>{var r,o;return e+(null!==(o=null===(r=t.storage)||void 0===r?void 0:r.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==o?o:0)},0);i.empire={ownedRooms:a.length,totalCreeps:c,totalStorageEnergy:u,gclProgress:Game.gcl.progress,gcl:Game.gcl.level,gpl:null!==(t=null===(e=Game.gpl)||void 0===e?void 0:e.level)&&void 0!==t?t:0,cpuUsed:Game.cpu.getUsed(),cpuLimit:Game.cpu.limit,cpuBucket:Game.cpu.bucket,heapUsed:(null!==(n=null===(s=null===(o=(r=Game.cpu).getHeapStatistics)||void 0===o?void 0:o.call(r))||void 0===s?void 0:s.used_heap_size)&&void 0!==n?n:0)/1024/1024,credits:Game.market.credits,rooms:a.map(e=>e.name)}}finalizeTick(){var e,t,r,o,s,n,i;if(!this.config.enabled)return;const a=this.getStatsRoot();a.tick=Game.time,a.nativeCalls={...this.nativeCallsThisTick},a.creeps={};const c={};for(const u of Object.values(Game.creeps)){const l=u.memory,m=null!==(e=l.role)&&void 0!==e?e:"unknown",p=null!==(r=null===(t=l.state)||void 0===t?void 0:t.action)&&void 0!==r?r:"idle",d=null!==(o=l.working)&&void 0!==o?o:"idle"!==p;a.creeps[u.name]||(a.creeps[u.name]={name:u.name,role:m,homeRoom:null!==(s=l.homeRoom)&&void 0!==s?s:u.room.name,currentRoom:u.room.name,cpu:0,action:p,ticksToLive:null!==(n=u.ticksToLive)&&void 0!==n?n:0,hits:u.hits,hitsMax:u.hitsMax,bodyParts:u.body.length,fatigue:u.fatigue,actionsThisTick:0}),c[m]||(c[m]={count:0,spawning:0,idle:0,active:0,totalTTL:0,totalBodyParts:0}),c[m].count++,c[m].totalBodyParts+=u.body.length,c[m].totalTTL+=null!==(i=u.ticksToLive)&&void 0!==i?i:0,u.spawning?c[m].spawning++:d&&"idle"!==p?c[m].active++:c[m].idle++}for(const[e,t]of Object.entries(c)){const r=a.roles[e];r?(r.count=t.count,r.spawningCount=t.spawning,r.idleCount=t.idle,r.activeCount=t.active,r.avgTicksToLive=t.count>0?t.totalTTL/t.count:0,r.totalBodyParts=t.totalBodyParts):a.roles[e]={count:t.count,avgCpu:0,peakCpu:0,calls:0,samples:0,spawningCount:t.spawning,idleCount:t.idle,activeCount:t.active,avgTicksToLive:t.count>0?t.totalTTL/t.count:0,totalBodyParts:t.totalBodyParts}}this.nativeCallsThisTick=this.createEmptyNativeCalls(),this.config.logInterval>0&&Game.time%this.config.logInterval===0&&this.logSummary()}logSummary(){const e=this.getStatsRoot();Q.info("=== Stats Summary ==="),Q.info(`Empire: ${e.empire.ownedRooms} rooms, ${e.empire.totalCreeps} creeps, ${e.empire.cpuUsed.toFixed(2)}/${e.empire.cpuLimit} CPU`);const t=Object.entries(e.subsystems).sort((e,t)=>t[1].avgCpu-e[1].avgCpu).slice(0,5);if(t.length>0){Q.info("Top Subsystems:");for(const[e,r]of t)Q.info(`  ${e}: ${r.avgCpu.toFixed(3)} CPU avg`)}const r=Object.entries(e.roles).sort((e,t)=>t[1].avgCpu-e[1].avgCpu).slice(0,5);if(r.length>0){Q.info("Top Roles:");for(const[e,t]of r)Q.info(`  ${e}: ${t.count} creeps, ${t.avgCpu.toFixed(3)} CPU avg`)}this.config.trackNativeCalls&&Q.info(`Native calls: ${e.nativeCalls.total} total`)}getStats(){return this.getStatsRoot()}reset(){Memory.stats=this.createEmptyStatsRoot()}setEnabled(e){this.config.enabled=e}isEnabled(){return this.config.enabled}},_e={smoothingFactor:.1,enabled:1,logInterval:100},Ae="stats",Me="profiler",Ne="swarmProfiler",be=new class{constructor(e={}){this.tickMeasurements=new Map,this.subsystemMeasurements=new Map,this.config={..._e,...e}}getStatsRoot(){const e=Memory;return e[Ae]&&"object"==typeof e[Ae]||(e[Ae]={}),e[Ae]}getMemory(){const e=Memory,t=this.getStatsRoot();return!t[Me]&&e[Ne]&&(t[Me]=e[Ne],delete e[Ne]),t[Me]||(t[Me]={rooms:{},subsystems:{},roles:{},tickCount:0,lastUpdate:0}),t[Me]}startRoom(e){return this.config.enabled?Game.cpu.getUsed():0}endRoom(e,t){if(!this.config.enabled)return;const r=Game.cpu.getUsed()-t;this.tickMeasurements.set(e,r);const o=this.getMemory();if(o.rooms[e]){const t=o.rooms[e];t.avgCpu=t.avgCpu*(1-this.config.smoothingFactor)+r*this.config.smoothingFactor,t.peakCpu=Math.max(t.peakCpu,r),t.samples++,t.lastTick=Game.time}else o.rooms[e]={avgCpu:r,peakCpu:r,samples:1,lastTick:Game.time}}measureSubsystem(e,t){var r;if(!this.config.enabled)return t();const o=Game.cpu.getUsed(),s=t(),n=Game.cpu.getUsed()-o,i=null!==(r=this.subsystemMeasurements.get(e))&&void 0!==r?r:[];return i.push(n),this.subsystemMeasurements.set(e,i),s}finalizeTick(){if(!this.config.enabled)return;const e=this.getMemory();e.tickCount++,e.lastUpdate=Game.time,e.roles||(e.roles={});for(const[t,r]of this.subsystemMeasurements){const o=r.reduce((e,t)=>e+t,0),s=t.startsWith("role:"),n=s?e.roles:e.subsystems,i=s?t.substring(5):t;if(n[i]){const e=n[i];e.avgCpu=e.avgCpu*(1-this.config.smoothingFactor)+o*this.config.smoothingFactor,e.peakCpu=Math.max(e.peakCpu,o),e.samples++,e.callsThisTick=r.length}else n[i]={avgCpu:o,peakCpu:o,samples:1,callsThisTick:r.length};if(s){const e=Object.values(Game.creeps).filter(e=>e.memory.role===i).length;Oe.recordRole(i,e,o,r.length)}else Oe.recordSubsystem(i,o,r.length)}this.tickMeasurements.clear(),this.subsystemMeasurements.clear(),this.config.logInterval>0&&Game.time%this.config.logInterval===0&&this.logSummary()}logSummary(){const e=this.getMemory();Q.info("=== Profiler Summary ==="),Q.info("Total ticks: "+e.tickCount);const t=Object.entries(e.rooms);if(t.length>0){Q.info("Room CPU (avg/peak):");for(const[e,r]of t)Q.info(`  ${e}: ${r.avgCpu.toFixed(3)} / ${r.peakCpu.toFixed(3)}`)}const r=Object.entries(e.subsystems);if(r.length>0){Q.info("Subsystem CPU (avg/peak):");for(const[e,t]of r)Q.info(`  ${e}: ${t.avgCpu.toFixed(3)} / ${t.peakCpu.toFixed(3)}`)}const o=Object.entries(e.roles||{});if(o.length>0){const e=o.sort((e,t)=>t[1].avgCpu-e[1].avgCpu).slice(0,10);Q.info("Top Roles by CPU (avg/peak):");for(const[t,r]of e)Q.info(`  ${t}: ${r.avgCpu.toFixed(3)} / ${r.peakCpu.toFixed(3)} (${r.callsThisTick} creeps)`)}}getRoomData(e){return this.getMemory().rooms[e]}getSubsystemData(e){return this.getMemory().subsystems[e]}getTotalRoomCpu(){const e=this.getMemory();return Object.values(e.rooms).reduce((e,t)=>e+t.avgCpu,0)}reset(){this.getStatsRoot()[Me]={rooms:{},subsystems:{},roles:{},tickCount:0,lastUpdate:0}}setEnabled(e){this.config.enabled=e}isEnabled(){return this.config.enabled}},we={showPheromones:1,showPaths:0,showCombat:1,showResourceFlow:0,showSpawnQueue:1,showRoomStats:1,opacity:.5},Ie={expand:"#00ff00",harvest:"#ffff00",build:"#ff8800",upgrade:"#0088ff",defense:"#ff0000",war:"#ff00ff",siege:"#880000",logistics:"#00ffff",nukeTarget:"#ff0088"};class xe{constructor(e={}){this.config={...we,...e}}draw(e){const t=new RoomVisual(e.name),r=Ce.getOrInitSwarmState(e.name);this.config.showRoomStats&&this.drawRoomStats(t,e,r),this.config.showPheromones&&r&&(this.drawPheromoneBars(t,r),this.drawPheromoneHeatmap(t,r)),this.config.showCombat&&this.drawCombatInfo(t,e),this.config.showSpawnQueue&&this.drawSpawnQueue(t,e),this.config.showResourceFlow&&this.drawResourceFlow(t,e),this.config.showPaths&&this.drawTrafficPaths(t,e),(null==r?void 0:r.collectionPoint)&&this.drawCollectionPoint(t,r)}drawRoomStats(e,t,r){var o,s,n;const i=.5;let a=.5;const c=.6;e.rect(0,0,8,6.5,{fill:"#000000",opacity:.7,stroke:"#ffffff",strokeWidth:.05});const u=null!==(s=null===(o=t.controller)||void 0===o?void 0:o.level)&&void 0!==s?s:0,l=t.controller?Math.round(t.controller.progress/t.controller.progressTotal*100)+"%":"N/A";e.text(`${t.name} | RCL ${u} (${l})`,i,a,{align:"left",font:"0.5 monospace",color:"#ffffff"}),a+=c;const m=t.energyAvailable,p=t.energyCapacityAvailable,d=p>0?Math.round(m/p*100):0;if(e.text(`Energy: ${m}/${p} (${d}%)`,i,a,{align:"left",font:"0.4 monospace",color:"#ffff00"}),a+=c,t.storage){const r=t.storage.store.getUsedCapacity(RESOURCE_ENERGY);e.text(`Storage: ${Math.round(r/1e3)}k energy`,i,a,{align:"left",font:"0.4 monospace",color:"#00ff00"}),a+=c}if(r){e.text("Stage: "+r.colonyLevel,i,a,{align:"left",font:"0.4 monospace",color:"#00ffff"}),a+=c;const t=["#00ff00","#ffff00","#ff8800","#ff0000"];e.text(`Posture: ${r.posture} | Danger: ${r.danger}`,i,a,{align:"left",font:"0.4 monospace",color:null!==(n=t[r.danger])&&void 0!==n?n:"#ffffff"}),a+=c}const g=t.find(FIND_MY_CREEPS).length,f=t.find(FIND_HOSTILE_CREEPS).length;e.text(`Creeps: ${g} | Hostiles: ${f}`,i,a,{align:"left",font:"0.4 monospace",color:f>0?"#ff0000":"#ffffff"}),a+=c;const R=Game.cpu.getUsed().toFixed(1),h=Game.cpu.bucket;e.text(`CPU: ${R} | Bucket: ${h}`,i,a,{align:"left",font:"0.4 monospace",color:3e3>h?"#ff8800":"#ffffff"})}drawPheromoneBars(e,t){let r=.5;e.rect(41.5,0,8,5.5,{fill:"#000000",opacity:.7,stroke:"#ffffff",strokeWidth:.05}),e.text("Pheromones",45,r,{align:"center",font:"0.5 monospace",color:"#ffffff"}),r+=.6;for(const[o,s]of Object.entries(t.pheromones)){const t=Ie[o],n=6*Math.min(1,s/100);e.rect(42,r,6,.4,{fill:"#333333",opacity:.8}),n>0&&e.rect(42,r,n,.4,{fill:t,opacity:this.config.opacity}),e.text(`${o}: ${Math.round(s)}`,41.8,r+.35,{align:"right",font:"0.35 monospace",color:t}),r+=.5}}drawPheromoneHeatmap(e,t){let r=null,o=xe.HEATMAP_MIN_THRESHOLD;for(const[e,s]of Object.entries(t.pheromones))s>o&&(o=s,r=e);if(!r||o<xe.HEATMAP_MIN_THRESHOLD)return;const s=Ie[r],n=.15*Math.min(1,o/100);e.rect(40,10,8,5,{fill:s,opacity:n}),e.text("Dominant: "+r,44,12.5,{align:"center",font:"0.5 monospace",color:s}),e.text("Intensity: "+Math.round(o),44,13.5,{align:"center",font:"0.4 monospace",color:"#ffffff"})}drawCombatInfo(e,t){const r=t.find(FIND_HOSTILE_CREEPS);for(const t of r){const r=this.calculateCreepThreat(t),o=r>30?"#ff0000":r>10?"#ff8800":"#ffff00";e.circle(t.pos,{radius:.6,fill:o,opacity:.3,stroke:o,strokeWidth:.1}),e.text("T:"+r,t.pos.x,t.pos.y-.8,{font:"0.4 monospace",color:o})}if(r.length>0){const r=t.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER});for(const t of r)e.circle(t.pos,{radius:5,fill:"#00ff00",opacity:.1,stroke:"#00ff00",strokeWidth:.05}),e.circle(t.pos,{radius:10,fill:"#ffff00",opacity:.05,stroke:"#ffff00",strokeWidth:.05})}}calculateCreepThreat(e){let t=0;for(const r of e.body)if(r.hits)switch(r.type){case ATTACK:t+=5*(r.boost?4:1);break;case RANGED_ATTACK:t+=4*(r.boost?4:1);break;case HEAL:t+=6*(r.boost?4:1);break;case TOUGH:t+=1*(r.boost?4:1);break;case WORK:t+=2*(r.boost?4:1)}return t}drawSpawnQueue(e,t){var r;const o=t.find(FIND_MY_SPAWNS);for(const t of o)if(t.spawning){const o=Game.creeps[t.spawning.name],s=1-t.spawning.remainingTime/t.spawning.needTime,n=2,i=.3,a=t.pos.x-1,c=t.pos.y-1.5;e.rect(a,c,n,i,{fill:"#333333",opacity:.8}),e.rect(a,c,n*s,i,{fill:"#00ff00",opacity:.8});const u=null==o?void 0:o.memory,l=null!==(r=null==u?void 0:u.role)&&void 0!==r?r:t.spawning.name;e.text(l,t.pos.x,t.pos.y-1.9,{font:"0.35 monospace",color:"#ffffff"})}}drawResourceFlow(e,t){const r=t.storage;if(!r)return;const o=t.find(FIND_SOURCES);for(const t of o)this.drawArrow(e,t.pos,r.pos,"#ffff00",.2);const s=t.find(FIND_MY_SPAWNS);for(const t of s)t.store.getFreeCapacity(RESOURCE_ENERGY)>0&&this.drawArrow(e,r.pos,t.pos,"#00ff00",.2);const n=t.controller;n&&this.drawArrow(e,r.pos,n.pos,"#00ffff",.2)}drawArrow(e,t,r,o,s){e.line(t,r,{color:o,opacity:s,width:.1,lineStyle:"dashed"})}drawTrafficPaths(e,t){const r=t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_ROAD});for(const t of r){const r=`hsl(${120-120*(1-t.hits/t.hitsMax)}, 100%, 50%)`;e.circle(t.pos,{radius:.2,fill:r,opacity:.5})}}drawBlueprint(e,t){var r;const o={spawn:"#ff8800",extension:"#ffff00",tower:"#ff0000",storage:"#00ff00",terminal:"#00ffff",lab:"#ff00ff",factory:"#8800ff",link:"#0088ff",observer:"#888888",nuker:"#ff0088",powerSpawn:"#ff4400",container:"#884400",road:"#444444",rampart:"#008800",constructedWall:"#666666",extractor:"#ff8888"};for(const s of t){const t=null!==(r=o[s.type])&&void 0!==r?r:"#ffffff";e.rect(s.pos.x-.4,s.pos.y-.4,.8,.8,{fill:t,opacity:.3,stroke:t,strokeWidth:.05}),e.text(s.type.charAt(0).toUpperCase(),s.pos.x,s.pos.y+.15,{font:"0.5 monospace",color:t})}}setConfig(e){this.config={...this.config,...e}}getConfig(){return{...this.config}}drawCollectionPoint(e,t){if(!t.collectionPoint)return;const{x:r,y:o}=t.collectionPoint;e.circle(r,o,{radius:.5,fill:"#00ff00",opacity:.3,stroke:"#00ff00",strokeWidth:.1}),e.text("",r,o+.25,{font:"0.6 monospace",color:"#00ff00",opacity:.8})}toggle(e){"boolean"==typeof this.config[e]&&(this.config[e]=!this.config[e])}}xe.HEATMAP_MIN_THRESHOLD=10;const Ge=new xe,Pe={showRoomStatus:1,showConnections:1,showThreats:1,showExpansion:0,showResourceFlow:0,showHighways:0,opacity:.6},ke=["#00ff00","#ffff00","#ff8800","#ff0000"],Le={eco:"#00ff00",expand:"#00ffff",defense:"#ffff00",war:"#ff8800",siege:"#ff0000",evacuate:"#ff00ff"},De=new class{constructor(e={}){this.config={...Pe,...e}}draw(){const e=Game.map.visual;this.config.showRoomStatus&&this.drawRoomStatus(e),this.config.showConnections&&this.drawConnections(e),this.config.showThreats&&this.drawThreats(e),this.config.showExpansion&&this.drawExpansionCandidates(e),this.config.showResourceFlow&&this.drawResourceFlow(e),this.config.showHighways&&this.drawHighways(e)}drawRoomStatus(e){var t,r,o;for(const s of Object.values(Game.rooms)){if(!(null===(t=s.controller)||void 0===t?void 0:t.my))continue;const n=Ce.getOrInitSwarmState(s.name),i=s.controller.level,a=Math.min(Math.max(n.danger,0),3),c=null!==(r=ke[a])&&void 0!==r?r:"#ffffff",u={radius:10,fill:c,opacity:.5*this.config.opacity,stroke:c,strokeWidth:1};if(e.circle(new RoomPosition(25,25,s.name),u),e.text("RCL"+i,new RoomPosition(25,25,s.name),{color:"#ffffff",fontSize:8,align:"center"}),"eco"!==n.posture){const t=null!==(o=Le[n.posture])&&void 0!==o?o:"#ffffff";e.text(n.posture.toUpperCase(),new RoomPosition(25,30,s.name),{color:t,fontSize:6,align:"center"})}}}drawConnections(e){var t;for(const r of Object.values(Game.rooms)){if(!(null===(t=r.controller)||void 0===t?void 0:t.my))continue;const o=Ce.getOrInitSwarmState(r.name);if(o.remoteAssignments&&o.remoteAssignments.length>0)for(const t of o.remoteAssignments){const o={color:"#00ffff",opacity:.8*this.config.opacity,width:.5};e.line(new RoomPosition(25,25,r.name),new RoomPosition(25,25,t),o);const s={radius:5,fill:"#00ffff",opacity:.3*this.config.opacity};e.circle(new RoomPosition(25,25,t),s)}if("war"===o.posture||"siege"===o.posture){const t=Object.values(Game.rooms).filter(e=>e.find(FIND_HOSTILE_CREEPS).length>0&&5>=Game.map.getRoomLinearDistance(r.name,e.name));for(const o of t){const t={color:"#ff0000",opacity:this.config.opacity,width:1};e.line(new RoomPosition(25,25,r.name),new RoomPosition(25,25,o.name),t)}}}}drawThreats(e){for(const t of Object.values(Game.rooms)){const r=t.find(FIND_HOSTILE_CREEPS),o=t.find(FIND_HOSTILE_STRUCTURES);if(r.length>0||o.length>0){const s=r.length+2*o.length,n=s>10?"#ff0000":"#ff8800";e.rect(new RoomPosition(20,20,t.name),10,10,{fill:n,opacity:.5*this.config.opacity,stroke:n,strokeWidth:1}),e.text(""+s,new RoomPosition(25,25,t.name),{color:"#ffffff",fontSize:8,align:"center"})}if(t.find(FIND_NUKES).length>0){const r=t.find(FIND_NUKES);e.circle(new RoomPosition(25,25,t.name),{radius:15,fill:"#ff00ff",opacity:.7*this.config.opacity,stroke:"#ff00ff",strokeWidth:2}),e.text(""+r.length,new RoomPosition(25,25,t.name),{color:"#ffffff",fontSize:10,align:"center",backgroundColor:"#ff00ff",backgroundPadding:2})}}}drawExpansionCandidates(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const r of Object.values(Game.rooms))!r.controller||r.controller.my||r.controller.owner||t.some(e=>3>=Game.map.getRoomLinearDistance(e.name,r.name))&&(e.circle(new RoomPosition(25,25,r.name),{radius:8,fill:"#00ff00",opacity:.3*this.config.opacity,stroke:"#00ff00",strokeWidth:.5,lineStyle:"dashed"}),e.text("EXP",new RoomPosition(25,25,r.name),{color:"#00ff00",fontSize:6,align:"center"}))}drawResourceFlow(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const r of t){if(!r.terminal)continue;const t=Game.market.orders;for(const o in t){const s=t[o];s.roomName===r.name&&s.remainingAmount<s.amount&&e.circle(new RoomPosition(25,25,r.name),{radius:12,fill:"#ffff00",opacity:.2*this.config.opacity,stroke:"#ffff00",strokeWidth:.5})}}}drawHighways(e){for(const t of Object.values(Game.rooms)){const r=t.name.match(/[WE](\d+)[NS](\d+)/);if(!r)continue;const o=parseInt(r[1],10),s=parseInt(r[2],10);o%10!=0&&s%10!=0||(e.rect(new RoomPosition(0,0,t.name),50,50,{fill:"#444444",opacity:.2*this.config.opacity}),o%10==0&&s%10==0&&e.text("SK",new RoomPosition(25,25,t.name),{color:"#ff8800",fontSize:12,align:"center"}))}}drawRoomOverlay(e){const t=Game.map.visual;Game.rooms[e]&&(t.rect(new RoomPosition(0,0,e),50,50,{fill:"transparent",opacity:1,stroke:"#00ffff",strokeWidth:2}),t.text(e,new RoomPosition(25,5,e),{color:"#00ffff",fontSize:10,align:"center",backgroundColor:"#000000",backgroundPadding:2}))}setConfig(e){this.config={...this.config,...e}}getConfig(){return{...this.config}}toggle(e){const t=this.config[e];"boolean"==typeof t&&(this.config[e]=!t)}};function $e(e,t,r,o){const s=o instanceof Error?o.message:o+"";Q.warn(`SafeFind error in ${e}(${t+""}) at ${r}: ${s}`,{subsystem:"SafeFind"})}function Ye(e,t,r){try{return e.find(t,r)}catch(r){return $e("room.find",t,e.name,r),[]}}function Ke(e,t,r){try{return e.findClosestByRange(t,r)}catch(r){return $e("pos.findClosestByRange",t,`${e.roomName}:${e.x+""},${e.y+""}`,r),null}}const He={[STRUCTURE_SPAWN]:100,[STRUCTURE_EXTENSION]:90,[STRUCTURE_TOWER]:80,[STRUCTURE_RAMPART]:75,[STRUCTURE_WALL]:70,[STRUCTURE_STORAGE]:70,[STRUCTURE_CONTAINER]:60,[STRUCTURE_ROAD]:30},Fe=new Map;function We(e){e._allStructuresLoaded||(e.allStructures=e.room.find(FIND_STRUCTURES),e._allStructuresLoaded=1)}function Be(e){return void 0===e._prioritizedSites&&(e._prioritizedSites=e.room.find(FIND_MY_CONSTRUCTION_SITES).sort((e,t)=>{var r,o;const s=null!==(r=He[e.structureType])&&void 0!==r?r:50;return(null!==(o=He[t.structureType])&&void 0!==o?o:50)-s})),e._prioritizedSites}function Ve(e){return void 0===e._repairTargets&&(We(e),e._repairTargets=e.allStructures.filter(e=>e.hits<.75*e.hitsMax&&e.structureType!==STRUCTURE_WALL)),e._repairTargets}function qe(){Fe.clear(),je()}let je=()=>{};function Xe(e){var t,r;const o=e.room,s=e.memory,n=function(e){const t=Fe.get(e.name);if(t&&t.tick===Game.time)return t;const r={tick:Game.time,room:e,hostiles:Ye(e,FIND_HOSTILE_CREEPS),myStructures:e.find(FIND_MY_STRUCTURES),allStructures:[]};return Fe.set(e.name,r),r}(o),i=null!==(t=s.homeRoom)&&void 0!==t?t:o.name;return{creep:e,room:o,memory:s,get swarmState(){return function(e){var t;const r=null===(t=Memory.rooms)||void 0===t?void 0:t[e];return null==r?void 0:r.swarm}(o.name)},get squadMemory(){return function(e){if(!e)return;const t=Memory.squads;return null==t?void 0:t[e]}(s.squadId)},homeRoom:i,isInHomeRoom:o.name===i,isFull:0===e.store.getFreeCapacity(),isEmpty:0===e.store.getUsedCapacity(),isWorking:null!==(r=s.working)&&void 0!==r?r:0,get assignedSource(){return function(e){return e.sourceId?Game.getObjectById(e.sourceId):null}(s)},get assignedMineral(){var e,t;return null!==(e=(void 0===(t=n)._minerals&&(t._minerals=t.room.find(FIND_MINERALS)),t._minerals)[0])&&void 0!==e?e:null},get energyAvailable(){return(e=n,void 0===e._activeSources&&(e._activeSources=e.room.find(FIND_SOURCES_ACTIVE)),e._activeSources).length>0;var e},get nearbyEnemies(){return n.hostiles.length>0&&function(e,t){for(const r of t){const t=Math.abs(e.x-r.pos.x),o=Math.abs(e.y-r.pos.y);if(10>=Math.max(t,o))return 1}return 0}(e.pos,n.hostiles)},get constructionSiteCount(){return Be(n).length},get damagedStructureCount(){return Ve(n).length},get droppedResources(){return void 0===(e=n)._droppedResources&&(e._droppedResources=e.room.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50})),e._droppedResources;var e},get containers(){return void 0===(e=n)._containers&&(We(e),e._containers=e.allStructures.filter(e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>100)),e._containers;var e},get depositContainers(){return void 0===(e=n)._depositContainers&&(We(e),e._depositContainers=e.allStructures.filter(e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0)),e._depositContainers;var e},get spawnStructures(){return void 0===(e=n)._spawnStructures&&(e._spawnStructures=e.myStructures.filter(e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_EXTENSION)&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0)),e._spawnStructures;var e},get towers(){return void 0===(e=n)._towers&&(e._towers=e.myStructures.filter(e=>e.structureType===STRUCTURE_TOWER&&e.store.getFreeCapacity(RESOURCE_ENERGY)>200)),e._towers;var e},storage:o.storage,terminal:o.terminal,hostiles:n.hostiles,get damagedAllies(){return void 0===(e=n)._damagedAllies&&(e._damagedAllies=e.room.find(FIND_MY_CREEPS,{filter:e=>e.hits<e.hitsMax})),e._damagedAllies;var e},get prioritizedSites(){return Be(n)},get repairTargets(){return Ve(n)},get labs(){return void 0===(e=n)._labs&&(e._labs=e.myStructures.filter(e=>e.structureType===STRUCTURE_LAB)),e._labs;var e},get factory(){return(e=n)._factoryChecked||(e._factory=e.myStructures.find(e=>e.structureType===STRUCTURE_FACTORY),e._factoryChecked=1),e._factory;var e}}}const ze=new Map;let Ze=-1;function Qe(){ze.clear(),Ze=Game.time}function Je(e,t){Ze!==Game.time&&Qe();const r=`${(o=t).roomName}:${o.x},${o.y}`;var o;const s={requester:e,targetPos:t,priority:tt(e),tick:Game.time},n=ze.get(r);return n?n.push(s):ze.set(r,[s]),1}const et={guard:100,healer:95,soldier:90,ranger:88,siegeUnit:85,harasser:82,harvester:75,queenCarrier:70,hauler:65,remoteHarvester:60,remoteHauler:55,upgrader:50,builder:45,larvaWorker:40,interRoomCarrier:38,scout:35,claimer:30,engineer:28,remoteWorker:26,linkManager:24,terminalManager:22,powerQueen:80,powerWarrior:78,powerHarvester:27,powerCarrier:25,mineralHarvester:20,labTech:10,factoryWorker:5};function tt(e){var t;const r=e.memory;return null!==(t=et[r.role])&&void 0!==t?t:50}function rt(e,t){const r=tt(e),o=tt(t);if(o>r)return 1;if(r>o)return 0;const s=e.memory,n=t.memory;if("hauler"===s.role&&"hauler"===n.role){const r=e.store.getUsedCapacity();if(t.store.getUsedCapacity()>r)return 1}return t.ticksToLive&&e.ticksToLive?t.ticksToLive<e.ticksToLive:0}const ot=48;function st(e,t){const r=t.getTerrain(),o=(e,o)=>1>e||e>ot||1>o||o>ot||r.get(e,o)===TERRAIN_MASK_WALL?0:!t.lookForAt(LOOK_STRUCTURES,e,o).some(e=>e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&(e.structureType!==STRUCTURE_RAMPART||!e.my));return(o(e.x,e.y-1)||o(e.x,e.y+1))!==(o(e.x-1,e.y)||o(e.x+1,e.y))}function nt(e,t){const r=e.room.getTerrain();var o;const s=function(e){var t;return null!==(t={[TOP]:{dx:0,dy:-1},[TOP_RIGHT]:{dx:1,dy:-1},[RIGHT]:{dx:1,dy:0},[BOTTOM_RIGHT]:{dx:1,dy:1},[BOTTOM]:{dx:0,dy:1},[BOTTOM_LEFT]:{dx:-1,dy:1},[LEFT]:{dx:-1,dy:0},[TOP_LEFT]:{dx:-1,dy:-1}}[e])&&void 0!==t?t:null}((o=t,{[TOP]:BOTTOM,[TOP_RIGHT]:BOTTOM_LEFT,[RIGHT]:LEFT,[BOTTOM_RIGHT]:TOP_LEFT,[BOTTOM]:TOP,[BOTTOM_LEFT]:TOP_RIGHT,[LEFT]:RIGHT,[TOP_LEFT]:BOTTOM_RIGHT}[o]));if(!s)return null;const n=e.pos.x+s.dx,i=e.pos.y+s.dy;return 1>n||n>ot||1>i||i>ot||r.get(n,i)===TERRAIN_MASK_WALL||e.room.lookForAt(LOOK_STRUCTURES,n,i).some(e=>e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&(e.structureType!==STRUCTURE_RAMPART||!e.my))||e.room.lookForAt(LOOK_CREEPS,n,i).length>0?null:new RoomPosition(n,i,e.room.name)}function it(e){var t;const r=e.room.getTerrain(),o=[];for(let t=-1;1>=t;t++)for(let s=-1;1>=s;s++){if(0===t&&0===s)continue;const n=e.pos.x+t,i=e.pos.y+s;1>n||n>ot||1>i||i>ot||r.get(n,i)!==TERRAIN_MASK_WALL&&(e.room.lookForAt(LOOK_STRUCTURES,n,i).some(e=>e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&(e.structureType!==STRUCTURE_RAMPART||!e.my))||e.room.lookForAt(LOOK_CREEPS,n,i).length>0||o.push(new RoomPosition(n,i,e.room.name)))}if(0===o.length)return null;const s=o.find(t=>e.room.lookForAt(LOOK_STRUCTURES,t).some(e=>e.structureType===STRUCTURE_ROAD));return null!==(t=null!=s?s:o[0])&&void 0!==t?t:null}function at(e){const t=Game.rooms[e.roomName];if(!t)return 0;if(t.getTerrain().get(e.x,e.y)===TERRAIN_MASK_WALL)return 0;const r=t.lookForAt(LOOK_STRUCTURES,e);for(const e of r)if(e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&(e.structureType!==STRUCTURE_RAMPART||!e.my))return 0;return 1}function ct(e){return"body"in e&&Array.isArray(e.body)}let ut=new Map,lt=-1;const mt="_tp",pt="_ts";function dt(e){return`${e.roomName}:${e.x},${e.y}`}function gt(e,t){var r,o;const s=null!==(r=[0,0,1,1,1,0,-1,-1,-1][t])&&void 0!==r?r:0,n=null!==(o=[0,-1,-1,0,1,1,1,0,-1][t])&&void 0!==o?o:0;let i=e.x+s,a=e.y+n,c=e.roomName;return 0>i?(i=49,c=ft(c,LEFT)):i>49&&(i=0,c=ft(c,RIGHT)),0>a?(a=49,c=ft(c,TOP)):a>49&&(a=0,c=ft(c,BOTTOM)),new RoomPosition(i,a,c)}function ft(e,t){const r=/^([WE])(\d+)([NS])(\d+)$/.exec(e);if(!r)return e;const[,o,s,n,i]=r;let a=parseInt(s,10),c=parseInt(i,10),u=o,l=n;return t===LEFT||t===TOP_LEFT||t===BOTTOM_LEFT?"W"===o?a++:0===a?(u="W",a=0):a--:t!==RIGHT&&t!==TOP_RIGHT&&t!==BOTTOM_RIGHT||("E"===o?a++:0===a?(u="E",a=0):a--),t===TOP||t===TOP_LEFT||t===TOP_RIGHT?"N"===n?c++:0===c?(l="N",c=0):c--:t!==BOTTOM&&t!==BOTTOM_LEFT&&t!==BOTTOM_RIGHT||("S"===n?c++:0===c?(l="S",c=0):c--),`${u}${a}${l}${c}`}function Rt(e){const t=/^[WE](\d+)[NS](\d+)$/.exec(e);if(!t)return 0;const r=parseInt(t[1])%10,o=parseInt(t[2])%10;return!(5===r&&5===o||4>r||r>6||4>o||o>6)}function ht(e){return 0===e.x||49===e.x||0===e.y||49===e.y}function yt(e){const t=e.pos,r=Game.rooms[t.roomName];if(!r)return null;const o=r.getTerrain(),s=[{dx:0,dy:-1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1},{dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1}],n=[];for(const e of s){const r=t.x+e.dx,s=t.y+e.dy;if(0>r||r>49||0>s||s>49)continue;if(0===r||49===r||0===s||49===s)continue;if(o.get(r,s)===TERRAIN_MASK_WALL)continue;const i=Math.min(r,49-r,s,49-s);n.push({pos:new RoomPosition(r,s,t.roomName),edgeDistance:i})}return n.sort((e,t)=>t.edgeDistance-e.edgeDistance),n.length>0?n[0].pos:null}function Et(e,t){const r=t.x-e.x,o=t.y-e.y;return 0===r&&-1===o?TOP:1===r&&-1===o?TOP_RIGHT:1===r&&0===o?RIGHT:1===r&&1===o?BOTTOM_RIGHT:0===r&&1===o?BOTTOM:-1===r&&1===o?BOTTOM_LEFT:-1===r&&0===o?LEFT:-1===r&&-1===o?TOP_LEFT:RIGHT}function Tt(e,t,r=1,o=0,s=0,n=0,i=2.5){const a=new PathFinder.CostMatrix,c=Game.rooms[e];if(!c){if(!o&&Ce.isRoomHostile(e))return 0;if(!s&&Rt(e)){const e=new PathFinder.CostMatrix;for(let t=0;50>t;t++)for(let r=0;50>r;r++)e.set(t,r,10);return e}return a}if(!o&&function(e){const t=Game.rooms[e];return t?t.find(FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER}).length>0?1:t.find(FIND_HOSTILE_CREEPS).some(e=>e.getActiveBodyparts(ATTACK)>0||e.getActiveBodyparts(RANGED_ATTACK)>0):0}(e))return Ce.setRoomHostile(e,1),0;const u=c.find(FIND_STRUCTURES);for(const e of u)if(e.structureType===STRUCTURE_ROAD)a.set(e.pos.x,e.pos.y,r);else if(e.structureType===STRUCTURE_CONTAINER)a.set(e.pos.x,e.pos.y,5);else if(e.structureType===STRUCTURE_PORTAL)a.set(e.pos.x,e.pos.y,1);else if(e.structureType!==STRUCTURE_RAMPART||!("my"in e)||!e.my)if(e.structureType===STRUCTURE_RAMPART){const t=e;t.my||t.isPublic||a.set(e.pos.x,e.pos.y,255)}else a.set(e.pos.x,e.pos.y,255);const l=c.find(FIND_MY_CONSTRUCTION_SITES);for(const e of l)e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&e.structureType!==STRUCTURE_RAMPART&&a.set(e.pos.x,e.pos.y,255);if(t){const e=c.find(FIND_CREEPS);for(const t of e)a.set(t.pos.x,t.pos.y,255);const t=c.find(FIND_POWER_CREEPS);for(const e of t)a.set(e.pos.x,e.pos.y,255)}return a}function Ct(e,t,r){var o,s,n,i,a,c,u,l,m,p,d,g,f,R,h;const y="pos"in t?t.pos:t,E="range"in t?t.range:1,T=null!==(o=r.roadCost)&&void 0!==o?o:1,C=null!==(s=r.allowHostileRooms)&&void 0!==s?s:0,v=null!==(n=r.allowSK)&&void 0!==n?n:0,S=null!==(i=r.preferHighway)&&void 0!==i?i:0,U=null!==(a=r.highwayBias)&&void 0!==a?a:2.5,O=e.roomName!==y.roomName,_=null!==(c=r.maxRooms)&&void 0!==c?c:O?16:1,A=Game.map.getRoomLinearDistance(e.roomName,y.roomName);let M;if(O&&A>2){const t=Game.map.findRoute(e.roomName,y.roomName,{routeCallback:t=>!C&&Ce.isRoomHostile(t)&&t!==y.roomName&&t!==e.roomName?1/0:!v&&Rt(t)?10*U:S&&function(e){const t=/^[WE](\d+)[NS](\d+)$/.exec(e);if(!t)return 0;const r=parseInt(t[1]),o=parseInt(t[2]);return r%10==0||o%10==0}(t)?1:U});if(t!==ERR_NO_PATH){M={[e.roomName]:1,[y.roomName]:1};for(const e of t)M[e.room]=1}}const N=[{pos:y,range:E}],b=PathFinder.search(e,N,{plainCost:null!==(u=r.plainCost)&&void 0!==u?u:2,swampCost:null!==(l=r.swampCost)&&void 0!==l?l:10,maxOps:null!==(m=r.maxOps)&&void 0!==m?m:2e3,maxRooms:_,flee:null!==(p=r.flee)&&void 0!==p?p:0,roomCallback:e=>{var t;return M&&!M[e]?0:Tt(e,null!==(t=r.avoidCreeps)&&void 0!==t?t:1,T,C,v,S,U)}});if(b.incomplete&&r.ensurePath&&O&&2>=A&&!M){const o={...r};return Ct(e,t,o)}if(b.incomplete&&r.allowAlternativeTarget&&!O){const t=null!==(d=r.alternativeRange)&&void 0!==d?d:1,o=function(e,t=1){const r=Game.rooms[e.roomName];if(!r)return null;for(let o=1;t>=o;o++)for(let t=-o;o>=t;t++)for(let s=-o;o>=s;s++){if(o>Math.abs(t)&&o>Math.abs(s))continue;const n=e.x+t,i=e.y+s;if(1>n||n>ot||1>i||i>ot)continue;const a=new RoomPosition(n,i,e.roomName);if(at(a)&&0===r.lookForAt(LOOK_CREEPS,a).length)return a}return null}(y,t);if(o){const t=[{pos:o,range:E}],s=PathFinder.search(e,t,{plainCost:null!==(g=r.plainCost)&&void 0!==g?g:2,swampCost:null!==(f=r.swampCost)&&void 0!==f?f:10,maxOps:null!==(R=r.maxOps)&&void 0!==R?R:2e3,maxRooms:_,flee:null!==(h=r.flee)&&void 0!==h?h:0,roomCallback:e=>{var t;return M&&!M[e]?0:Tt(e,null!==(t=r.avoidCreeps)&&void 0!==t?t:1,T,C,v,S,U)}});if(!s.incomplete||s.path.length<b.path.length)return s}}return b}function vt(e,t,r){var o,s,n,i;if("spawning"in e&&e.spawning)return ERR_BUSY;if("fatigue"in e&&e.fatigue>0)return ERR_TIRED;let a,c=1;if(Array.isArray(t)){const e=t[0];if(!e)return ERR_INVALID_TARGET;if(e instanceof RoomPosition)a=e;else{if(!("object"==typeof e&&null!==e&&"pos"in e&&e.pos instanceof RoomPosition))return ERR_INVALID_TARGET;a=e.pos,"range"in e&&"number"==typeof e.range&&(c=e.range)}}else if(t instanceof RoomPosition)a=t;else{if(!("object"==typeof t&&null!==t&&"pos"in t&&t.pos instanceof RoomPosition))return ERR_INVALID_TARGET;a=t.pos,"range"in t&&"number"==typeof t.range&&(c=t.range)}const u=null!=r?r:{},l=null!==(o=u.priority)&&void 0!==o?o:1;if(e.pos.inRangeTo(a,c))return OK;const m=ht(e.pos),p=a.roomName!==e.pos.roomName;if(m&&p){const t=yt(e);if(t){const r=Et(e.pos,t),o=e.pos.roomName;if(lt===Game.time){ut.has(o)||ut.set(o,[]);const r=ut.get(o);return r&&r.push({creep:e,priority:l+1,targetPos:t}),OK}return e.move(r)}}const d=e.memory,g=d[mt],f=null!==(s=d[pt])&&void 0!==s?s:0,R=d._tl,h=dt(e.pos),y=dt(a),E=R===h?f+1:0;d[pt]=E,d._tl=h;let T=0;if(g&&g.path)if("string"==typeof g.path)T=0;else if(Array.isArray(g.path)){const t=g.path[0];T=g.path.length>0&&void 0!==t&&t.r!==e.pos.roomName}let C=0;if(u.movingTarget&&g&&g.targetKey!==y){const e=g.targetKey.split(":");if(2===e.length){const[t,r]=e,[o,s]=r.split(",").map(e=>parseInt(e,10)),n=new RoomPosition(o,s,t);if(n.isNearTo(a)){C=1;const e=n.getDirectionTo(a);"string"==typeof g.path?g.path+=e.toString():g.path.push({x:a.x,y:a.y,r:a.roomName}),g.targetKey=y,d[mt]=g}}}const v=null!==(n=u.repathIfStuck)&&void 0!==n?n:3,S=null!==(i=u.reusePath)&&void 0!==i?i:30;let U,O=null;function _(){var t,r;const o=Game.cpu.getUsed(),s=Ct(e.pos,{pos:a,range:c},u),n=Game.cpu.getUsed()-o;if(s.incomplete||0===s.path.length)return delete d[mt],null;const i=(null!==(t=null==g?void 0:g.cpu)&&void 0!==t?t:0)+n;i>(null!==(r=u.cpuReportThreshold)&&void 0!==r?r:1e3)&&console.log(`[Movement] Heavy pathfinding CPU: ${e.name} used ${i.toFixed(2)} CPU (${n.toFixed(2)} this call) from ${e.pos} to ${a}`);const l=s.path.some(t=>t.roomName!==e.pos.roomName)?function(e){return e.map(e=>({x:e.x,y:e.y,r:e.roomName}))}(s.path):function(e,t){let r="",o=e;for(const e of t){if(e.roomName===o.roomName)r+=o.getDirectionTo(e);else{let t=e.x-o.x,s=e.y-o.y;Math.abs(t)>25&&(t=t>0?-(50-t):50+t),Math.abs(s)>25&&(s=s>0?-(50-s):50+s);let n=RIGHT;0===t&&-1===s?n=TOP:1===t&&-1===s?n=TOP_RIGHT:1===t&&0===s?n=RIGHT:1===t&&1===s?n=BOTTOM_RIGHT:0===t&&1===s?n=BOTTOM:-1===t&&1===s?n=BOTTOM_LEFT:-1===t&&0===s?n=LEFT:-1===t&&-1===s&&(n=TOP_LEFT),r+=n}o=e}return r}(e.pos,s.path);return d[mt]={path:l,tick:Game.time,targetKey:y,cpu:i},d[pt]=0,s.path}if(!g||!C&&g.targetKey!==y||Game.time-g.tick>S||E>=v||T){const e=_();if(!e)return ERR_NO_PATH;U=e}else"string"==typeof g.path?(O=g.path,U=function(e,t){const r=[];let o=e;for(const e of t){const t=gt(o,parseInt(e,10));t&&(r.push(t),o=t)}return r}(e.pos,g.path)):U=g.path.map(e=>new RoomPosition(e.x,e.y,e.r));let A=U.findIndex(t=>t.x===e.pos.x&&t.y===e.pos.y&&t.roomName===e.pos.roomName);if(-1===A&&m){const e=_();if(!e)return ERR_NO_PATH;U=e,O=null,A=-1}const M=-1===A?0:A+1;if(M>=U.length)return delete d[mt],OK;const N=U[M],b=e.pos.roomName,w=null!==O&&O.length>0;if(lt===Game.time){ut.has(b)||ut.set(b,[]);const t=ut.get(b);if(t&&t.push({creep:e,priority:l,targetPos:N}),w&&g&&null!==O&&(g.path=O.substring(1),d[mt]=g),u.visualizePathStyle){const e=new RoomVisual(b),t=U.slice(M);t.length>0&&e.poly(t.map(e=>[e.x,e.y]),{...u.visualizePathStyle,opacity:.5})}return OK}{const t=Et(e.pos,N),r=e.move(t);if(r===OK&&w&&g&&(g.path=O.substring(1),d[mt]=g),u.visualizePathStyle){const e=new RoomVisual(b),t=U.slice(M);t.length>0&&e.poly(t.map(e=>[e.x,e.y]),{...u.visualizePathStyle,opacity:.5})}return r}}function St(){ut=new Map,lt=Game.time}function Ut(){!function(){for(const[e,t]of ut){if(0===t.length)continue;t.sort((e,t)=>t.priority-e.priority);const r=new Set,o=new Set(t.map(e=>e.creep.name)),s=Game.rooms[e];if(s){const e=s.find(FIND_CREEPS);for(const t of e)o.has(t.name)||r.add(dt(t.pos))}for(const e of t){const t=dt(e.targetPos);if(r.has(t)){if(s){const o=s.lookForAt(LOOK_CREEPS,e.targetPos.x,e.targetPos.y).find(t=>t.my&&t.name!==e.creep.name);if(o&&ct(e.creep)&&rt(o,e.creep)){let n=null;if(st(o.pos,s)){const t=o.pos.getDirectionTo(e.creep.pos);n=nt(o,t)}else n=it(o);n&&o.move(o.pos.getDirectionTo(n))===OK&&(r.delete(t),r.add(dt(n)))}}if(r.has(t)){ct(e.creep)&&Je(e.creep,e.targetPos);continue}}const o=Et(e.creep.pos,e.targetPos);e.creep.move(o)===OK&&r.add(t)}}}()}function Ot(e,t,r){return vt(e,t instanceof RoomPosition?t:t.pos,r)}function _t(e,t,r){if(e.pos.roomName===t)return OK;const o=new RoomPosition(25,25,t),s={...r};return s.maxRooms||(s.maxRooms=16),void 0===s.allowHostileRooms&&(s.allowHostileRooms=0),vt(e,{pos:o,range:20},s)}function At(e,t){var r;if(!ht(e.pos))return 0;if("spawning"in e&&e.spawning)return 0;if("fatigue"in e&&e.fatigue>0)return 0;const o=yt(e);if(!o)return 0;const s=null!==(r=null==t?void 0:t.priority)&&void 0!==r?r:2,n=e.pos.roomName;if(lt===Game.time){ut.has(n)||ut.set(n,[]);const t=ut.get(n);return t&&t.push({creep:e,priority:s,targetPos:o}),1}{const t=Et(e.pos,o);return e.move(t),1}}const Mt=new Map;function Nt(e,t){return e>=50&&t>=8}function bt(e,t,r){var o;if(t.get(e.x,e.y)===TERRAIN_MASK_WALL)return 0;const s=`${e.x},${e.y}`;return!(null!==(o=r.get(s))&&void 0!==o&&o)}const wt="#ffaa00",It="#ffffff",xt="#ff0000",Gt="#00ff00",Pt="#0000ff";function kt(e,t,r){var o;let s=0;switch(t.type){case"harvest":s=Lt(e,()=>e.harvest(t.target),t.target,wt);break;case"harvestMineral":s=Lt(e,()=>e.harvest(t.target),t.target,"#00ff00");break;case"harvestDeposit":s=Lt(e,()=>e.harvest(t.target),t.target,"#00ffff");break;case"pickup":s=Lt(e,()=>e.pickup(t.target),t.target,wt);break;case"withdraw":s=Lt(e,()=>e.withdraw(t.target,t.resourceType),t.target,wt);break;case"transfer":s=Lt(e,()=>e.transfer(t.target,t.resourceType),t.target,It);break;case"drop":e.drop(t.resourceType);break;case"build":s=Lt(e,()=>e.build(t.target),t.target,"#ffffff");break;case"repair":s=Lt(e,()=>e.repair(t.target),t.target,"#ffff00");break;case"upgrade":s=Lt(e,()=>e.upgradeController(t.target),t.target,It);break;case"dismantle":s=Lt(e,()=>e.dismantle(t.target),t.target,xt);break;case"attack":Lt(e,()=>e.attack(t.target),t.target,xt);break;case"rangedAttack":Lt(e,()=>e.rangedAttack(t.target),t.target,xt);break;case"heal":Lt(e,()=>e.heal(t.target),t.target,Gt);break;case"rangedHeal":e.rangedHeal(t.target),Ot(e,t.target,{visualizePathStyle:{stroke:Gt}})===ERR_NO_PATH&&(s=1);break;case"claim":Lt(e,()=>e.claimController(t.target),t.target,Gt);break;case"reserve":Lt(e,()=>e.reserveController(t.target),t.target,Gt);break;case"attackController":Lt(e,()=>e.attackController(t.target),t.target,xt);break;case"moveTo":Ot(e,t.target,{visualizePathStyle:{stroke:Pt}})===ERR_NO_PATH&&(s=1);break;case"moveToRoom":_t(e,t.roomName,{visualizePathStyle:{stroke:Pt}})===ERR_NO_PATH&&(s=1);break;case"flee":{const r=function(e,t,r=10){return function(e,t,r=10,o){var s;if(0===t.length)return OK;if("spawning"in e&&e.spawning)return ERR_BUSY;if("fatigue"in e&&e.fatigue>0)return ERR_TIRED;const n={...o,flee:1},i=null!==(s=n.priority)&&void 0!==s?s:1,a=function(e,t,r,o){var s,n,i,a,c,u,l,m,p;const d=t.map(e=>({pos:e,range:r})),g=null!==(s=o.roadCost)&&void 0!==s?s:1,f=null!==(n=o.allowHostileRooms)&&void 0!==n?n:0,R=null!==(i=o.allowSK)&&void 0!==i?i:0,h=null!==(a=o.preferHighway)&&void 0!==a?a:0,y=null!==(c=o.highwayBias)&&void 0!==c?c:2.5,E=null!==(u=o.maxRooms)&&void 0!==u?u:4;return PathFinder.search(e,d,{plainCost:null!==(l=o.plainCost)&&void 0!==l?l:2,swampCost:null!==(m=o.swampCost)&&void 0!==m?m:10,maxOps:null!==(p=o.maxOps)&&void 0!==p?p:2e3,maxRooms:E,flee:1,roomCallback:e=>{var t;return Tt(e,null!==(t=o.avoidCreeps)&&void 0!==t?t:1,g,f,R,h,y)}})}(e.pos,t,r,n);if(a.incomplete||0===a.path.length)return ERR_NO_PATH;const c=a.path[0],u=e.pos.roomName;if(lt===Game.time){ut.has(u)||ut.set(u,[]);const t=ut.get(u);return t&&t.push({creep:e,priority:i,targetPos:c}),OK}{const t=Et(e.pos,c);return e.move(t)}}(e,t,r,void 0)}(e,t.from,10);r===ERR_NO_PATH&&(s=1);break}case"wait":if(At(e))break;e.pos.isEqualTo(t.position)||Ot(e,t.position)===ERR_NO_PATH&&(s=1);break;case"requestMove":Je(e,t.target),Ot(e,t.target,{visualizePathStyle:{stroke:Pt}})===ERR_NO_PATH&&(s=1);break;case"idle":{if(At(e))break;const t=Game.rooms[e.pos.roomName];if(t&&(null===(o=t.controller)||void 0===o?void 0:o.my)){const r=function(e,t){const r=Mt.get(e.name);if(r&&500>Game.time-r.tick)return r.pos;if(t.collectionPoint){const r=new RoomPosition(t.collectionPoint.x,t.collectionPoint.y,e.name);if(function(e,t){const r=e.getTerrain();if(!function(e,t,r){return r.get(t.x,t.y)===TERRAIN_MASK_WALL?0:!e.lookForAt(LOOK_STRUCTURES,t.x,t.y).some(e=>e.structureType===STRUCTURE_ROAD||e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_RAMPART&&e.my?0:1)}(e,t,r))return 0;const o=e.find(FIND_MY_SPAWNS);if(0===o.length)return 0;const s=t.getRangeTo(o[0].pos);return 5>s||s>15?0:1}(e,r))return Mt.set(e.name,{pos:r,tick:Game.time}),r}const o=function(e){var t;const r=e.find(FIND_MY_SPAWNS);if(0===r.length)return null;const o=r[0],s=e.storage,n=e.controller,i=new Map,a=new Map,c=e.find(FIND_STRUCTURES);for(const e of c){const t=`${e.pos.x},${e.pos.y}`;e.structureType===STRUCTURE_ROAD&&i.set(t,1),e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&(e.structureType!==STRUCTURE_RAMPART||!e.my)&&a.set(t,1)}const u=[],l=e.getTerrain();for(let r=5;15>=r;r++){const c=o.pos.x,m=o.pos.y;for(let o=-r;r>=o;o++){for(let p=-r;r>=p;p++){if(Math.max(Math.abs(o),Math.abs(p))!==r)continue;const d=c+o,g=m+p;if(3>d||d>46||3>g||g>46)continue;const f=new RoomPosition(d,g,e.name);if(!bt(f,l,a))continue;let R=0;if(R-=Math.abs(r-8),s&&(R-=.5*f.getRangeTo(s.pos)),n&&(R-=.3*f.getRangeTo(n.pos)),(null!==(t=i.get(`${d},${g}`))&&void 0!==t?t:0)&&(R-=5),u.push({pos:f,score:R}),Nt(u.length,r))break}if(Nt(u.length,r))break}if(Nt(u.length,r))break}return u.sort((e,t)=>t.score-e.score),u.length>0?u[0].pos:null}(e);return o?(t.collectionPoint={x:o.x,y:o.y},Mt.set(e.name,{pos:o,tick:Game.time})):(t.collectionPoint=void 0,Mt.delete(e.name)),o}(t,Ce.getOrInitSwarmState(t.name));if(r&&!e.pos.isEqualTo(r)){Ot(e,r,{visualizePathStyle:{stroke:"#888888"},priority:2})===ERR_NO_PATH&&(s=1);break}}!function(e,t=1,r){var o;if("spawning"in e&&e.spawning)return 0;if("fatigue"in e&&e.fatigue>0)return 0;const s=function(e,t){const r=Game.rooms[e.pos.roomName];if(!r)return null;const o=r.find(FIND_MY_SPAWNS);if(0===o.length)return null;let s=null;for(const r of o)if(e.pos.inRangeTo(r.pos,t)){s=r;break}if(!s)return null;const n=r.getTerrain(),i=[{dx:0,dy:-1},{dx:1,dy:-1},{dx:1,dy:0},{dx:1,dy:1},{dx:0,dy:1},{dx:-1,dy:1},{dx:-1,dy:0},{dx:-1,dy:-1}],a=[];for(const t of i){const o=e.pos.x+t.dx,i=e.pos.y+t.dy;if(!(o>0&&49>o&&i>0&&49>i))continue;if(n.get(o,i)===TERRAIN_MASK_WALL)continue;const c=new RoomPosition(o,i,e.pos.roomName);if(r.lookForAt(LOOK_STRUCTURES,o,i).some(e=>e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&!(e.structureType===STRUCTURE_RAMPART&&e.my)))continue;if(r.lookForAt(LOOK_CREEPS,o,i).length>0)continue;const u=c.getRangeTo(s.pos);a.push({pos:c,spawnDistance:u})}return a.sort((e,t)=>t.spawnDistance-e.spawnDistance),a.length>0?a[0].pos:null}(e,t);if(!s)return 0;const n=null!==(o=null==r?void 0:r.priority)&&void 0!==o?o:2,i=e.pos.roomName;if(lt===Game.time){ut.has(i)||ut.set(i,[]);const t=ut.get(i);return t&&t.push({creep:e,priority:n,targetPos:s}),1}{const t=Et(e.pos,s);e.move(t)}}(e);break}}s&&delete r.memory.state,function(e){e.isEmpty&&(e.memory.working=0),e.isFull&&(e.memory.working=1)}(r)}function Lt(e,t,r,o){const s=t();return s===ERR_NOT_IN_RANGE?Ot(e,r,{visualizePathStyle:{stroke:o}})===ERR_NO_PATH?1:0:s===ERR_FULL||s===ERR_NOT_ENOUGH_RESOURCES||s===ERR_INVALID_TARGET?1:0}const Dt="_ct";function $t(e,t,r,o=10){if(0===t.length)return Yt(e,r),null;if(1===t.length)return t[0];const s=e.memory,n=s[Dt],i=null==n?void 0:n[r];if(i&&Game.time-i.t<o&&i.k===r){const r=Game.getObjectById(i.i);if(r&&t.some(e=>e.id===r.id)&&20>=e.pos.getRangeTo(r.pos))return r}const a=e.pos.findClosestByRange(t);return a?(s[Dt]||(s[Dt]={}),s[Dt][r]={i:a.id,t:Game.time,k:r}):Yt(e,r),a}function Yt(e,t){const r=e.memory,o=r[Dt];o&&(t?delete o[t]:delete r[Dt])}function Kt(e){Yt(e)}const Ht=new class{constructor(){this.configs=new Map}initialize(e){var t;const r=Game.rooms[e];if(!r||!(null===(t=r.controller)||void 0===t?void 0:t.my))return;const o=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB});if(0===o.length)return void this.configs.delete(e);let s=this.configs.get(e);s||(s={roomName:e,labs:[],lastUpdate:Game.time,isValid:0},this.configs.set(e,s)),this.updateLabEntries(s,o),s.isValid||this.autoAssignRoles(s,o)}updateLabEntries(e,t){e.labs=e.labs.filter(e=>t.some(t=>t.id===e.labId));for(const r of t)e.labs.find(e=>e.labId===r.id)||e.labs.push({labId:r.id,role:"unassigned",pos:{x:r.pos.x,y:r.pos.y},lastConfigured:Game.time});e.lastUpdate=Game.time}autoAssignRoles(e,t){var r,o,s,n;if(3>t.length)return void(e.isValid=0);const i=new Map;for(const e of t){const r=[];for(const o of t)e.id===o.id||e.pos.getRangeTo(o)>2||r.push(o.id);i.set(e.id,r)}const a=t.map(e=>{var t,r;return{lab:e,reach:null!==(r=null===(t=i.get(e.id))||void 0===t?void 0:t.length)&&void 0!==r?r:0}}).sort((e,t)=>t.reach-e.reach);if(3>a.length||2>(null!==(o=null===(r=a[0])||void 0===r?void 0:r.reach)&&void 0!==o?o:0))return e.isValid=0,void Q.warn(`Lab layout in ${e.roomName} is not optimal for reactions`,{subsystem:"Labs"});const c=null===(s=a[0])||void 0===s?void 0:s.lab,u=null===(n=a[1])||void 0===n?void 0:n.lab;if(c&&u){for(const t of e.labs)if(t.labId===c.id)t.role="input1",t.lastConfigured=Game.time;else if(t.labId===u.id)t.role="input2",t.lastConfigured=Game.time;else{const e=2>=c.pos.getRangeTo(Game.getObjectById(t.labId)),r=2>=u.pos.getRangeTo(Game.getObjectById(t.labId));t.role=e&&r?"output":"boost",t.lastConfigured=Game.time}e.isValid=1,e.lastUpdate=Game.time,Q.info(`Auto-assigned lab roles in ${e.roomName}: `+e.labs.filter(e=>"input1"===e.role).length+" input1, "+e.labs.filter(e=>"input2"===e.role).length+" input2, "+e.labs.filter(e=>"output"===e.role).length+" output, "+e.labs.filter(e=>"boost"===e.role).length+" boost",{subsystem:"Labs"})}else e.isValid=0}getConfig(e){return this.configs.get(e)}getLabsByRole(e,t){const r=this.configs.get(e);return r?r.labs.filter(e=>e.role===t).map(e=>Game.getObjectById(e.labId)).filter(e=>null!==e):[]}getInputLabs(e){var t,r;const o=this.configs.get(e);if(!o)return{};const s=o.labs.find(e=>"input1"===e.role),n=o.labs.find(e=>"input2"===e.role);return{input1:s&&null!==(t=Game.getObjectById(s.labId))&&void 0!==t?t:void 0,input2:n&&null!==(r=Game.getObjectById(n.labId))&&void 0!==r?r:void 0}}getOutputLabs(e){return this.getLabsByRole(e,"output")}getBoostLabs(e){return this.getLabsByRole(e,"boost")}setActiveReaction(e,t,r,o){const s=this.configs.get(e);if(!s||!s.isValid)return 0;s.activeReaction={input1:t,input2:r,output:o};const n=s.labs.find(e=>"input1"===e.role),i=s.labs.find(e=>"input2"===e.role);n&&(n.resourceType=t),i&&(i.resourceType=r);for(const e of s.labs.filter(e=>"output"===e.role))e.resourceType=o;return s.lastUpdate=Game.time,Q.info(`Set active reaction in ${e}: ${t} + ${r} -> ${o}`,{subsystem:"Labs"}),1}clearActiveReaction(e){const t=this.configs.get(e);if(t){delete t.activeReaction;for(const e of t.labs)delete e.resourceType;t.lastUpdate=Game.time}}setLabRole(e,t,r,o){const s=this.configs.get(e);if(!s)return 0;const n=s.labs.find(e=>e.labId===t);return n?(n.role=r,n.resourceType=o,n.lastConfigured=Game.time,this.validateConfig(s),1):0}validateConfig(e){const t=e.labs.some(e=>"input1"===e.role),r=e.labs.some(e=>"input2"===e.role),o=e.labs.some(e=>"output"===e.role);if(e.isValid=t&&r&&o,e.isValid){const t=e.labs.find(e=>"input1"===e.role),r=e.labs.find(e=>"input2"===e.role),o=e.labs.filter(e=>"output"===e.role);if(t&&r&&o.length>0){const s=Game.getObjectById(t.labId),n=Game.getObjectById(r.labId);if(s&&n){const t=o.some(e=>{const t=Game.getObjectById(e.labId);return t&&2>=s.pos.getRangeTo(t)&&2>=n.pos.getRangeTo(t)});e.isValid=t}else e.isValid=0}}}runReactions(e){const t=this.configs.get(e);if(!t||!t.isValid||!t.activeReaction)return 0;const{input1:r,input2:o}=this.getInputLabs(e);if(!r||!o)return 0;const s=this.getOutputLabs(e);let n=0;for(const e of s)0===e.cooldown&&e.runReaction(r,o)===OK&&n++;return n}saveToMemory(e){const t=this.configs.get(e);if(!t)return;const r=Memory.rooms[e];if(r){r.labConfig=t;const o=`memory:room:${e}:labConfig`;ye.set(o,t,fe)}}loadFromMemory(e){const t=`memory:room:${e}:labConfig`;let r=ye.get(t);if(!r){const o=Memory.rooms[e],s=null==o?void 0:o.labConfig;s&&(ye.set(t,s,fe),r=s)}r&&this.configs.set(e,r)}getConfiguredRooms(){return Array.from(this.configs.keys())}hasValidConfig(e){var t;const r=this.configs.get(e);return null!==(t=null==r?void 0:r.isValid)&&void 0!==t?t:0}},Ft=new class{getLabResourceNeeds(e){var t,r,o;if(!Game.rooms[e])return[];const s=Ht.getConfig(e);if(!s||!s.isValid)return[];const n=[],{input1:i,input2:a}=Ht.getInputLabs(e);if(i&&s.activeReaction){const e=null!==(t=i.store[s.activeReaction.input1])&&void 0!==t?t:0;1e3>e&&n.push({labId:i.id,resourceType:s.activeReaction.input1,amount:2e3-e,priority:10})}if(a&&s.activeReaction){const e=null!==(r=a.store[s.activeReaction.input2])&&void 0!==r?r:0;1e3>e&&n.push({labId:a.id,resourceType:s.activeReaction.input2,amount:2e3-e,priority:10})}const c=Ht.getBoostLabs(e);for(const e of c){const t=s.labs.find(t=>t.labId===e.id);if(null==t?void 0:t.resourceType){const r=null!==(o=e.store[t.resourceType])&&void 0!==o?o:0;1e3>r&&n.push({labId:e.id,resourceType:t.resourceType,amount:1500-r,priority:8})}}return n}getLabOverflow(e){var t,r;if(!Game.rooms[e])return[];const o=Ht.getConfig(e);if(!o)return[];const s=[],n=Ht.getOutputLabs(e);for(const e of n){const r=e.mineralType;if(!r)continue;const n=null!==(t=e.store[r])&&void 0!==t?t:0,i=o.activeReaction&&r!==o.activeReaction.output;(n>2e3||i&&n>0)&&s.push({labId:e.id,resourceType:r,amount:n,priority:i?10:5})}const{input1:i,input2:a}=Ht.getInputLabs(e),c=[i,a].filter(e=>void 0!==e);for(const e of c){const t=e.mineralType;if(!t)continue;const n=o.labs.find(t=>t.labId===e.id),i=null==n?void 0:n.resourceType;if(i&&t!==i){const o=null!==(r=e.store[t])&&void 0!==r?r:0;o>0&&s.push({labId:e.id,resourceType:t,amount:o,priority:9})}}return s}areLabsReady(e,t){var r,o;const s=Ht.getConfig(e);if(!s||!s.isValid)return 0;const{input1:n,input2:i}=Ht.getInputLabs(e);if(!n||!i)return 0;if(500>(null!==(r=n.store[t.input1])&&void 0!==r?r:0))return 0;if(500>(null!==(o=i.store[t.input2])&&void 0!==o?o:0))return 0;const a=Ht.getOutputLabs(e);if(0===a.length)return 0;for(const e of a){const t=e.store.getFreeCapacity();if(null===t||100>t)return 0}return 1}clearReactions(e){Ht.clearActiveReaction(e),Q.info("Cleared active reactions in "+e,{subsystem:"Labs"})}setActiveReaction(e,t,r,o){const s=Ht.setActiveReaction(e,t,r,o);return s&&Q.info(`Set active reaction: ${t} + ${r} -> ${o}`,{subsystem:"Labs",room:e}),s}runReactions(e){return Ht.runReactions(e)}hasAvailableBoostLabs(e){return Ht.getBoostLabs(e).length>0}prepareBoostLab(e,t){var r;const o=Ht.getConfig(e);if(!o)return null;const s=Ht.getBoostLabs(e);for(const e of s)if(e.mineralType===t&&(null!==(r=e.store[t])&&void 0!==r?r:0)>=30)return e.id;for(const e of s)if(!e.mineralType){const r=o.labs.find(t=>t.labId===e.id);return r&&(r.resourceType=t,o.lastUpdate=Game.time),e.id}return null}handleUnboost(e,t){if(!e.body.some(e=>e.boost))return 0;if(!e.ticksToLive||e.ticksToLive>50)return 0;const r=t.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB});if(0===r.length)return 0;for(const o of r){const r=o.store.getFreeCapacity();if(null!==r&&r>=50){if(!e.pos.isNearTo(o))return e.moveTo(o),0;if(o.unboostCreep(e)===OK)return Q.info(`Unboosted ${e.name}, recovered resources`,{subsystem:"Labs",room:t.name}),1}}return 0}getLabTaskStatus(e){const t=Ht.getConfig(e);return t&&t.isValid?t.activeReaction?"reacting":this.getLabResourceNeeds(e).length>0?"loading":this.getLabOverflow(e).length>0?"unloading":"idle":"idle"}initialize(e){Ht.initialize(e),Ht.loadFromMemory(e)}save(e){Ht.saveToMemory(e)}};function Wt(e){var t,r;const o=null!==(t=e.memory.working)&&void 0!==t?t:0;e.isEmpty&&(e.memory.working=0),e.isFull&&(e.memory.working=1);const s=null!==(r=e.memory.working)&&void 0!==r?r:0;return o!==s&&Kt(e.creep),s}function Bt(e){if(e.droppedResources.length>0){const t=$t(e.creep,e.droppedResources,"energy_drop",5);if(t)return{type:"pickup",target:t}}if(e.containers.length>0){const t=$t(e.creep,e.containers,"energy_container",10);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}if(e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>0)return{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY};const t=e.room.find(FIND_SOURCES_ACTIVE);if(t.length>0){const r=$t(e.creep,t,"energy_source",20);if(r)return{type:"harvest",target:r}}return{type:"idle"}}function Vt(e){if(e.spawnStructures.length>0){const t=$t(e.creep,e.spawnStructures,"deliver_spawn",5);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}if(e.towers.length>0){const t=$t(e.creep,e.towers,"deliver_tower",10);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}return null}function qt(e){if(Wt(e)){const t=Vt(e);if(t)return t;if(e.storage&&e.storage.store.getFreeCapacity(RESOURCE_ENERGY)>0)return{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY};const r=function(e){var t;const r=Ce.getSwarmState(e.room.name);return null!==(t=null==r?void 0:r.pheromones)&&void 0!==t?t:null}(e.creep);if(r){if(function(e){return e.build>15}(r)&&e.prioritizedSites.length>0)return{type:"build",target:e.prioritizedSites[0]};if(function(e){return e.upgrade>15}(r)&&e.room.controller)return{type:"upgrade",target:e.room.controller}}return e.prioritizedSites.length>0?{type:"build",target:e.prioritizedSites[0]}:e.room.controller?{type:"upgrade",target:e.room.controller}:{type:"idle"}}return Bt(e)}function jt(e){var t,r;const o=e.room.find(FIND_SOURCES);if(0===o.length)return null;const s="sourceCounts_"+e.room.name,n="sourceCounts_tick_"+e.room.name,i=global,a=i[s],c=i[n];let u;if(a&&c===Game.time)u=a;else{u=new Map;for(const e of o)u.set(e.id,0);for(const r in Game.creeps){const o=Game.creeps[r],s=o.memory;"harvester"===s.role&&s.sourceId&&o.room.name===e.room.name&&u.set(s.sourceId,(null!==(t=u.get(s.sourceId))&&void 0!==t?t:0)+1)}i[s]=u,i[n]=Game.time}let l=null,m=1/0;for(const e of o){const t=null!==(r=u.get(e.id))&&void 0!==r?r:0;m>t&&(m=t,l=e)}return l&&(e.memory.sourceId=l.id),l}const Xt={larvaWorker:qt,harvester:function(e){let t=e.assignedSource;if(t||(t=jt(e)),!t)return{type:"idle"};if(!e.creep.pos.isNearTo(t))return{type:"moveTo",target:t};const r=e.creep.store.getCapacity(),o=e.creep.store.getFreeCapacity()>0;if(null===r||0===r||o)return{type:"harvest",target:t};const s=e.creep.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0})[0];if(s)return{type:"transfer",target:s,resourceType:RESOURCE_ENERGY};const n=e.creep.pos.findInRange(FIND_MY_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_LINK&&e.store.getFreeCapacity(RESOURCE_ENERGY)>0})[0];return n?{type:"transfer",target:n,resourceType:RESOURCE_ENERGY}:{type:"drop",resourceType:RESOURCE_ENERGY}},hauler:function(e){var t;if(Wt(e)){const r=Object.keys(e.creep.store)[0];if(r&&r!==RESOURCE_ENERGY){const o=null!==(t=e.terminal)&&void 0!==t?t:e.storage;if(o)return{type:"transfer",target:o,resourceType:r}}const o=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(o.length>0){const t=$t(e.creep,o,"hauler_spawn",10);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}const s=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_EXTENSION);if(s.length>0){const t=$t(e.creep,s,"hauler_ext",10);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}if(e.towers.length>0){const t=$t(e.creep,e.towers,"hauler_tower",15);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}if(e.storage&&e.storage.store.getFreeCapacity(RESOURCE_ENERGY)>0)return{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY};if(e.depositContainers.length>0){const t=$t(e.creep,e.depositContainers,"hauler_cont",15);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}return{type:"idle"}}if(e.droppedResources.length>0){const t=$t(e.creep,e.droppedResources,"hauler_drop",5);if(t)return{type:"pickup",target:t}}const r=e.room.find(FIND_TOMBSTONES,{filter:e=>e.store.getUsedCapacity(RESOURCE_ENERGY)>0});if(r.length>0){const t=$t(e.creep,r,"hauler_tomb",10);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}if(e.containers.length>0){const t=$t(e.creep,e.containers,"hauler_source",15);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}const o=e.room.find(FIND_STRUCTURES,{filter:e=>{if(e.structureType!==STRUCTURE_CONTAINER)return 0;const t=e;return Object.keys(t.store).some(e=>e!==RESOURCE_ENERGY&&t.store.getUsedCapacity(e)>0)}});if(o.length>0){const t=$t(e.creep,o,"hauler_mineral",15);if(t){const e=Object.keys(t.store).find(e=>e!==RESOURCE_ENERGY&&t.store.getUsedCapacity(e)>0);if(e)return{type:"withdraw",target:t,resourceType:e}}}return e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>0?{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY}:{type:"idle"}},builder:function(e){return Wt(e)?e.prioritizedSites.length>0?{type:"build",target:e.prioritizedSites[0]}:e.room.controller?{type:"upgrade",target:e.room.controller}:{type:"idle"}:Bt(e)},upgrader:function(e){if(Wt(e))return e.room.controller?{type:"upgrade",target:e.room.controller}:{type:"idle"};const t="upgrader_nearby_containers",r=e.creep.memory,o=r[t];let s=[];if(o&&30>Game.time-o.tick?s=o.ids.map(e=>Game.getObjectById(e)).filter(e=>null!==e):(s=e.creep.pos.findInRange(FIND_STRUCTURES,3,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>50}),r[t]={ids:s.map(e=>e.id),tick:Game.time}),s.length>0){const t=$t(e.creep,s,"upgrader_nearby",30);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}if(e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>1e3)return{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY};if(e.containers.length>0){const t=$t(e.creep,e.containers,"upgrader_cont",30);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}const n=e.room.find(FIND_SOURCES_ACTIVE);if(n.length>0){const t=$t(e.creep,n,"upgrader_source",30);if(t)return{type:"harvest",target:t}}return{type:"idle"}},queenCarrier:function(e){return Wt(e)?Vt(e)||(e.storage?{type:"moveTo",target:e.storage}:{type:"idle"}):e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>0?{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY}:e.terminal&&e.terminal.store.getUsedCapacity(RESOURCE_ENERGY)>0?{type:"withdraw",target:e.terminal,resourceType:RESOURCE_ENERGY}:{type:"idle"}},mineralHarvester:function(e){var t;const r=e.room.find(FIND_MINERALS)[0];if(!r)return{type:"idle"};if(!r.pos.lookFor(LOOK_STRUCTURES).find(e=>e.structureType===STRUCTURE_EXTRACTOR))return{type:"idle"};if(0===r.mineralAmount)return e.storage?{type:"moveTo",target:e.storage}:{type:"idle"};if(e.isFull){const r=Object.keys(e.creep.store)[0],o=e.creep.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getFreeCapacity(r)>0})[0];if(o)return{type:"transfer",target:o,resourceType:r};const s=null!==(t=e.terminal)&&void 0!==t?t:e.storage;if(s)return{type:"transfer",target:s,resourceType:r}}return{type:"harvestMineral",target:r}},depositHarvester:function(e){var t;if(!e.memory.targetId){const t=e.room.find(FIND_DEPOSITS);if(t.length>0){const r=t.reduce((e,t)=>e.cooldown<t.cooldown?e:t);e.memory.targetId=r.id}}if(!e.memory.targetId)return{type:"idle"};const r=Game.getObjectById(e.memory.targetId);if(!r||null===(o=r)||"object"!=typeof o||!("depositType"in o)||!("cooldown"in o)||"structureType"in o)return delete e.memory.targetId,{type:"idle"};var o;const s=r;if(s.cooldown>100)return delete e.memory.targetId,{type:"idle"};if(e.isFull){const r=Game.rooms[e.homeRoom];if(r){const o=null!==(t=r.terminal)&&void 0!==t?t:r.storage;if(o)return{type:"transfer",target:o,resourceType:Object.keys(e.creep.store)[0]}}return{type:"moveToRoom",roomName:e.homeRoom}}return{type:"harvestDeposit",target:s}},labTech:function(e){var t,r;if(0===e.labs.length)return{type:"idle"};const o=e.labs.slice(0,2),s=e.labs.slice(2);if(e.creep.store.getUsedCapacity()>0){const r=Object.keys(e.creep.store)[0],s=[RESOURCE_HYDROGEN,RESOURCE_OXYGEN,RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_CATALYST];if(r!==RESOURCE_ENERGY&&!s.includes(r)){const o=null!==(t=e.terminal)&&void 0!==t?t:e.storage;if(o)return{type:"transfer",target:o,resourceType:r}}for(const e of o){const t=e.store.getFreeCapacity(r);if(null!==t&&t>0)return{type:"transfer",target:e,resourceType:r}}}for(const e of s){const t=e.mineralType;if(t&&e.store.getUsedCapacity(t)>100)return{type:"withdraw",target:e,resourceType:t}}const n=null!==(r=e.terminal)&&void 0!==r?r:e.storage;if(n){const e=[RESOURCE_HYDROGEN,RESOURCE_OXYGEN,RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_CATALYST];for(const t of o)for(const r of e)if(n.store.getUsedCapacity(r)>0&&t.store.getFreeCapacity(r)>0)return{type:"withdraw",target:n,resourceType:r}}return{type:"idle"}},labSupply:function(e){return function(e){var t,r;const o=null!==(t=e.memory.working)&&void 0!==t?t:0;e.isEmpty&&(e.memory.working=0),e.isFull&&(e.memory.working=1);const s=null!==(r=e.memory.working)&&void 0!==r?r:0;return o!==s&&(Kt(e.creep),delete e.memory.targetId),s}(e)?function(e){if(e.memory.targetId){const t=Game.getObjectById(e.memory.targetId);if(t){const r=Object.keys(e.creep.store).find(t=>e.creep.store[t]>0);if(r)return{type:"transfer",target:t,resourceType:r}}delete e.memory.targetId}const t=Ft.getLabResourceNeeds(e.room.name);if(0===t.length)return{type:"idle"};t.sort((e,t)=>t.priority-e.priority);const r=t[0];if(!r)return{type:"idle"};const o=Object.keys(e.creep.store).find(t=>e.creep.store[t]>0);if(o&&o!==r.resourceType&&e.terminal)return{type:"transfer",target:e.terminal,resourceType:o};const s=Game.getObjectById(r.labId);return s?(e.memory.targetId=r.labId,{type:"transfer",target:s,resourceType:r.resourceType}):{type:"idle"}}(e):function(e){var t;const r=Ft.getLabOverflow(e.room.name);if(r.length>0){r.sort((e,t)=>t.priority-e.priority);const e=r[0];if(e){const t=Game.getObjectById(e.labId);if(t)return{type:"withdraw",target:t,resourceType:e.resourceType}}}const o=Ft.getLabResourceNeeds(e.room.name);if(o.length>0&&e.terminal){o.sort((e,t)=>t.priority-e.priority);const r=o[0];if(r&&(null!==(t=e.terminal.store[r.resourceType])&&void 0!==t?t:0)>0)return e.memory.targetId=r.labId,{type:"withdraw",target:e.terminal,resourceType:r.resourceType}}return{type:"idle"}}(e)},factoryWorker:function(e){var t;if(!e.factory)return{type:"idle"};if(Wt(e)){const t=Object.keys(e.creep.store)[0];return{type:"transfer",target:e.factory,resourceType:t}}const r=null!==(t=e.terminal)&&void 0!==t?t:e.storage;if(!r)return{type:"idle"};const o=[RESOURCE_UTRIUM_BAR,RESOURCE_LEMERGIUM_BAR,RESOURCE_KEANIUM_BAR,RESOURCE_ZYNTHIUM_BAR,RESOURCE_GHODIUM_MELT,RESOURCE_OXIDANT,RESOURCE_REDUCTANT,RESOURCE_PURIFIER,RESOURCE_BATTERY];for(const t of o)if(e.factory.store.getUsedCapacity(t)>100)return{type:"withdraw",target:e.factory,resourceType:t};if(5e3>e.factory.store.getUsedCapacity(RESOURCE_ENERGY)&&r.store.getUsedCapacity(RESOURCE_ENERGY)>1e4)return{type:"withdraw",target:r,resourceType:RESOURCE_ENERGY};const s=[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_OXYGEN,RESOURCE_HYDROGEN,RESOURCE_CATALYST,RESOURCE_GHODIUM];for(const t of s)if(1e3>e.factory.store.getUsedCapacity(t)&&r.store.getUsedCapacity(t)>500)return{type:"withdraw",target:r,resourceType:t};return{type:"idle"}},remoteHarvester:function(e){const t=e.memory.targetRoom;if(!t||t===e.memory.homeRoom)return{type:"idle"};if(e.nearbyEnemies&&e.hostiles.length>0){const r=e.hostiles.filter(t=>5>=e.creep.pos.getRangeTo(t)&&(t.getActiveBodyparts(ATTACK)>0||t.getActiveBodyparts(RANGED_ATTACK)>0));if(r.length>0)return e.room.name===t?{type:"moveToRoom",roomName:e.memory.homeRoom}:{type:"flee",from:r.map(e=>e.pos)}}if(e.room.name!==t)return{type:"moveToRoom",roomName:t};let r=e.assignedSource;if(r||(r=jt(e)),!r)return{type:"idle"};if(!e.creep.pos.isNearTo(r))return{type:"moveTo",target:r};const o=e.creep.store.getCapacity(),s=e.creep.store.getFreeCapacity()>0;if(null===o||0===o||s)return{type:"harvest",target:r};const n=r.pos.findInRange(FIND_STRUCTURES,2,{filter:e=>e.structureType===STRUCTURE_CONTAINER});return n.length>0?{type:"transfer",target:n[0],resourceType:RESOURCE_ENERGY}:{type:"drop",resourceType:RESOURCE_ENERGY}},remoteHauler:function(e){const t=Wt(e),r=e.memory.targetRoom,o=e.memory.homeRoom;if(!r||r===o)return{type:"idle"};if(e.nearbyEnemies&&e.hostiles.length>0){const r=e.hostiles.filter(t=>5>=e.creep.pos.getRangeTo(t)&&(t.getActiveBodyparts(ATTACK)>0||t.getActiveBodyparts(RANGED_ATTACK)>0));if(r.length>0)return t&&e.room.name!==o?{type:"moveToRoom",roomName:o}:{type:"flee",from:r.map(e=>e.pos)}}if(t){if(e.room.name!==o)return{type:"moveToRoom",roomName:o};const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(t.length>0){const r=$t(e.creep,t,"remoteHauler_spawn",5);if(r)return{type:"transfer",target:r,resourceType:RESOURCE_ENERGY}}const r=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_EXTENSION);if(r.length>0){const t=$t(e.creep,r,"remoteHauler_ext",5);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}if(e.towers.length>0){const t=$t(e.creep,e.towers,"remoteHauler_tower",10);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}if(e.storage&&e.storage.store.getFreeCapacity(RESOURCE_ENERGY)>0)return{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY};if(e.depositContainers.length>0){const t=$t(e.creep,e.depositContainers,"remoteHauler_cont",10);if(t)return{type:"transfer",target:t,resourceType:RESOURCE_ENERGY}}return{type:"idle"}}{if(e.room.name!==r)return{type:"moveToRoom",roomName:r};const t=.3*e.creep.store.getCapacity(RESOURCE_ENERGY),o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(RESOURCE_ENERGY)>=t});if(o.length>0){const t=$t(e.creep,o,"remoteHauler_remoteCont",10);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}const s=e.room.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_ENERGY&&e.amount>50});if(s.length>0){const t=$t(e.creep,s,"remoteHauler_remoteDrop",3);if(t)return{type:"pickup",target:t}}if(0===o.length){const t=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});if(t.length>0){const r=$t(e.creep,t,"remoteHauler_waitCont",20);if(r&&e.creep.pos.getRangeTo(r)>2)return{type:"moveTo",target:r}}}return{type:"idle"}}},interRoomCarrier:function(e){const t=e.memory;if(!t.transferRequest)return{type:"idle"};const{fromRoom:r,toRoom:o,resourceType:s}=t.transferRequest;if(e.creep.store.getUsedCapacity(s)>0){if(e.room.name!==o)return{type:"moveToRoom",roomName:o};const t=Game.rooms[o];if(!t)return{type:"moveToRoom",roomName:o};if(t.storage)return{type:"transfer",target:t.storage,resourceType:s};const r=t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getFreeCapacity(s)>0});if(r.length>0){const t=$t(e.creep,r,"interRoomCarrier_targetCont",10);if(t)return{type:"transfer",target:t,resourceType:s}}const n=t.find(FIND_MY_SPAWNS);return n.length>0?e.creep.pos.isNearTo(n[0])?{type:"drop",resourceType:s}:{type:"moveTo",target:n[0].pos}:{type:"idle"}}{if(e.room.name!==r)return{type:"moveToRoom",roomName:r};const t=Game.rooms[r];if(!t)return{type:"moveToRoom",roomName:r};if(t.storage&&t.storage.store.getUsedCapacity(s)>0)return{type:"withdraw",target:t.storage,resourceType:s};const o=t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER&&e.store.getUsedCapacity(s)>0});if(o.length>0){const t=$t(e.creep,o,"interRoomCarrier_sourceCont",10);if(t)return{type:"withdraw",target:t,resourceType:s}}return{type:"idle"}}}};function zt(e){var t;return(null!==(t=Xt[e.memory.role])&&void 0!==t?t:qt)(e)}const Zt=new Map;function Qt(e){const t=e.find(FIND_MY_SPAWNS),r=t.length,o=Zt.get(e.name);if(o&&o.spawnCount===r&&1e3>Game.time-o.tick)return o.waypoints;const s=e.name,n=[];for(const e of t)n.push(new RoomPosition(e.pos.x+3,e.pos.y+3,s)),n.push(new RoomPosition(e.pos.x-3,e.pos.y-3,s));n.push(new RoomPosition(25,5,s)),n.push(new RoomPosition(25,44,s)),n.push(new RoomPosition(5,25,s)),n.push(new RoomPosition(44,25,s));const i=n.map(e=>({x:Math.max(2,Math.min(47,e.x)),y:Math.max(2,Math.min(47,e.y)),roomName:s})).filter(t=>e.getTerrain().get(t.x,t.y)!==TERRAIN_MASK_WALL).map(e=>new RoomPosition(e.x,e.y,e.roomName));return Zt.set(e.name,{waypoints:i,spawnCount:r,tick:Game.time}),i}function Jt(e,t){var r;if(0===t.length)return null;const o=e.memory;void 0===o.patrolIndex&&(o.patrolIndex=0);const s=t[o.patrolIndex%t.length];return s&&2>=e.pos.getRangeTo(s)&&(o.patrolIndex=(o.patrolIndex+1)%t.length),null!==(r=t[o.patrolIndex%t.length])&&void 0!==r?r:null}function er(e){var t,r;if(0===e.hostiles.length)return null;const o=e.hostiles.map(e=>{let t=0;if(t+=100*e.getActiveBodyparts(HEAL),t+=50*e.getActiveBodyparts(RANGED_ATTACK),t+=40*e.getActiveBodyparts(ATTACK),t+=60*e.getActiveBodyparts(CLAIM),t+=30*e.getActiveBodyparts(WORK),t>0)for(const r of e.body)if(r.boost){t+=20;break}return{hostile:e,score:t}});return o.sort((e,t)=>t.score-e.score),null!==(r=null===(t=o[0])||void 0===t?void 0:t.hostile)&&void 0!==r?r:null}function tr(e,t){return e.getActiveBodyparts(t)>0}function rr(e){var t;return null===(t=Memory.squads)||void 0===t?void 0:t[e]}function or(e){const t=e.creep.memory;if(t.assistTarget&&delete t.assistTarget,e.creep.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const r=er(e);if(r){const t=e.creep.pos.getRangeTo(r),o=tr(e.creep,RANGED_ATTACK),s=tr(e.creep,ATTACK);return o&&3>=t?{type:"rangedAttack",target:r}:s&&1>=t?{type:"attack",target:r}:{type:"moveTo",target:r}}const o=Qt(e.room),s=Jt(e.creep,o);if(s)return{type:"moveTo",target:s};const n=e.creep.pos.findClosestByRange(FIND_MY_SPAWNS);return n&&e.creep.pos.getRangeTo(n)>5?{type:"moveTo",target:n}:{type:"idle"}}function sr(e){const t=e.creep.memory;if(e.creep.hits<.5*e.creep.hitsMax)return{type:"heal",target:e.creep};if(t.targetRoom){if(e.room.name!==t.targetRoom)return{type:"moveToRoom",roomName:t.targetRoom};const r=e.room.find(FIND_MY_CREEPS,{filter:e=>{const r=e.memory;return"powerHarvester"===r.role&&r.targetRoom===t.targetRoom}});if(r.length>0){r.sort((e,t)=>e.hits/e.hitsMax-t.hits/t.hitsMax);const t=r[0],o=e.creep.pos.getRangeTo(t);return o>3?{type:"moveTo",target:t}:o>1?{type:"rangedHeal",target:t}:{type:"heal",target:t}}const o=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_BANK})[0];if(!o&&0===r.length)return delete t.targetRoom,{type:"moveToRoom",roomName:e.homeRoom};if(o&&e.creep.pos.getRangeTo(o)>3)return{type:"moveTo",target:o}}if(t.assistTarget){const r=Game.rooms[t.assistTarget];if(!r)return{type:"moveToRoom",roomName:t.assistTarget};if(0===r.find(FIND_HOSTILE_CREEPS).length)return delete t.assistTarget,{type:"idle"};if(e.creep.room.name!==t.assistTarget)return{type:"moveToRoom",roomName:t.assistTarget}}const r=e.creep.pos.findInRange(FIND_MY_CREEPS,3,{filter:e=>e.hits<e.hitsMax});if(r.length>0){r.sort((e,t)=>e.hits/e.hitsMax-t.hits/t.hitsMax);const t=r[0];return e.creep.pos.getRangeTo(t)>1?{type:"rangedHeal",target:t}:{type:"heal",target:t}}const o=e.room.find(FIND_MY_CREEPS,{filter:e=>{const t=e.memory;return"military"===t.family&&"healer"!==t.role}});if(o.length>0){const t=$t(e.creep,o,"healer_follow",5);if(t)return{type:"moveTo",target:t}}return{type:"idle"}}function nr(e){var t;if(e.memory.squadId){const t=rr(e.memory.squadId);if(t)return cr(e,t)}if(.3>e.creep.hits/e.creep.hitsMax){if(e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);return t.length>0&&e.creep.pos.getRangeTo(t[0])>3?{type:"moveTo",target:t[0]}:{type:"idle"}}const r=null!==(t=e.memory.targetRoom)&&void 0!==t?t:e.homeRoom;if(e.room.name!==r)return{type:"moveToRoom",roomName:r};const o=er(e);if(o){const t=e.creep.pos.getRangeTo(o),r=tr(e.creep,RANGED_ATTACK),s=tr(e.creep,ATTACK);return r&&3>=t?{type:"rangedAttack",target:o}:s&&1>=t?{type:"attack",target:o}:{type:"moveTo",target:o}}const s=Ke(e.creep.pos,FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_CONTROLLER});if(s)return{type:"attack",target:s};const n=Qt(e.room),i=Jt(e.creep,n);if(i)return{type:"moveTo",target:i};const a=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(a.length>0){const t=$t(e.creep,a,"soldier_spawn",20);if(t&&e.creep.pos.getRangeTo(t)>5)return{type:"moveTo",target:t}}return{type:"idle"}}function ir(e){var t;if(e.memory.squadId){const t=rr(e.memory.squadId);if(t)return cr(e,t)}if(.3>e.creep.hits/e.creep.hitsMax){if(e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);return t.length>0&&e.creep.pos.getRangeTo(t[0])>3?{type:"moveTo",target:t[0]}:{type:"idle"}}const r=null!==(t=e.memory.targetRoom)&&void 0!==t?t:e.homeRoom;if(e.room.name!==r)return{type:"moveToRoom",roomName:r};const o=Ke(e.creep.pos,FIND_HOSTILE_SPAWNS);if(o)return{type:"dismantle",target:o};const s=Ke(e.creep.pos,FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER});if(s)return{type:"dismantle",target:s};const n=e.room.find(FIND_STRUCTURES,{filter:t=>{var r;return t.structureType===STRUCTURE_WALL?1e5>t.hits&&!(null===(r=e.room.controller)||void 0===r?void 0:r.my):t.structureType===STRUCTURE_RAMPART?1e5>t.hits&&!t.my:0}});if(n.length>0){const t=$t(e.creep,n,"siege_wall",10);if(t)return{type:"dismantle",target:t}}const i=Ke(e.creep.pos,FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_CONTROLLER});if(i)return{type:"dismantle",target:i};const a=Qt(e.room),c=Jt(e.creep,a);if(c)return{type:"moveTo",target:c};const u=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(u.length>0){const t=$t(e.creep,u,"siege_spawn",20);if(t&&e.creep.pos.getRangeTo(t)>5)return{type:"moveTo",target:t}}return{type:"idle"}}function ar(e){const t=e.creep.memory;if(.3>e.creep.hits/e.creep.hitsMax){if(t.assistTarget&&delete t.assistTarget,e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const r=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);return r.length>0&&e.creep.pos.getRangeTo(r[0])>3?{type:"moveTo",target:r[0]}:{type:"idle"}}if(t.assistTarget){const r=Game.rooms[t.assistTarget];if(!r)return{type:"moveToRoom",roomName:t.assistTarget};{if(0===r.find(FIND_HOSTILE_CREEPS).length)return delete t.assistTarget,{type:"idle"};if(e.creep.room.name!==t.assistTarget)return{type:"moveToRoom",roomName:t.assistTarget};const o=er(e);if(o){const t=e.creep.pos.getRangeTo(o);return 3>t?{type:"flee",from:[o.pos]}:t>3?{type:"moveTo",target:o}:{type:"rangedAttack",target:o}}}}if(e.memory.squadId){const t=rr(e.memory.squadId);if(t)return cr(e,t)}const r=er(e);if(r){const t=e.creep.pos.getRangeTo(r);return 3>t?{type:"flee",from:[r.pos]}:t>3?{type:"moveTo",target:r}:{type:"rangedAttack",target:r}}const o=Qt(e.room),s=Jt(e.creep,o);if(s)return{type:"moveTo",target:s};const n=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(n.length>0){const t=$t(e.creep,n,"harasser_home_spawn",20);if(t&&e.creep.pos.getRangeTo(t)>10)return{type:"moveTo",target:t}}return{type:"idle"}}function cr(e,t){var r;switch(t.state){case"gathering":if(e.room.name!==t.rallyRoom)return{type:"moveToRoom",roomName:t.rallyRoom};const o=new RoomPosition(25,25,t.rallyRoom);return e.creep.pos.getRangeTo(o)>3?{type:"moveTo",target:o}:{type:"idle"};case"moving":{const r=t.targetRooms[0];return r&&e.room.name!==r?(()=>{const r=t.members.filter(t=>{const r=Game.creeps[t];return r&&r.room.name===e.room.name}).length,o=t.members.length;return Math.max(2,.5*o)>r})()?{type:"idle"}:{type:"moveToRoom",roomName:r}:{type:"idle"}}case"attacking":const s=e.creep.hits/e.creep.hitsMax;if((null!==(r=t.retreatThreshold)&&void 0!==r?r:.3)>s&&e.room.name!==t.rallyRoom)return{type:"moveToRoom",roomName:t.rallyRoom};switch(e.memory.role){case"soldier":case"guard":default:return nr(e);case"healer":return sr(e);case"siegeUnit":return ir(e);case"ranger":return ar(e)}case"retreating":return e.room.name!==t.rallyRoom?{type:"moveToRoom",roomName:t.rallyRoom}:{type:"moveTo",target:new RoomPosition(25,25,t.rallyRoom)};case"dissolving":return e.room.name!==e.homeRoom?{type:"moveToRoom",roomName:e.homeRoom}:(delete e.memory.squadId,{type:"idle"});default:return{type:"idle"}}}const ur={guard:or,remoteGuard:function(e){const t=e.creep.memory;if(!t.targetRoom)return e.creep.room.name!==e.homeRoom?{type:"moveToRoom",roomName:e.homeRoom}:{type:"idle"};if(e.creep.room.name!==t.targetRoom)return{type:"moveToRoom",roomName:t.targetRoom};const r=e.room.find(FIND_HOSTILE_CREEPS).filter(e=>e.body.some(e=>e.type===ATTACK||e.type===RANGED_ATTACK||e.type===WORK));if(0===r.length)return e.creep.room.name!==e.homeRoom?{type:"moveToRoom",roomName:e.homeRoom}:{type:"idle"};const o=function(e,t){if(0===t.length)return null;const r=[t.filter(e=>e.body.some(e=>e.boost)),t.filter(e=>tr(e,HEAL)),t.filter(e=>tr(e,RANGED_ATTACK)),t.filter(e=>tr(e,ATTACK)),t];for(const t of r)if(t.length>0)return e.creep.pos.findClosestByRange(t);return null}(e,r);if(o){const t=e.creep.pos.getRangeTo(o),r=tr(e.creep,RANGED_ATTACK),s=tr(e.creep,ATTACK);return r&&3>=t?{type:"rangedAttack",target:o}:s&&1>=t?{type:"attack",target:o}:{type:"moveTo",target:o}}const s=e.room.find(FIND_SOURCES);if(s.length>0){const t=e.creep.pos.findClosestByRange(s);if(t&&e.creep.pos.getRangeTo(t)>3)return{type:"moveTo",target:t}}return{type:"idle"}},healer:sr,soldier:nr,siegeUnit:ir,harasser:function(e){const t=e.memory.targetRoom;if(.4>e.creep.hits/e.creep.hitsMax){if(e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);return t.length>0&&e.creep.pos.getRangeTo(t[0])>3?{type:"moveTo",target:t[0]}:{type:"idle"}}if(!t){const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(t.length>0){const r=$t(e.creep,t,"harasser_spawn",20);if(r)return{type:"moveTo",target:r}}return{type:"idle"}}if(e.room.name!==t)return{type:"moveToRoom",roomName:t};const r=e.hostiles.filter(t=>5>e.creep.pos.getRangeTo(t)&&t.body.some(e=>e.type===ATTACK||e.type===RANGED_ATTACK));if(r.length>0)return{type:"flee",from:r.map(e=>e.pos)};const o=e.hostiles.filter(e=>e.body.some(e=>e.type===WORK||e.type===CARRY));if(o.length>0){const t=o.reduce((t,r)=>e.creep.pos.getRangeTo(t)<e.creep.pos.getRangeTo(r)?t:r),r=e.creep.pos.getRangeTo(t);return r>1?r>3?{type:"moveTo",target:t}:{type:"rangedAttack",target:t}:{type:"attack",target:t}}return{type:"idle"}},ranger:ar};function lr(e){var t;return(null!==(t=ur[e.memory.role])&&void 0!==t?t:or)(e)}function mr(e,t){var r,o,s,n,i,a,c;const u=t.roomsSeen,l=t.roomIntel,m=l[e.name],p=null!==(r=null==m?void 0:m.lastSeen)&&void 0!==r?r:0,d=Game.time-p;if(u[e.name]=Game.time,m&&1e3>d){m.lastSeen=Game.time;const t=Ye(e,FIND_HOSTILE_CREEPS);return m.threatLevel=t.length>5?3:t.length>2?2:t.length>0?1:0,void(e.controller&&(m.controllerLevel=null!==(o=e.controller.level)&&void 0!==o?o:0,(null===(s=e.controller.owner)||void 0===s?void 0:s.username)&&(m.owner=e.controller.owner.username),(null===(n=e.controller.reservation)||void 0===n?void 0:n.username)&&(m.reserver=e.controller.reservation.username)))}const g=e.find(FIND_SOURCES),f=e.find(FIND_MINERALS)[0],R=e.controller,h=Ye(e,FIND_HOSTILE_CREEPS),y=e.getTerrain();let E=0,T=0;for(let e=5;50>e;e+=10)for(let t=5;50>t;t+=10){const r=y.get(e,t);r===TERRAIN_MASK_SWAMP?E++:0===r&&T++}const C=E>2*T?"swamp":T>2*E?"plains":"mixed",v=e.name.match(/^[WE](\d+)[NS](\d+)$/),S=v?parseInt(v[1],10)%10==0||parseInt(v[2],10)%10==0:0,U=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_KEEPER_LAIR}).length>0,O={name:e.name,lastSeen:Game.time,sources:g.length,controllerLevel:null!==(i=null==R?void 0:R.level)&&void 0!==i?i:0,threatLevel:h.length>5?3:h.length>2?2:h.length>0?1:0,scouted:1,terrain:C,isHighway:S,isSK:U};(null===(a=null==R?void 0:R.owner)||void 0===a?void 0:a.username)&&(O.owner=R.owner.username),(null===(c=null==R?void 0:R.reservation)||void 0===c?void 0:c.username)&&(O.reserver=R.reservation.username),(null==f?void 0:f.mineralType)&&(O.mineralType=f.mineralType),l[e.name]=O}function pr(e){return{type:"moveTo",target:new RoomPosition(25,25,e)}}function dr(e){const t=function(){const e=Memory;return e.overmind||(e.overmind={roomsSeen:{},roomIntel:{},claimQueue:[],warTargets:[],nukeCandidates:[],powerBanks:[],objectives:{targetPowerLevel:0,targetRoomCount:1,warMode:0,expansionPaused:0},lastRun:0}),e.overmind}(),r=e.memory.lastExploredRoom;let o=e.memory.targetRoom;const s=ht(e.creep.pos);o&&e.room.name,o||(o=function(e,t,r){var o,s;const n=t.roomsSeen,i=Game.map.describeExits(e);if(!i)return;const a=[];for(const[,e]of Object.entries(i)){if(r&&e===r)continue;const t=null!==(o=n[e])&&void 0!==o?o:0;Game.time-t>1e3&&a.push({room:e,lastSeen:t})}return a.sort((e,t)=>e.lastSeen-t.lastSeen),null===(s=a[0])||void 0===s?void 0:s.room}(e.room.name,t,r),o?e.memory.targetRoom=o:(delete e.memory.targetRoom,delete e.memory.lastExploredRoom));const n=o&&e.room.name!==o;if(s&&!n)return pr(e.room.name);if(o&&e.room.name!==o)return{type:"moveToRoom",roomName:o};if(o&&e.room.name===o){if(s)return pr(e.room.name);const r=function(e){const t=[new RoomPosition(5,5,e.name),new RoomPosition(44,5,e.name),new RoomPosition(5,44,e.name),new RoomPosition(44,44,e.name),new RoomPosition(25,25,e.name)],r=e.getTerrain();for(const e of t)if(r.get(e.x,e.y)!==TERRAIN_MASK_WALL)return e;return null}(e.room);if(r){const o=3;if(e.creep.pos.getRangeTo(r)>o)return{type:"moveTo",target:r};mr(e.room,t),e.memory.lastExploredRoom=e.room.name,delete e.memory.targetRoom}else mr(e.room,t),e.memory.lastExploredRoom=e.room.name,delete e.memory.targetRoom}return{type:"idle"}}je=function(){};const gr={scout:dr,claimer:function(e){const t=e.memory.targetRoom;if(!t){const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(t.length>0){const r=$t(e.creep,t,"claimer_spawn",20);if(r)return{type:"moveTo",target:r}}return{type:"idle"}}if(e.room.name!==t)return{type:"moveToRoom",roomName:t};const r=e.room.controller;if(!r)return{type:"idle"};const o=e.memory.task;return"claim"===o?{type:"claim",target:r}:"attack"===o?{type:"attackController",target:r}:{type:"reserve",target:r}},engineer:function(e){var t,r;if(e.isEmpty&&(e.memory.working=0),e.isFull&&(e.memory.working=1),e.memory.working){const o=e.repairTargets.filter(e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_TOWER||e.structureType===STRUCTURE_STORAGE)&&e.hits<.5*e.hitsMax);if(o.length>0){const t=$t(e.creep,o,"engineer_critical",5);if(t)return{type:"repair",target:t}}const s=e.repairTargets.filter(e=>(e.structureType===STRUCTURE_ROAD||e.structureType===STRUCTURE_CONTAINER)&&e.hits<.75*e.hitsMax);if(s.length>0){const t=$t(e.creep,s,"engineer_infra",5);if(t)return{type:"repair",target:t}}const n=null!==(r=null===(t=e.swarmState)||void 0===t?void 0:t.danger)&&void 0!==r?r:0,i=0===n?1e5:1===n?3e5:2===n?5e6:5e7,a=e.repairTargets.filter(e=>e.structureType===STRUCTURE_RAMPART&&e.hits<i);if(a.length>0){const t=$t(e.creep,a,"engineer_rampart",5);if(t)return{type:"repair",target:t}}const c=e.repairTargets.filter(e=>e.structureType===STRUCTURE_WALL&&e.hits<i);if(c.length>0){const t=$t(e.creep,c,"engineer_wall",5);if(t)return{type:"repair",target:t}}return e.prioritizedSites.length>0?{type:"build",target:e.prioritizedSites[0]}:{type:"idle"}}if(e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>0)return{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY};if(e.containers.length>0){const t=$t(e.creep,e.containers,"engineer_cont",15);if(t)return{type:"withdraw",target:t,resourceType:RESOURCE_ENERGY}}return{type:"idle"}},remoteWorker:function(e){var t;const r=null!==(t=e.memory.targetRoom)&&void 0!==t?t:e.homeRoom;if(e.isEmpty&&(e.memory.working=0),e.isFull&&(e.memory.working=1),e.memory.working){if(e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};if(e.storage)return{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY};const t=e.spawnStructures.filter(e=>e.structureType===STRUCTURE_SPAWN);if(t.length>0){const r=$t(e.creep,t,"remoteWorker_spawn",5);if(r)return{type:"transfer",target:r,resourceType:RESOURCE_ENERGY}}return{type:"idle"}}if(e.room.name!==r)return{type:"moveToRoom",roomName:r};const o=e.creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE);return o?{type:"harvest",target:o}:{type:"idle"}},linkManager:function(e){const t=e.room.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LINK});if(2>t.length||!e.storage)return{type:"idle"};const r=t.find(t=>2>=t.pos.getRangeTo(e.storage));return r?r.store.getUsedCapacity(RESOURCE_ENERGY)>400?e.creep.store.getFreeCapacity()>0?{type:"withdraw",target:r,resourceType:RESOURCE_ENERGY}:{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY}:e.creep.pos.getRangeTo(e.storage)>2?{type:"moveTo",target:e.storage}:{type:"idle"}:{type:"idle"}},terminalManager:function(e){if(!e.terminal||!e.storage)return{type:"idle"};const t=e.terminal.store.getUsedCapacity(RESOURCE_ENERGY),r=e.storage.store.getUsedCapacity(RESOURCE_ENERGY);if(e.creep.store.getUsedCapacity()>0){const r=Object.keys(e.creep.store)[0];return r===RESOURCE_ENERGY?5e4>t?{type:"transfer",target:e.terminal,resourceType:RESOURCE_ENERGY}:{type:"transfer",target:e.storage,resourceType:RESOURCE_ENERGY}:{type:"transfer",target:e.terminal,resourceType:r}}if(4e4>t&&r>2e4)return{type:"withdraw",target:e.storage,resourceType:RESOURCE_ENERGY};if(t>6e4)return{type:"withdraw",target:e.terminal,resourceType:RESOURCE_ENERGY};for(const t of Object.keys(e.storage.store))if(t!==RESOURCE_ENERGY&&e.storage.store.getUsedCapacity(t)>5e3)return{type:"withdraw",target:e.storage,resourceType:t};return e.creep.pos.getRangeTo(e.storage)>2?{type:"moveTo",target:e.storage}:{type:"idle"}}};function fr(e){var t;return(null!==(t=gr[e.memory.role])&&void 0!==t?t:dr)(e)}function Rr(e,t){const r=e.effects;return void 0!==r&&Array.isArray(r)&&r.some(e=>e.effect===t)}function hr(e){const t=e.memory.targetRoom;if(!t)return{type:"idle"};if(e.room.name!==t)return{type:"moveToRoom",roomName:t};const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_BANK})[0];if(!r)return delete e.memory.targetRoom,{type:"moveToRoom",roomName:e.homeRoom};if(e.creep.hits<.5*e.creep.hitsMax){const r=e.room.find(FIND_MY_CREEPS,{filter:e=>"healer"===e.memory.role&&e.memory.targetRoom===t});if(r.length>0){const t=e.creep.pos.findClosestByRange(r);if(t&&e.creep.pos.getRangeTo(t)>1)return{type:"moveTo",target:t}}}return e.creep.attack(r)===ERR_NOT_IN_RANGE?{type:"moveTo",target:r}:{type:"idle"}}const yr={powerHarvester:hr,powerCarrier:function(e){const t=e.memory.targetRoom;if(e.creep.store.getUsedCapacity(RESOURCE_POWER)>0){if(e.room.name!==e.homeRoom)return{type:"moveToRoom",roomName:e.homeRoom};const t=Game.rooms[e.homeRoom];if(t){const r=t.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN})[0];if(r&&r.store.getFreeCapacity(RESOURCE_POWER)>0)return{type:"transfer",target:r,resourceType:RESOURCE_POWER};if(e.storage)return{type:"transfer",target:e.storage,resourceType:RESOURCE_POWER}}return{type:"idle"}}if(!t)return{type:"idle"};if(e.room.name!==t)return{type:"moveToRoom",roomName:t};const r=e.room.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_POWER})[0];if(r)return{type:"pickup",target:r};const o=e.room.find(FIND_RUINS,{filter:e=>e.store.getUsedCapacity(RESOURCE_POWER)>0})[0];if(o)return{type:"withdraw",target:o,resourceType:RESOURCE_POWER};const s=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_BANK})[0];return s?e.creep.pos.getRangeTo(s)>3?{type:"moveTo",target:s}:{type:"idle"}:(delete e.memory.targetRoom,{type:"moveToRoom",roomName:e.homeRoom})}};function Er(e){var t;return(null!==(t=yr[e.memory.role])&&void 0!==t?t:hr)(e)}function Tr(e,t){const r=e.memory.state;if(r&&(o=r)&&!(Game.time-o.startTick>o.timeout||o.targetId&&!Game.getObjectById(o.targetId)))if(function(e,t){if(!e)return 1;switch(e.action){case"harvest":case"harvestMineral":case"pickup":case"withdraw":return t.isFull||e.targetId&&!Game.getObjectById(e.targetId)?1:0;case"harvestDeposit":if(t.isFull)return 1;if(e.targetId){const t=Game.getObjectById(e.targetId);if(!t)return 1;if("object"==typeof t&&"cooldown"in t&&t.cooldown>100)return 1}return 0;case"transfer":case"build":return t.isEmpty||e.targetId&&!Game.getObjectById(e.targetId)?1:0;case"repair":if(t.isEmpty)return 1;if(e.targetId){const t=Game.getObjectById(e.targetId);if(!t)return 1;if("object"==typeof(r=t)&&null!==r&&"hits"in r&&"hitsMax"in r&&t.hits>=t.hitsMax)return 1}return 0;case"upgrade":return t.isEmpty;case"moveToRoom":return void 0!==e.targetRoom&&t.room.name===e.targetRoom;case"moveTo":if(e.targetId){const r=Game.getObjectById(e.targetId);if(r&&"object"==typeof r&&"pos"in r){const e=r;return t.creep.pos.inRangeTo(e.pos,1)}}return 0;case"idle":return 1;default:return 0}var r}(r,e))delete e.memory.state;else{const t=function(e){var t,r;let o=null;if(e.targetId){const t=Game.getObjectById(e.targetId);if(!t)return null;if("object"!=typeof t||!("pos"in t)||!("room"in t))return null;o=t}switch(e.action){case"harvest":return o?{type:"harvest",target:o}:null;case"harvestMineral":return o?{type:"harvestMineral",target:o}:null;case"harvestDeposit":return o?{type:"harvestDeposit",target:o}:null;case"pickup":return o?{type:"pickup",target:o}:null;case"withdraw":return o&&(null===(t=e.data)||void 0===t?void 0:t.resourceType)?{type:"withdraw",target:o,resourceType:e.data.resourceType}:null;case"transfer":return o&&(null===(r=e.data)||void 0===r?void 0:r.resourceType)?{type:"transfer",target:o,resourceType:e.data.resourceType}:null;case"build":return o?{type:"build",target:o}:null;case"repair":return o?{type:"repair",target:o}:null;case"upgrade":return o?{type:"upgrade",target:o}:null;case"moveTo":return o?{type:"moveTo",target:o}:null;case"moveToRoom":return e.targetRoom?{type:"moveToRoom",roomName:e.targetRoom}:null;case"idle":return{type:"idle"};default:return null}}(r);if(t)return t;delete e.memory.state}else delete e.memory.state;var o;const s=t(e);return"idle"!==s.type&&(e.memory.state=function(e){const t={action:e.type,startTick:Game.time,timeout:50};return"target"in e&&e.target&&"id"in e.target&&(t.targetId=e.target.id),"moveToRoom"===e.type&&(t.targetRoom=e.roomName),"withdraw"!==e.type&&"transfer"!==e.type||(t.data={resourceType:e.resourceType}),t}(s)),s}function Cr(e){const t=function(e){var t;if(!e.room)return null;const r=e.room,o=null!==(t=e.memory.homeRoom)&&void 0!==t?t:r.name,s=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB}),n=r.find(FIND_MY_SPAWNS),i=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_EXTENSION}),a=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_FACTORY})[0],c=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN})[0],u=[];for(const t of Object.keys(e.powers)){const r=e.powers[t];r&&0===r.cooldown&&u.push(t)}return{powerCreep:e,room:r,homeRoom:o,isInHomeRoom:r.name===o,storage:r.storage,terminal:r.terminal,factory:a,labs:s,spawns:n,extensions:i,powerSpawn:c,availablePowers:u,ops:e.store.getUsedCapacity(RESOURCE_OPS)}}(e);t&&function(e,t){var r;switch(t.type){case"usePower":(t.target?e.usePower(t.power,t.target):e.usePower(t.power))===ERR_NOT_IN_RANGE&&t.target&&Ot(e,t.target);break;case"moveTo":Ot(e,t.target);break;case"moveToRoom":_t(e,t.roomName);break;case"renewSelf":e.renew(t.spawn)===ERR_NOT_IN_RANGE&&Ot(e,t.spawn);break;case"enableRoom":(null===(r=e.room)||void 0===r?void 0:r.controller)&&e.enableRoom(e.room.controller)===ERR_NOT_IN_RANGE&&Ot(e,e.room.controller)}}(e,function(e){return"powerWarrior"===e.powerCreep.memory.role?function(e){if(void 0!==e.powerCreep.ticksToLive&&1e3>e.powerCreep.ticksToLive&&e.powerSpawn)return{type:"renewSelf",spawn:e.powerSpawn};const t=e.availablePowers,r=Ye(e.room,FIND_HOSTILE_CREEPS),o=Ye(e.room,FIND_HOSTILE_STRUCTURES);if(e.room.controller&&!e.room.controller.isPowerEnabled)return{type:"enableRoom"};if(t.includes(PWR_GENERATE_OPS)&&20>e.ops)return{type:"usePower",power:PWR_GENERATE_OPS};if(t.includes(PWR_SHIELD)&&e.ops>=10&&r.length>0){const t=e.room.find(FIND_MY_CREEPS,{filter:e=>"military"===e.memory.family&&e.hits<.7*e.hitsMax})[0];if(t)return{type:"usePower",power:PWR_SHIELD,target:t}}if(t.includes(PWR_DISRUPT_SPAWN)&&e.ops>=10){const t=Ye(e.room,FIND_HOSTILE_SPAWNS,{filter:e=>!Rr(e,PWR_DISRUPT_SPAWN)})[0];if(t)return{type:"usePower",power:PWR_DISRUPT_SPAWN,target:t}}if(t.includes(PWR_DISRUPT_TOWER)&&e.ops>=10){const t=Ye(e.room,FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER&&!Rr(e,PWR_DISRUPT_TOWER)})[0];if(t)return{type:"usePower",power:PWR_DISRUPT_TOWER,target:t}}if(t.includes(PWR_OPERATE_TOWER)&&e.ops>=10&&r.length>0){const t=e.room.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER&&!Rr(e,PWR_OPERATE_TOWER)})[0];if(t)return{type:"usePower",power:PWR_OPERATE_TOWER,target:t}}if(t.includes(PWR_FORTIFY)&&e.ops>=5&&r.length>0){const t=[...e.spawns,e.storage,e.terminal].filter(e=>void 0!==e);for(const r of t){if(!r)continue;const t=e.room.lookForAt(LOOK_STRUCTURES,r.pos).find(e=>e.structureType===STRUCTURE_RAMPART);if(t&&t.hits<.5*t.hitsMax)return{type:"usePower",power:PWR_FORTIFY,target:t}}const r=e.room.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_RAMPART&&5e5>e.hits})[0];if(r)return{type:"usePower",power:PWR_FORTIFY,target:r}}if(t.includes(PWR_DISRUPT_TERMINAL)&&e.ops>=50){const e=o.find(e=>e.structureType===STRUCTURE_TERMINAL&&!Rr(e,PWR_DISRUPT_TERMINAL));if(e)return{type:"usePower",power:PWR_DISRUPT_TERMINAL,target:e}}if(t.includes(PWR_GENERATE_OPS)&&100>e.ops)return{type:"usePower",power:PWR_GENERATE_OPS};if(!e.isInHomeRoom)return{type:"moveToRoom",roomName:e.homeRoom};if(r.length>0){const t=e.powerCreep.pos.findClosestByRange(r);if(t&&e.powerCreep.pos.getRangeTo(t)>5)return{type:"moveTo",target:t}}return{type:"idle"}}(e):function(e){if(void 0!==e.powerCreep.ticksToLive&&1e3>e.powerCreep.ticksToLive&&e.powerSpawn)return{type:"renewSelf",spawn:e.powerSpawn};const t=e.availablePowers;if(e.room.controller&&!e.room.controller.isPowerEnabled)return{type:"enableRoom"};if(t.includes(PWR_GENERATE_OPS)&&20>e.ops)return{type:"usePower",power:PWR_GENERATE_OPS};if(t.includes(PWR_OPERATE_SPAWN)&&e.ops>=100){const t=e.spawns.find(e=>{const t=e;return null!==t.spawning&&!Rr(t,PWR_OPERATE_SPAWN)});if(t)return{type:"usePower",power:PWR_OPERATE_SPAWN,target:t}}if(t.includes(PWR_OPERATE_EXTENSION)&&e.ops>=2&&e.extensions.reduce((e,t)=>e+t.store.getFreeCapacity(RESOURCE_ENERGY),0)>1e3&&e.storage&&e.storage.store.getUsedCapacity(RESOURCE_ENERGY)>1e4&&!Rr(e.storage,PWR_OPERATE_EXTENSION))return{type:"usePower",power:PWR_OPERATE_EXTENSION,target:e.storage};if(t.includes(PWR_OPERATE_TOWER)&&e.ops>=10&&e.room.find(FIND_HOSTILE_CREEPS).length>0){const t=e.room.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER&&!Rr(e,PWR_OPERATE_TOWER)});if(t.length>0)return{type:"usePower",power:PWR_OPERATE_TOWER,target:t[0]}}if(t.includes(PWR_OPERATE_LAB)&&e.ops>=10){const t=e.labs.find(e=>0===e.cooldown&&e.mineralType&&!Rr(e,PWR_OPERATE_LAB));if(t)return{type:"usePower",power:PWR_OPERATE_LAB,target:t}}if(t.includes(PWR_OPERATE_FACTORY)&&e.ops>=100&&e.factory&&0===e.factory.cooldown&&!Rr(e.factory,PWR_OPERATE_FACTORY))return{type:"usePower",power:PWR_OPERATE_FACTORY,target:e.factory};if(t.includes(PWR_OPERATE_STORAGE)&&e.ops>=100&&e.storage&&e.storage.store.getUsedCapacity()>.85*e.storage.store.getCapacity()&&!Rr(e.storage,PWR_OPERATE_STORAGE))return{type:"usePower",power:PWR_OPERATE_STORAGE,target:e.storage};if(t.includes(PWR_REGEN_SOURCE)&&e.ops>=100){const t=e.room.find(FIND_SOURCES,{filter:e=>0===e.energy&&e.ticksToRegeneration>100})[0];if(t)return{type:"usePower",power:PWR_REGEN_SOURCE,target:t}}return t.includes(PWR_GENERATE_OPS)&&100>e.ops?{type:"usePower",power:PWR_GENERATE_OPS}:e.isInHomeRoom?e.storage&&e.powerCreep.pos.getRangeTo(e.storage)>3?{type:"moveTo",target:e.storage}:{type:"idle"}:{type:"moveToRoom",roomName:e.homeRoom}}(e)}(t))}function vr(e){return null!==e&&"object"==typeof e&&"pos"in e&&e.pos instanceof RoomPosition&&"room"in e&&e.room instanceof Room}const Sr=new Set(["harvester","upgrader","mineralHarvester","depositHarvester","factoryWorker","labTech","builder"]),Ur={harvester:me.CRITICAL,queenCarrier:me.CRITICAL,hauler:me.HIGH,guard:me.HIGH,healer:me.HIGH,soldier:me.HIGH,ranger:me.HIGH,siegeUnit:me.HIGH,harasser:me.HIGH,powerQueen:me.HIGH,powerWarrior:me.HIGH,larvaWorker:me.HIGH,builder:me.MEDIUM,upgrader:me.MEDIUM,interRoomCarrier:me.MEDIUM,scout:me.MEDIUM,claimer:me.MEDIUM,engineer:me.MEDIUM,remoteHarvester:me.MEDIUM,powerHarvester:me.MEDIUM,powerCarrier:me.MEDIUM,remoteHauler:me.LOW,remoteWorker:me.LOW,linkManager:me.LOW,terminalManager:me.LOW,mineralHarvester:me.LOW,labTech:me.IDLE,factoryWorker:me.IDLE};function Or(e){var t;return null!==(t=Ur[e])&&void 0!==t?t:me.MEDIUM}const _r=new class{constructor(){this.registeredCreeps=new Set,this.lastSyncTick=-1}syncCreepProcesses(){if(this.lastSyncTick===Game.time)return;this.lastSyncTick=Game.time;const e=new Set;for(const t in Game.creeps){const r=Game.creeps[t];r.spawning||(e.add(t),this.registeredCreeps.has(t)||this.registerCreepProcess(r))}for(const t of this.registeredCreeps)e.has(t)||this.unregisterCreepProcess(t)}registerCreepProcess(e){const t=e.memory.role,r=Or(t),o="creep:"+e.name;ge.registerProcess({id:o,name:`Creep ${e.name} (${t})`,priority:r,frequency:"high",interval:1,minBucket:this.getMinBucketForPriority(r),cpuBudget:this.getCpuBudgetForPriority(r),execute:()=>{const t=Game.creeps[e.name];t&&!t.spawning&&function(e){if(function(e){const t=e.memory;if(!Sr.has(t.role))return 0;const r=t.state;if(!r||!r.startTick)return 0;if(2>Game.time-r.startTick)return 0;switch(t.role){case"harvester":return function(e,t){if("harvest"!==t.action&&"transfer"!==t.action)return 0;if(!t.targetId)return 0;const r=Game.getObjectById(t.targetId);if(!r||!vr(r))return 0;if(!e.pos.isNearTo(r.pos))return 0;if("harvest"===t.action){const t=e.store.getCapacity();if(null!==t&&t>0&&0===e.store.getFreeCapacity())return 0}return"transfer"===t.action&&40>e.store.getUsedCapacity(RESOURCE_ENERGY)?0:1}(e,r);case"upgrader":return function(e,t){if("upgrade"!==t.action&&"withdraw"!==t.action)return 0;if(!t.targetId)return 0;const r=Game.getObjectById(t.targetId);return r&&vr(r)&&e.pos.inRangeTo(r.pos,3)?"upgrade"===t.action&&0===e.store.getUsedCapacity(RESOURCE_ENERGY)||"withdraw"===t.action&&0===e.store.getFreeCapacity(RESOURCE_ENERGY)?0:1:0}(e,r);case"mineralHarvester":return function(e,t){if("harvestMineral"!==t.action)return 0;if(!t.targetId)return 0;const r=Game.getObjectById(t.targetId);return r&&vr(r)&&e.pos.isNearTo(r.pos)?0===e.store.getFreeCapacity()?0:1:0}(e,r);case"builder":return function(e,t){if("build"!==t.action)return 0;if(!t.targetId)return 0;const r=Game.getObjectById(t.targetId);return r&&vr(r)&&e.pos.inRangeTo(r.pos,3)?0===e.store.getUsedCapacity(RESOURCE_ENERGY)?0:1:0}(e,r);case"depositHarvester":case"factoryWorker":case"labTech":return 1;default:return 0}}(e))return void function(e){const t=e.memory.state;if(!t||!t.targetId)return 0;const r=Game.getObjectById(t.targetId);if(!r||!vr(r))return 0;switch(t.action){case"harvest":return"energy"in r&&"energyCapacity"in r&&"ticksToRegeneration"in r?e.harvest(r)===OK:0;case"harvestMineral":return"mineralType"in r&&"mineralAmount"in r&&"ticksToRegeneration"in r?e.harvest(r)===OK:0;case"transfer":return"store"in r&&r.store&&"object"==typeof r.store?e.transfer(r,RESOURCE_ENERGY)===OK:0;case"withdraw":return"store"in r&&r.store&&"object"==typeof r.store?e.withdraw(r,RESOURCE_ENERGY)===OK:0;case"upgrade":return"level"in r&&"progress"in r&&"my"in r?e.upgradeController(r)===OK:0;case"build":return"progressTotal"in r&&"progress"in r?e.build(r)===OK:0;case"repair":"hits"in r&&"hitsMax"in r&&(e.repair(r),OK)}}(e);const t=function(e){var t;return null!==(t=e.memory.family)&&void 0!==t?t:"economy"}(e),r=e.memory.role;be.measureSubsystem("role:"+r,()=>{switch(t){case"economy":default:!function(e){const t=Xe(e);kt(e,Tr(t,zt),t)}(e);break;case"military":!function(e){const t=Xe(e);kt(e,Tr(t,lr),t)}(e);break;case"utility":!function(e){const t=Xe(e);kt(e,Tr(t,fr),t)}(e);break;case"power":!function(e){const t=Xe(e);kt(e,Tr(t,Er),t)}(e)}})}(t)}}),this.registeredCreeps.add(e.name),Q.debug(`Registered creep process: ${e.name} (${t}) with priority ${r}`,{subsystem:"CreepProcessManager"})}unregisterCreepProcess(e){const t="creep:"+e;ge.unregisterProcess(t),this.registeredCreeps.delete(e),Q.debug("Unregistered creep process: "+e,{subsystem:"CreepProcessManager"})}getMinBucketForPriority(e){return e<me.CRITICAL?e<me.HIGH?e<me.MEDIUM?5e3:2e3:500:100}getCpuBudgetForPriority(e){return e<me.CRITICAL?e<me.HIGH?e<me.MEDIUM?.006:.008:.01:.012}getStats(){var e,t;const r={};for(const o of this.registeredCreeps){const s=Game.creeps[o];if(s){const o=Or(s.memory.role),n=null!==(e=me[o])&&void 0!==e?e:"UNKNOWN";r[n]=(null!==(t=r[n])&&void 0!==t?t:0)+1}}return{totalCreeps:Object.keys(Game.creeps).length,registeredCreeps:this.registeredCreeps.size,creepsByPriority:r}}forceResync(){this.lastSyncTick=-1,this.syncCreepProcesses()}reset(){this.registeredCreeps.clear(),this.lastSyncTick=-1}},Ar={updateInterval:5,decayFactors:{expand:.95,harvest:.9,build:.92,upgrade:.93,defense:.97,war:.98,siege:.99,logistics:.91,nukeTarget:.99},diffusionRates:{expand:.3,harvest:.1,build:.15,upgrade:.1,defense:.4,war:.5,siege:.6,logistics:.2,nukeTarget:.1},maxValue:100,minValue:0};class Mr{constructor(e=10){this.maxSamples=e,this.values=[],this.sum=0}add(e){if(this.values.push(e),this.sum+=e,this.values.length>this.maxSamples){const e=this.values.shift();this.sum-=null!=e?e:0}return this.get()}get(){return this.values.length>0?this.sum/this.values.length:0}reset(){this.values=[],this.sum=0}}const Nr=new class{constructor(e={}){this.trackers=new Map,this.config={...Ar,...e}}getTracker(e){let t=this.trackers.get(e);return t||(t={energyHarvested:new Mr(10),energySpawning:new Mr(10),energyConstruction:new Mr(10),energyRepair:new Mr(10),energyTower:new Mr(10),controllerProgress:new Mr(10),hostileCount:new Mr(5),damageReceived:new Mr(5),idleWorkers:new Mr(10),lastControllerProgress:0},this.trackers.set(e,t)),t}updateMetrics(e,t){var r;const o=this.getTracker(e.name),s="sources_"+e.name,n=global[s];let i;n&&n.tick===Game.time?i=n.sources:(i=e.find(FIND_SOURCES),global[s]={sources:i,tick:Game.time});let a=0,c=0;for(const e of i)a+=e.energyCapacity,c+=e.energy;const u=a-c;if(o.energyHarvested.add(u),null===(r=e.controller)||void 0===r?void 0:r.my){const t=e.controller.progress-o.lastControllerProgress;t>0&&1e5>t&&o.controllerProgress.add(t),o.lastControllerProgress=e.controller.progress}const l=Ye(e,FIND_HOSTILE_CREEPS);o.hostileCount.add(l.length);let m=0;for(const e of l)for(const t of e.body)t.hits>0&&(t.type===ATTACK?m+=30:t.type===RANGED_ATTACK&&(m+=10));o.damageReceived.add(m),t.metrics.energyHarvested=o.energyHarvested.get(),t.metrics.controllerProgress=o.controllerProgress.get(),t.metrics.hostileCount=Math.round(o.hostileCount.get()),t.metrics.damageReceived=o.damageReceived.get()}updatePheromones(e,t){if(Game.time<e.nextUpdateTick)return;const r=e.pheromones;for(const e of Object.keys(r)){const t=this.config.decayFactors[e];r[e]=this.clamp(r[e]*t)}this.calculateContributions(e,t),e.nextUpdateTick=Game.time+this.config.updateInterval,e.lastUpdate=Game.time}calculateContributions(e,t){var r;const o=e.pheromones,s=this.getTracker(t.name),n="sources_"+t.name,i=global[n];let a;if(i&&i.tick===Game.time?a=i.sources:(a=t.find(FIND_SOURCES),global[n]={sources:a,tick:Game.time}),a.length>0){const e=a.reduce((e,t)=>e+t.energy,0)/a.length;o.harvest=this.clamp(o.harvest+e/3e3*10)}const c=t.find(FIND_MY_CONSTRUCTION_SITES);if(c.length>0&&(o.build=this.clamp(o.build+Math.min(2*c.length,20))),null===(r=t.controller)||void 0===r?void 0:r.my){const e=t.controller.progress/t.controller.progressTotal;.5>e&&(o.upgrade=this.clamp(o.upgrade+15*(1-e)))}const u=s.hostileCount.get();if(u>0&&(o.defense=this.clamp(o.defense+10*u)),2>e.danger||(o.war=this.clamp(o.war+10*e.danger)),3>e.danger||(o.siege=this.clamp(o.siege+20)),t.storage){const e=t.find(FIND_MY_SPAWNS),r=e.reduce((e,t)=>e+t.store.getUsedCapacity(RESOURCE_ENERGY),0);150*e.length>r&&(o.logistics=this.clamp(o.logistics+10))}const l=s.energyHarvested.get()-e.metrics.energySpawning;l>0&&0===e.danger&&(o.expand=this.clamp(o.expand+Math.min(l/100,10)))}clamp(e){return Math.max(this.config.minValue,Math.min(this.config.maxValue,e))}onHostileDetected(e,t,r){e.danger=r,e.pheromones.defense=this.clamp(e.pheromones.defense+5*t),2>r||(e.pheromones.war=this.clamp(e.pheromones.war+10*r)),3>r||(e.pheromones.siege=this.clamp(e.pheromones.siege+20)),Q.info(`Hostile detected: ${t} hostiles, danger=${r}`,{room:e.role,subsystem:"Pheromone"})}onStructureDestroyed(e,t){e.pheromones.defense=this.clamp(e.pheromones.defense+5),e.pheromones.build=this.clamp(e.pheromones.build+10),t!==STRUCTURE_SPAWN&&t!==STRUCTURE_STORAGE&&t!==STRUCTURE_TOWER||(e.danger=Math.min(3,e.danger+1),e.pheromones.siege=this.clamp(e.pheromones.siege+15))}onNukeDetected(e){e.danger=3,e.pheromones.siege=this.clamp(e.pheromones.siege+50),e.pheromones.defense=this.clamp(e.pheromones.defense+30)}onRemoteSourceLost(e){e.pheromones.expand=this.clamp(e.pheromones.expand-10),e.pheromones.defense=this.clamp(e.pheromones.defense+5)}applyDiffusion(e){const t=[];for(const[r,o]of e){const s=this.getNeighborRoomNames(r);for(const n of s){if(!e.get(n))continue;const s=["defense","war","expand","siege"];for(const e of s){const s=o.pheromones[e];if(s>1){const o=this.config.diffusionRates[e];t.push({source:r,target:n,type:e,amount:s*o*.5,sourceIntensity:s})}}}}for(const r of t){const t=e.get(r.target);if(t){const e=t.pheromones[r.type]+r.amount;t.pheromones[r.type]=this.clamp(Math.min(e,r.sourceIntensity))}}}getNeighborRoomNames(e){const t=e.match(/^([WE])(\d+)([NS])(\d+)$/);if(!t)return[];const[,r,o,s,n]=t;if(!(r&&o&&s&&n))return[];const i=parseInt(o,10),a=parseInt(n,10),c=[];return"N"===s?c.push(`${r}${i}N${a+1}`):a>0?c.push(`${r}${i}S${a-1}`):c.push(`${r}${i}N0`),"S"===s?c.push(`${r}${i}S${a+1}`):a>0?c.push(`${r}${i}N${a-1}`):c.push(`${r}${i}S0`),"E"===r?c.push(`E${i+1}${s}${a}`):i>0?c.push(`W${i-1}${s}${a}`):c.push(`E0${s}${a}`),"W"===r?c.push(`W${i+1}${s}${a}`):i>0?c.push(`E${i-1}${s}${a}`):c.push(`W0${s}${a}`),c}getDominantPheromone(e){let t=null,r=1;for(const o of Object.keys(e))e[o]>r&&(r=e[o],t=o);return t}},br={seedNest:{rcl:1},foragingExpansion:{rcl:3,minRooms:1,minRemoteRooms:1,minTowerCount:1},matureColony:{rcl:4,requiresStorage:1,requiresTerminal:1,requiresLabs:1,minLabCount:3,minTowerCount:2},fortifiedHive:{rcl:7,requiresTerminal:1,requiresLabs:1,minLabCount:6,requiresFactory:1,requiresPowerSpawn:1,minTowerCount:4},empireDominance:{rcl:8,requiresNuker:1,requiresObserver:1,requiresTerminal:1,requiresLabs:1,minLabCount:8,requiresFactory:1,requiresPowerSpawn:1,minGcl:10,minRooms:3,minRemoteRooms:2,minTowerCount:6}},wr={eco:{economy:.75,military:.05,utility:.15,power:.05},expand:{economy:.55,military:.15,utility:.25,power:.05},defensive:{economy:.45,military:.35,utility:.15,power:.05},war:{economy:.3,military:.5,utility:.1,power:.1},siege:{economy:.2,military:.6,utility:.1,power:.1},evacuate:{economy:.1,military:.1,utility:.8,power:0},nukePrep:{economy:.4,military:.3,utility:.2,power:.1}},Ir={eco:{upgrade:80,build:60,repair:40,spawn:70,terminal:50,labs:30},expand:{upgrade:60,build:80,repair:50,spawn:75,terminal:60,labs:40},defensive:{upgrade:30,build:50,repair:80,spawn:90,terminal:40,labs:60},war:{upgrade:10,build:30,repair:70,spawn:95,terminal:70,labs:80},siege:{upgrade:5,build:20,repair:90,spawn:100,terminal:50,labs:90},evacuate:{upgrade:0,build:5,repair:10,spawn:50,terminal:80,labs:10},nukePrep:{upgrade:20,build:40,repair:95,spawn:80,terminal:30,labs:70}},xr=new class{constructor(){this.structureCountsCache=new Map,this.structureCacheTtl=20}determineEvolutionStage(e,t,r){var o,s,n,i;const a=null!==(s=null===(o=t.controller)||void 0===o?void 0:o.level)&&void 0!==s?s:0,c=Game.gcl.level,u=this.getStructureCounts(t),l=null!==(i=null===(n=e.remoteAssignments)||void 0===n?void 0:n.length)&&void 0!==i?i:0;return this.meetsThreshold("empireDominance",a,r,c,u,l)?"empireDominance":this.meetsThreshold("fortifiedHive",a,r,c,u,l)?"fortifiedHive":this.meetsThreshold("matureColony",a,r,c,u,l)?"matureColony":this.meetsThreshold("foragingExpansion",a,r,c,u,l)?"foragingExpansion":"seedNest"}meetsThreshold(e,t,r,o,s,n){var i,a;const c=br[e],u=null!==(i=s[STRUCTURE_TOWER])&&void 0!==i?i:0,l=null!==(a=s[STRUCTURE_LAB])&&void 0!==a?a:0;return t<c.rcl||c.minRooms&&r<c.minRooms||c.minGcl&&o<c.minGcl||c.minRemoteRooms&&n<c.minRemoteRooms||c.minTowerCount&&u<c.minTowerCount||c.requiresStorage&&!s[STRUCTURE_STORAGE]?0:!c.requiresTerminal||6>t||s[STRUCTURE_TERMINAL]?c.requiresLabs&&0===l||c.minLabCount&&t>=6&&l<c.minLabCount||c.requiresFactory&&t>=7&&!s[STRUCTURE_FACTORY]||c.requiresPowerSpawn&&t>=7&&!s[STRUCTURE_POWER_SPAWN]||c.requiresObserver&&t>=8&&!s[STRUCTURE_OBSERVER]||c.requiresNuker&&t>=8&&!s[STRUCTURE_NUKER]?0:1:0}getStructureCounts(e){var t;const r=this.structureCountsCache.get(e.name);if(r&&Game.time-r.tick<=this.structureCacheTtl)return r.counts;const o={},s=e.find(FIND_MY_STRUCTURES);for(const e of s){const r=e.structureType;o[r]=(null!==(t=o[r])&&void 0!==t?t:0)+1}return this.structureCountsCache.set(e.name,{counts:o,tick:Game.time}),o}updateEvolutionStage(e,t,r){const o=this.determineEvolutionStage(e,t,r);return o!==e.colonyLevel?(Q.info(`Room evolution: ${e.colonyLevel} -> ${o}`,{room:t.name,subsystem:"Evolution"}),e.colonyLevel=o,1):0}updateMissingStructures(e,t){var r,o,s,n,i,a,c,u,l,m,p,d;const g=this.getStructureCounts(t),f=null!==(o=null===(r=t.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0,R=br[e.colonyLevel],h=R.requiresLabs&&f>=6,y=h?null!==(s=R.minLabCount)&&void 0!==s?s:3:0,E=R.requiresFactory&&f>=7,T=R.requiresTerminal&&f>=6,C=R.requiresStorage&&f>=4,v=R.requiresPowerSpawn&&f>=7,S=R.requiresObserver&&f>=8,U=R.requiresNuker&&f>=8;e.missingStructures={spawn:0===(null!==(n=g[STRUCTURE_SPAWN])&&void 0!==n?n:0),storage:C?0===(null!==(i=g[STRUCTURE_STORAGE])&&void 0!==i?i:0):0,terminal:T?0===(null!==(a=g[STRUCTURE_TERMINAL])&&void 0!==a?a:0):0,labs:h?(null!==(c=g[STRUCTURE_LAB])&&void 0!==c?c:0)<y:0,nuker:U?0===(null!==(u=g[STRUCTURE_NUKER])&&void 0!==u?u:0):0,factory:E?0===(null!==(l=g[STRUCTURE_FACTORY])&&void 0!==l?l:0):0,extractor:6>f?0:0===(null!==(m=g[STRUCTURE_EXTRACTOR])&&void 0!==m?m:0),powerSpawn:v?0===(null!==(p=g[STRUCTURE_POWER_SPAWN])&&void 0!==p?p:0):0,observer:S?0===(null!==(d=g[STRUCTURE_OBSERVER])&&void 0!==d?d:0):0}}},Gr=new class{determinePosture(e,t){if(t)return t;const{pheromones:r,danger:o}=e;return 3>o?2>o?r.siege>30?"siege":r.war>25?"war":r.defense>20?"defensive":r.nukeTarget>40?"nukePrep":r.expand>30&&0===o?"expand":1>o?"eco":"defensive":"war":"siege"}updatePosture(e,t,r){const o=this.determinePosture(e,t);if(o!==e.posture){const t=e.posture,s=null!=r?r:e.role;return Q.info(`Posture change: ${t} -> ${o}`,{room:s,subsystem:"Posture"}),e.posture=o,ge.emit("posture.change",{roomName:s,oldPosture:t,newPosture:o,source:"PostureManager"}),1}return 0}getSpawnProfile(e){return wr[e]}getResourcePriorities(e){return Ir[e]}allowsBuilding(e){return"evacuate"!==e&&"siege"!==e}allowsUpgrading(e){return"evacuate"!==e&&"siege"!==e&&"war"!==e}isCombatPosture(e){return"defensive"===e||"war"===e||"siege"===e}allowsExpansion(e){return"eco"===e||"expand"===e}},Pr={enabled:1,smoothingFactor:.1,trackNativeCalls:1,logInterval:100,segmentUpdateInterval:10,segmentId:90,maxHistoryPoints:1e3},kr=new class{constructor(e={}){this.subsystemMeasurements=new Map,this.roomMeasurements=new Map,this.lastSegmentUpdate=0,this.segmentRequested=0,this.config={...Pr,...e},this.currentSnapshot=this.createEmptySnapshot(),this.nativeCallsThisTick=this.createEmptyNativeCalls()}initialize(){RawMemory.setActiveSegments([this.config.segmentId]),this.segmentRequested=1,Q.info("Unified stats system initialized",{subsystem:"Stats"})}startTick(){this.config.enabled&&(this.currentSnapshot=this.createEmptySnapshot(),this.nativeCallsThisTick=this.createEmptyNativeCalls(),this.subsystemMeasurements.clear(),this.roomMeasurements.clear())}finalizeTick(){var e,t,r,o,s,n;this.config.enabled&&(this.currentSnapshot.cpu={used:Game.cpu.getUsed(),limit:Game.cpu.limit,bucket:Game.cpu.bucket,percent:Game.cpu.limit>0?Game.cpu.getUsed()/Game.cpu.limit*100:0,heapUsed:(null!==(o=null===(r=null===(t=(e=Game.cpu).getHeapStatistics)||void 0===t?void 0:t.call(e))||void 0===r?void 0:r.used_heap_size)&&void 0!==o?o:0)/1024/1024},this.currentSnapshot.progression={gcl:{level:Game.gcl.level,progress:Game.gcl.progress,progressTotal:Game.gcl.progressTotal,progressPercent:Game.gcl.progressTotal>0?Game.gcl.progress/Game.gcl.progressTotal*100:0},gpl:{level:null!==(n=null===(s=Game.gpl)||void 0===s?void 0:s.level)&&void 0!==n?n:0}},this.finalizeEmpireStats(),this.finalizeSubsystemStats(),this.currentSnapshot.native={...this.nativeCallsThisTick},this.currentSnapshot.tick=Game.time,this.currentSnapshot.timestamp=Date.now(),this.publishToMemory(),Game.time-this.lastSegmentUpdate<this.config.segmentUpdateInterval||(this.updateSegment(),this.lastSegmentUpdate=Game.time),this.config.logInterval>0&&Game.time%this.config.logInterval===0&&this.logSummary())}startRoom(e){return this.config.enabled?Game.cpu.getUsed():0}endRoom(e,t){if(!this.config.enabled)return;const r=Game.cpu.getUsed()-t;this.roomMeasurements.set(e,r)}measureSubsystem(e,t){var r;if(!this.config.enabled)return t();const o=Game.cpu.getUsed(),s=t(),n=Game.cpu.getUsed()-o,i=null!==(r=this.subsystemMeasurements.get(e))&&void 0!==r?r:[];return i.push(n),this.subsystemMeasurements.set(e,i),s}recordNativeCall(e){this.config.enabled&&this.config.trackNativeCalls&&(this.nativeCallsThisTick[e]++,this.nativeCallsThisTick.total++)}recordRoom(e,t){var r,o,s,n,i,a,c,u,l,m,p,d,g;if(!this.config.enabled)return;const f=Ce.getSwarmState(e.name),R=Object.values(Game.creeps).filter(t=>t.room.name===e.name).length,h=e.find(FIND_HOSTILE_CREEPS);let y=this.currentSnapshot.rooms[e.name];if(y||(y={name:e.name,rcl:null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0,energy:{available:e.energyAvailable,capacity:e.energyCapacityAvailable,storage:null!==(n=null===(s=e.storage)||void 0===s?void 0:s.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==n?n:0,terminal:null!==(a=null===(i=e.terminal)||void 0===i?void 0:i.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==a?a:0},controller:{progress:null!==(u=null===(c=e.controller)||void 0===c?void 0:c.progress)&&void 0!==u?u:0,progressTotal:null!==(m=null===(l=e.controller)||void 0===l?void 0:l.progressTotal)&&void 0!==m?m:1,progressPercent:0},creeps:R,hostiles:h.length,brain:{danger:null!==(p=null==f?void 0:f.danger)&&void 0!==p?p:0,postureCode:this.postureToCode(null!==(d=null==f?void 0:f.posture)&&void 0!==d?d:"eco"),colonyLevelCode:this.colonyLevelToCode(null!==(g=null==f?void 0:f.colonyLevel)&&void 0!==g?g:"seedNest")},pheromones:{},metrics:{energyHarvested:0,energySpawning:0,energyConstruction:0,energyRepair:0,energyTower:0,energyAvailableForSharing:0,energyCapacityTotal:0,energyNeed:0,controllerProgress:0,hostileCount:h.length,damageReceived:0,constructionSites:0},profiler:{avgCpu:t,peakCpu:t,samples:1}},this.currentSnapshot.rooms[e.name]=y),y.controller.progressPercent=y.controller.progressTotal>0?y.controller.progress/y.controller.progressTotal*100:0,f){for(const[e,t]of Object.entries(f.pheromones))y.pheromones[e]=t;y.metrics={energyHarvested:f.metrics.energyHarvested,energySpawning:f.metrics.energySpawning,energyConstruction:f.metrics.energyConstruction,energyRepair:f.metrics.energyRepair,energyTower:f.metrics.energyTower,energyAvailableForSharing:f.metrics.energyAvailable,energyCapacityTotal:f.metrics.energyCapacity,energyNeed:f.metrics.energyNeed,controllerProgress:f.metrics.controllerProgress,hostileCount:f.metrics.hostileCount,damageReceived:f.metrics.damageReceived,constructionSites:f.metrics.constructionSites}}const E=this.getProfilerMemory().rooms[e.name];E&&(y.profiler.avgCpu=E.avgCpu*(1-this.config.smoothingFactor)+t*this.config.smoothingFactor,y.profiler.peakCpu=Math.max(E.peakCpu,t),y.profiler.samples=E.samples+1),this.getProfilerMemory().rooms[e.name]={avgCpu:y.profiler.avgCpu,peakCpu:y.profiler.peakCpu,samples:y.profiler.samples,lastTick:Game.time}}createEmptySnapshot(){return{tick:Game.time,timestamp:Date.now(),cpu:{used:0,limit:0,bucket:0,percent:0,heapUsed:0},progression:{gcl:{level:0,progress:0,progressTotal:1,progressPercent:0},gpl:{level:0}},empire:{rooms:0,creeps:0,energy:{storage:0,terminal:0,available:0,capacity:0},credits:0},rooms:{},subsystems:{},roles:{},native:this.createEmptyNativeCalls()}}createEmptyNativeCalls(){return{pathfinderSearch:0,moveTo:0,move:0,harvest:0,transfer:0,withdraw:0,build:0,repair:0,upgradeController:0,attack:0,rangedAttack:0,heal:0,dismantle:0,say:0,total:0}}finalizeEmpireStats(){const e=Object.values(this.currentSnapshot.rooms),t=Object.keys(Game.creeps).length;this.currentSnapshot.empire={rooms:e.length,creeps:t,energy:{storage:e.reduce((e,t)=>e+t.energy.storage,0),terminal:e.reduce((e,t)=>e+t.energy.terminal,0),available:e.reduce((e,t)=>e+t.energy.available,0),capacity:e.reduce((e,t)=>e+t.energy.capacity,0)},credits:Game.market.credits}}finalizeSubsystemStats(){var e,t,r;const o=this.getProfilerMemory();for(const[s,n]of this.subsystemMeasurements){const i=n.reduce((e,t)=>e+t,0),a=s.startsWith("role:"),c=a?s.substring(5):s;if(a){const r=Object.values(Game.creeps).filter(e=>e.memory.role===c).length,s=null===(e=o.roles)||void 0===e?void 0:e[c],a=s?s.avgCpu*(1-this.config.smoothingFactor)+i*this.config.smoothingFactor:i,u=s?Math.max(s.peakCpu,i):i;this.currentSnapshot.roles[c]={name:c,count:r,avgCpu:a,peakCpu:u,calls:n.length,samples:(null!==(t=null==s?void 0:s.samples)&&void 0!==t?t:0)+1},o.roles||(o.roles={}),o.roles[c]={avgCpu:a,peakCpu:u,samples:this.currentSnapshot.roles[c].samples,callsThisTick:n.length}}else{const e=o.subsystems[c],t=e?e.avgCpu*(1-this.config.smoothingFactor)+i*this.config.smoothingFactor:i,s=e?Math.max(e.peakCpu,i):i;this.currentSnapshot.subsystems[c]={name:c,avgCpu:t,peakCpu:s,calls:n.length,samples:(null!==(r=null==e?void 0:e.samples)&&void 0!==r?r:0)+1},o.subsystems[c]={avgCpu:t,peakCpu:s,samples:this.currentSnapshot.subsystems[c].samples,callsThisTick:n.length}}}}publishToMemory(){const e=Memory,t=this.currentSnapshot;e.stats={tick:t.tick,timestamp:t.timestamp,cpu:{used:t.cpu.used,limit:t.cpu.limit,bucket:t.cpu.bucket,percent:t.cpu.percent,heap_mb:t.cpu.heapUsed},gcl:{level:t.progression.gcl.level,progress:t.progression.gcl.progress,progress_total:t.progression.gcl.progressTotal,progress_percent:t.progression.gcl.progressPercent},gpl:{level:t.progression.gpl.level},empire:{rooms:t.empire.rooms,creeps:t.empire.creeps,energy:{storage:t.empire.energy.storage,terminal:t.empire.energy.terminal,available:t.empire.energy.available,capacity:t.empire.energy.capacity},credits:t.empire.credits},rooms:{},subsystems:{},roles:{},native:{pathfinder_search:t.native.pathfinderSearch,move_to:t.native.moveTo,move:t.native.move,harvest:t.native.harvest,transfer:t.native.transfer,withdraw:t.native.withdraw,build:t.native.build,repair:t.native.repair,upgrade_controller:t.native.upgradeController,attack:t.native.attack,ranged_attack:t.native.rangedAttack,heal:t.native.heal,dismantle:t.native.dismantle,say:t.native.say,total:t.native.total}};for(const[r,o]of Object.entries(t.rooms))e.stats.rooms[r]={rcl:o.rcl,energy:{available:o.energy.available,capacity:o.energy.capacity,storage:o.energy.storage,terminal:o.energy.terminal},controller:{progress:o.controller.progress,progress_total:o.controller.progressTotal,progress_percent:o.controller.progressPercent},creeps:o.creeps,hostiles:o.hostiles,brain:{danger:o.brain.danger,posture_code:o.brain.postureCode,colony_level_code:o.brain.colonyLevelCode},pheromones:{...o.pheromones},metrics:{energy:{harvested:o.metrics.energyHarvested,spawning:o.metrics.energySpawning,construction:o.metrics.energyConstruction,repair:o.metrics.energyRepair,tower:o.metrics.energyTower,available_for_sharing:o.metrics.energyAvailableForSharing,capacity_total:o.metrics.energyCapacityTotal,need:o.metrics.energyNeed},controller_progress:o.metrics.controllerProgress,hostile_count:o.metrics.hostileCount,damage_received:o.metrics.damageReceived,construction_sites:o.metrics.constructionSites},profiler:{avg_cpu:o.profiler.avgCpu,peak_cpu:o.profiler.peakCpu,samples:o.profiler.samples}};for(const[r,o]of Object.entries(t.subsystems))e.stats.subsystems[r]={avg_cpu:o.avgCpu,peak_cpu:o.peakCpu,calls:o.calls,samples:o.samples};for(const[r,o]of Object.entries(t.roles))e.stats.roles[r]={count:o.count,avg_cpu:o.avgCpu,peak_cpu:o.peakCpu,calls:o.calls,samples:o.samples}}updateSegment(){}getProfilerMemory(){const e=Memory;return e.stats&&"object"==typeof e.stats||(e.stats={}),e.stats.profiler||(e.stats.profiler={rooms:{},subsystems:{},roles:{},tickCount:0,lastUpdate:0}),e.stats.profiler}logSummary(){const e=this.currentSnapshot;Q.info("=== Unified Stats Summary ==="),Q.info(`CPU: ${e.cpu.used.toFixed(2)}/${e.cpu.limit} (${e.cpu.percent.toFixed(1)}%) | Bucket: ${e.cpu.bucket}`),Q.info(`Empire: ${e.empire.rooms} rooms, ${e.empire.creeps} creeps, ${e.empire.credits} credits`);const t=Object.values(e.subsystems).sort((e,t)=>t.avgCpu-e.avgCpu).slice(0,5);if(t.length>0){Q.info("Top Subsystems:");for(const e of t)Q.info(`  ${e.name}: ${e.avgCpu.toFixed(3)} CPU`)}const r=Object.values(e.roles).sort((e,t)=>t.avgCpu-e.avgCpu).slice(0,5);if(r.length>0){Q.info("Top Roles:");for(const e of r)Q.info(`  ${e.name}: ${e.count} creeps, ${e.avgCpu.toFixed(3)} CPU`)}this.config.trackNativeCalls&&Q.info(`Native calls: ${e.native.total} total`)}postureToCode(e){var t;return null!==(t={eco:0,expand:1,defensive:2,war:3,siege:4,evacuate:5,nukePrep:6}[e])&&void 0!==t?t:-1}colonyLevelToCode(e){var t;return null!==(t={seedNest:1,foragingExpansion:2,matureColony:3,fortifiedHive:4,empireDominance:5}[e])&&void 0!==t?t:0}getSnapshot(){return this.currentSnapshot}setEnabled(e){this.config.enabled=e}isEnabled(){return this.config.enabled}reset(){var e;this.currentSnapshot=this.createEmptySnapshot();const t=Memory;(null===(e=t.stats)||void 0===e?void 0:e.profiler)&&(t.stats.profiler={rooms:{},subsystems:{},roles:{},tickCount:0,lastUpdate:0})}},Lr={recalculateInterval:1e3,maxPathOps:2e3,includeRemoteRoads:1},Dr=new Map;function $r(e,t,r={}){var o,s,n;const i={...Lr,...r},a=Dr.get(e.name);if(a&&Game.time-a.lastCalculated<i.recalculateInterval)return a;const c=new Set,u=null!==(s=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==s?s:0,l=e.find(FIND_SOURCES),m=e.controller,p=e.storage,d=e.find(FIND_MINERALS)[0],g=null!==(n=null==p?void 0:p.pos)&&void 0!==n?n:t;for(const t of l){const r=Kr(g,t.pos,e.name,i.maxPathOps);for(const e of r)c.add(`${e.x},${e.y}`)}if(m){const t=Kr(g,m.pos,e.name,i.maxPathOps);for(const e of t)c.add(`${e.x},${e.y}`)}if(d&&u>=6){const t=Kr(g,d.pos,e.name,i.maxPathOps);for(const e of t)c.add(`${e.x},${e.y}`)}if(!p){for(const r of l){const o=Kr(t,r.pos,e.name,i.maxPathOps);for(const e of o)c.add(`${e.x},${e.y}`)}if(m){const r=Kr(t,m.pos,e.name,i.maxPathOps);for(const e of r)c.add(`${e.x},${e.y}`)}}const f={roomName:e.name,positions:c,lastCalculated:Game.time};return Dr.set(e.name,f),Q.debug(`Calculated road network for ${e.name}: ${c.size} positions`,{subsystem:"RoadNetwork"}),f}function Yr(e,t,r={}){var o,s;const n={...Lr,...r},i=new Map;if(!n.includeRemoteRoads)return i;const a=e.storage,c=e.find(FIND_MY_SPAWNS)[0],u=null!==(o=null==a?void 0:a.pos)&&void 0!==o?o:null==c?void 0:c.pos;if(!u)return i;for(const e of t){const t=new RoomPosition(25,25,e);try{const e=PathFinder.search(u,{pos:t,range:20},{plainCost:2,swampCost:10,maxOps:n.maxPathOps,roomCallback:e=>Hr(e)});if(!e.incomplete)for(const t of e.path)i.has(t.roomName)||i.set(t.roomName,new Set),null===(s=i.get(t.roomName))||void 0===s||s.add(`${t.x},${t.y}`)}catch(t){const r=t instanceof Error?t.message:t+"";Q.warn(`Failed to calculate remote road to ${e}: ${r}`,{subsystem:"RoadNetwork"})}}return i}function Kr(e,t,r,o){const s=[],n=PathFinder.search(e,{pos:t,range:1},{plainCost:2,swampCost:10,maxOps:o,roomCallback:e=>e!==r?0:Hr(e)});if(!n.incomplete)for(const e of n.path)e.roomName===r&&s.push({x:e.x,y:e.y});return s}function Hr(e){const t=Game.rooms[e],r=new PathFinder.CostMatrix;if(!t)return r;const o=t.find(FIND_STRUCTURES);for(const e of o)e.structureType===STRUCTURE_ROAD?r.set(e.pos.x,e.pos.y,1):e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_RAMPART&&"my"in e&&e.my||r.set(e.pos.x,e.pos.y,255);const s=t.find(FIND_MY_CONSTRUCTION_SITES);for(const e of s)e.structureType===STRUCTURE_ROAD?r.set(e.pos.x,e.pos.y,1):e.structureType!==STRUCTURE_CONTAINER&&r.set(e.pos.x,e.pos.y,255);return r}function Fr(e,t,r,o=[]){const s=new Set,n=e.getTerrain();for(const e of r){const r=t.x+e.x,o=t.y+e.y;1>r||r>48||1>o||o>48||n.get(r,o)===TERRAIN_MASK_WALL||s.add(`${r},${o}`)}const i=$r(e,t);for(const e of i.positions)s.add(e);if(o.length>0){const t=Yr(e,o).get(e.name);if(t)for(const e of t)s.add(e)}return s}const Wr={name:"seedNest",rcl:1,type:"spread",minSpaceRadius:3,anchor:{x:25,y:25},structures:[{x:0,y:0,structureType:STRUCTURE_SPAWN},{x:-2,y:0,structureType:STRUCTURE_EXTENSION},{x:2,y:0,structureType:STRUCTURE_EXTENSION},{x:0,y:-2,structureType:STRUCTURE_EXTENSION},{x:0,y:2,structureType:STRUCTURE_EXTENSION},{x:-2,y:-2,structureType:STRUCTURE_EXTENSION}],roads:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1}],ramparts:[]},Br={name:"foragingExpansion",rcl:3,type:"spread",minSpaceRadius:4,anchor:{x:25,y:25},structures:[{x:0,y:0,structureType:STRUCTURE_SPAWN},{x:0,y:-4,structureType:STRUCTURE_TOWER},{x:-2,y:0,structureType:STRUCTURE_EXTENSION},{x:2,y:0,structureType:STRUCTURE_EXTENSION},{x:0,y:-2,structureType:STRUCTURE_EXTENSION},{x:0,y:2,structureType:STRUCTURE_EXTENSION},{x:-2,y:-2,structureType:STRUCTURE_EXTENSION},{x:2,y:-2,structureType:STRUCTURE_EXTENSION},{x:-2,y:2,structureType:STRUCTURE_EXTENSION},{x:2,y:2,structureType:STRUCTURE_EXTENSION},{x:-4,y:0,structureType:STRUCTURE_EXTENSION},{x:4,y:0,structureType:STRUCTURE_EXTENSION},{x:0,y:4,structureType:STRUCTURE_EXTENSION},{x:-1,y:-3,structureType:STRUCTURE_EXTENSION},{x:1,y:-3,structureType:STRUCTURE_EXTENSION},{x:-3,y:-1,structureType:STRUCTURE_EXTENSION},{x:3,y:-1,structureType:STRUCTURE_EXTENSION},{x:-3,y:1,structureType:STRUCTURE_EXTENSION},{x:3,y:1,structureType:STRUCTURE_EXTENSION},{x:-1,y:3,structureType:STRUCTURE_EXTENSION},{x:1,y:3,structureType:STRUCTURE_EXTENSION},{x:-3,y:-3,structureType:STRUCTURE_EXTENSION}],roads:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1},{x:-2,y:-1},{x:2,y:-1},{x:-2,y:1},{x:2,y:1},{x:-1,y:-2},{x:1,y:-2},{x:-1,y:2},{x:1,y:2},{x:0,y:-3},{x:0,y:3},{x:-3,y:0},{x:3,y:0}],ramparts:[]},Vr={name:"matureColony",rcl:5,type:"spread",minSpaceRadius:6,anchor:{x:25,y:25},structures:[{x:0,y:0,structureType:STRUCTURE_SPAWN},{x:4,y:0,structureType:STRUCTURE_SPAWN},{x:0,y:4,structureType:STRUCTURE_STORAGE},{x:2,y:4,structureType:STRUCTURE_TERMINAL},{x:0,y:-4,structureType:STRUCTURE_TOWER},{x:-4,y:0,structureType:STRUCTURE_TOWER},{x:4,y:-4,structureType:STRUCTURE_TOWER},{x:-2,y:0,structureType:STRUCTURE_EXTENSION},{x:2,y:0,structureType:STRUCTURE_EXTENSION},{x:0,y:-2,structureType:STRUCTURE_EXTENSION},{x:0,y:2,structureType:STRUCTURE_EXTENSION},{x:-2,y:-2,structureType:STRUCTURE_EXTENSION},{x:2,y:-2,structureType:STRUCTURE_EXTENSION},{x:-2,y:2,structureType:STRUCTURE_EXTENSION},{x:2,y:2,structureType:STRUCTURE_EXTENSION},{x:-1,y:-3,structureType:STRUCTURE_EXTENSION},{x:1,y:-3,structureType:STRUCTURE_EXTENSION},{x:-3,y:-1,structureType:STRUCTURE_EXTENSION},{x:3,y:-1,structureType:STRUCTURE_EXTENSION},{x:-3,y:1,structureType:STRUCTURE_EXTENSION},{x:3,y:1,structureType:STRUCTURE_EXTENSION},{x:-1,y:3,structureType:STRUCTURE_EXTENSION},{x:1,y:3,structureType:STRUCTURE_EXTENSION},{x:-4,y:-2,structureType:STRUCTURE_EXTENSION},{x:-4,y:2,structureType:STRUCTURE_EXTENSION},{x:-2,y:-4,structureType:STRUCTURE_EXTENSION},{x:2,y:-4,structureType:STRUCTURE_EXTENSION},{x:-3,y:-3,structureType:STRUCTURE_EXTENSION},{x:3,y:-3,structureType:STRUCTURE_EXTENSION},{x:-3,y:3,structureType:STRUCTURE_EXTENSION},{x:-6,y:0,structureType:STRUCTURE_EXTENSION},{x:-6,y:-2,structureType:STRUCTURE_EXTENSION},{x:6,y:-2,structureType:STRUCTURE_EXTENSION},{x:6,y:2,structureType:STRUCTURE_EXTENSION},{x:-4,y:-4,structureType:STRUCTURE_EXTENSION},{x:4,y:2,structureType:STRUCTURE_EXTENSION},{x:6,y:0,structureType:STRUCTURE_EXTENSION},{x:-3,y:5,structureType:STRUCTURE_LAB},{x:-4,y:4,structureType:STRUCTURE_LAB},{x:-5,y:5,structureType:STRUCTURE_LAB},{x:-2,y:4,structureType:STRUCTURE_LINK}],roads:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1},{x:3,y:-1},{x:3,y:0},{x:3,y:1},{x:4,y:-1},{x:4,y:1},{x:5,y:-1},{x:5,y:0},{x:5,y:1},{x:-2,y:-1},{x:2,y:-1},{x:-2,y:1},{x:2,y:1},{x:-1,y:-2},{x:1,y:-2},{x:-1,y:2},{x:1,y:2},{x:0,y:-3},{x:0,y:3},{x:-3,y:0},{x:3,y:0}],ramparts:[{x:0,y:0},{x:4,y:0},{x:0,y:4},{x:1,y:4}]},qr={name:"fortifiedHive",rcl:7,type:"spread",minSpaceRadius:7,anchor:{x:25,y:25},structures:[{x:0,y:0,structureType:STRUCTURE_SPAWN},{x:-5,y:-1,structureType:STRUCTURE_SPAWN},{x:5,y:-1,structureType:STRUCTURE_SPAWN},{x:0,y:4,structureType:STRUCTURE_STORAGE},{x:2,y:4,structureType:STRUCTURE_TERMINAL},{x:0,y:-4,structureType:STRUCTURE_TOWER},{x:-4,y:-2,structureType:STRUCTURE_TOWER},{x:4,y:-2,structureType:STRUCTURE_TOWER},{x:-4,y:2,structureType:STRUCTURE_TOWER},{x:4,y:2,structureType:STRUCTURE_TOWER},{x:0,y:6,structureType:STRUCTURE_TOWER},{x:-2,y:4,structureType:STRUCTURE_FACTORY},{x:-4,y:4,structureType:STRUCTURE_LAB},{x:-3,y:5,structureType:STRUCTURE_LAB},{x:-4,y:6,structureType:STRUCTURE_LAB},{x:-5,y:5,structureType:STRUCTURE_LAB},{x:-6,y:4,structureType:STRUCTURE_LAB},{x:-6,y:6,structureType:STRUCTURE_LAB},{x:-2,y:6,structureType:STRUCTURE_LAB},{x:-5,y:3,structureType:STRUCTURE_LAB},{x:-7,y:5,structureType:STRUCTURE_LAB},{x:-3,y:7,structureType:STRUCTURE_LAB},{x:4,y:4,structureType:STRUCTURE_NUKER},{x:6,y:0,structureType:STRUCTURE_OBSERVER},{x:-1,y:5,structureType:STRUCTURE_POWER_SPAWN},{x:1,y:5,structureType:STRUCTURE_LINK},{x:5,y:-3,structureType:STRUCTURE_LINK},{x:-5,y:-3,structureType:STRUCTURE_LINK},{x:-2,y:0,structureType:STRUCTURE_EXTENSION},{x:2,y:0,structureType:STRUCTURE_EXTENSION},{x:0,y:-2,structureType:STRUCTURE_EXTENSION},{x:0,y:2,structureType:STRUCTURE_EXTENSION},{x:-2,y:-2,structureType:STRUCTURE_EXTENSION},{x:2,y:-2,structureType:STRUCTURE_EXTENSION},{x:-2,y:2,structureType:STRUCTURE_EXTENSION},{x:2,y:2,structureType:STRUCTURE_EXTENSION},{x:-3,y:-1,structureType:STRUCTURE_EXTENSION},{x:3,y:-1,structureType:STRUCTURE_EXTENSION}],roads:[{x:-1,y:-1},{x:0,y:-1},{x:1,y:-1},{x:-1,y:0},{x:1,y:0},{x:-1,y:1},{x:0,y:1},{x:1,y:1},{x:-6,y:-2},{x:-5,y:-2},{x:-4,y:-2},{x:-6,y:-1},{x:-4,y:-1},{x:-6,y:0},{x:-5,y:0},{x:-4,y:0},{x:4,y:-2},{x:5,y:-2},{x:6,y:-2},{x:4,y:-1},{x:6,y:-1},{x:4,y:0},{x:5,y:0},{x:6,y:0},{x:-3,y:0},{x:3,y:0},{x:0,y:-3},{x:0,y:3},{x:-2,y:-1},{x:2,y:-1},{x:-2,y:1},{x:2,y:1},{x:-1,y:-2},{x:1,y:-2},{x:-1,y:2},{x:1,y:2}],ramparts:[{x:0,y:0},{x:-5,y:-1},{x:5,y:-1},{x:0,y:4},{x:2,y:4},{x:0,y:-4},{x:-4,y:-2},{x:4,y:-2},{x:-4,y:2},{x:4,y:2},{x:0,y:6},{x:4,y:4},{x:-1,y:5}]},jr={name:"compactBunker",rcl:8,type:"bunker",minSpaceRadius:6,anchor:{x:25,y:25},structures:[{x:0,y:0,structureType:STRUCTURE_STORAGE},{x:-1,y:1,structureType:STRUCTURE_TERMINAL},{x:1,y:1,structureType:STRUCTURE_FACTORY},{x:0,y:-2,structureType:STRUCTURE_SPAWN},{x:-2,y:1,structureType:STRUCTURE_SPAWN},{x:2,y:1,structureType:STRUCTURE_SPAWN},{x:0,y:2,structureType:STRUCTURE_POWER_SPAWN},{x:-2,y:-1,structureType:STRUCTURE_NUKER},{x:-3,y:-2,structureType:STRUCTURE_TOWER},{x:3,y:-2,structureType:STRUCTURE_TOWER},{x:-4,y:0,structureType:STRUCTURE_TOWER},{x:4,y:0,structureType:STRUCTURE_TOWER},{x:-3,y:3,structureType:STRUCTURE_TOWER},{x:3,y:3,structureType:STRUCTURE_TOWER},{x:-2,y:3,structureType:STRUCTURE_LAB},{x:-1,y:3,structureType:STRUCTURE_LAB},{x:-3,y:4,structureType:STRUCTURE_LAB},{x:-2,y:4,structureType:STRUCTURE_LAB},{x:-1,y:4,structureType:STRUCTURE_LAB},{x:0,y:3,structureType:STRUCTURE_LAB},{x:0,y:4,structureType:STRUCTURE_LAB},{x:1,y:3,structureType:STRUCTURE_LAB},{x:1,y:4,structureType:STRUCTURE_LAB},{x:2,y:3,structureType:STRUCTURE_LAB},{x:2,y:-1,structureType:STRUCTURE_OBSERVER},{x:-1,y:-1,structureType:STRUCTURE_LINK},{x:1,y:-1,structureType:STRUCTURE_LINK},{x:-3,y:1,structureType:STRUCTURE_LINK},{x:3,y:1,structureType:STRUCTURE_LINK},{x:-1,y:-3,structureType:STRUCTURE_LINK},{x:1,y:-3,structureType:STRUCTURE_LINK},{x:-2,y:-2,structureType:STRUCTURE_EXTENSION},{x:0,y:-4,structureType:STRUCTURE_EXTENSION},{x:2,y:-2,structureType:STRUCTURE_EXTENSION},{x:-4,y:-2,structureType:STRUCTURE_EXTENSION},{x:4,y:-2,structureType:STRUCTURE_EXTENSION},{x:-4,y:2,structureType:STRUCTURE_EXTENSION},{x:4,y:2,structureType:STRUCTURE_EXTENSION},{x:-5,y:-3,structureType:STRUCTURE_EXTENSION},{x:-3,y:-3,structureType:STRUCTURE_EXTENSION},{x:-1,y:-5,structureType:STRUCTURE_EXTENSION},{x:1,y:-5,structureType:STRUCTURE_EXTENSION},{x:3,y:-3,structureType:STRUCTURE_EXTENSION},{x:5,y:-3,structureType:STRUCTURE_EXTENSION},{x:-5,y:-1,structureType:STRUCTURE_EXTENSION},{x:5,y:-1,structureType:STRUCTURE_EXTENSION},{x:-5,y:1,structureType:STRUCTURE_EXTENSION},{x:5,y:1,structureType:STRUCTURE_EXTENSION},{x:-5,y:3,structureType:STRUCTURE_EXTENSION},{x:5,y:3,structureType:STRUCTURE_EXTENSION},{x:-6,y:-4,structureType:STRUCTURE_EXTENSION},{x:-4,y:-4,structureType:STRUCTURE_EXTENSION},{x:-2,y:-4,structureType:STRUCTURE_EXTENSION},{x:2,y:-4,structureType:STRUCTURE_EXTENSION},{x:4,y:-4,structureType:STRUCTURE_EXTENSION},{x:6,y:-4,structureType:STRUCTURE_EXTENSION},{x:-6,y:-2,structureType:STRUCTURE_EXTENSION},{x:6,y:-2,structureType:STRUCTURE_EXTENSION},{x:-6,y:0,structureType:STRUCTURE_EXTENSION},{x:6,y:0,structureType:STRUCTURE_EXTENSION},{x:-6,y:2,structureType:STRUCTURE_EXTENSION},{x:6,y:2,structureType:STRUCTURE_EXTENSION},{x:-6,y:4,structureType:STRUCTURE_EXTENSION},{x:-4,y:4,structureType:STRUCTURE_EXTENSION},{x:2,y:4,structureType:STRUCTURE_EXTENSION},{x:4,y:4,structureType:STRUCTURE_EXTENSION},{x:6,y:4,structureType:STRUCTURE_EXTENSION},{x:-5,y:-5,structureType:STRUCTURE_EXTENSION},{x:-3,y:-5,structureType:STRUCTURE_EXTENSION},{x:3,y:-5,structureType:STRUCTURE_EXTENSION},{x:5,y:-5,structureType:STRUCTURE_EXTENSION},{x:-5,y:5,structureType:STRUCTURE_EXTENSION},{x:-3,y:5,structureType:STRUCTURE_EXTENSION},{x:3,y:5,structureType:STRUCTURE_EXTENSION},{x:5,y:5,structureType:STRUCTURE_EXTENSION}],roads:[{x:-1,y:0},{x:1,y:0},{x:0,y:1},{x:-1,y:-2},{x:1,y:-2},{x:-2,y:0},{x:2,y:0},{x:-2,y:2},{x:2,y:2},{x:-3,y:-1},{x:3,y:-1},{x:-3,y:2},{x:3,y:2},{x:0,y:2},{x:-1,y:2},{x:1,y:2}],ramparts:[{x:0,y:0},{x:-1,y:1},{x:1,y:1},{x:0,y:-2},{x:-2,y:1},{x:2,y:1},{x:0,y:2},{x:-2,y:-1},{x:-3,y:-2},{x:3,y:-2},{x:-4,y:0},{x:4,y:0},{x:-3,y:3},{x:3,y:3},{x:-2,y:3},{x:-1,y:3},{x:0,y:3},{x:1,y:3},{x:2,y:3},{x:-3,y:4},{x:-2,y:4},{x:-1,y:4},{x:0,y:4},{x:1,y:4}]};function Xr(e,t){var r;const o=zr(t),s={};let n=e.structures.filter(e=>{var t,r;const n=e.structureType,i=null!==(t=o[n])&&void 0!==t?t:0,a=null!==(r=s[n])&&void 0!==r?r:0;return i>a?(s[n]=a+1,1):0});const i=null!==(r=o[STRUCTURE_EXTENSION])&&void 0!==r?r:0;return i>0&&(n=function(e,t){const r=t-e.filter(e=>e.structureType===STRUCTURE_EXTENSION).length;if(0>=r)return e;const o=function(){const e=[],t=[{x:-2,y:0},{x:2,y:0},{x:0,y:-2},{x:0,y:2},{x:-2,y:-2},{x:2,y:-2},{x:-2,y:2},{x:2,y:2},{x:-1,y:-3},{x:1,y:-3},{x:-1,y:3},{x:1,y:3},{x:-3,y:-1},{x:3,y:-1},{x:-3,y:1},{x:3,y:1},{x:-4,y:0},{x:4,y:0},{x:0,y:-4},{x:0,y:4},{x:-3,y:-3},{x:3,y:-3},{x:-3,y:3},{x:3,y:3},{x:-4,y:-2},{x:4,y:-2},{x:-4,y:2},{x:4,y:2},{x:-2,y:-4},{x:2,y:-4},{x:-2,y:4},{x:2,y:4},{x:-1,y:-5},{x:1,y:-5},{x:-1,y:5},{x:1,y:5},{x:-5,y:-1},{x:5,y:-1},{x:-5,y:1},{x:5,y:1},{x:-4,y:-4},{x:4,y:-4},{x:-4,y:4},{x:4,y:4},{x:-3,y:-5},{x:3,y:-5},{x:-3,y:5},{x:3,y:5},{x:-5,y:-3},{x:5,y:-3},{x:-5,y:3},{x:5,y:3},{x:-6,y:0},{x:6,y:0},{x:0,y:-6},{x:0,y:6},{x:-6,y:-2},{x:6,y:-2},{x:-6,y:2},{x:6,y:2},{x:-2,y:-6},{x:2,y:-6},{x:-2,y:6},{x:2,y:6},{x:-5,y:-5},{x:5,y:-5},{x:-5,y:5},{x:5,y:5},{x:-4,y:-6},{x:4,y:-6},{x:-4,y:6},{x:4,y:6},{x:-6,y:-4},{x:6,y:-4},{x:-6,y:4},{x:6,y:4}];for(let r=0;Math.min(80,t.length)>r;r++)e.push({x:t[r].x,y:t[r].y,structureType:STRUCTURE_EXTENSION});return e}(),s=new Set(e.map(e=>`${e.x},${e.y}`)),n=o.filter(e=>!s.has(`${e.x},${e.y}`)).slice(0,r);return[...e,...n]}(n,i)),n}function zr(e){var t;const r={1:{spawn:1,extension:0,road:2500,constructedWall:0},2:{spawn:1,extension:5,road:2500,constructedWall:2500,rampart:2500,container:5},3:{spawn:1,extension:10,road:2500,constructedWall:2500,rampart:2500,container:5,tower:1},4:{spawn:1,extension:20,road:2500,constructedWall:2500,rampart:2500,container:5,tower:1,storage:1},5:{spawn:1,extension:30,road:2500,constructedWall:2500,rampart:2500,container:5,tower:2,storage:1,link:2},6:{spawn:1,extension:40,road:2500,constructedWall:2500,rampart:2500,container:5,tower:2,storage:1,link:3,terminal:1,extractor:1,lab:3},7:{spawn:2,extension:50,road:2500,constructedWall:2500,rampart:2500,container:5,tower:3,storage:1,link:4,terminal:1,extractor:1,lab:6,factory:1},8:{spawn:3,extension:60,road:2500,constructedWall:2500,rampart:2500,container:5,tower:6,storage:1,link:6,terminal:1,extractor:1,lab:10,factory:1,nuker:1,observer:1,powerSpawn:1}};return null!==(t=r[e])&&void 0!==t?t:r[1]}function Zr(e){return function(e){return 7>e?5>e?3>e?Wr:Br:Vr:qr}(e)}const Qr=[STRUCTURE_EXTENSION,STRUCTURE_ROAD,STRUCTURE_TOWER,STRUCTURE_LAB,STRUCTURE_LINK,STRUCTURE_FACTORY,STRUCTURE_OBSERVER,STRUCTURE_NUKER,STRUCTURE_POWER_SPAWN,STRUCTURE_EXTRACTOR],Jr=new Set(Qr);function eo(e,t,r){const o=e.getTerrain();for(let e=-1;1>=e;e++)for(let s=-1;1>=s;s++){const n=t+e,i=r+s;if(1>n||n>48||1>i||i>48)return 0;if(o.get(n,i)===TERRAIN_MASK_WALL)return 0}return 1}function to(e,t,r){var o;const s=e.getTerrain(),n=null!==(o=r.minSpaceRadius)&&void 0!==o?o:7;let i=0,a=0;if(t.x<n||t.x>49-n||t.y<n||t.y>49-n)return{fits:0,reason:`Anchor too close to room edge (needs ${n} tile margin)`};for(const e of r.structures){const r=t.x+e.x,o=t.y+e.y;if(1>r||r>48||1>o||o>48)return{fits:0,reason:`Structure ${e.structureType} at (${e.x},${e.y}) would be outside room bounds`};a++,s.get(r,o)===TERRAIN_MASK_WALL&&i++}for(const e of r.roads){const r=t.x+e.x,o=t.y+e.y;1>r||r>48||1>o||o>48||(a++,s.get(r,o)===TERRAIN_MASK_WALL&&i++)}const c=a>0?i/a*100:0;return"bunker"===r.type&&c>10?{fits:0,reason:`Too many walls in blueprint area (${c.toFixed(1)}% walls, max 10% for bunker)`,wallCount:i,totalTiles:a}:"spread"===r.type&&c>25?{fits:0,reason:`Too many walls in blueprint area (${c.toFixed(1)}% walls, max 25% for spread layout)`,wallCount:i,totalTiles:a}:{fits:1,wallCount:i,totalTiles:a}}function ro(e,t){var r;const o=e.controller;if(!o)return null;const s=e.find(FIND_SOURCES);e.find(FIND_MINERALS)[0];let n=o.pos.x,i=o.pos.y;for(const e of s)n+=e.pos.x,i+=e.pos.y;const a=Math.round(n/(s.length+1)),c=Math.round(i/(s.length+1)),u=null!==(r=t.minSpaceRadius)&&void 0!==r?r:7,l=[];for(let r=0;15>=r;r++){for(let n=-r;r>=n;n++)for(let i=-r;r>=i;i++){if(Math.abs(n)!==r&&Math.abs(i)!==r&&r>0)continue;const m=a+n,p=c+i;if(u>m||m>49-u||u>p||p>49-u)continue;const d=new RoomPosition(m,p,e.name),g=to(e,d,t);if(g.fits){let e=1e3;const t=d.getRangeTo(o);4>t||t>8?4>t?e-=50:t>12&&(e-=30):e+=100;let r=0;for(const e of s)r+=d.getRangeTo(e);const n=r/s.length;5>n||n>10?5>n&&(e-=20):e+=80;const i=Math.abs(m-25)+Math.abs(p-25);if(10>i?e+=50:i>20&&(e-=30),void 0!==g.wallCount&&void 0!==g.totalTiles){const t=g.wallCount/g.totalTiles*100;e+=Math.max(0,50-2*t)}l.push({pos:d,score:e})}}if(l.length>0)return l.sort((e,t)=>t.score-e.score),l[0].pos}return null}function oo(e,t){if(t>=8){const t=ro(e,jr);if(t)return{blueprint:jr,anchor:t};const r=ro(e,qr);if(r)return{blueprint:qr,anchor:r}}if(t>=7){const t=ro(e,qr);if(t)return{blueprint:qr,anchor:t}}if(t>=5){const t=ro(e,Vr);if(t)return{blueprint:Vr,anchor:t}}if(t>=3){const t=ro(e,Br);if(t)return{blueprint:Br,anchor:t}}const r=ro(e,Wr);if(r)return{blueprint:Wr,anchor:r};const o=function(e){const t=e.controller;if(!t)return null;const r=e.find(FIND_SOURCES),o=e.getTerrain();let s=t.pos.x,n=t.pos.y;for(const e of r)s+=e.pos.x,n+=e.pos.y;const i=Math.round(s/(r.length+1)),a=Math.round(n/(r.length+1));for(let r=0;15>r;r++)for(let s=-r;r>=s;s++)for(let n=-r;r>=n;n++){if(Math.abs(s)!==r&&Math.abs(n)!==r)continue;const c=i+s,u=a+n;if(!(3>c||c>46||3>u||u>46)&&eo(e,c,u)){if(Math.max(Math.abs(c-t.pos.x),Math.abs(u-t.pos.y))>20)continue;if(o.get(c,u)===TERRAIN_MASK_WALL)continue;return new RoomPosition(c,u,e.name)}}return null}(e);return o?{blueprint:Wr,anchor:o}:null}const so=new class{checkSafeMode(e,t){var r,o,s,n,i;if(!(null===(r=e.controller)||void 0===r?void 0:r.safeMode)&&!(null===(o=e.controller)||void 0===o?void 0:o.safeModeCooldown)&&0!==(null!==(n=null===(s=e.controller)||void 0===s?void 0:s.safeModeAvailable)&&void 0!==n?n:0)&&this.shouldTriggerSafeMode(e,t)){const t=null===(i=e.controller)||void 0===i?void 0:i.activateSafeMode();if(t===OK)Q.warn("SAFE MODE ACTIVATED in "+e.name,{subsystem:"Defense"});else{const r=void 0!==t?t+"":"undefined";Q.error(`Failed to activate safe mode in ${e.name}: ${r}`,{subsystem:"Defense"})}}}shouldTriggerSafeMode(e,t){if(2>t.danger)return 0;const r=e.find(FIND_MY_SPAWNS);for(const e of r)if(e.hits<.2*e.hitsMax)return Q.warn(`Spawn ${e.name} critical: ${e.hits}/${e.hitsMax}`,{subsystem:"Defense"}),1;if(e.storage&&e.storage.hits<.2*e.storage.hitsMax)return Q.warn(`Storage critical: ${e.storage.hits}/${e.storage.hitsMax}`,{subsystem:"Defense"}),1;if(e.terminal&&e.terminal.hits<.2*e.terminal.hitsMax)return Q.warn(`Terminal critical: ${e.terminal.hits}/${e.terminal.hitsMax}`,{subsystem:"Defense"}),1;const o=e.find(FIND_HOSTILE_CREEPS),s=e.find(FIND_MY_CREEPS,{filter:e=>{const t=e.memory.role;return"guard"===t||"ranger"===t||"soldier"===t}});if(o.length>3*s.length)return Q.warn(`Overwhelmed: ${o.length} hostiles vs ${s.length} defenders`,{subsystem:"Defense"}),1;const n=o.filter(e=>e.body.some(e=>e.boost));return n.length>0&&s.length<2*n.length?(Q.warn("Boosted hostiles detected: "+n.length,{subsystem:"Defense"}),1):0}};function no(e,t){var r,o;const s=null!==(r={1:0,2:3e5,3:1e6,4:3e6,5:1e7,6:3e7,7:1e8,8:3e8}[e])&&void 0!==r?r:0;if(0===s)return 0;const n=null!==(o={0:.3,1:.5,2:.8,3:1}[t])&&void 0!==o?o:1;return Math.floor(s*n)}function io(e){const t={guards:0,rangers:0,healers:0,urgency:1,reasons:[]},r=e.find(FIND_HOSTILE_CREEPS);if(0===r.length)return t;let o=0,s=0,n=0,i=0,a=0;for(const e of r){const t=e.body;t.some(e=>void 0!==e.boost)&&a++;for(const e of t)e.type===ATTACK&&o++,e.type===RANGED_ATTACK&&s++,e.type===HEAL&&n++,e.type===WORK&&i++}return o>0&&(t.guards=Math.max(1,Math.ceil(o/4)),t.reasons.push(o+" melee parts detected")),s>0&&(t.rangers=Math.max(1,Math.ceil(s/6)),t.reasons.push(s+" ranged parts detected")),n>0&&(t.healers=Math.max(1,Math.ceil(n/8)),t.reasons.push(n+" heal parts detected")),i>0&&(t.guards+=Math.ceil(i/5),t.reasons.push(i+" work parts (dismantlers)")),a>0&&(t.guards=Math.ceil(1.5*t.guards),t.rangers=Math.ceil(1.5*t.rangers),t.healers=Math.ceil(1.5*t.healers),t.urgency=2,t.reasons.push(a+" boosted enemies (high threat)")),r.length>0&&(t.guards=Math.max(t.guards,1),t.rangers=Math.max(t.rangers,1)),3>r.length||(t.healers=Math.max(t.healers,1)),5>r.length||(t.urgency=Math.max(t.urgency,1.5),t.reasons.push(r.length+" hostiles (large attack)")),e.find(FIND_MY_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_STORAGE||e.structureType===STRUCTURE_TERMINAL)&&e.hits<.8*e.hitsMax}).length>0&&(t.urgency=3,t.reasons.push("Critical structures under attack!")),Q.info(`Defender analysis for ${e.name}: ${t.guards} guards, ${t.rangers} rangers, ${t.healers} healers (urgency: ${t.urgency}x) - ${t.reasons.join(", ")}`,{subsystem:"Defense"}),t}function ao(e){const t=e.find(FIND_MY_CREEPS);return{guards:t.filter(e=>"guard"===e.memory.role).length,rangers:t.filter(e=>"ranger"===e.memory.role).length,healers:t.filter(e=>"healer"===e.memory.role).length}}function co(e,t){if(2>t.danger)return 0;const r=io(e),o=ao(e),s=r.guards-o.guards+(r.rangers-o.rangers);if(0>=s)return 0;const n=e.find(FIND_MY_SPAWNS);return 0===n.length||0===n.filter(e=>!e.spawning).length||250>e.energyAvailable?1:(2>r.urgency||2>s)&&(3>t.danger||1>s)?0:1}function uo(e,t){if(!co(e,t))return null;const r=io(e),o=ao(e),s={roomName:e.name,guardsNeeded:Math.max(0,r.guards-o.guards),rangersNeeded:Math.max(0,r.rangers-o.rangers),healersNeeded:Math.max(0,r.healers-o.healers),urgency:r.urgency,createdAt:Game.time,threat:r.reasons.join("; ")};return Q.warn(`Defense assistance requested for ${e.name}: ${s.guardsNeeded} guards, ${s.rangersNeeded} rangers, ${s.healersNeeded} healers - ${s.threat}`,{subsystem:"Defense"}),s}var lo;!function(e){e[e.NONE=0]="NONE",e[e.LOW=1]="LOW",e[e.MEDIUM=2]="MEDIUM",e[e.HIGH=3]="HIGH",e[e.CRITICAL=4]="CRITICAL"}(lo||(lo={}));const mo=new class{constructor(){this.emergencyStates=new Map}assess(e,t){const r=this.emergencyStates.get(e.name),o=this.calculateEmergencyLevel(e,t);let s;return r?(s=r,s.level=o):(s={level:o,startedAt:Game.time,assistanceRequested:0,boostsAllocated:0,lastEscalation:0},this.emergencyStates.set(e.name,s)),o===lo.NONE?(r&&(Q.info("Emergency resolved in "+e.name,{subsystem:"Defense"}),this.emergencyStates.delete(e.name)),s):(r&&o>r.level&&(Q.warn(`Emergency escalated in ${e.name}: Level ${r.level}  ${o}`,{subsystem:"Defense"}),s.lastEscalation=Game.time),this.executeEmergencyResponse(e,t,s),s)}calculateEmergencyLevel(e,t){if(0===t.danger)return lo.NONE;const r=e.find(FIND_HOSTILE_CREEPS),o=io(e),s=ao(e);if(e.find(FIND_MY_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_SPAWN||e.structureType===STRUCTURE_STORAGE||e.structureType===STRUCTURE_TERMINAL)&&e.hits<.3*e.hitsMax}).length>0)return lo.CRITICAL;const n=r.filter(e=>e.body.some(e=>e.boost)),i=o.guards-s.guards+(o.rangers-s.rangers);return n.length>0&&i>=2?lo.HIGH:5>r.length||0!==s.guards||0!==s.rangers?2>t.danger||1>i?1>t.danger?lo.NONE:lo.LOW:lo.MEDIUM:lo.HIGH}executeEmergencyResponse(e,t,r){r.level!==lo.HIGH&&r.level!==lo.CRITICAL||r.assistanceRequested||this.requestDefenseAssistance(e,t)&&(r.assistanceRequested=1),r.level<lo.MEDIUM||r.boostsAllocated||!e.controller||6>e.controller.level||(this.allocateBoostsForDefense(e,t),r.boostsAllocated=1),this.updateDefensePosture(e,t,r)}requestDefenseAssistance(e,t){var r;if(!co(e,t))return 0;const o=uo(e,t);if(!o)return 0;const s=Memory,n=(null!==(r=s.defenseRequests)&&void 0!==r?r:[]).filter(t=>t.roomName!==e.name||500>Game.time-t.createdAt);return n.push(o),s.defenseRequests=n,Q.warn(`Defense assistance requested for ${e.name}: ${o.guardsNeeded} guards, ${o.rangersNeeded} rangers - ${o.threat}`,{subsystem:"Defense"}),1}allocateBoostsForDefense(e,t){var r;const o=Memory,s=null!==(r=o.boostDefensePriority)&&void 0!==r?r:{};s[e.name]=1,o.boostDefensePriority=s,Q.info("Allocated boost priority for defenders in "+e.name,{subsystem:"Defense"})}updateDefensePosture(e,t,r){switch(r.level){case lo.CRITICAL:"evacuate"!==t.posture&&(t.posture="war",t.pheromones.war=100,t.pheromones.defense=100,Q.warn(e.name+" posture: CRITICAL DEFENSE",{subsystem:"Defense"}));break;case lo.HIGH:"war"!==t.posture&&"evacuate"!==t.posture&&(t.posture="defensive",t.pheromones.defense=80,t.pheromones.war=40,Q.info(e.name+" posture: HIGH DEFENSE",{subsystem:"Defense"}));break;case lo.MEDIUM:"eco"!==t.posture&&"expand"!==t.posture||(t.posture="defensive",t.pheromones.defense=60,Q.info(e.name+" posture: MEDIUM DEFENSE",{subsystem:"Defense"}));break;case lo.LOW:"eco"!==t.posture&&"expand"!==t.posture||(t.pheromones.defense=30,Q.debug(e.name+": LOW DEFENSE alert",{subsystem:"Defense"}))}}getDefenseRequests(){var e;const t=Memory,r=null!==(e=t.defenseRequests)&&void 0!==e?e:[],o=r.filter(e=>500>Game.time-e.createdAt);return o.length!==r.length&&(t.defenseRequests=o),o}clearDefenseRequest(e){var t;const r=Memory,o=(null!==(t=r.defenseRequests)&&void 0!==t?t:[]).filter(t=>t.roomName!==e);r.defenseRequests=o}getEmergencyState(e){return this.emergencyStates.get(e)}hasEmergency(e){const t=this.emergencyStates.get(e);return void 0!==t&&t.level>lo.NONE}getActiveEmergencies(){const e=[];for(const[t,r]of this.emergencyStates.entries())r.level>lo.NONE&&e.push({roomName:t,state:r});return e.sort((e,t)=>t.state.level-e.state.level)}},po=[STRUCTURE_SPAWN,STRUCTURE_STORAGE,STRUCTURE_TERMINAL,STRUCTURE_TOWER,STRUCTURE_LAB,STRUCTURE_FACTORY,STRUCTURE_POWER_SPAWN,STRUCTURE_NUKER,STRUCTURE_OBSERVER],go=[STRUCTURE_SPAWN,STRUCTURE_TOWER,STRUCTURE_STORAGE];function fo(e,t,r){return e.lookForAt(LOOK_STRUCTURES,t,r).some(e=>e.structureType===STRUCTURE_RAMPART)}function Ro(e,t,r){return e.lookForAt(LOOK_CONSTRUCTION_SITES,t,r).some(e=>e.structureType===STRUCTURE_RAMPART)}const ho={[RESOURCE_HYDROXIDE]:{product:RESOURCE_HYDROXIDE,input1:RESOURCE_HYDROGEN,input2:RESOURCE_OXYGEN,priority:10},[RESOURCE_ZYNTHIUM_KEANITE]:{product:RESOURCE_ZYNTHIUM_KEANITE,input1:RESOURCE_ZYNTHIUM,input2:RESOURCE_KEANIUM,priority:10},[RESOURCE_UTRIUM_LEMERGITE]:{product:RESOURCE_UTRIUM_LEMERGITE,input1:RESOURCE_UTRIUM,input2:RESOURCE_LEMERGIUM,priority:10},[RESOURCE_GHODIUM]:{product:RESOURCE_GHODIUM,input1:RESOURCE_ZYNTHIUM_KEANITE,input2:RESOURCE_UTRIUM_LEMERGITE,priority:15},[RESOURCE_UTRIUM_HYDRIDE]:{product:RESOURCE_UTRIUM_HYDRIDE,input1:RESOURCE_UTRIUM,input2:RESOURCE_HYDROGEN,priority:20},[RESOURCE_UTRIUM_OXIDE]:{product:RESOURCE_UTRIUM_OXIDE,input1:RESOURCE_UTRIUM,input2:RESOURCE_OXYGEN,priority:20},[RESOURCE_KEANIUM_HYDRIDE]:{product:RESOURCE_KEANIUM_HYDRIDE,input1:RESOURCE_KEANIUM,input2:RESOURCE_HYDROGEN,priority:20},[RESOURCE_KEANIUM_OXIDE]:{product:RESOURCE_KEANIUM_OXIDE,input1:RESOURCE_KEANIUM,input2:RESOURCE_OXYGEN,priority:20},[RESOURCE_LEMERGIUM_HYDRIDE]:{product:RESOURCE_LEMERGIUM_HYDRIDE,input1:RESOURCE_LEMERGIUM,input2:RESOURCE_HYDROGEN,priority:20},[RESOURCE_LEMERGIUM_OXIDE]:{product:RESOURCE_LEMERGIUM_OXIDE,input1:RESOURCE_LEMERGIUM,input2:RESOURCE_OXYGEN,priority:20},[RESOURCE_ZYNTHIUM_HYDRIDE]:{product:RESOURCE_ZYNTHIUM_HYDRIDE,input1:RESOURCE_ZYNTHIUM,input2:RESOURCE_HYDROGEN,priority:20},[RESOURCE_ZYNTHIUM_OXIDE]:{product:RESOURCE_ZYNTHIUM_OXIDE,input1:RESOURCE_ZYNTHIUM,input2:RESOURCE_OXYGEN,priority:20},[RESOURCE_GHODIUM_HYDRIDE]:{product:RESOURCE_GHODIUM_HYDRIDE,input1:RESOURCE_GHODIUM,input2:RESOURCE_HYDROGEN,priority:20},[RESOURCE_GHODIUM_OXIDE]:{product:RESOURCE_GHODIUM_OXIDE,input1:RESOURCE_GHODIUM,input2:RESOURCE_OXYGEN,priority:20},[RESOURCE_UTRIUM_ACID]:{product:RESOURCE_UTRIUM_ACID,input1:RESOURCE_UTRIUM_HYDRIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_UTRIUM_ALKALIDE]:{product:RESOURCE_UTRIUM_ALKALIDE,input1:RESOURCE_UTRIUM_OXIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_KEANIUM_ACID]:{product:RESOURCE_KEANIUM_ACID,input1:RESOURCE_KEANIUM_HYDRIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_KEANIUM_ALKALIDE]:{product:RESOURCE_KEANIUM_ALKALIDE,input1:RESOURCE_KEANIUM_OXIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_LEMERGIUM_ACID]:{product:RESOURCE_LEMERGIUM_ACID,input1:RESOURCE_LEMERGIUM_HYDRIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_LEMERGIUM_ALKALIDE]:{product:RESOURCE_LEMERGIUM_ALKALIDE,input1:RESOURCE_LEMERGIUM_OXIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_ZYNTHIUM_ACID]:{product:RESOURCE_ZYNTHIUM_ACID,input1:RESOURCE_ZYNTHIUM_HYDRIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_ZYNTHIUM_ALKALIDE]:{product:RESOURCE_ZYNTHIUM_ALKALIDE,input1:RESOURCE_ZYNTHIUM_OXIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_GHODIUM_ACID]:{product:RESOURCE_GHODIUM_ACID,input1:RESOURCE_GHODIUM_HYDRIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_GHODIUM_ALKALIDE]:{product:RESOURCE_GHODIUM_ALKALIDE,input1:RESOURCE_GHODIUM_OXIDE,input2:RESOURCE_HYDROXIDE,priority:30},[RESOURCE_CATALYZED_UTRIUM_ACID]:{product:RESOURCE_CATALYZED_UTRIUM_ACID,input1:RESOURCE_UTRIUM_ACID,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_UTRIUM_ALKALIDE]:{product:RESOURCE_CATALYZED_UTRIUM_ALKALIDE,input1:RESOURCE_UTRIUM_ALKALIDE,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_KEANIUM_ACID]:{product:RESOURCE_CATALYZED_KEANIUM_ACID,input1:RESOURCE_KEANIUM_ACID,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_KEANIUM_ALKALIDE]:{product:RESOURCE_CATALYZED_KEANIUM_ALKALIDE,input1:RESOURCE_KEANIUM_ALKALIDE,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_LEMERGIUM_ACID]:{product:RESOURCE_CATALYZED_LEMERGIUM_ACID,input1:RESOURCE_LEMERGIUM_ACID,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]:{product:RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,input1:RESOURCE_LEMERGIUM_ALKALIDE,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_ZYNTHIUM_ACID]:{product:RESOURCE_CATALYZED_ZYNTHIUM_ACID,input1:RESOURCE_ZYNTHIUM_ACID,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]:{product:RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,input1:RESOURCE_ZYNTHIUM_ALKALIDE,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_GHODIUM_ACID]:{product:RESOURCE_CATALYZED_GHODIUM_ACID,input1:RESOURCE_GHODIUM_ACID,input2:RESOURCE_CATALYST,priority:40},[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]:{product:RESOURCE_CATALYZED_GHODIUM_ALKALIDE,input1:RESOURCE_GHODIUM_ALKALIDE,input2:RESOURCE_CATALYST,priority:40}},yo={[RESOURCE_CATALYZED_UTRIUM_ACID]:3e3,[RESOURCE_CATALYZED_KEANIUM_ALKALIDE]:3e3,[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE]:3e3,[RESOURCE_CATALYZED_GHODIUM_ACID]:3e3,[RESOURCE_CATALYZED_GHODIUM_ALKALIDE]:2e3,[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE]:2e3,[RESOURCE_GHODIUM]:5e3,[RESOURCE_HYDROXIDE]:5e3};function Eo(e,t){var r;const o=null!==(r=yo[e])&&void 0!==r?r:1e3;return"war"!==t.posture&&"siege"!==t.posture||e!==RESOURCE_CATALYZED_UTRIUM_ACID&&e!==RESOURCE_CATALYZED_KEANIUM_ALKALIDE&&e!==RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE&&e!==RESOURCE_CATALYZED_GHODIUM_ACID?"war"!==t.posture&&"siege"!==t.posture||e!==RESOURCE_CATALYZED_GHODIUM_ALKALIDE&&e!==RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE?o:.5*o:1.5*o}const To=new class{getReaction(e){return ho[e]}calculateReactionChain(e,t){const r=[],o=new Set,s=e=>{var n,i,a;if(o.has(e))return 1;o.add(e);const c=ho[e];return c?100>(null!==(i=t[c.input1])&&void 0!==i?i:0)&&!s(c.input1)||100>(null!==(a=t[c.input2])&&void 0!==a?a:0)&&!s(c.input2)?0:(r.push(c),1):(null!==(n=t[e])&&void 0!==n?n:0)>0};return s(e),r}hasResourcesForReaction(e,t,r=100){var o,s;const n=null!==(o=e.store[t.input1])&&void 0!==o?o:0,i=null!==(s=e.store[t.input2])&&void 0!==s?s:0;return n>=r&&i>=r}planReactions(e,t){var r;if(3>e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB}).length)return null;const o=e.terminal;if(!o)return null;const s=this.getTargetCompounds(t);for(const n of s){if(!ho[n])continue;const s=null!==(r=o.store[n])&&void 0!==r?r:0;if(Eo(n,t)>s){const t={};for(const[e,r]of Object.entries(o.store))t[e]=r;const r=this.calculateReactionChain(n,t);for(const e of r)if(this.hasResourcesForReaction(o,e,1e3))return e;r.length>0&&Q.debug(`Cannot produce ${n}: missing inputs in reaction chain`,{subsystem:"Chemistry",room:e.name})}}return null}getTargetCompounds(e){const t=[];return t.push(RESOURCE_GHODIUM,RESOURCE_HYDROXIDE),"war"!==e.posture&&"siege"!==e.posture&&2>e.danger?t.push(RESOURCE_CATALYZED_GHODIUM_ALKALIDE,RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE):t.push(RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_KEANIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,RESOURCE_CATALYZED_GHODIUM_ACID),t}executeReaction(e,t){const r=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB});if(3>r.length)return;const o=r[0],s=r[1],n=r.slice(2);(o.mineralType!==t.input1||500>o.store[t.input1])&&Q.debug(`Lab ${o.id} needs ${t.input1}`,{subsystem:"Chemistry"}),(s.mineralType!==t.input2||500>s.store[t.input2])&&Q.debug(`Lab ${s.id} needs ${t.input2}`,{subsystem:"Chemistry"});for(const e of n){if(e.cooldown>0)continue;const r=e.store.getFreeCapacity();null!==r&&100>r?Q.debug(`Lab ${e.id} is full, needs unloading`,{subsystem:"Chemistry"}):e.runReaction(o,s)===OK&&Q.debug(`Produced ${t.product} in lab ${e.id}`,{subsystem:"Chemistry"})}}},Co=[{role:"soldier",boosts:[RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],minDanger:2},{role:"ranger",boosts:[RESOURCE_CATALYZED_KEANIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],minDanger:2},{role:"healer",boosts:[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE],minDanger:2},{role:"siegeUnit",boosts:[RESOURCE_CATALYZED_GHODIUM_ACID,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE],minDanger:1}];function vo(e){switch(e){case ERR_NOT_OWNER:return"not owner of lab";case ERR_NOT_FOUND:return"no suitable body parts";case ERR_NOT_ENOUGH_RESOURCES:return"not enough compound";case ERR_INVALID_TARGET:return"invalid creep target";case ERR_NOT_IN_RANGE:return"creep not in range";case ERR_RCL_NOT_ENOUGH:return"RCL too low";default:return"error code "+e}}const So=new class{shouldBoost(e,t){var r;const o=e.memory;if(o.boosted)return 0;const s=Co.find(e=>e.role===o.role);if(!s)return 0;const n=1==(null!==(r=Memory.boostDefensePriority)&&void 0!==r?r:{})[e.room.name]?Math.max(1,s.minDanger-1):s.minDanger;return t.danger<n||t.missingStructures.labs?0:1}boostCreep(e,t){const r=e.memory,o=Co.find(e=>e.role===r.role);if(!o)return 0;const s=t.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB}),n=[];for(const t of o.boosts){if(e.body.some(e=>e.boost===t))continue;n.push(t);const r=s.find(e=>e.mineralType===t&&e.store[t]>=30);if(!r)return Q.debug(`Lab not ready with ${t} for ${e.name}`,{subsystem:"Boost"}),0;if(!e.pos.isNearTo(r))return e.moveTo(r,{visualizePathStyle:{stroke:"#ffaa00"}}),0;{const o=r.boostCreep(e);if(o===OK)Q.info(`Boosted ${e.name} with ${t}`,{subsystem:"Boost"});else if(o!==ERR_NOT_FOUND)return Q.error(`Failed to boost ${e.name}: ${vo(o)}`,{subsystem:"Boost"}),0}}return 0===n.length?(r.boosted=1,Q.info(`${e.name} fully boosted (all ${o.boosts.length} boosts applied)`,{subsystem:"Boost"}),1):0}areBoostLabsReady(e,t){const r=Co.find(e=>e.role===t);if(!r)return 1;const o=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB});for(const e of r.boosts)if(!o.find(t=>t.mineralType===e&&t.store[e]>=30))return 0;return 1}getMissingBoosts(e,t){const r=Co.find(e=>e.role===t);if(!r)return[];const o=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB}),s=[];for(const e of r.boosts)o.find(t=>t.mineralType===e&&t.store[e]>=30)||s.push(e);return s}prepareLabs(e,t){if(2>t.danger)return;const r=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB});if(3>r.length)return;const o=r.slice(2),s=new Set;for(const e of Co)if(t.danger>=e.minDanger)for(const t of e.boosts)s.add(t);let n=0;for(const e of s){if(n>=o.length)break;const t=o[n];(t.mineralType!==e||1e3>t.store[e])&&Q.debug(`Lab ${t.id} needs ${e} for boosting`,{subsystem:"Boost"}),n++}}};function Uo(e){return e>=2&&3>=e}const Oo={enablePheromones:1,enableEvolution:1,enableSpawning:1,enableConstruction:1,enableTowers:1,enableProcessing:1},_o=new Map,Ao=new Map;function Mo(e){const t=_o.get(e.name);if(t&&t.tick===Game.time)return t;const r=e.find(FIND_MY_STRUCTURES),o={tick:Game.time,towers:r.filter(e=>e.structureType===STRUCTURE_TOWER),spawns:r.filter(e=>e.structureType===STRUCTURE_SPAWN),links:r.filter(e=>e.structureType===STRUCTURE_LINK),factory:r.find(e=>e.structureType===STRUCTURE_FACTORY),powerSpawn:r.find(e=>e.structureType===STRUCTURE_POWER_SPAWN),sources:e.find(FIND_SOURCES),constructionSites:e.find(FIND_MY_CONSTRUCTION_SITES)};return _o.set(e.name,o),o}class No{constructor(e,t={}){this.roomName=e,this.config={...Oo,...t}}run(e){var t,r,o;const s=kr.startRoom(this.roomName),n=Game.rooms[this.roomName];if(!n||!(null===(t=n.controller)||void 0===t?void 0:t.my))return void kr.endRoom(this.roomName,s);!function(e){var t;if(!(null===(t=e.controller)||void 0===t?void 0:t.my))return;const r=function(){const e=global;return e._objectCache&&e._objectCache.tick===Game.time||(e._objectCache={tick:Game.time,objects:new Map}),e._objectCache}();e.storage&&!r.objects.has(e.storage.id)&&r.objects.set(e.storage.id,e.storage),e.terminal&&!r.objects.has(e.terminal.id)&&r.objects.set(e.terminal.id,e.terminal),e.controller&&!r.objects.has(e.controller.id)&&r.objects.set(e.controller.id,e.controller);const o=e.find(FIND_SOURCES);for(const e of o)r.objects.has(e.id)||r.objects.set(e.id,e)}(n);const i=Ce.getOrInitSwarmState(this.roomName);if(this.config.enablePheromones&&Game.time%5==0&&Nr.updateMetrics(n,i),this.updateThreatAssessment(n,i),mo.assess(n,i),so.checkSafeMode(n,i),this.config.enableEvolution&&(xr.updateEvolutionStage(i,n,e),xr.updateMissingStructures(i,n)),Gr.updatePosture(i),this.config.enablePheromones&&Nr.updatePheromones(i,n),this.config.enableTowers&&this.runTowerControl(n,i),this.config.enableConstruction&&Gr.allowsBuilding(i.posture)){const e=Uo(null!==(o=null===(r=n.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:1)?5:10;Game.time%e===0&&this.runConstruction(n,i)}this.config.enableProcessing&&Game.time%5==0&&this.runResourceProcessing(n,i);const a=Game.cpu.getUsed()-s;kr.recordRoom(n,a),kr.endRoom(this.roomName,s)}updateThreatAssessment(e,t){var r,o;if(Game.time%5==0){const t=Mo(e),r=t.spawns.length+t.towers.length,o=Ao.get(this.roomName);o&&o.lastTick<Game.time&&r<o.lastStructureCount&&(t.spawns.length<o.lastSpawns.length&&ge.emit("structure.destroyed",{roomName:this.roomName,structureType:STRUCTURE_SPAWN,structureId:"unknown",source:this.roomName}),t.towers.length<o.lastTowers.length&&ge.emit("structure.destroyed",{roomName:this.roomName,structureType:STRUCTURE_TOWER,structureId:"unknown",source:this.roomName})),Ao.set(this.roomName,{lastStructureCount:r,lastSpawns:[...t.spawns],lastTowers:[...t.towers],lastTick:Game.time})}const s=Ye(e,FIND_HOSTILE_CREEPS),n=s.length>0||t.danger>0?Ye(e,FIND_HOSTILE_STRUCTURES,{filter:e=>e.structureType!==STRUCTURE_CONTROLLER}):[];let i=0;for(const e of s)for(const t of e.body)t.hits>0&&(t.type===ATTACK?i+=30:t.type===RANGED_ATTACK&&(i+=10));const a=function(e,t,r){return 10>e&&2e3>t?5>e&&1e3>t?2>e&&300>t&&!r?0:1:2:3}(s.length,i,n.length>0);if(a>t.danger){Nr.onHostileDetected(t,s.length,a),Ce.addRoomEvent(this.roomName,"hostileDetected",`${s.length} hostiles, danger=${a}`);for(const e of s)ge.emit("hostile.detected",{roomName:this.roomName,hostileId:e.id,hostileOwner:e.owner.username,bodyParts:e.body.length,threatLevel:a,source:this.roomName})}else 0===s.length&&t.danger>0&&ge.emit("hostile.cleared",{roomName:this.roomName,source:this.roomName});if(t.danger=a,Game.time%10==0){const s=e.find(FIND_NUKES);if(s.length>0){if(!t.nukeDetected){Nr.onNukeDetected(t);const e=null!==(o=null===(r=s[0])||void 0===r?void 0:r.launchRoomName)&&void 0!==o?o:"unidentified source";Ce.addRoomEvent(this.roomName,"nukeDetected",`${s.length} nuke(s) incoming from ${e}`),t.nukeDetected=1;for(const e of s)ge.emit("nuke.detected",{roomName:this.roomName,nukeId:e.id,landingTick:Game.time+e.timeToLand,launchRoomName:e.launchRoomName,source:this.roomName})}}else t.nukeDetected=0}}runTowerControl(e,t){var r,o;const s=Mo(e).towers;if(0===s.length)return;const n=Ye(e,FIND_HOSTILE_CREEPS);for(const i of s)if(i.store.getUsedCapacity(RESOURCE_ENERGY)>=10){if(n.length>0){const e=this.selectTowerTarget(n);if(e){i.attack(e);continue}}if("siege"!==t.posture){const e=i.pos.findClosestByRange(FIND_MY_CREEPS,{filter:e=>e.hits<e.hitsMax});if(e){i.heal(e);continue}}if(!Gr.isCombatPosture(t.posture)){const e=i.pos.findClosestByRange(FIND_STRUCTURES,{filter:e=>e.hits<.8*e.hitsMax&&e.structureType!==STRUCTURE_WALL&&e.structureType!==STRUCTURE_RAMPART});if(e){i.repair(e);continue}}if(!Gr.isCombatPosture(t.posture)&&0===n.length){const s=no(null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:1,t.danger),n=i.pos.findClosestByRange(FIND_STRUCTURES,{filter:e=>(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)&&e.hits<s});n&&i.repair(n)}}}selectTowerTarget(e){var t;return null!==(t=e.sort((e,t)=>{const r=this.getHostilePriority(e);return this.getHostilePriority(t)-r})[0])&&void 0!==t?t:null}getHostilePriority(e){let t=0;for(const r of e.body)if(r.hits){switch(r.type){case HEAL:t+=100;break;case RANGED_ATTACK:t+=50;break;case ATTACK:t+=40;break;case CLAIM:t+=60;break;case WORK:t+=30}r.boost&&(t+=20)}return t}runConstruction(e,t){var r,o,s;const n=Mo(e),i=n.constructionSites;if(i.length>=10)return;const a=null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:1;let c=n.spawns[0],u=null==c?void 0:c.pos;if(!c){if(1===a&&0===i.length){const t=oo(e,a);t&&e.createConstructionSite(t.anchor.x,t.anchor.y,STRUCTURE_SPAWN)}return}const l=oo(e,a);if(l)u=l.anchor;else{if(!Zr(a))return;u=c.pos}const m=null!==(s=null==l?void 0:l.blueprint)&&void 0!==s?s:Zr(a);if(!m||!u)return;if(!Gr.isCombatPosture(t.posture)){const r=function(e,t,r,o=1,s=[]){const n=function(e,t,r,o=[]){var s,n,i;const a=null!==(n=null===(s=e.controller)||void 0===s?void 0:s.level)&&void 0!==n?n:1,c=Xr(r,a),u=e.getTerrain(),l=[],m=new Map;for(const e of c){const r=t.x+e.x,o=t.y+e.y;if(1>r||r>48||1>o||o>48)continue;if(u.get(r,o)===TERRAIN_MASK_WALL)continue;const s=`${r},${o}`;m.has(e.structureType)||m.set(e.structureType,new Set),null===(i=m.get(e.structureType))||void 0===i||i.add(s)}const p=Fr(e,t,r.roads,o);if(m.set(STRUCTURE_ROAD,p),a>=6){const t=e.find(FIND_MINERALS);if(t.length>0){const e=t[0],r=new Set;r.add(`${e.pos.x},${e.pos.y}`),m.set(STRUCTURE_EXTRACTOR,r)}}const d=e.find(FIND_STRUCTURES,{filter:e=>Jr.has(e.structureType)&&(1==e.my||e.structureType===STRUCTURE_ROAD)});for(const e of d){const t=`${e.pos.x},${e.pos.y}`,r=e.structureType,o=m.get(r);o&&o.has(t)||l.push({structure:e,reason:`${e.structureType} at ${t} is not in blueprint`})}return l}(e,t,r,s);let i=0;for(const{structure:e,reason:t}of n){if(i>=o)break;e.destroy()===OK&&(i++,console.log("[Blueprint] Destroyed misplaced "+t))}return i}(e,u,m,1,t.remoteAssignments);if(r>0){const e=1===r?"structure":"structures";Ce.addRoomEvent(this.roomName,"structureDestroyed",`${r} misplaced ${e} destroyed for blueprint compliance`)}}let p={sitesPlaced:0,wallsRemoved:0};if(a>=2&&8>i.length){const r=Uo(a)?5:3;p=function(e,t,r,o,s=3,n=[]){if(2>o)return{sitesPlaced:0,wallsRemoved:0};const i=function(e,t,r,o=[]){const s=Fr(e,t,r,o),n=function(e){var t;const r=Game.map.getRoomTerrain(e),o=[],s=[],n=function(e){const t=[],r=Game.map.getRoomTerrain(e),o=Game.rooms[e],s=new Set;if(o){const e=o.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART});for(const t of e)s.add(`${t.pos.x},${t.pos.y}`)}for(let e=0;50>e;e++)r.get(e,0)===TERRAIN_MASK_WALL||s.has(e+",0")||t.push({x:e,y:0,exitDirection:"top",isChokePoint:0});for(let e=0;50>e;e++)r.get(e,49)===TERRAIN_MASK_WALL||s.has(e+",49")||t.push({x:e,y:49,exitDirection:"bottom",isChokePoint:0});for(let e=1;49>e;e++)r.get(0,e)===TERRAIN_MASK_WALL||s.has("0,"+e)||t.push({x:0,y:e,exitDirection:"left",isChokePoint:0});for(let e=1;49>e;e++)r.get(49,e)===TERRAIN_MASK_WALL||s.has("49,"+e)||t.push({x:49,y:e,exitDirection:"right",isChokePoint:0});return t}(e),i=new Map;for(const e of n){const r=null!==(t=i.get(e.exitDirection))&&void 0!==t?t:[];r.push(e),i.set(e.exitDirection,r)}for(const[e,t]of i){const n=[...t].sort((e,t)=>e.x===t.x?e.y-t.y:e.x-t.x),i=[];let a=[];for(let e=0;e<n.length;e++){const t=n[e],r=n[e-1];!(r&&1>=Math.abs(t.x-r.x)&&1>=Math.abs(t.y-r.y))&&a.length>0&&(i.push(a),a=[]),a.push(t)}a.length>0&&i.push(a);for(const t of i){const n=Math.floor(t.length/2);for(let i=0;i<t.length;i++){const a=t[i];let c=a.x,u=a.y;switch(e){case"top":u=2;break;case"bottom":u=47;break;case"left":c=2;break;case"right":c=47}r.get(c,u)!==TERRAIN_MASK_WALL&&(4>t.length||i!==n&&i!==n-1?o.push({x:c,y:u,exitDirection:e,isChokePoint:0}):s.push({x:c,y:u,exitDirection:e,isChokePoint:0}))}}}return{walls:o,ramparts:s}}(e.name),i=[],a=[],c=[...n.ramparts];for(const e of n.walls){const t=`${e.x},${e.y}`;s.has(t)?(i.push(e),c.push(e)):a.push(e)}const u=[],l=e.find(FIND_STRUCTURES);for(const e of l)if(e.structureType===STRUCTURE_WALL){const t=`${e.pos.x},${e.pos.y}`;s.has(t)&&u.push({x:e.pos.x,y:e.pos.y})}return{walls:a,ramparts:c,roadCrossings:i,wallsToRemove:u}}(e,t,r,n),a=e.find(FIND_MY_CONSTRUCTION_SITES),c=e.find(FIND_STRUCTURES);if(a.length>=10)return{sitesPlaced:0,wallsRemoved:0};let u=0,l=0;const m=Math.min(s,10-a.length),p=c.filter(e=>e.structureType===STRUCTURE_WALL).length+a.filter(e=>e.structureType===STRUCTURE_WALL).length,d=c.filter(e=>e.structureType===STRUCTURE_RAMPART).length+a.filter(e=>e.structureType===STRUCTURE_RAMPART).length,g=2>o?0:2500,f=2>o?0:2500;if(o>=3&&i.wallsToRemove.length>0)for(const e of i.wallsToRemove){const t=c.find(t=>t.structureType===STRUCTURE_WALL&&t.pos.x===e.x&&t.pos.y===e.y);if(t&&!c.some(t=>t.structureType===STRUCTURE_RAMPART&&t.pos.x===e.x&&t.pos.y===e.y)){const r=t.destroy();r===OK?(l++,Q.info(`Removed wall at (${e.x},${e.y}) to allow road passage`,{subsystem:"Defense"})):Q.warn(`Failed to remove wall at (${e.x},${e.y}): ${r}`,{subsystem:"Defense"})}}if(o>=2&&m>u&&g>p)for(const t of i.walls){if(u>=m)break;if(p+u>=g)break;const r=c.some(e=>e.pos.x===t.x&&e.pos.y===t.y&&(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART)),o=a.some(e=>e.pos.x===t.x&&e.pos.y===t.y&&(e.structureType===STRUCTURE_WALL||e.structureType===STRUCTURE_RAMPART));r||o||e.createConstructionSite(t.x,t.y,STRUCTURE_WALL)===OK&&(u++,Q.debug(`Placed perimeter wall at (${t.x},${t.y})`,{subsystem:"Defense"}))}if(o>=3&&m>u&&f>d)for(const t of i.ramparts){if(u>=m)break;if(d+u>=f)break;const r=c.some(e=>e.pos.x===t.x&&e.pos.y===t.y&&e.structureType===STRUCTURE_RAMPART),o=a.some(e=>e.pos.x===t.x&&e.pos.y===t.y&&e.structureType===STRUCTURE_RAMPART),s=c.some(e=>e.pos.x===t.x&&e.pos.y===t.y&&e.structureType===STRUCTURE_WALL);r||o||s||e.createConstructionSite(t.x,t.y,STRUCTURE_RAMPART)===OK&&(u++,i.roadCrossings.some(e=>e.x===t.x&&e.y===t.y)?Q.debug(`Placed rampart at road crossing (${t.x},${t.y})`,{subsystem:"Defense"}):Q.debug(`Placed rampart gap at (${t.x},${t.y})`,{subsystem:"Defense"}))}return{sitesPlaced:u,wallsRemoved:l}}(e,u,m.roads,a,r,t.remoteAssignments),p.wallsRemoved>0&&Ce.addRoomEvent(this.roomName,"wallRemoved",p.wallsRemoved+" wall(s) removed to allow road passage")}const d=function(e,t,r){var o,s,n,i,a,c;const u=null!==(s=null===(o=e.controller)||void 0===o?void 0:o.level)&&void 0!==s?s:1,l=Xr(r,u),m=e.getTerrain(),p=[];if(u>=6){const r=e.find(FIND_MINERALS);if(r.length>0){const e=r[0];p.push({x:e.pos.x-t.x,y:e.pos.y-t.y,structureType:STRUCTURE_EXTRACTOR})}}const d=[...l,...p];let g=0;const f=e.find(FIND_MY_CONSTRUCTION_SITES),R=e.find(FIND_STRUCTURES);if(f.length>=10)return 0;const h={};for(const e of R){const t=e.structureType;h[t]=(null!==(n=h[t])&&void 0!==n?n:0)+1}for(const e of f){const t=e.structureType;h[t]=(null!==(i=h[t])&&void 0!==i?i:0)+1}const y=zr(u);for(const r of d){const o=null!==(a=h[r.structureType])&&void 0!==a?a:0;if(o>=(null!==(c=y[r.structureType])&&void 0!==c?c:0))continue;const s=t.x+r.x,n=t.y+r.y;if(!(1>s||s>48||1>n||n>48||m.get(s,n)===TERRAIN_MASK_WALL||R.some(e=>e.pos.x===s&&e.pos.y===n&&e.structureType===r.structureType)||f.some(e=>e.pos.x===s&&e.pos.y===n&&e.structureType===r.structureType)||e.createConstructionSite(s,n,r.structureType)!==OK||(g++,h[r.structureType]=o+1,3>g&&10>f.length+g)))break}if(3>g&&10>f.length+g)for(const o of r.roads){const r=t.x+o.x,s=t.y+o.y;if(!(1>r||r>48||1>s||s>48||m.get(r,s)===TERRAIN_MASK_WALL||R.some(e=>e.pos.x===r&&e.pos.y===s&&e.structureType===STRUCTURE_ROAD)||f.some(e=>e.pos.x===r&&e.pos.y===s&&e.structureType===STRUCTURE_ROAD)||e.createConstructionSite(r,s,STRUCTURE_ROAD)!==OK||(g++,3>g&&10>f.length+g)))break}return g}(e,u,m),g=function(e,t,r=3){const o=e.find(FIND_MY_CONSTRUCTION_SITES);if(o.length>=10)return 0;const s=$r(e,t),n=e.getTerrain(),i=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_ROAD}),a=new Set(i.map(e=>`${e.pos.x},${e.pos.y}`)),c=new Set(o.filter(e=>e.structureType===STRUCTURE_ROAD).map(e=>`${e.pos.x},${e.pos.y}`));let u=0;for(const t of s.positions){if(u>=r)break;if(o.length+u>=10)break;if(a.has(t))continue;if(c.has(t))continue;const[s,i]=t.split(","),l=parseInt(s,10),m=parseInt(i,10);n.get(l,m)!==TERRAIN_MASK_WALL&&e.createConstructionSite(l,m,STRUCTURE_ROAD)===OK&&u++}return u}(e,u,2);let f={placed:0,needsRepair:0,totalCritical:0,protected:0};if(a>=2&&9>i.length){const r=2>t.danger?2:3;f=function(e,t,r,o=5){const s={placed:0,needsRepair:0,totalCritical:0,protected:0};if(2>t)return s;const n=function(e,t){const r=e.find(FIND_MY_STRUCTURES),o=4>t?go:po;return r.filter(e=>o.includes(e.structureType))}(e,t);if(s.totalCritical=n.length,0===n.length)return s;const i=e.find(FIND_MY_CONSTRUCTION_SITES);if(i.length>=10)return s;const a=Math.min(o,10-i.length),c=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_RAMPART}),u=no(t,r),l=[];for(const t of n){const{x:o,y:n}=t.pos;if(fo(e,o,n)){s.protected++;const e=c.find(e=>e.pos.x===o&&e.pos.y===n);e&&e.hits<u&&s.needsRepair++}else if(!Ro(e,o,n)){let e=10;t.structureType===STRUCTURE_SPAWN?e=100:t.structureType===STRUCTURE_STORAGE?e=90:t.structureType===STRUCTURE_TOWER?e=80:t.structureType===STRUCTURE_TERMINAL?e=70:t.structureType===STRUCTURE_LAB&&(e=60),2>r||(e+=50),l.push({structure:t,priority:e})}}l.sort((e,t)=>t.priority-e.priority);for(const{structure:t}of l){if(s.placed>=a)break;const{x:r,y:o}=t.pos,n=e.createConstructionSite(r,o,STRUCTURE_RAMPART);if(n===OK)s.placed++,Q.debug(`Placed rampart on ${t.structureType} at (${r},${o})`,{subsystem:"Defense"});else if(n===ERR_FULL)break}return(s.placed>0||l.length>0)&&Q.info(`Rampart automation for ${e.name}: ${s.protected}/${s.totalCritical} protected, `+s.placed+" placed, "+(l.length-s.placed)+" pending",{subsystem:"Defense"}),s}(e,a,t.danger,r),f.placed>0&&Ce.addRoomEvent(this.roomName,"rampartPlaced",f.placed+" rampart(s) placed on critical structures")}t.metrics.constructionSites=i.length+d+g+p.sitesPlaced+f.placed}runResourceProcessing(e,t){var r,o;const s=null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0;6>s||this.runLabs(e),7>s||this.runFactory(e),8>s||this.runPowerSpawn(e),this.runLinks(e)}runLabs(e){const t=Ce.getSwarmState(e.name);if(!t)return;Ft.initialize(e.name),So.prepareLabs(e,t);const r=To.planReactions(e,t);if(r){const t={product:r.product,input1:r.input1,input2:r.input2,amountNeeded:1e3,priority:r.priority};if(Ft.areLabsReady(e.name,t)){const t=Ht.getConfig(e.name),o=null==t?void 0:t.activeReaction;o&&o.input1===r.input1&&o.input2===r.input2&&o.output===r.product||Ft.setActiveReaction(e.name,r.input1,r.input2,r.product),To.executeReaction(e,r)}else Q.debug(`Labs not ready for reaction: ${r.input1} + ${r.input2} -> ${r.product}`,{subsystem:"Labs",room:e.name})}Ft.save(e.name)}runFactory(e){const t=Mo(e).factory;if(!t||t.cooldown>0)return;const r=[RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_HYDROGEN,RESOURCE_OXYGEN];for(const e of r)if(t.store.getUsedCapacity(e)>=500&&t.store.getUsedCapacity(RESOURCE_ENERGY)>=200&&t.produce(RESOURCE_UTRIUM_BAR)===OK)break}runPowerSpawn(e){const t=Mo(e).powerSpawn;t&&(1>t.store.getUsedCapacity(RESOURCE_POWER)||50>t.store.getUsedCapacity(RESOURCE_ENERGY)||t.processPower())}runLinks(e){const t=Mo(e),r=t.links;if(2>r.length)return;const o=e.storage;if(!o)return;const s=r.find(e=>2>=e.pos.getRangeTo(o));if(!s)return;const n=t.sources,i=r.filter(e=>n.some(t=>2>=e.pos.getRangeTo(t))),a=e.controller,c=a?r.find(e=>3>=e.pos.getRangeTo(a)&&e.id!==s.id):void 0;for(const e of i)if(e.store.getUsedCapacity(RESOURCE_ENERGY)>=400&&0===e.cooldown&&s.store.getFreeCapacity(RESOURCE_ENERGY)>=400)return void e.transferEnergy(s);if(c&&0===s.cooldown){const e=400>c.store.getUsedCapacity(RESOURCE_ENERGY),t=s.store.getUsedCapacity(RESOURCE_ENERGY)>=400;e&&t&&s.transferEnergy(c)}}}const bo=new class{constructor(){this.nodes=new Map}run(){var e;const t=global,r=t._ownedRooms,o=t._ownedRoomsTick;let s;s=r&&o===Game.time?r:Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});const n=s.length;for(const e of s)this.nodes.has(e.name)||this.nodes.set(e.name,new No(e.name));for(const[t]of this.nodes){const r=Game.rooms[t];r&&(null===(e=r.controller)||void 0===e?void 0:e.my)||this.nodes.delete(t)}for(const e of this.nodes.values())try{e.run(n)}catch(t){const r=t instanceof Error?t.message:t+"";console.log(`[RoomManager] ERROR in room ${e.roomName}: ${r}`),t instanceof Error&&t.stack&&console.log(t.stack)}}getNode(e){return this.nodes.get(e)}getAllNodes(){return Array.from(this.nodes.values())}runRoom(e){var t;if(!(null===(t=e.controller)||void 0===t?void 0:t.my))return;this.nodes.has(e.name)||this.nodes.set(e.name,new No(e.name));const r=global,o=r._ownedRooms,s=r._ownedRoomsTick;let n;n=o&&s===Game.time?o.length:Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}).length;const i=this.nodes.get(e.name);try{i.run(n)}catch(t){const r=t instanceof Error?t.message:t+"";console.log(`[RoomManager] ERROR in room ${e.name}: ${r}`),t instanceof Error&&t.stack&&console.log(t.stack)}}};function wo(e){var t,r,o;return e.find(FIND_HOSTILE_CREEPS).length>0?me.CRITICAL:(null===(t=e.controller)||void 0===t?void 0:t.my)?me.HIGH:"ralphschuler"===(null===(o=null===(r=e.controller)||void 0===r?void 0:r.reservation)||void 0===o?void 0:o.username)?me.MEDIUM:me.LOW}function Io(e){var t;if(!(null===(t=e.controller)||void 0===t?void 0:t.my))return.02;const r=e.controller.level;return e.find(FIND_HOSTILE_CREEPS).length>0?.12:r>3?r>6?.08:.06:.04}const xo=new class{constructor(){this.registeredRooms=new Set,this.lastSyncTick=-1}syncRoomProcesses(){if(this.lastSyncTick===Game.time)return;this.lastSyncTick=Game.time;const e=new Set;for(const t in Game.rooms){const r=Game.rooms[t];e.add(t);const o="room:"+t,s=ge.getProcess(o),n=wo(r),i=Io(r);this.registeredRooms.has(t)?s&&(s.priority!==n||Math.abs(s.cpuBudget-i)>1e-4)&&this.updateRoomProcess(r,n,i):this.registerRoomProcess(r)}for(const t of this.registeredRooms)e.has(t)||this.unregisterRoomProcess(t)}registerRoomProcess(e){var t;const r=wo(e),o=Io(e),s="room:"+e.name;ge.registerProcess({id:s,name:`Room ${e.name}${(null===(t=e.controller)||void 0===t?void 0:t.my)?" (owned)":""}`,priority:r,frequency:"high",interval:1,minBucket:this.getMinBucketForPriority(r),cpuBudget:o,execute:()=>{const t=Game.rooms[e.name];t&&bo.runRoom(t)}}),this.registeredRooms.add(e.name),Q.debug(`Registered room process: ${e.name} with priority ${r}`,{subsystem:"RoomProcessManager"})}updateRoomProcess(e,t,r){var o;const s="room:"+e.name;ge.unregisterProcess(s),ge.registerProcess({id:s,name:`Room ${e.name}${(null===(o=e.controller)||void 0===o?void 0:o.my)?" (owned)":""}`,priority:t,frequency:"high",interval:1,minBucket:this.getMinBucketForPriority(t),cpuBudget:r,execute:()=>{const t=Game.rooms[e.name];t&&bo.runRoom(t)}}),Q.debug(`Updated room process: ${e.name} priority=${t} budget=${r}`,{subsystem:"RoomProcessManager"})}unregisterRoomProcess(e){const t="room:"+e;ge.unregisterProcess(t),this.registeredRooms.delete(e),Q.debug("Unregistered room process: "+e,{subsystem:"RoomProcessManager"})}getMinBucketForPriority(e){return e<me.CRITICAL?e<me.HIGH?e<me.MEDIUM?5e3:2e3:500:100}getStats(){var e,t,r;const o={};let s=0;for(const n of this.registeredRooms){const i=Game.rooms[n];if(i){const n=wo(i),a=null!==(e=me[n])&&void 0!==e?e:"UNKNOWN";o[a]=(null!==(t=o[a])&&void 0!==t?t:0)+1,(null===(r=i.controller)||void 0===r?void 0:r.my)&&s++}}return{totalRooms:Object.keys(Game.rooms).length,registeredRooms:this.registeredRooms.size,roomsByPriority:o,ownedRooms:s}}forceResync(){this.lastSyncTick=-1,this.syncRoomProcesses()}reset(){this.registeredRooms.clear(),this.lastSyncTick=-1}};class Go{setLogLevel(e){const t={debug:D.DEBUG,info:D.INFO,warn:D.WARN,error:D.ERROR,none:D.NONE}[e.toLowerCase()];return void 0===t?`Invalid log level: ${e}. Valid levels: debug, info, warn, error, none`:(W({level:t}),"Log level set to: "+e.toUpperCase())}toggleDebug(){const e=!ue().debug;return le({debug:e}),W({level:e?D.DEBUG:D.INFO}),`Debug mode: ${e?"ENABLED":"DISABLED"} (Log level: ${e?"DEBUG":"INFO"})`}}H([te({name:"setLogLevel",description:"Set the log level for the bot",usage:"setLogLevel(level)",examples:["setLogLevel('debug')","setLogLevel('info')","setLogLevel('warn')","setLogLevel('error')","setLogLevel('none')"],category:"Logging"})],Go.prototype,"setLogLevel",null),H([te({name:"toggleDebug",description:"Toggle debug mode on/off (affects log level and debug features)",usage:"toggleDebug()",examples:["toggleDebug()"],category:"Logging"})],Go.prototype,"toggleDebug",null);class Po{toggleVisualizations(){const e=!ue().visualizations;return le({visualizations:e}),"Visualizations: "+(e?"ENABLED":"DISABLED")}toggleVisualization(e){const t=Ge.getConfig(),r=Object.keys(t).filter(e=>e.startsWith("show")&&"boolean"==typeof t[e]);if(!r.includes(e))return`Invalid key: ${e}. Valid keys: ${r.join(", ")}`;const o=e;return Ge.toggle(o),`Room visualization '${e}': ${Ge.getConfig()[o]?"ENABLED":"DISABLED"}`}toggleMapVisualization(e){const t=De.getConfig(),r=Object.keys(t).filter(e=>e.startsWith("show")&&"boolean"==typeof t[e]);if(!r.includes(e))return`Invalid key: ${e}. Valid keys: ${r.join(", ")}`;const o=e;return De.toggle(o),`Map visualization '${e}': ${De.getConfig()[o]?"ENABLED":"DISABLED"}`}showMapConfig(){const e=De.getConfig();return Object.entries(e).map(([e,t])=>`${e}: ${t+""}`).join("\n")}}H([te({name:"toggleVisualizations",description:"Toggle all visualizations on/off",usage:"toggleVisualizations()",examples:["toggleVisualizations()"],category:"Visualization"})],Po.prototype,"toggleVisualizations",null),H([te({name:"toggleVisualization",description:"Toggle a specific room visualization feature",usage:"toggleVisualization(key)",examples:["toggleVisualization('showPheromones')","toggleVisualization('showPaths')","toggleVisualization('showCombat')"],category:"Visualization"})],Po.prototype,"toggleVisualization",null),H([te({name:"toggleMapVisualization",description:"Toggle a specific map visualization feature",usage:"toggleMapVisualization(key)",examples:["toggleMapVisualization('showRoomStatus')","toggleMapVisualization('showConnections')","toggleMapVisualization('showThreats')","toggleMapVisualization('showExpansion')"],category:"Visualization"})],Po.prototype,"toggleMapVisualization",null),H([te({name:"showMapConfig",description:"Show current map visualization configuration",usage:"showMapConfig()",examples:["showMapConfig()"],category:"Visualization"})],Po.prototype,"showMapConfig",null);class ko{showStats(){const e=Se.getLatestStats();return e?`=== SwarmBot Stats (Tick ${e.tick}) ===\nCPU: ${e.cpuUsed.toFixed(2)}/${e.cpuLimit} (Bucket: ${e.cpuBucket})\nGCL: ${e.gclLevel} (${(100*e.gclProgress).toFixed(1)}%)\nGPL: ${e.gplLevel}\nCreeps: ${e.totalCreeps}\nRooms: ${e.totalRooms}\n${e.rooms.map(e=>`  ${e.roomName}: RCL${e.rcl} | ${e.creepCount} creeps | ${e.storageEnergy}E`).join("\n")}`:"No stats available yet. Wait for a few ticks."}toggleProfiling(){const e=!ue().profiling;return le({profiling:e}),be.setEnabled(e),W({cpuLogging:e}),"Profiling: "+(e?"ENABLED":"DISABLED")}}H([te({name:"showStats",description:"Show current bot statistics from memory segment",usage:"showStats()",examples:["showStats()"],category:"Statistics"})],ko.prototype,"showStats",null),H([te({name:"toggleProfiling",description:"Toggle CPU profiling on/off",usage:"toggleProfiling()",examples:["toggleProfiling()"],category:"Statistics"})],ko.prototype,"toggleProfiling",null);class Lo{showConfig(){const e=ue(),t=B();return`=== SwarmBot Config ===\nDebug: ${e.debug+""}\nProfiling: ${e.profiling+""}\nVisualizations: ${e.visualizations+""}\nLogger Level: ${D[t.level]}\nCPU Logging: ${t.cpuLogging+""}`}}H([te({name:"showConfig",description:"Show current bot configuration",usage:"showConfig()",examples:["showConfig()"],category:"Configuration"})],Lo.prototype,"showConfig",null);class Do{showKernelStats(){const e=ge.getStatsSummary(),t=ge.getConfig();let r=`=== Kernel Stats ===\nBucket Mode: ${ge.getBucketMode().toUpperCase()}\nCPU Bucket: ${Game.cpu.bucket}\nCPU Limit: ${ge.getCpuLimit().toFixed(2)} (${(100*t.targetCpuUsage).toFixed(0)}% of ${Game.cpu.limit})\nRemaining CPU: ${ge.getRemainingCpu().toFixed(2)}\n\nProcesses: ${e.totalProcesses} total (${e.activeProcesses} active, ${e.suspendedProcesses} suspended)\nTotal CPU Used: ${e.totalCpuUsed.toFixed(3)}\nAvg CPU/Process: ${e.avgCpuPerProcess.toFixed(4)}\n\nTop CPU Consumers:`;for(const t of e.topCpuProcesses)r+=`\n  ${t.name}: ${t.avgCpu.toFixed(4)} avg CPU`;return r}listProcesses(){const e=ge.getProcesses();if(0===e.length)return"No processes registered with kernel.";let t="=== Registered Processes ===\n";t+="ID | Name | Priority | Frequency | State | Runs | Avg CPU | Skipped | Errors\n",t+="-".repeat(90)+"\n";const r=[...e].sort((e,t)=>t.priority-e.priority);for(const e of r){const r=e.stats.avgCpu.toFixed(4);t+=`${e.id} | ${e.name} | ${e.priority} | ${e.frequency} | ${e.state} | ${e.stats.runCount} | ${r} | ${e.stats.skippedCount} | ${e.stats.errorCount}\n`}return t}suspendProcess(e){return ge.suspendProcess(e)?`Process "${e}" suspended.`:`Process "${e}" not found.`}resumeProcess(e){return ge.resumeProcess(e)?`Process "${e}" resumed.`:`Process "${e}" not found or not suspended.`}resetKernelStats(){return ge.resetStats(),"Kernel statistics reset."}showCreepStats(){const e=_r.getStats();let t=`=== Creep Process Stats ===\nTotal Creeps: ${e.totalCreeps}\nRegistered Processes: ${e.registeredCreeps}\n\nCreeps by Priority:`;for(const[r,o]of Object.entries(e.creepsByPriority))t+=`\n  ${r}: ${o}`;return t}showRoomStats(){const e=xo.getStats();let t=`=== Room Process Stats ===\nTotal Rooms: ${e.totalRooms}\nRegistered Processes: ${e.registeredRooms}\nOwned Rooms: ${e.ownedRooms}\n\nRooms by Priority:`;for(const[r,o]of Object.entries(e.roomsByPriority))t+=`\n  ${r}: ${o}`;return t}listCreepProcesses(e){let t=ge.getProcesses().filter(e=>e.id.startsWith("creep:"));if(e&&(t=t.filter(t=>t.name.includes(`(${e})`))),0===t.length)return e?"No creep processes found with role: "+e:"No creep processes registered.";let r=e?`=== Creep Processes (Role: ${e}) ===\n`:"=== All Creep Processes ===\n";r+="Name | Priority | Runs | Avg CPU | Errors\n",r+="-".repeat(70)+"\n";const o=[...t].sort((e,t)=>t.priority-e.priority);for(const e of o){const t=e.stats.avgCpu.toFixed(4);r+=`${e.name} | ${e.priority} | ${e.stats.runCount} | ${t} | ${e.stats.errorCount}\n`}return r+=`\nTotal: ${t.length} creep processes`,r}listRoomProcesses(){const e=ge.getProcesses().filter(e=>e.id.startsWith("room:"));if(0===e.length)return"No room processes registered.";let t="=== Room Processes ===\n";t+="Name | Priority | Runs | Avg CPU | Errors\n",t+="-".repeat(70)+"\n";const r=[...e].sort((e,t)=>t.priority-e.priority);for(const e of r){const r=e.stats.avgCpu.toFixed(4);t+=`${e.name} | ${e.priority} | ${e.stats.runCount} | ${r} | ${e.stats.errorCount}\n`}return t+=`\nTotal: ${e.length} room processes`,t}}H([te({name:"showKernelStats",description:"Show kernel statistics including CPU usage and process info",usage:"showKernelStats()",examples:["showKernelStats()"],category:"Kernel"})],Do.prototype,"showKernelStats",null),H([te({name:"listProcesses",description:"List all registered kernel processes",usage:"listProcesses()",examples:["listProcesses()"],category:"Kernel"})],Do.prototype,"listProcesses",null),H([te({name:"suspendProcess",description:"Suspend a kernel process by ID",usage:"suspendProcess(processId)",examples:["suspendProcess('empire:manager')","suspendProcess('cluster:manager')"],category:"Kernel"})],Do.prototype,"suspendProcess",null),H([te({name:"resumeProcess",description:"Resume a suspended kernel process",usage:"resumeProcess(processId)",examples:["resumeProcess('empire:manager')"],category:"Kernel"})],Do.prototype,"resumeProcess",null),H([te({name:"resetKernelStats",description:"Reset all kernel process statistics",usage:"resetKernelStats()",examples:["resetKernelStats()"],category:"Kernel"})],Do.prototype,"resetKernelStats",null),H([te({name:"showCreepStats",description:"Show statistics about creep processes managed by the kernel",usage:"showCreepStats()",examples:["showCreepStats()"],category:"Kernel"})],Do.prototype,"showCreepStats",null),H([te({name:"showRoomStats",description:"Show statistics about room processes managed by the kernel",usage:"showRoomStats()",examples:["showRoomStats()"],category:"Kernel"})],Do.prototype,"showRoomStats",null),H([te({name:"listCreepProcesses",description:"List all creep processes with their details",usage:"listCreepProcesses(role?)",examples:["listCreepProcesses()","listCreepProcesses('harvester')"],category:"Kernel"})],Do.prototype,"listCreepProcesses",null),H([te({name:"listRoomProcesses",description:"List all room processes with their details",usage:"listRoomProcesses()",examples:["listRoomProcesses()"],category:"Kernel"})],Do.prototype,"listRoomProcesses",null);class $o{listCommands(){return ee.generateHelp()}commandHelp(e){return ee.generateCommandHelp(e)}}H([te({name:"listCommands",description:"List all available commands (alias for help)",usage:"listCommands()",examples:["listCommands()"],category:"System"})],$o.prototype,"listCommands",null),H([te({name:"commandHelp",description:"Get detailed help for a specific command",usage:"commandHelp(commandName)",examples:["commandHelp('setLogLevel')","commandHelp('suspendProcess')"],category:"System"})],$o.prototype,"commandHelp",null);const Yo=new Go,Ko=new Po,Ho=new ko,Fo=new Lo,Wo=new Do,Bo=new $o,Vo=[{carryParts:4,capacity:200,moveParts:4,cost:400},{carryParts:8,capacity:400,moveParts:8,cost:800},{carryParts:16,capacity:800,moveParts:16,cost:1600},{carryParts:24,capacity:1200,moveParts:24,cost:2400}];function qo(e,t,r,o){const s=function(e,t){const r=e=>{const t=e.match(/^([WE])(\d+)([NS])(\d+)$/);return t?{x:"W"===t[1]?-parseInt(t[2],10):parseInt(t[2],10),y:"N"===t[3]?parseInt(t[4],10):-parseInt(t[4],10)}:{x:0,y:0}},o=r(e),s=r(t);return Math.abs(s.x-o.x)+Math.abs(s.y-o.y)}(e,t),n=function(e,t=1.2){return Math.ceil(50*e*t*2)}(s),i=10*r;let a=Vo[0];for(const e of Vo){if(e.cost>o)break;a=e}const c=Math.max(1,Math.ceil(i*n/a.capacity*1.2)),u=Math.min(2*r,c+1);return Q.debug(`Remote hauler calculation: ${e} -> ${t} (${r} sources, ${s} rooms away) - RT: ${n} ticks, E/tick: ${i}, Min: ${c}, Rec: ${u}, Cap: ${a.capacity}`,{subsystem:"HaulerDimensioning"}),{minHaulers:c,recommendedHaulers:u,haulerConfig:a,distance:s,roundTripTicks:n,energyPerTick:i}}function jo(e){const t={[MOVE]:50,[WORK]:100,[CARRY]:50,[ATTACK]:80,[RANGED_ATTACK]:150,[HEAL]:250,[CLAIM]:600,[TOUGH]:10};return e.reduce((e,r)=>e+t[r],0)}function Xo(e,t=0){return{parts:e,cost:jo(e),minCapacity:t||jo(e)}}const zo={larvaWorker:{role:"larvaWorker",family:"economy",bodies:[Xo([WORK,CARRY],150),Xo([WORK,CARRY,MOVE],200),Xo([WORK,WORK,CARRY,CARRY,MOVE,MOVE],400),Xo([WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE],600),Xo([WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],800)],priority:100,maxPerRoom:3,remoteRole:0},harvester:{role:"harvester",family:"economy",bodies:[Xo([WORK,WORK,MOVE],250),Xo([WORK,WORK,WORK,WORK,MOVE,MOVE],500),Xo([WORK,WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE],700),Xo([WORK,WORK,WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE],800),Xo([WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE,MOVE],1e3)],priority:95,maxPerRoom:2,remoteRole:0},hauler:{role:"hauler",family:"economy",bodies:[Xo([CARRY,CARRY,MOVE,MOVE],200),Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],400),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],800),Xo([...Array(16).fill(CARRY),...Array(16).fill(MOVE)],1600)],priority:90,maxPerRoom:2,remoteRole:1},upgrader:{role:"upgrader",family:"economy",bodies:[Xo([WORK,CARRY,MOVE],200),Xo([WORK,WORK,WORK,CARRY,MOVE,MOVE],450),Xo([WORK,WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],1e3),Xo([WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1700)],priority:60,maxPerRoom:2,remoteRole:0},builder:{role:"builder",family:"economy",bodies:[Xo([WORK,CARRY,MOVE,MOVE],250),Xo([WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],650),Xo([WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1400)],priority:70,maxPerRoom:2,remoteRole:0},queenCarrier:{role:"queenCarrier",family:"economy",bodies:[Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE],300),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE],450),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],600)],priority:85,maxPerRoom:1,remoteRole:0},mineralHarvester:{role:"mineralHarvester",family:"economy",bodies:[Xo([WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE],550),Xo([WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE],850)],priority:40,maxPerRoom:1,remoteRole:0},labTech:{role:"labTech",family:"economy",bodies:[Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],400),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],600)],priority:35,maxPerRoom:1,remoteRole:0},factoryWorker:{role:"factoryWorker",family:"economy",bodies:[Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],400),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],600)],priority:35,maxPerRoom:1,remoteRole:0},remoteHarvester:{role:"remoteHarvester",family:"economy",bodies:[Xo([WORK,WORK,CARRY,MOVE,MOVE,MOVE],400),Xo([WORK,WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],750),Xo([WORK,WORK,WORK,WORK,WORK,WORK,WORK,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1050),Xo([WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1600)],priority:75,maxPerRoom:6,remoteRole:1},remoteHauler:{role:"remoteHauler",family:"economy",bodies:[Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],400),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],800),Xo([...Array(16).fill(CARRY),...Array(16).fill(MOVE)],1600)],priority:70,maxPerRoom:6,remoteRole:1},interRoomCarrier:{role:"interRoomCarrier",family:"economy",bodies:[Xo([CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],400),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],600),Xo([CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],800)],priority:90,maxPerRoom:4,remoteRole:0},guard:{role:"guard",family:"military",bodies:[Xo([TOUGH,ATTACK,MOVE,MOVE],190),Xo([TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE],500),Xo([TOUGH,TOUGH,TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,RANGED_ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1070)],priority:80,maxPerRoom:2,remoteRole:0},remoteGuard:{role:"remoteGuard",family:"military",bodies:[Xo([TOUGH,ATTACK,MOVE,MOVE],190),Xo([TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE],500),Xo([TOUGH,TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,ATTACK,RANGED_ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],880)],priority:85,maxPerRoom:4,remoteRole:1},healer:{role:"healer",family:"military",bodies:[Xo([HEAL,MOVE],300),Xo([HEAL,HEAL,MOVE,MOVE],600),Xo([HEAL,HEAL,HEAL,HEAL,MOVE,MOVE,MOVE,MOVE],1200)],priority:75,maxPerRoom:1,remoteRole:0},soldier:{role:"soldier",family:"military",bodies:[Xo([ATTACK,ATTACK,MOVE,MOVE],260),Xo([ATTACK,ATTACK,ATTACK,ATTACK,MOVE,MOVE,MOVE,MOVE],520),Xo([TOUGH,TOUGH,TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,RANGED_ATTACK,RANGED_ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1340)],priority:70,maxPerRoom:2,remoteRole:0},siegeUnit:{role:"siegeUnit",family:"military",bodies:[Xo([WORK,WORK,MOVE,MOVE],300),Xo([TOUGH,TOUGH,WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],620),Xo([TOUGH,TOUGH,TOUGH,TOUGH,WORK,WORK,WORK,WORK,WORK,WORK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],1040)],priority:50,maxPerRoom:2,remoteRole:0},ranger:{role:"ranger",family:"military",bodies:[Xo([RANGED_ATTACK,MOVE],200),Xo([RANGED_ATTACK,RANGED_ATTACK,MOVE,MOVE],400),Xo([RANGED_ATTACK,RANGED_ATTACK,RANGED_ATTACK,RANGED_ATTACK,MOVE,MOVE,MOVE,MOVE],800)],priority:65,maxPerRoom:2,remoteRole:0},scout:{role:"scout",family:"utility",bodies:[Xo([MOVE],50)],priority:65,maxPerRoom:2,remoteRole:1},claimer:{role:"claimer",family:"utility",bodies:[Xo([CLAIM,MOVE],650),Xo([CLAIM,CLAIM,MOVE,MOVE],1300)],priority:50,maxPerRoom:3,remoteRole:1},engineer:{role:"engineer",family:"utility",bodies:[Xo([WORK,CARRY,MOVE,MOVE],250),Xo([WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],500)],priority:55,maxPerRoom:2,remoteRole:0},remoteWorker:{role:"remoteWorker",family:"utility",bodies:[Xo([WORK,WORK,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE],500),Xo([WORK,WORK,WORK,CARRY,CARRY,CARRY,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],750)],priority:45,maxPerRoom:4,remoteRole:1},powerHarvester:{role:"powerHarvester",family:"power",bodies:[Xo([TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],2300),Xo([TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,TOUGH,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,ATTACK,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE,MOVE],3e3)],priority:30,maxPerRoom:2,remoteRole:1},powerCarrier:{role:"powerCarrier",family:"power",bodies:[Xo([...Array(20).fill(CARRY),...Array(20).fill(MOVE)],2e3),Xo([...Array(25).fill(CARRY),...Array(25).fill(MOVE)],2500)],priority:25,maxPerRoom:2,remoteRole:1}};function Zo(e,t,r){let o=0;if("guard"!==r&&"ranger"!==r&&"healer"!==r||(o+=function(e,t,r){const o=io(e),s=ao(e);if(0===o.guards&&0===o.rangers&&0===o.healers)return 0;let n=0;return("guard"===r&&s.guards<o.guards||"ranger"===r&&s.rangers<o.rangers||"healer"===r&&s.healers<o.healers)&&(n=100*o.urgency),n}(e,0,r)),"upgrader"===r&&t.clusterId){const r=Ce.getCluster(t.clusterId);(null==r?void 0:r.focusRoom)===e.name&&(o+=40)}return o}function Qo(e,t){var r;const o={harvester:"harvest",hauler:"logistics",upgrader:"upgrade",builder:"build",guard:"defense",remoteGuard:"defense",healer:"defense",soldier:"war",siegeUnit:"siege",ranger:"war",scout:"expand",claimer:"expand",remoteWorker:"expand",engineer:"build",remoteHarvester:"harvest",remoteHauler:"logistics",interRoomCarrier:"logistics"}[e];return o?.5+(null!==(r=t[o])&&void 0!==r?r:0)/100*1.5:1}const Jo=new Map;let es=-1,ts=null;function rs(e,t=0){var r,o;es===Game.time&&ts===Game.creeps||(Jo.clear(),es=Game.time,ts=Game.creeps);const s=t?e+"_active":e,n=Jo.get(s);if(n)return n;const i=new Map;for(const s in Game.creeps){const n=Game.creeps[s],a=n.memory;if(a.homeRoom===e){if(t&&n.spawning)continue;const e=null!==(r=a.role)&&void 0!==r?r:"unknown";i.set(e,(null!==(o=i.get(e))&&void 0!==o?o:0)+1)}}return Jo.set(s,i),i}function os(e,t){let r=null;for(const o of e.bodies)o.cost>t||r&&o.cost<=r.cost||(r=o);return r}function ss(e,t,r){let o=0;for(const s of Object.values(Game.creeps)){const n=s.memory;n.homeRoom===e&&n.role===t&&n.targetRoom===r&&o++}return o}function ns(e,t,r){var o,s,n;const i=null!==(o=r.remoteAssignments)&&void 0!==o?o:[];if(0===i.length)return null;for(const r of i){const o=ss(e,t,r),i=Game.rooms[r];let a;if(a="remoteHarvester"===t?i?i.find(FIND_SOURCES).length:2:"remoteHauler"===t&&i?qo(e,r,i.find(FIND_SOURCES).length,null!==(n=null===(s=Game.rooms[e])||void 0===s?void 0:s.energyCapacityAvailable)&&void 0!==n?n:800).recommendedHaulers:2,a>o)return r}return null}function is(e,t,r){var o,s;const n=zo[t];if(!n)return 0;if("remoteHarvester"===t||"remoteHauler"===t)return null!==ns(e,t,r);if("remoteGuard"===t){const s=null!==(o=r.remoteAssignments)&&void 0!==o?o:[];if(0===s.length)return 0;for(const r of s){const o=Game.rooms[r];if(!o)continue;const s=o.find(FIND_HOSTILE_CREEPS).filter(e=>e.body.some(e=>e.type===ATTACK||e.type===RANGED_ATTACK||e.type===WORK));if(s.length>0){const o=ss(e,t,r);if(Math.min(n.maxPerRoom,Math.ceil(s.length/2))>o)return 1}}return 0}const i=null!==(s=rs(e).get(t))&&void 0!==s?s:0;let a=n.maxPerRoom;if("upgrader"===t&&r.clusterId){const t=Ce.getCluster(r.clusterId);if((null==t?void 0:t.focusRoom)===e){const t=Game.rooms[e];(null==t?void 0:t.controller)&&(a=t.controller.level>3?t.controller.level>6?6:4:2)}}if(i>=a)return 0;const c=Game.rooms[e];if(!c)return 0;if("scout"===t)return 0===i||"expand"===r.posture&&i<n.maxPerRoom?1:0;if("claimer"===t){const e=Ce.getOvermind(),t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),o=t.length<Game.gcl.level,s=e.claimQueue.some(e=>!e.claimed),n=function(e,t){var r,o,s,n;const i=null!==(r=t.remoteAssignments)&&void 0!==r?r:[];if(0===i.length)return 0;const a=function(){const e=Object.values(Game.spawns);return e.length>0?e[0].owner.username:""}();for(const e of i){const t=Game.rooms[e];if(null==t?void 0:t.controller){const r=t.controller;if(r.owner)continue;const i=(null===(o=r.reservation)||void 0===o?void 0:o.username)===a,c=null!==(n=null===(s=r.reservation)||void 0===s?void 0:s.ticksToEnd)&&void 0!==n?n:0;if((!i||3e3>c)&&!Object.values(Game.creeps).some(t=>{const r=t.memory;return"claimer"===r.role&&r.targetRoom===e}))return 1}else if(!Object.values(Game.creeps).some(t=>{const r=t.memory;return"claimer"===r.role&&r.targetRoom===e}))return 1}return 0}(0,r);return o&&s||n?1:0}if("mineralHarvester"===t){const e=c.find(FIND_MINERALS)[0];if(!e)return 0;if(!e.pos.lookFor(LOOK_STRUCTURES).find(e=>e.structureType===STRUCTURE_EXTRACTOR))return 0;if(0===e.mineralAmount)return 0}if("labTech"===t&&3>c.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_LAB}).length)return 0;if("factoryWorker"===t&&0===c.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_FACTORY}).length)return 0;if("queenCarrier"===t&&!c.storage)return 0;if("builder"===t&&0===c.find(FIND_MY_CONSTRUCTION_SITES).length&&i>0)return 0;if("interRoomCarrier"===t){if(!r.clusterId)return 0;const e=Ce.getCluster(r.clusterId);if(!e||!e.resourceRequests||0===e.resourceRequests.length)return 0;if(!e.resourceRequests.some(e=>{if(e.fromRoom!==c.name)return 0;const t=e.assignedCreeps.filter(e=>Game.creeps[e]).length;return e.amount-e.delivered>500&&2>t}))return 0}return 1}function as(e){return`${e}_${Game.time}_${Math.floor(1e3*Math.random())}`}function cs(e){var t,r;return(null!==(t=e.get("harvester"))&&void 0!==t?t:0)+(null!==(r=e.get("larvaWorker"))&&void 0!==r?r:0)}const us=[{role:"larvaWorker",minCount:1},{role:"harvester",minCount:1},{role:"hauler",minCount:1},{role:"harvester",minCount:2},{role:"queenCarrier",minCount:1,condition:e=>!!e.storage},{role:"upgrader",minCount:1}];function ls(e,t){var r,o;const s=rs(e,1);if(0===cs(s))return 1;if(0===function(e){var t,r;return(null!==(t=e.get("hauler"))&&void 0!==t?t:0)+(null!==(r=e.get("larvaWorker"))&&void 0!==r?r:0)}(s)&&(null!==(r=s.get("harvester"))&&void 0!==r?r:0)>0)return 1;const n=rs(e,0);for(const e of us)if((!e.condition||e.condition(t))&&(null!==(o=n.get(e.role))&&void 0!==o?o:0)<e.minCount)return 1;return 0}function ms(e,t){var r,o;const s=e.find(FIND_MY_SPAWNS).find(e=>!e.spawning);if(!s)return;const n=e.energyCapacityAvailable,i=e.energyAvailable,a=0===cs(rs(e.name,1)),c=a?i:n;if(a&&150>i&&(Q.warn(`WORKFORCE COLLAPSE: ${i} energy available, need 150 to spawn minimal larvaWorker. Room will recover once energy reaches 150.`,{subsystem:"spawn",room:e.name}),ge.emit("spawn.emergency",{roomName:e.name,energyAvailable:i,message:"Critical workforce collapse - waiting for energy to spawn minimal creep",source:"SpawnManager"})),ls(e.name,e)&&Game.time%10==0){const t=rs(e.name,1),s=rs(e.name,0),a=null!==(r=t.get("larvaWorker"))&&void 0!==r?r:0;s.get("larvaWorker");const c=null!==(o=t.get("harvester"))&&void 0!==o?o:0;s.get("harvester"),Q.info(`BOOTSTRAP MODE: ${cs(t)} active energy producers (${a} larva, ${c} harvest), ${cs(s)} total. Energy: ${i}/${n}`,{subsystem:"spawn",room:e.name})}if(ls(e.name,e)){const r=function(e,t,r){var o;if(0===cs(rs(e,1)))return"larvaWorker";const s=rs(e,0);for(const n of us)if((!n.condition||n.condition(t))&&(null!==(o=s.get(n.role))&&void 0!==o?o:0)<n.minCount&&is(e,n.role,r))return n.role;return null}(e.name,e,t);if(!r)return;const o=zo[r];if(!o)return;const n=os(o,c);if(!n)return;if(i<n.cost)return;const a=as(r),u={role:o.role,family:o.family,homeRoom:e.name,version:1};if("remoteHarvester"===r||"remoteHauler"===r){const o=ns(e.name,r,t);if(!o)return;u.targetRoom=o}return void(s.spawnCreep(n.parts,a,{memory:u})===OK&&(Q.info(`BOOTSTRAP SPAWN: ${r} (${a}) with ${n.parts.length} parts, cost ${n.cost}. Recovery in progress.`,{subsystem:"spawn",room:e.name}),ge.emit("spawn.completed",{roomName:e.name,creepName:a,role:r,cost:n.cost,source:"SpawnManager"})))}const u=function(e,t){var r,o;const s=rs(e.name),n=function(e){switch(e){case"eco":return{harvester:1.5,hauler:1.2,upgrader:1.3,builder:1,queenCarrier:1,guard:.3,remoteGuard:.8,healer:.1,scout:1,claimer:.8,engineer:.8,remoteHarvester:1.2,remoteHauler:1.2,interRoomCarrier:1};case"expand":return{harvester:1.2,hauler:1,upgrader:.8,builder:1,queenCarrier:.8,guard:.3,remoteGuard:1,scout:1.5,claimer:1.5,remoteWorker:1.5,engineer:.5,remoteHarvester:1.5,remoteHauler:1.5,interRoomCarrier:1.2};case"defensive":return{harvester:1,hauler:1,upgrader:.5,builder:.5,queenCarrier:1,guard:2,remoteGuard:1.8,healer:1.5,ranger:1,scout:.8,engineer:1.2,remoteHarvester:.5,remoteHauler:.5,interRoomCarrier:1.5};case"war":return{harvester:.8,hauler:.8,upgrader:.3,builder:.3,queenCarrier:1,guard:2.5,healer:2,soldier:2,ranger:1.5,scout:.8,engineer:.5,remoteHarvester:.3,remoteHauler:.3,interRoomCarrier:.5};case"siege":return{harvester:.5,hauler:.5,upgrader:.1,builder:.1,queenCarrier:1,guard:3,healer:2.5,soldier:2.5,siegeUnit:2,ranger:1,scout:.5,engineer:.2,remoteHarvester:.1,remoteHauler:.1};case"evacuate":return{hauler:2,queenCarrier:1.5};case"nukePrep":return{harvester:1,hauler:1,upgrader:.5,builder:.5,queenCarrier:1,guard:1.5,scout:.5,engineer:2,remoteHarvester:.5,remoteHauler:.5};default:return{harvester:1,hauler:1,upgrader:1,builder:1,queenCarrier:1,scout:1,remoteHarvester:1,remoteHauler:1}}}(t.posture),i=[];for(const[a,c]of Object.entries(zo)){if(!is(e.name,a,t))continue;const u=c.priority,l=null!==(r=n[a])&&void 0!==r?r:.5,m=Qo(a,t.pheromones),p=Zo(e,t,a),d=null!==(o=s.get(a))&&void 0!==o?o:0,g=(u+p)*l*m*Math.max(.1,1-d/c.maxPerRoom);i.push({role:a,score:g})}return i.sort((e,t)=>t.score-e.score),i.map(e=>e.role)}(e,t);for(const r of u){const o=zo[r];if(!o)continue;let n=os(o,c);if(n&&i>=n.cost);else if(n=os(o,i),!n||i<n.cost)continue;const a=as(r),u={role:o.role,family:o.family,homeRoom:e.name,version:1};if("remoteHarvester"===r||"remoteHauler"===r){const o=ns(e.name,r,t);if(!o)continue;u.targetRoom=o}if("interRoomCarrier"===r&&t.clusterId){const r=Ce.getCluster(t.clusterId);if(r){const t=r.resourceRequests.find(t=>{if(t.fromRoom!==e.name)return 0;const r=t.assignedCreeps.filter(e=>Game.creeps[e]).length;return t.amount-t.delivered>500&&2>r});t&&(u.transferRequest={fromRoom:t.fromRoom,toRoom:t.toRoom,resourceType:t.resourceType,amount:t.amount},t.assignedCreeps.push(a))}}const l=s.spawnCreep(n.parts,a,{memory:u});if(l===OK)return void ge.emit("spawn.completed",{roomName:e.name,creepName:a,role:r,cost:n.cost,source:"SpawnManager"});if(l!==ERR_NOT_ENOUGH_ENERGY)return}}const ps=[],ds=new Set;function gs(e){return function(t,r,o){ps.push({options:e,methodName:r+"",target:t})}}function fs(e,t,r){return gs({id:e,name:t,priority:me.MEDIUM,frequency:"medium",minBucket:2e3,cpuBudget:.15,interval:5,...r})}function Rs(e,t,r){return gs({id:e,name:t,priority:me.LOW,frequency:"low",minBucket:5e3,cpuBudget:.1,interval:20,...r})}function hs(e,t,r){return gs({id:e,name:t,priority:me.IDLE,frequency:"low",minBucket:8e3,cpuBudget:.05,interval:100,...r})}function ys(){return function(e){return ds.add(e),e}}function Es(e){var t,r;const o=Object.getPrototypeOf(e);for(const s of ps)if(s.target===o||Object.getPrototypeOf(s.target)===o||s.target===Object.getPrototypeOf(o)){const o=e[s.methodName];if("function"==typeof o){const n=o.bind(e);ge.registerProcess({id:s.options.id,name:s.options.name,priority:null!==(t=s.options.priority)&&void 0!==t?t:me.MEDIUM,frequency:null!==(r=s.options.frequency)&&void 0!==r?r:"medium",minBucket:s.options.minBucket,cpuBudget:s.options.cpuBudget,interval:s.options.interval,execute:n}),Q.debug(`Registered decorated process "${s.options.name}" (${s.options.id})`,{subsystem:"ProcessDecorators"})}}}const Ts={minBucket:2e3,criticalEnergyThreshold:300,mediumEnergyThreshold:1e3,lowEnergyThreshold:3e3,surplusEnergyThreshold:1e4,minTransferAmount:500,maxRequestsPerRoom:3,requestTimeout:500,focusRoomMediumThreshold:5e3,focusRoomLowThreshold:15e3},Cs=new class{constructor(e={}){this.config={...Ts,...e}}processCluster(e){if(Game.cpu.bucket<this.config.minBucket)return;this.cleanupRequests(e);const t=this.getRoomStatuses(e).filter(e=>!e.hasTerminal);2>t.length||this.createTransferRequests(e,t)}cleanupRequests(e){e.resourceRequests=e.resourceRequests.filter(t=>{if(Game.time-t.createdAt>this.config.requestTimeout)return Q.debug(`Resource request from ${t.fromRoom} to ${t.toRoom} expired`,{subsystem:"ResourceSharing"}),0;if(t.delivered>=t.amount)return Q.info(`Resource transfer completed: ${t.delivered} ${t.resourceType} from ${t.fromRoom} to ${t.toRoom}`,{subsystem:"ResourceSharing"}),0;if(!e.memberRooms.includes(t.toRoom)||!e.memberRooms.includes(t.fromRoom))return 0;if(Game.rooms[t.toRoom]){const e=Ce.getSwarmState(t.toRoom);if(e&&0===e.metrics.energyNeed)return Q.debug(`Resource request from ${t.fromRoom} to ${t.toRoom} no longer needed`,{subsystem:"ResourceSharing"}),0}return 1})}getRoomStatuses(e){var t;const r=[];for(const o of e.memberRooms){const s=Game.rooms[o];if(!s||!(null===(t=s.controller)||void 0===t?void 0:t.my))continue;const n=Ce.getSwarmState(o);if(!n)continue;const i=e.focusRoom===o,{energyAvailable:a,energyCapacity:c}=this.calculateRoomEnergy(s),u=this.calculateEnergyNeed(s,a,n,i);let l=0;i?l=0:a>this.config.surplusEnergyThreshold&&(l=a-this.config.mediumEnergyThreshold);let m=0;3===u?m=this.config.criticalEnergyThreshold-a:2===u?m=this.config.mediumEnergyThreshold-a:1===u&&(m=this.config.lowEnergyThreshold-a),m=Math.max(m,i&&u>0?2*this.config.minTransferAmount:this.config.minTransferAmount),r.push({roomName:o,hasTerminal:void 0!==s.terminal&&s.terminal.my,energyAvailable:a,energyCapacity:c,energyNeed:u,canProvide:l,needsAmount:m}),n.metrics.energyAvailable=a,n.metrics.energyCapacity=c,n.metrics.energyNeed=u}return r}calculateRoomEnergy(e){let t=0,r=0;e.storage&&(t+=e.storage.store.getUsedCapacity(RESOURCE_ENERGY),r+=e.storage.store.getCapacity());const o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_CONTAINER});for(const e of o)t+=e.store.getUsedCapacity(RESOURCE_ENERGY),r+=e.store.getCapacity();return{energyAvailable:t,energyCapacity:r}}calculateEnergyNeed(e,t,r,o=0){return t<this.config.criticalEnergyThreshold?(e.find(FIND_MY_SPAWNS).length>0&&e.energyAvailable,3):o?t<this.config.focusRoomMediumThreshold?2:t<this.config.focusRoomLowThreshold?1:0:t<this.config.mediumEnergyThreshold?2:t<this.config.lowEnergyThreshold?1:0}createTransferRequests(e,t){const r=t.filter(e=>e.energyNeed>0).sort((e,t)=>t.energyNeed-e.energyNeed),o=t.filter(e=>e.canProvide>0).sort((e,t)=>t.canProvide-e.canProvide);if(0!==r.length&&0!==o.length)for(const t of r){if(e.resourceRequests.filter(e=>e.toRoom===t.roomName).length>=this.config.maxRequestsPerRoom)continue;let r=null,s=1/0;for(const n of o){if(n.roomName===t.roomName)continue;if(e.resourceRequests.some(e=>e.fromRoom===n.roomName&&e.toRoom===t.roomName))continue;const o=Game.map.getRoomLinearDistance(n.roomName,t.roomName);s>o&&n.canProvide>=this.config.minTransferAmount&&(s=o,r=n)}if(r&&3>=s){const o=Math.min(t.needsAmount,r.canProvide),n={toRoom:t.roomName,fromRoom:r.roomName,resourceType:RESOURCE_ENERGY,amount:o,priority:t.energyNeed,createdAt:Game.time,assignedCreeps:[],delivered:0};e.resourceRequests.push(n),Q.info(`Created resource transfer: ${o} energy from ${r.roomName} to ${t.roomName} (priority ${n.priority}, distance ${s})`,{subsystem:"ResourceSharing"}),r.canProvide-=o}}}getRequestsForRoom(e,t){return e.resourceRequests.filter(e=>e.toRoom===t||e.fromRoom===t)}updateRequestProgress(e,t,r){if(t>=0&&t<e.resourceRequests.length){const o=e.resourceRequests[t];o.delivered+=r,Q.debug(`Updated transfer progress: ${o.delivered}/${o.amount} from ${o.fromRoom} to ${o.toRoom}`,{subsystem:"ResourceSharing"})}}},vs={1:{guards:1,rangers:1,healers:0,siegeUnits:0},2:{guards:2,rangers:2,healers:1,siegeUnits:0},3:{guards:3,rangers:3,healers:2,siegeUnits:1}};function Ss(e,t){let r=e.coreRoom,o=1/0;for(const s of e.memberRooms){const e=Game.map.getRoomLinearDistance(s,t);o>e&&(o=e,r=s)}return r}function Us(e,t){const r=function(e){var t;const r=Math.min(3,Math.max(1,e.urgency)),o=null!==(t=vs[r])&&void 0!==t?t:vs[2];return{guards:Math.max(o.guards,e.guardsNeeded),rangers:Math.max(o.rangers,e.rangersNeeded),healers:Math.max(o.healers,e.healersNeeded),siegeUnits:o.siegeUnits}}(t),o=`defense_${t.roomName}_${Game.time}`,s=Ss(e,t.roomName),n={id:o,type:"defense",members:[],rallyRoom:s,targetRooms:[t.roomName],state:"gathering",createdAt:Game.time};return Q.info(`Created defense squad ${o} for ${t.roomName}: ${r.guards}G/${r.rangers}R/${r.healers}H rally at ${s}`,{subsystem:"Squad"}),n}function Os(e){const t=Game.time-e.createdAt;if("gathering"===e.state&&t>300)return Q.warn(`Squad ${e.id} timed out during formation (${t} ticks)`,{subsystem:"Squad"}),1;if(0===e.members.length&&t>50)return Q.info(`Squad ${e.id} has no members, dissolving`,{subsystem:"Squad"}),1;if("attacking"===e.state){const r=e.targetRooms[0];if(r){const o=Game.rooms[r];if(o&&0===o.find(FIND_HOSTILE_CREEPS).length&&t>100)return Q.info(`Squad ${e.id} mission complete, no more hostiles`,{subsystem:"Squad"}),1}}return 0}function _s(e){const t=e.members.length;e.members=e.members.filter(e=>Game.creeps[e]),e.members.length<t&&Q.debug(`Squad ${e.id} lost ${t-e.members.length} members`,{subsystem:"Squad"});const r=e.members.map(e=>Game.creeps[e]).filter(e=>!!e);if(0===r.length)return;const o=e.targetRooms[0];if(o)switch(e.state){case"gathering":r.every(t=>t.room.name===e.rallyRoom)&&(e.state="moving",Q.info(`Squad ${e.id} gathered, moving to ${o}`,{subsystem:"Squad"}));break;case"moving":r.some(e=>e.room.name===o)&&(e.state="attacking",Q.info(`Squad ${e.id} reached ${o}, engaging`,{subsystem:"Squad"}));break;case"attacking":Game.time-e.createdAt>50&&3>r.length&&(e.state="retreating",Q.warn(`Squad ${e.id} retreating - heavy casualties`,{subsystem:"Squad"}));break;case"retreating":r.every(t=>t.room.name===e.rallyRoom)&&(e.state="dissolving",Q.info(`Squad ${e.id} retreated to ${e.rallyRoom}, dissolving`,{subsystem:"Squad"}))}}RESOURCE_CATALYZED_GHODIUM_ALKALIDE,RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,RESOURCE_CATALYZED_GHODIUM_ALKALIDE,RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_KEANIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,RESOURCE_CATALYZED_GHODIUM_ALKALIDE,RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_ZYNTHIUM_ACID,RESOURCE_CATALYZED_KEANIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE;const As={0:0,1:5e3,2:15e3,3:5e4};function Ms(e,t){let r=As[t];const o=Ce.getClusters();for(const t in o)o[t].defenseRequests.some(t=>t.roomName===e&&t.urgency>=2)&&(r+=1e4);return r}function Ns(e,t,r){let o,s=0;for(const n of e.memberRooms){if(n===t)continue;const e=Game.rooms[n];if(!e||!e.storage)continue;const i=Ce.getSwarmState(n);if(!i)continue;const a=e.storage.store.getUsedCapacity(RESOURCE_ENERGY)-Ms(n,i.danger);a>r&&a>s&&(s=a,o=n)}if(!o)return Q.warn(`No available energy source for emergency routing to ${t} (need ${r})`,{subsystem:"MilitaryPool"}),{success:0};const n=Game.rooms[o],i=Game.rooms[t];return(null==n?void 0:n.terminal)&&(null==i?void 0:i.terminal)?n.terminal.send(RESOURCE_ENERGY,r,t)===OK?(Q.info(`Emergency energy routed: ${r} from ${o} to ${t}`,{subsystem:"MilitaryPool"}),{success:1,sourceRoom:o}):{success:0}:(Q.info(`Creating hauler transfer request: ${r} energy from ${o} to ${t}`,{subsystem:"MilitaryPool"}),e.resourceRequests.push({toRoom:t,fromRoom:o,resourceType:RESOURCE_ENERGY,amount:r,priority:5,createdAt:Game.time,assignedCreeps:[],delivered:0}),{success:1,sourceRoom:o})}const bs={harassment:{composition:{harassers:3,soldiers:0,rangers:1,healers:0,siegeUnits:0},targetPriority:{workers:100,military:50,spawns:20,towers:10,extensions:15,storage:10,defenses:5,labs:5},minEnergy:5e4,useBoosts:0,retreatThreshold:.5,creepSize:"small",engagement:{engageTowers:0,maxTowers:0,prioritizeDefenses:0}},raid:{composition:{harassers:1,soldiers:2,rangers:3,healers:2,siegeUnits:0},targetPriority:{military:100,towers:80,spawns:90,workers:60,extensions:50,storage:40,labs:30,defenses:20},minEnergy:1e5,useBoosts:0,retreatThreshold:.4,creepSize:"medium",engagement:{engageTowers:1,maxTowers:2,prioritizeDefenses:0}},siege:{composition:{harassers:0,soldiers:2,rangers:4,healers:3,siegeUnits:2},targetPriority:{towers:100,spawns:100,military:90,defenses:80,storage:70,labs:60,extensions:50,workers:40},minEnergy:2e5,useBoosts:1,retreatThreshold:.3,creepSize:"large",engagement:{engageTowers:1,maxTowers:6,prioritizeDefenses:1}}};function ws(e,t){var r,o,s,n;if(!t)return Q.debug(`No intel for ${e}, defaulting to harassment`,{subsystem:"Doctrine"}),"harassment";const i=null!==(r=t.towerCount)&&void 0!==r?r:0,a=null!==(o=t.spawnCount)&&void 0!==o?o:0,c=null!==(s=t.rcl)&&void 0!==s?s:0,u=3*i+2*a+1.5*(null!==(n=t.militaryPresence)&&void 0!==n?n:0)+.5*c;return 20>u&&7>c?10>u&&5>c?(Q.info(`Selected HARASSMENT doctrine for ${e} (threat: ${u})`,{subsystem:"Doctrine"}),"harassment"):(Q.info(`Selected RAID doctrine for ${e} (threat: ${u})`,{subsystem:"Doctrine"}),"raid"):(Q.info(`Selected SIEGE doctrine for ${e} (threat: ${u})`,{subsystem:"Doctrine"}),"siege")}function Is(e,t){var r;const o=bs[t];let s=0;for(const t of e.memberRooms){const e=Game.rooms[t];if(!e||!(null===(r=e.controller)||void 0===r?void 0:r.my))continue;const o=e.storage,n=e.terminal;o&&(s+=o.store.energy),n&&(s+=n.store.energy)}const n=s>=o.minEnergy;return n||Q.debug(`Cannot launch ${t}: insufficient energy (${s}/${o.minEnergy})`,{subsystem:"Doctrine"}),n}const xs={rclWeight:10,resourceWeight:5,strategicWeight:3,distancePenalty:2,weakDefenseBonus:20,strongDefensePenalty:15,warTargetBonus:50};function Gs(e,t,r,o){var s,n;let i=0;i+=e.controllerLevel*o.rclWeight,6>e.controllerLevel?4>e.controllerLevel||(i+=2*o.resourceWeight):i+=5*o.resourceWeight,i+=e.sources*o.strategicWeight,i-=t*o.distancePenalty;const a=null!==(s=e.towerCount)&&void 0!==s?s:0,c=null!==(n=e.spawnCount)&&void 0!==n?n:0;return 0!==a||c>1?4>a&&(2>a||2>c)||(i-=o.strongDefensePenalty):i+=o.weakDefenseBonus,r&&(i+=o.warTargetBonus),2>e.threatLevel||r||(i-=10*e.threatLevel),Math.max(0,i)}function Ps(e,t){let r=1/0;for(const o of e.memberRooms){const e=Game.map.getRoomLinearDistance(o,t);r>e&&(r=e)}return r}var ks;!function(e){e[e.EMERGENCY=1e3]="EMERGENCY",e[e.HIGH=500]="HIGH",e[e.NORMAL=100]="NORMAL",e[e.LOW=50]="LOW"}(ks||(ks={}));const Ls=new class{constructor(){this.queues=new Map}getQueue(e){return this.queues.has(e)||this.queues.set(e,{requests:[],inProgress:new Map,lastUpdate:Game.time}),this.queues.get(e)}addRequest(e){const t=this.getQueue(e.roomName);e.id||(e.id=`${e.role}_${Game.time}_${Math.random().toString(36).substring(2,11)}`),t.requests.push(e),t.requests.sort((e,t)=>t.priority-e.priority),Q.debug(`Added spawn request: ${e.role} (priority: ${e.priority}) for room ${e.roomName}`,{subsystem:"SpawnQueue"})}getNextRequest(e,t){const r=this.getQueue(e);this.cleanupInProgress(r);for(let e=0;e<r.requests.length;e++){const o=r.requests[e];if(!this.isRequestInProgress(r,o.id)&&o.body.cost<=t)return o}return null}removeRequest(e,t){const r=this.getQueue(e);r.requests=r.requests.filter(e=>e.id!==t)}markInProgress(e,t,r){this.getQueue(e).inProgress.set(t,{spawnId:r,requestId:t})}isRequestInProgress(e,t){return e.inProgress.has(t)}cleanupInProgress(e){const t=[];for(const[r,{spawnId:o}]of e.inProgress){const e=Game.getObjectById(o);e&&e.spawning||t.push(r)}for(const r of t)e.inProgress.delete(r)}getPendingRequests(e){return[...this.getQueue(e).requests]}getQueueSize(e){return this.getQueue(e).requests.length}clearQueue(e){this.getQueue(e).requests=[],Q.debug("Cleared spawn queue for room "+e,{subsystem:"SpawnQueue"})}getAvailableSpawns(e){const t=Game.rooms[e];return t?t.find(FIND_MY_SPAWNS).filter(e=>!e.spawning):[]}processQueue(e){const t=Game.rooms[e];if(!t)return 0;const r=this.getAvailableSpawns(e);if(0===r.length)return 0;this.getQueue(e);let o=0;for(const s of r){const r=this.getNextRequest(e,t.energyAvailable);if(!r)break;const n=this.executeSpawn(s,r);n===OK?(o++,this.markInProgress(e,r.id,s.id),this.removeRequest(e,r.id)):n!==ERR_NOT_ENOUGH_ENERGY&&(this.removeRequest(e,r.id),Q.warn(`Spawn request failed: ${r.role} in ${e} (error: ${n})`,{subsystem:"SpawnQueue"}))}return o}executeSpawn(e,t){const r=this.generateCreepName(t.role),o={role:t.role,family:t.family,homeRoom:t.roomName,version:1,...t.additionalMemory};return t.targetRoom&&(o.targetRoom=t.targetRoom),t.sourceId&&(o.sourceId=t.sourceId),t.boostRequirements&&(o.boostRequirements=t.boostRequirements),e.spawnCreep(t.body.parts,r,{memory:o})}generateCreepName(e){return`${e}_${Game.time}_${Math.random().toString(36).substring(2,11)}`}hasEmergencySpawns(e){return this.getQueue(e).requests.some(e=>e.priority>=ks.EMERGENCY)}countByPriority(e,t){return this.getQueue(e).requests.filter(e=>e.priority>=t).length}getQueueStats(e){const t=this.getQueue(e);return{total:t.requests.length,emergency:t.requests.filter(e=>e.priority>=ks.EMERGENCY).length,high:t.requests.filter(e=>e.priority>=ks.HIGH&&e.priority<ks.EMERGENCY).length,normal:t.requests.filter(e=>e.priority>=ks.NORMAL&&e.priority<ks.HIGH).length,low:t.requests.filter(e=>e.priority<ks.NORMAL).length,inProgress:t.inProgress.size}}},Ds={move:50,work:100,carry:50,attack:80,ranged_attack:150,heal:250,claim:600,tough:10},$s=new Map;function Ys(e,t,r){const o=Math.min(r,"small"===t?1500:"medium"===t?3e3:5e3);switch(e){case"harasser":return Ks([MOVE,ATTACK],o,[MOVE,ATTACK]);case"soldier":return Ks([TOUGH,MOVE,ATTACK,MOVE,ATTACK],o,[TOUGH,MOVE,ATTACK]);case"ranger":return Ks([TOUGH,MOVE,RANGED_ATTACK],o,[MOVE,RANGED_ATTACK]);case"healer":return Ks([TOUGH,MOVE,HEAL],o,[MOVE,HEAL]);case"siegeUnit":return Ks([TOUGH,MOVE,WORK],o,[TOUGH,MOVE,WORK]);default:return[MOVE,ATTACK]}}function Ks(e,t,r){const o=[...e];let s=e.reduce((e,t)=>e+Ds[t],0);const n=r.reduce((e,t)=>e+Ds[t],0);for(;t>=s+n&&50>o.length;)o.push(...r),s+=n;return o.slice(0,50)}function Hs(e){switch(e){case"soldier":return[{compound:RESOURCE_CATALYZED_UTRIUM_ALKALIDE,parts:[ATTACK]}];case"ranger":return[{compound:RESOURCE_CATALYZED_KEANIUM_ALKALIDE,parts:[RANGED_ATTACK]}];case"healer":return[{compound:RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,parts:[HEAL]}];case"siegeUnit":return[{compound:RESOURCE_CATALYZED_ZYNTHIUM_ACID,parts:[WORK]}];default:return[]}}const Fs=new Map;function Ws(e){e.lastUpdate=Game.time;const t=Ce.getCluster(e.clusterId);if(!t)return e.state="failed",void Q.error(`Cluster ${e.clusterId} not found for operation ${e.id}`,{subsystem:"Offensive"});switch(e.state){case"forming":!function(e){e.squadIds.every(e=>!function(e){return $s.has(e)}(e))&&(e.state="executing",Q.info(`Operation ${e.id} entering execution phase`,{subsystem:"Offensive"})),Game.time-e.createdAt>1e3&&(e.state="failed",Q.warn(`Operation ${e.id} formation timed out`,{subsystem:"Offensive"}))}(e);break;case"executing":!function(e,t){for(const r of e.squadIds){const o=t.squads.find(e=>e.id===r);if(o&&(_s(o),Os(o))){Q.info(`Squad ${r} dissolving, operation ${e.id} may complete`,{subsystem:"Offensive"});const o=t.squads.findIndex(e=>e.id===r);0>o||t.squads.splice(o,1)}}0===e.squadIds.filter(e=>t.squads.some(t=>t.id===e)).length&&(e.state="complete",Q.info(`Operation ${e.id} complete`,{subsystem:"Offensive"}))}(e,t)}}const Bs={updateInterval:10,minBucket:3e3,resourceBalanceThreshold:1e4,minTerminalEnergy:5e4};let Vs=class{constructor(e={}){this.lastRun=new Map,this.config={...Bs,...e}}run(){const e=Ce.getClusters();for(const t in e){const r=e[t];if(this.shouldRunCluster(t))try{this.runCluster(r),this.lastRun.set(t,Game.time)}catch(e){const r=e instanceof Error?e.message:e+"";Q.error(`Cluster ${t} error: ${r}`,{subsystem:"Cluster"})}}}shouldRunCluster(e){var t;const r=null!==(t=this.lastRun.get(e))&&void 0!==t?t:0;return Game.time-r>=this.config.updateInterval}runCluster(e){const t=Game.cpu.getUsed();be.measureSubsystem(`cluster:${e.id}:metrics`,()=>{this.updateClusterMetrics(e)}),be.measureSubsystem(`cluster:${e.id}:defense`,()=>{this.processDefenseRequests(e)}),be.measureSubsystem(`cluster:${e.id}:terminals`,()=>{this.balanceTerminalResources(e)}),be.measureSubsystem(`cluster:${e.id}:resourceSharing`,()=>{Cs.processCluster(e)}),be.measureSubsystem(`cluster:${e.id}:squads`,()=>{this.updateSquads(e)}),be.measureSubsystem(`cluster:${e.id}:offensive`,()=>{this.updateOffensiveOperations(e)}),be.measureSubsystem(`cluster:${e.id}:rallyPoints`,()=>{this.updateRallyPoints(e)}),be.measureSubsystem(`cluster:${e.id}:militaryResources`,()=>{!function(e){for(const t of e.memberRooms){const e=Ce.getSwarmState(t);if(!e)continue;const r=Ms(t,e.danger);r>0&&Game.time%100==0&&Q.debug(`Military energy reservation for ${t}: ${r} (danger ${e.danger})`,{subsystem:"MilitaryPool"})}}(e)}),be.measureSubsystem(`cluster:${e.id}:role`,()=>{this.updateClusterRole(e)}),be.measureSubsystem(`cluster:${e.id}:focusRoom`,()=>{this.updateFocusRoom(e)}),e.lastUpdate=Game.time;const r=Game.cpu.getUsed()-t;r>1&&Game.time%50==0&&Q.debug(`Cluster ${e.id} tick: ${r.toFixed(2)} CPU`,{subsystem:"Cluster"})}updateClusterMetrics(e){let t=0,r=0,o=0,s=0,n=0;for(const i of e.memberRooms){const e=Ce.getSwarmState(i);if(!e)continue;t+=e.metrics.energyHarvested,r+=e.metrics.energySpawning+e.metrics.energyConstruction+e.metrics.energyRepair,o+=25*e.danger;const a=Game.rooms[i];(null==a?void 0:a.storage)?s+=a.storage.store.getUsedCapacity(RESOURCE_ENERGY)/a.storage.store.getCapacity()*100:s+=e.metrics.energyHarvested>0?50:0,n++}n>0&&(e.metrics.energyIncome=t/n,e.metrics.energyConsumption=r/n,e.metrics.energyBalance=e.metrics.energyIncome-e.metrics.energyConsumption,e.metrics.warIndex=Math.min(100,o/n),e.metrics.economyIndex=Math.min(100,s/n)),e.metrics.militaryReadiness=this.calculateMilitaryReadiness(e)}calculateMilitaryReadiness(e){var t;let r=0,o=0;for(const s of e.memberRooms){const e=Game.rooms[s];if(!e||!(null===(t=e.controller)||void 0===t?void 0:t.my))continue;r+=e.find(FIND_MY_CREEPS,{filter:e=>"military"===e.memory.family}).length;const n=e.controller.level;o+=Math.max(2,Math.floor(n/2))}return 0===o?0:Math.min(100,Math.round(r/o*100))}balanceTerminalResources(e){const t=[];for(const r of e.memberRooms){const e=Game.rooms[r];(null==e?void 0:e.terminal)&&e.terminal.my&&t.push({room:e,terminal:e.terminal})}if(t.length>=2&&(this.balanceResource(t,RESOURCE_ENERGY),Game.time%50==0)){const e=[RESOURCE_HYDROGEN,RESOURCE_OXYGEN,RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_CATALYST];for(const r of e)this.balanceResource(t,r)}}balanceResource(e,t){let r=0;for(const{terminal:o}of e)r+=o.store.getUsedCapacity(t);const o=r/e.length,s=e.filter(e=>e.terminal.store.getUsedCapacity(t)>o+this.config.resourceBalanceThreshold),n=e.filter(e=>e.terminal.store.getUsedCapacity(t)<o-this.config.resourceBalanceThreshold);if(0!==s.length&&0!==n.length)for(const e of s)if(!(e.terminal.cooldown>0||t===RESOURCE_ENERGY&&e.terminal.store.getUsedCapacity(RESOURCE_ENERGY)<this.config.minTerminalEnergy+this.config.resourceBalanceThreshold))for(const r of n){const s=Math.min(e.terminal.store.getUsedCapacity(t)-o,o-r.terminal.store.getUsedCapacity(t),1e4);if(s>1e3&&e.terminal.send(t,s,r.room.name)===OK){Q.debug(`Transferred ${s} ${t} from ${e.room.name} to ${r.room.name}`,{subsystem:"Cluster"});break}}}updateSquads(e){for(const t of e.squads)_s(t),Os(t)&&(t.state="dissolving");e.squads=e.squads.filter(e=>"dissolving"!==e.state),this.autoCreateDefenseSquads(e)}autoCreateDefenseSquads(e){const t=e.defenseRequests.filter(t=>!e.squads.some(e=>"defense"===e.type&&e.targetRooms.includes(t.roomName))&&t.urgency>=2);for(const r of t){const t=Us(e,r);e.squads.push(t)}}updateOffensiveOperations(e){Game.time%100==0&&function(e){if("war"!==e.role&&"mixed"!==e.role)return;const t=Array.from(Fs.values()).filter(t=>t.clusterId===e.id&&"complete"!==t.state&&"failed"!==t.state);if(t.length>=2)return void Q.debug(`Cluster ${e.id} at max operations (${t.length})`,{subsystem:"Offensive"});const r=function(e,t=10,r=5,o={}){var s,n;const i={...xs,...o},a=[],c=Ce.getOvermind(),u=c.roomIntel,l=new Set(c.warTargets);for(const r in u){const o=u[r];if(!o.scouted)continue;if("self"===o.owner)continue;if(o.isHighway||o.isSK)continue;const c=Ps(e,r);if(c>t)continue;const m=null!==(n=null===(s=Memory.lastAttacked)||void 0===s?void 0:s[r])&&void 0!==n?n:0;if(5e3>Game.time-m)continue;const p=Gs(o,c,l.has(r),i);let d="neutral";o.owner&&(d=l.has(o.owner)||l.has(r)?"enemy":"hostile");const g=ws(r,{towerCount:o.towerCount,spawnCount:o.spawnCount,rcl:o.controllerLevel,owner:o.owner});a.push({roomName:r,score:p,distance:c,doctrine:g,type:d,intel:o})}a.sort((e,t)=>t.score-e.score);const m=a.slice(0,r);return m.length>0&&Q.info(`Found ${m.length} attack targets for cluster ${e.id}: `+m.map(e=>`${e.roomName}(${e.score.toFixed(0)})`).join(", "),{subsystem:"AttackTarget"}),m}(e,10,3);if(0===r.length)return void Q.debug("No attack targets found for cluster "+e.id,{subsystem:"Offensive"});const o=r[0];Is(e,o.doctrine)?function(e,t,r){if(!function(e){const t=Ce.getOvermind().roomIntel[e];return t?Game.time-t.lastSeen>5e3?(Q.warn(`Intel for ${e} is stale (${Game.time-t.lastSeen} ticks old)`,{subsystem:"AttackTarget"}),0):1:(Q.warn("No intel for target "+e,{subsystem:"AttackTarget"}),0)}(t))return Q.warn("Invalid target "+t,{subsystem:"Offensive"}),null;const o=Ce.getOvermind().roomIntel[t],s=null!=r?r:ws(t,{towerCount:null==o?void 0:o.towerCount,spawnCount:null==o?void 0:o.spawnCount,rcl:null==o?void 0:o.controllerLevel,owner:null==o?void 0:o.owner});if(!Is(e,s))return Q.warn(`Cannot launch ${s} operation on ${t} - insufficient resources`,{subsystem:"Offensive"}),null;const n=`op_${e.id}_${t}_${Game.time}`,i={id:n,clusterId:e.id,targetRoom:t,doctrine:s,squadIds:[],state:"planning",createdAt:Game.time,lastUpdate:Game.time};Fs.set(n,i);const a=function(e,t,r,o){const s=function(e,t){var r,o;let s={guards:2,rangers:3,healers:2,siegeUnits:1};if(t){const e=null!==(r=t.towerCount)&&void 0!==r?r:0,n=null!==(o=t.spawnCount)&&void 0!==o?o:0;3>e||(s.healers+=1),2>e||2>n||(s.siegeUnits+=1),2>n||(s.guards+=1)}return s}(0,o),n=`${r}_${t}_${Game.time}`,i=Ss(e,t);let a=.3;"harass"===r?a=.5:"raid"===r?a=.4:"siege"===r&&(a=.3);const c={id:n,type:r,members:[],rallyRoom:i,targetRooms:[t],state:"gathering",createdAt:Game.time,retreatThreshold:a};return Q.info(`Created ${r} squad ${n} for ${t}: ${s.guards}G/${s.rangers}R/${s.healers}H/${s.siegeUnits}S rally at ${i}`,{subsystem:"Squad"}),c}(e,t,"harassment"===s?"harass":s,{towerCount:null==o?void 0:o.towerCount,spawnCount:null==o?void 0:o.spawnCount});var c;e.squads.push(a),i.squadIds.push(a.id),function(e,t){const r=t.id;if($s.has(r))return void Q.debug(`Squad ${r} already forming`,{subsystem:"SquadFormation"});let o;if("defense"===t.type)o={harassers:0,soldiers:2,rangers:2,healers:1,siegeUnits:0};else{const e="harass"===t.type?"harassment":t.type;o=bs[e].composition}const s={};o.harassers>0&&(s.harasser=o.harassers),o.soldiers>0&&(s.soldier=o.soldiers),o.rangers>0&&(s.ranger=o.rangers),o.healers>0&&(s.healer=o.healers),o.siegeUnits>0&&(s.siegeUnit=o.siegeUnits);const n={squadId:r,targetComposition:s,currentComposition:{},spawnRequests:new Set,formationStarted:Game.time};$s.set(r,n);const i=Game.rooms[t.rallyRoom];i?(function(e,t,r,o){let s=0;if("defense"!==t.type){const e="harass"===t.type?"harassment":t.type;s=bs[e].useBoosts}let n=ks.NORMAL;"siege"===t.type?n=ks.HIGH:"defense"===t.type&&(n=ks.EMERGENCY);const i=(r,i)=>{for(let a=0;i>a;a++){const i=Ys(r,"medium",e.energyCapacityAvailable),c=i.reduce((e,t)=>e+Ds[t],0),u=s?Hs(r):[],l={id:`${t.id}_${r}_${a}_${Game.time}`,roomName:e.name,role:r,family:"military",body:{parts:i,cost:c,minCapacity:c},priority:n,targetRoom:t.targetRooms[0],boostRequirements:u.length>0?u.map(e=>({resourceType:e.compound,bodyParts:i.filter(t=>e.parts.includes(t))})):void 0,createdAt:Game.time,additionalMemory:{squadId:t.id}};Ls.addRequest(l),o.spawnRequests.add(l.id)}};r.harassers>0&&i("harasser",r.harassers),r.soldiers>0&&i("soldier",r.soldiers),r.rangers>0&&i("ranger",r.rangers),r.healers>0&&i("healer",r.healers),r.siegeUnits>0&&i("siegeUnit",r.siegeUnits)}(i,t,o,n),Q.info(`Started forming squad ${r}: ${JSON.stringify(s)}`,{subsystem:"SquadFormation"})):Q.warn(`Rally room ${t.rallyRoom} not visible for squad ${r}`,{subsystem:"SquadFormation"})}(0,a),i.state="forming",c=t,Memory.lastAttacked||(Memory.lastAttacked={}),Memory.lastAttacked[c]=Game.time,Q.info(`Marked ${c} as attacked at tick ${Game.time}`,{subsystem:"AttackTarget"}),Q.info(`Launched ${s} operation ${n} on ${t} with squad ${a.id}`,{subsystem:"Offensive"})}(e,o.roomName,o.doctrine):Q.info(`Cluster ${e.id} cannot launch ${o.doctrine} doctrine (insufficient resources)`,{subsystem:"Offensive"})}(e),function(){!function(){const e=Game.time;for(const[t,r]of $s.entries()){const o=e-r.formationStarted;o>500&&(Q.warn(`Squad ${t} formation timed out after ${o} ticks`,{subsystem:"SquadFormation"}),$s.delete(t))}}();for(const[e,t]of Fs.entries())Ws(t);!function(){for(const[e,t]of Fs.entries()){const r=Game.time-t.createdAt;"complete"!==t.state&&"failed"!==t.state||5e3>=r||(Fs.delete(e),Q.debug("Cleaned up operation "+e,{subsystem:"Offensive"}))}}()}()}updateClusterRole(e){const{warIndex:t,economyIndex:r}=e.metrics;e.role=t>50?"war":r>70&&20>t?"economic":40>r?"frontier":"mixed"}updateRallyPoints(e){const t=e.rallyPoints.filter(t=>"defense"===t.purpose?1:e.squads.some(e=>e.rallyRoom===t.roomName&&"dissolving"!==e.state));e.rallyPoints=t;for(const t of e.memberRooms)e.rallyPoints.find(e=>e.roomName===t&&"defense"===e.purpose)||e.rallyPoints.push({roomName:t,x:25,y:25,purpose:"defense"})}updateFocusRoom(e){var t,r;const o=[];for(const r of e.memberRooms){const e=Game.rooms[r];e&&(null===(t=e.controller)||void 0===t?void 0:t.my)&&o.push({roomName:r,rcl:e.controller.level})}if(0!==o.length){if(e.focusRoom){const t=Game.rooms[e.focusRoom];8===(null===(r=null==t?void 0:t.controller)||void 0===r?void 0:r.level)&&(Q.info(`Focus room ${e.focusRoom} reached RCL 8, selecting next room`,{subsystem:"Cluster"}),e.focusRoom=void 0),t||(Q.warn(`Focus room ${e.focusRoom} no longer valid, selecting new focus`,{subsystem:"Cluster"}),e.focusRoom=void 0)}if(!e.focusRoom){const t=o.filter(e=>8>e.rcl);if(0===t.length)return;t.sort((e,t)=>e.rcl!==t.rcl?e.rcl-t.rcl:e.roomName.localeCompare(t.roomName)),e.focusRoom=t[0].roomName,Q.info(`Selected ${e.focusRoom} (RCL ${t[0].rcl}) as focus room for upgrading`,{subsystem:"Cluster"})}}}createCluster(e){const t="cluster_"+e,r=Ce.getCluster(t,e);if(!r)throw Error("Failed to create cluster for "+e);return Q.info(`Created cluster ${t} with core room ${e}`,{subsystem:"Cluster"}),r}addRoomToCluster(e,t,r=0){const o=Ce.getCluster(e);o?r?o.remoteRooms.includes(t)||(o.remoteRooms.push(t),Q.info(`Added remote room ${t} to cluster ${e}`,{subsystem:"Cluster"})):o.memberRooms.includes(t)||(o.memberRooms.push(t),Q.info(`Added member room ${t} to cluster ${e}`,{subsystem:"Cluster"})):Q.error(`Cluster ${e} not found`,{subsystem:"Cluster"})}processDefenseRequests(e){var t;e.defenseRequests=e.defenseRequests.filter(e=>{const t=Game.time-e.createdAt;if(t>500)return Q.debug(`Defense request for ${e.roomName} expired (${t} ticks old)`,{subsystem:"Cluster"}),0;const r=Game.rooms[e.roomName];return r?0===r.find(FIND_HOSTILE_CREEPS).length?(Q.info(`Defense request for ${e.roomName} resolved - no more hostiles`,{subsystem:"Cluster"}),0):1:0});for(const t of e.defenseRequests)if(t.urgency>=3){const r=Game.rooms[t.roomName];r&&r.storage&&1e4>r.storage.store.getUsedCapacity(RESOURCE_ENERGY)&&Ns(e,t.roomName,2e4)}for(const r of e.memberRooms){const o=Game.rooms[r];if(!o||!(null===(t=o.controller)||void 0===t?void 0:t.my))continue;const s=Ce.getSwarmState(r);if(s&&co(o,s)){const t=e.defenseRequests.find(e=>e.roomName===r);if(t){const e=uo(o,s);e&&e.urgency>t.urgency&&(t.urgency=e.urgency,t.guardsNeeded=e.guardsNeeded,t.rangersNeeded=e.rangersNeeded,t.healersNeeded=e.healersNeeded,t.threat=e.threat)}else{const t=uo(o,s);t&&e.defenseRequests.push({...t,assignedCreeps:[]})}}}this.assignDefendersToRequests(e)}assignDefendersToRequests(e){if(0===e.defenseRequests.length)return;const t=[...e.defenseRequests].sort((e,t)=>t.urgency-e.urgency),r=[];for(const o of t){if(!Game.rooms[o.roomName])continue;for(const t of e.memberRooms){if(t===o.roomName)continue;const e=Game.rooms[t];if(!e)continue;const s=e.find(FIND_MY_CREEPS);for(const n of s){const s=n.memory;if("military"!==s.family)continue;if(s.assistTarget)continue;if(o.assignedCreeps.includes(n.name))continue;const i=o.guardsNeeded>0,a=o.rangersNeeded>0,c=o.healersNeeded>0,u="guard"===s.role,l="ranger"===s.role,m="healer"===s.role;if(i&&u||a&&l||c&&m){const s=Game.map.getRoomLinearDistance(t,o.roomName);r.push({creep:n,room:e,distance:s,targetRoom:o.roomName})}}}r.sort((e,t)=>e.distance-t.distance);const t=o.guardsNeeded+o.rangersNeeded+o.healersNeeded,s=Math.min(t,r.length);for(let e=0;s>e;e++){const t=r[e];t&&(t.creep.memory.assistTarget=o.roomName,o.assignedCreeps.push(t.creep.name),Q.info(`Assigned ${t.creep.name} (${t.creep.memory.role}) from ${t.room.name} to assist ${o.roomName} (distance: ${t.distance})`,{subsystem:"Cluster"}),"guard"===t.creep.memory.role&&o.guardsNeeded--,"ranger"===t.creep.memory.role&&o.rangersNeeded--,"healer"===t.creep.memory.role&&o.healersNeeded--)}for(let e=r.length-1;e>=0;e--)o.assignedCreeps.includes(r[e].creep.name)&&r.splice(e,1)}}};H([fs("cluster:manager","Cluster Manager",{priority:me.MEDIUM,interval:10,minBucket:3e3,cpuBudget:.03})],Vs.prototype,"run",null),Vs=H([ys()],Vs);const qs=new Vs,js={triggerDangerLevel:3,nukeEvacuationLeadTime:5e3,minStorageEnergy:5e4,priorityResources:[RESOURCE_ENERGY,RESOURCE_POWER,RESOURCE_GHODIUM,RESOURCE_CATALYZED_GHODIUM_ACID,RESOURCE_CATALYZED_UTRIUM_ACID,RESOURCE_CATALYZED_LEMERGIUM_ACID,RESOURCE_CATALYZED_KEANIUM_ACID,RESOURCE_CATALYZED_ZYNTHIUM_ACID,RESOURCE_OPS],maxTransfersPerTick:2};let Xs=class{constructor(e={}){this.evacuations=new Map,this.lastTransferTick=0,this.transfersThisTick=0,this.config={...js,...e}}run(){Game.time!==this.lastTransferTick&&(this.transfersThisTick=0,this.lastTransferTick=Game.time),this.checkEvacuationTriggers();for(const e of this.evacuations.values())e.complete||this.processEvacuation(e);for(const[e,t]of this.evacuations.entries())t.complete&&Game.time-t.startedAt>1e3&&this.evacuations.delete(e)}checkEvacuationTriggers(){var e,t,r,o;for(const s in Game.rooms){const n=Game.rooms[s];if(!(null===(e=n.controller)||void 0===e?void 0:e.my))continue;if(this.evacuations.has(s))continue;const i=Ce.getSwarmState(s);if(!i)continue;const a=n.find(FIND_NUKES);if(a.length>0){const e=a.reduce((e,t)=>{var r,o;return(null!==(r=e.timeToLand)&&void 0!==r?r:1/0)<(null!==(o=t.timeToLand)&&void 0!==o?o:1/0)?e:t});if((null!==(t=e.timeToLand)&&void 0!==t?t:1/0)<=this.config.nukeEvacuationLeadTime){i.nukeDetected||(i.nukeDetected=1);const t=a.length;Q.warn(`Triggering evacuation for ${s}: ${t} nuke(s) detected, impact in ${null!==(r=e.timeToLand)&&void 0!==r?r:0} ticks`,{subsystem:"Evacuation"}),this.startEvacuation(s,"nuke",Game.time+(null!==(o=e.timeToLand)&&void 0!==o?o:0));continue}}if(i.danger>=this.config.triggerDangerLevel&&"siege"===i.posture){const e=n.find(FIND_HOSTILE_CREEPS),t=n.find(FIND_MY_CREEPS,{filter:e=>{const t=e.body.map(e=>e.type);return t.includes(ATTACK)||t.includes(RANGED_ATTACK)}});if(e.length>3*t.length){this.startEvacuation(s,"siege");continue}}}}startEvacuation(e,t,r){var o;if(this.evacuations.has(e))return 0;const s=Game.rooms[e];if(!s||!(null===(o=s.controller)||void 0===o?void 0:o.my))return 0;const n=this.findEvacuationTarget(e);if(!n)return Q.error(`Cannot evacuate ${e}: no valid target room found`,{subsystem:"Evacuation"}),0;const i={roomName:e,reason:t,startedAt:Game.time,targetRoom:n,resourcesEvacuated:[],creepsRecalled:[],progress:0,complete:0,deadline:r};this.evacuations.set(e,i);const a=Ce.getSwarmState(e);return a&&(a.posture="evacuate"),Q.warn(`Starting evacuation of ${e} (${t}), target: ${n}`+(r?`, deadline: ${r-Game.time} ticks`:""),{subsystem:"Evacuation"}),1}findEvacuationTarget(e){var t,r;const o=Object.values(Game.rooms).filter(t=>{var r;return(null===(r=t.controller)||void 0===r?void 0:r.my)&&t.name!==e});if(0===o.length)return null;const s=o.map(t=>{var r,o;let s=0;if(!t.terminal)return{room:t,score:-1e3};s-=10*Game.map.getRoomLinearDistance(e,t.name);const n=t.terminal.store.getFreeCapacity();if(s+=10*Math.min(100,n/1e4),s+=5*(null!==(o=null===(r=t.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0),t.storage){s+=50;const e=t.storage.store.getFreeCapacity();s+=5*Math.min(100,e/5e4)}const i=t.find(FIND_HOSTILE_CREEPS);return i.length>0&&(s-=20*i.length),{room:t,score:s}}).filter(e=>e.score>-500).sort((e,t)=>t.score-e.score);return s.length>0&&null!==(r=null===(t=s[0])||void 0===t?void 0:t.room.name)&&void 0!==r?r:null}processEvacuation(e){const t=Game.rooms[e.roomName],r=Game.rooms[e.targetRoom];if(!t)return e.complete=1,void Q.error(`Lost room ${e.roomName} during evacuation`,{subsystem:"Evacuation"});this.transfersThisTick<this.config.maxTransfersPerTick&&this.transferResources(e,t,r),this.recallCreeps(e,t),e.progress=this.calculateProgress(e,t),100>e.progress||(e.complete=1,Q.info(`Evacuation of ${e.roomName} complete: `+e.resourcesEvacuated.reduce((e,t)=>e+t.amount,0)+" resources, "+e.creepsRecalled.length+" creeps",{subsystem:"Evacuation"})),e.deadline&&Game.time>=e.deadline&&(e.complete=1,Q.warn(`Evacuation of ${e.roomName} reached deadline`,{subsystem:"Evacuation"}))}transferResources(e,t,r){const o=t.terminal,s=null==r?void 0:r.terminal;if(!o||!s)return;const n=Game.map.getRoomLinearDistance(t.name,e.targetRoom),i=e=>Math.ceil(e*(1-Math.exp(-n/30)));for(const r of this.config.priorityResources){const n=o.store.getUsedCapacity(r);if(0>=n)continue;const a=s.store.getFreeCapacity(r);if(0>=a)continue;const c=i(n),u=o.store.getUsedCapacity(RESOURCE_ENERGY);if(r!==RESOURCE_ENERGY&&c>u)continue;const l=Math.min(n,a,5e4);if(l>0&&o.send(r,l,e.targetRoom)===OK)return e.resourcesEvacuated.push({resourceType:r,amount:l}),this.transfersThisTick++,void Q.debug(`Evacuated ${l} ${r} from ${t.name} to ${e.targetRoom}`,{subsystem:"Evacuation"})}for(const t of Object.keys(o.store)){if(this.config.priorityResources.includes(t))continue;const r=o.store.getUsedCapacity(t);if(0>=r)continue;const n=s.store.getFreeCapacity(t);if(0>=n)continue;const a=i(r),c=o.store.getUsedCapacity(RESOURCE_ENERGY);if(t!==RESOURCE_ENERGY&&a>c)continue;const u=Math.min(r,n,5e4);if(u>0&&o.send(t,u,e.targetRoom)===OK)return e.resourcesEvacuated.push({resourceType:t,amount:u}),void this.transfersThisTick++}}recallCreeps(e,t){for(const r of t.find(FIND_MY_CREEPS)){const t=r.memory;t.evacuating||(t.evacuating=1,t.evacuationTarget=e.targetRoom,e.creepsRecalled.push(r.name))}}calculateProgress(e,t){const r=t.terminal,o=t.storage;let s=0,n=0;r&&(s+=1e5,n+=r.store.getUsedCapacity()),o&&(s+=o.store.getCapacity(),n+=o.store.getUsedCapacity());const i=s>0?Math.min(100,(s-n)/s*100):100,a=t.find(FIND_MY_CREEPS).length,c=e.creepsRecalled.length>0?Math.min(100,(e.creepsRecalled.length-a)/e.creepsRecalled.length*100):100;return Math.round((i+c)/2)}cancelEvacuation(e){const t=this.evacuations.get(e);if(!t)return;this.evacuations.delete(e);for(const e of t.creepsRecalled){const t=Game.creeps[e];if(t){const e=t.memory;delete e.evacuating,delete e.evacuationTarget}}const r=Ce.getSwarmState(e);r&&(r.posture="eco"),Q.info(`Evacuation of ${e} cancelled`,{subsystem:"Evacuation"})}getEvacuationState(e){return this.evacuations.get(e)}isEvacuating(e){const t=this.evacuations.get(e);return void 0!==t&&!t.complete}getActiveEvacuations(){return Array.from(this.evacuations.values()).filter(e=>!e.complete)}};H([fs("cluster:evacuation","Evacuation Manager",{priority:me.HIGH,interval:5,minBucket:2e3,cpuBudget:.02})],Xs.prototype,"run",null),Xs=H([ys()],Xs);const zs=new Xs,Zs={minBucket:2e3,minStorageEnergy:5e4,terminalEnergyTarget:2e4,terminalEnergyMax:5e4,energySendThreshold:1e5,energyRequestThreshold:3e4,minTransferAmount:5e3,maxTransferCostRatio:.1};let Qs=class{constructor(e={}){this.transferQueue=[],this.config={...Zs,...e}}requestTransfer(e,t,r,o,s=3){if(this.transferQueue.some(o=>o.fromRoom===e&&o.toRoom===t&&o.resourceType===r))return Q.debug(`Transfer already queued: ${o} ${r} from ${e} to ${t}`,{subsystem:"Terminal"}),0;const n=Game.rooms[e],i=Game.rooms[t];return n&&i&&n.terminal&&i.terminal?(this.transferQueue.push({fromRoom:e,toRoom:t,resourceType:r,amount:o,priority:s}),Q.info(`Queued transfer request: ${o} ${r} from ${e} to ${t} (priority: ${s})`,{subsystem:"Terminal"}),1):(Q.warn("Cannot queue transfer: rooms or terminals not available",{subsystem:"Terminal"}),0)}run(){if(Game.cpu.bucket<this.config.minBucket)return;const e=Object.values(Game.rooms).filter(e=>{var t;return(null===(t=e.controller)||void 0===t?void 0:t.my)&&e.terminal&&e.terminal.my&&e.terminal.isActive()});2>e.length||(this.cleanTransferQueue(),this.balanceEnergy(e),this.balanceMinerals(e),this.executeTransfers(e))}cleanTransferQueue(){this.transferQueue=this.transferQueue.filter(e=>{const t=Game.rooms[e.fromRoom],r=Game.rooms[e.toRoom];return t&&r&&t.terminal&&r.terminal?1:0})}balanceEnergy(e){const t=e.map(e=>{var t;const r=e.storage,o=e.terminal,s=null!==(t=null==r?void 0:r.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==t?t:0,n=o.store.getUsedCapacity(RESOURCE_ENERGY),i=s+n;return{room:e,terminal:o,totalEnergy:i,storageEnergy:s,terminalEnergy:n,needsEnergy:i<this.config.energyRequestThreshold,hasExcess:i>this.config.energySendThreshold&&s>this.config.minStorageEnergy}}),r=t.filter(e=>e.needsEnergy).sort((e,t)=>e.totalEnergy-t.totalEnergy),o=t.filter(e=>e.hasExcess).sort((e,t)=>t.totalEnergy-e.totalEnergy);for(const e of r)for(const t of o){if(t.room.name===e.room.name)continue;if(this.transferQueue.some(r=>r.fromRoom===t.room.name&&r.toRoom===e.room.name&&r.resourceType===RESOURCE_ENERGY))continue;const r=Math.min(Math.floor((t.totalEnergy-this.config.energySendThreshold)/2),this.config.energyRequestThreshold-e.totalEnergy,t.terminal.store.getUsedCapacity(RESOURCE_ENERGY));if(r<this.config.minTransferAmount)continue;const o=Game.market.calcTransactionCost(r,t.room.name,e.room.name),s=o/r;if(s<=this.config.maxTransferCostRatio){this.transferQueue.push({fromRoom:t.room.name,toRoom:e.room.name,resourceType:RESOURCE_ENERGY,amount:r,priority:2}),Q.info(`Queued energy transfer: ${r} from ${t.room.name} to ${e.room.name} (cost: ${o})`,{subsystem:"Terminal"});break}Q.debug(`Skipping terminal transfer from ${t.room.name} to ${e.room.name}: cost ratio ${s.toFixed(2)} too high`,{subsystem:"Terminal"})}}balanceMinerals(e){const t=new Map;for(const r of e){const e=r.terminal,o=Object.keys(e.store);for(const s of o){if(s===RESOURCE_ENERGY)continue;const o=e.store.getUsedCapacity(s);0!==o&&(t.has(s)||t.set(s,[]),t.get(s).push({room:r,amount:o}))}}for(const[e,r]of t.entries()){if(2>r.length)continue;r.sort((e,t)=>t.amount-e.amount);const t=r[0],o=r[r.length-1],s=t.amount-o.amount;if(5e3>s)continue;if(this.transferQueue.some(r=>r.fromRoom===t.room.name&&r.toRoom===o.room.name&&r.resourceType===e))continue;const n=Math.min(Math.floor(s/2),t.amount-1e3);1e3>n||(this.transferQueue.push({fromRoom:t.room.name,toRoom:o.room.name,resourceType:e,amount:n,priority:1}),Q.info(`Queued mineral transfer: ${n} ${e} from ${t.room.name} to ${o.room.name}`,{subsystem:"Terminal"}))}}executeTransfers(e){this.transferQueue.sort((e,t)=>t.priority-e.priority);const t=new Set;for(const r of this.transferQueue){if(t.has(r.fromRoom))continue;const o=e.find(e=>e.name===r.fromRoom);if(!o||!o.terminal)continue;const s=o.terminal;if(s.cooldown>0)continue;const n=s.store.getUsedCapacity(r.resourceType);if(n<r.amount){Q.debug(`Terminal transfer cancelled: insufficient ${r.resourceType} in ${r.fromRoom} (need ${r.amount}, have ${n})`,{subsystem:"Terminal"}),this.transferQueue=this.transferQueue.filter(e=>e!==r);continue}const i=s.send(r.resourceType,r.amount,r.toRoom,"Terminal auto-balance");i===OK?(Q.info(`Terminal transfer executed: ${r.amount} ${r.resourceType} from ${r.fromRoom} to ${r.toRoom}`,{subsystem:"Terminal"}),t.add(r.fromRoom),this.transferQueue=this.transferQueue.filter(e=>e!==r)):(Q.warn(`Terminal transfer failed: ${i} for ${r.amount} ${r.resourceType} from ${r.fromRoom} to ${r.toRoom}`,{subsystem:"Terminal"}),this.transferQueue=this.transferQueue.filter(e=>e!==r))}}queueTransfer(e,t,r,o,s=1){this.transferQueue.push({fromRoom:e,toRoom:t,resourceType:r,amount:o,priority:s})}};H([fs("terminal:manager","Terminal Manager",{priority:me.MEDIUM,interval:20,minBucket:2e3,cpuBudget:.1})],Qs.prototype,"run",null),Qs=H([ys()],Qs);const Js=new Qs,en={minBucket:2500,minStorageEnergy:8e4,inputBufferAmount:2e3,outputBufferAmount:5e3},tn={[RESOURCE_UTRIUM_BAR]:{[RESOURCE_UTRIUM]:500,[RESOURCE_ENERGY]:200},[RESOURCE_LEMERGIUM_BAR]:{[RESOURCE_LEMERGIUM]:500,[RESOURCE_ENERGY]:200},[RESOURCE_ZYNTHIUM_BAR]:{[RESOURCE_ZYNTHIUM]:500,[RESOURCE_ENERGY]:200},[RESOURCE_KEANIUM_BAR]:{[RESOURCE_KEANIUM]:500,[RESOURCE_ENERGY]:200},[RESOURCE_GHODIUM_MELT]:{[RESOURCE_GHODIUM]:500,[RESOURCE_ENERGY]:200},[RESOURCE_OXIDANT]:{[RESOURCE_OXYGEN]:500,[RESOURCE_ENERGY]:200},[RESOURCE_REDUCTANT]:{[RESOURCE_HYDROGEN]:500,[RESOURCE_ENERGY]:200},[RESOURCE_PURIFIER]:{[RESOURCE_CATALYST]:500,[RESOURCE_ENERGY]:200},[RESOURCE_BATTERY]:{[RESOURCE_ENERGY]:600}},rn={[RESOURCE_BATTERY]:10,[RESOURCE_UTRIUM_BAR]:5,[RESOURCE_LEMERGIUM_BAR]:5,[RESOURCE_ZYNTHIUM_BAR]:5,[RESOURCE_KEANIUM_BAR]:5,[RESOURCE_GHODIUM_MELT]:4,[RESOURCE_OXIDANT]:3,[RESOURCE_REDUCTANT]:3,[RESOURCE_PURIFIER]:3};let on=class{constructor(e={}){this.config={...en,...e}}run(){if(Game.cpu.bucket<this.config.minBucket)return;const e=Object.values(Game.rooms).filter(e=>{var t;return(null===(t=e.controller)||void 0===t?void 0:t.my)?e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_FACTORY}).length>0:0});for(const t of e)this.processFactory(t)}processFactory(e){const t=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_FACTORY});if(0===t.length)return;const r=t[0];if(r.cooldown>0)return;const o=e.storage;if(!o)return;if(o.store.getUsedCapacity(RESOURCE_ENERGY)<this.config.minStorageEnergy)return;const s=this.selectProduction(e,r,o);if(!s)return;const n=tn[s];if(!n)return;let i=1;for(const[e,t]of Object.entries(n))if(t>r.store.getUsedCapacity(e)){i=0;break}if(i){const t=r.produce(s);t===OK?Q.info(`Factory in ${e.name} producing ${s}`,{subsystem:"Factory"}):t!==ERR_TIRED&&Q.debug(`Factory production failed in ${e.name}: ${t}`,{subsystem:"Factory"})}}selectProduction(e,t,r){var o;const s=[];for(const[e,n]of Object.entries(tn)){const i=e;let a=1,c=0;for(const[e,t]of Object.entries(n)){const o=e,s=r.store.getUsedCapacity(o);if(2*t>s){a=0;break}c+=s/(10*t)}if(!a)continue;const u=t.store.getUsedCapacity(i)+r.store.getUsedCapacity(i);if(u>this.config.outputBufferAmount)continue;const l=null!==(o=rn[i])&&void 0!==o?o:1,m=l*c*(1-u/this.config.outputBufferAmount);s.push({commodity:i,priority:l,score:m})}return 0===s.length?null:(s.sort((e,t)=>t.score-e.score),s[0].commodity)}getRequiredInputs(e,t){const r=t.storage;if(!r)return[];const o=this.selectProduction(t,e,r);if(!o)return[];const s=tn[o];if(!s)return[];const n=[];for(const[t,r]of Object.entries(s)){const o=t,s=e.store.getUsedCapacity(o),i=Math.max(0,this.config.inputBufferAmount-s);i>0&&n.push({resource:o,amount:Math.min(i,2*r)})}return n}hasOutputsToRemove(e){for(const t of Object.keys(tn))if(e.store.getUsedCapacity(t)>0)return 1;return 0}};H([fs("factory:manager","Factory Manager",{priority:me.LOW,interval:30,minBucket:2500,cpuBudget:.05})],on.prototype,"run",null),on=H([ys()],on);const sn=new on,nn={updateInterval:30,minBucket:5e3,maxCpuBudget:.05,minGclForExpansion:2,maxExpansionDistance:10,minExpansionScore:50,intelRefreshInterval:100,minStableRcl:4,gclNotifyThreshold:90};let an=class{constructor(e={}){this.lastRun=0,this.config={...nn,...e}}run(){const e=Game.cpu.getUsed(),t=Ce.getOvermind();this.lastRun=Game.time,t.lastRun=Game.time,be.measureSubsystem("empire:expansion",()=>{this.updateExpansionQueue(t)}),be.measureSubsystem("empire:powerBanks",()=>{this.updatePowerBanks(t)}),be.measureSubsystem("empire:warTargets",()=>{this.updateWarTargets(t)}),be.measureSubsystem("empire:objectives",()=>{this.updateObjectives(t)}),be.measureSubsystem("empire:intelRefresh",()=>{this.refreshRoomIntel(t)}),be.measureSubsystem("empire:gclTracking",()=>{this.trackGCLProgress(t)}),be.measureSubsystem("empire:expansionReadiness",()=>{this.checkExpansionReadiness(t)}),be.measureSubsystem("empire:nukeCandidates",()=>{this.refreshNukeCandidates(t)}),be.measureSubsystem("empire:clusterHealth",()=>{this.monitorClusterHealth()}),be.measureSubsystem("empire:powerBankProfitability",()=>{this.assessPowerBankProfitability(t)});const r=Game.cpu.getUsed()-e;Game.time%100==0&&Q.info(`Empire tick completed in ${r.toFixed(2)} CPU`,{subsystem:"Empire"})}cleanupClaimQueue(e,t){const r=e.claimQueue.length;e.claimQueue=e.claimQueue.filter(e=>t.has(e.roomName)?(Q.info(`Removing ${e.roomName} from claim queue - now owned`,{subsystem:"Empire"}),0):1),e.claimQueue.length<r&&Q.info(`Cleaned up claim queue: removed ${r-e.claimQueue.length} owned room(s)`,{subsystem:"Empire"})}updateExpansionQueue(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),r=new Set(t.map(e=>e.name)),o=Game.gcl.level,s=Object.values(Game.spawns);if(s.length>0&&s[0].owner){const r=s[0].owner.username;for(const o of t){const t=e.roomIntel[o.name];t&&t.owner!==r&&(t.owner=r,Q.info(`Updated room intel for ${o.name} - now owned by ${r}`,{subsystem:"Empire"}))}}if(this.cleanupClaimQueue(e,r),t.length>=o)return;if(o<this.config.minGclForExpansion)return;if(e.objectives.expansionPaused)return;const n=[];for(const r in e.roomIntel){const o=e.roomIntel[r];if(o.owner||o.reserver)continue;if(!o.scouted)continue;const s=this.scoreExpansionCandidate(o,t);s<this.config.minExpansionScore||n.push({roomName:o.name,score:s,distance:this.getMinDistanceToOwned(o.name,t),claimed:0,lastEvaluated:Game.time})}n.sort((e,t)=>t.score-e.score),e.claimQueue=n.slice(0,10),n.length>0&&Game.time%100==0&&Q.info(`Expansion queue updated: ${n.length} candidates, top score: ${n[0].score}`,{subsystem:"Empire"})}scoreExpansionCandidate(e,t){let r=0;r+=40*e.sources;const o=this.getMinDistanceToOwned(e.name,t);return o>this.config.maxExpansionDistance?0:(r-=3*o,e.mineralType&&([RESOURCE_CATALYST,RESOURCE_ZYNTHIUM,RESOURCE_KEANIUM].includes(e.mineralType)?r+=15:r+=10),"plains"===e.terrain?r+=10:"swamp"===e.terrain&&(r-=5),r-=20*e.threatLevel,e.isHighway?0:(e.isSK&&(r-=30),Math.max(0,r)))}getMinDistanceToOwned(e,t){let r=1/0;for(const o of t){const t=Game.map.getRoomLinearDistance(e,o.name);r>t&&(r=t)}return r}updatePowerBanks(e){var t;e.powerBanks=e.powerBanks.filter(e=>e.decayTick>Game.time);for(const r in Game.rooms){const o=Game.rooms[r].find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_BANK});for(const s of o)e.powerBanks.find(e=>e.roomName===r&&e.pos.x===s.pos.x&&e.pos.y===s.pos.y)||(e.powerBanks.push({roomName:r,pos:{x:s.pos.x,y:s.pos.y},power:s.power,decayTick:Game.time+(null!==(t=s.ticksToDecay)&&void 0!==t?t:5e3),active:0}),Q.info(`Power bank discovered in ${r}: ${s.power} power`,{subsystem:"Empire"}))}}updateWarTargets(e){if(e.warTargets=e.warTargets.filter(t=>{var r,o;const s=e.roomIntel[t];return s?s.owner===(null!==(o=null===(r=Object.values(Game.spawns)[0])||void 0===r?void 0:r.owner.username)&&void 0!==o?o:"")?0:1:0}),e.objectives.warMode)for(const t in e.roomIntel){const r=e.roomIntel[t];2>r.threatLevel||e.warTargets.includes(t)||(e.warTargets.push(t),Q.warn(`Added war target: ${t} (threat level ${r.threatLevel})`,{subsystem:"Empire"}))}}updateObjectives(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});e.objectives.targetRoomCount=Game.gcl.level,e.objectives.targetPowerLevel=Math.min(25,3*t.length),e.warTargets.length>0&&!e.objectives.warMode&&(e.objectives.warMode=1,Q.warn("War mode enabled due to active war targets",{subsystem:"Empire"})),0===e.warTargets.length&&e.objectives.warMode&&(e.objectives.warMode=0,Q.info("War mode disabled - no active war targets",{subsystem:"Empire"}))}getNextExpansionTarget(){const e=Ce.getOvermind().claimQueue.filter(e=>!e.claimed);return e.length>0?e[0]:null}markExpansionClaimed(e){const t=Ce.getOvermind().claimQueue.find(t=>t.roomName===e);t&&(t.claimed=1,Q.info("Marked expansion target as claimed: "+e,{subsystem:"Empire"}))}refreshRoomIntel(e){if(Game.time%this.config.intelRefreshInterval!==0)return;let t=0;for(const r in Game.rooms){const o=Game.rooms[r];e.roomIntel[r]?(this.updateRoomIntel(e.roomIntel[r],o),t++):(e.roomIntel[r]=this.createRoomIntel(o),t++)}t>0&&Game.time%500==0&&Q.info(`Refreshed intel for ${t} rooms`,{subsystem:"Empire"})}createRoomIntel(e){var t,r,o;const s=e.find(FIND_SOURCES),n=e.find(FIND_MINERALS)[0],i=e.controller;let a=0,c=0;const u=new Room.Terrain(e.name);for(let e=0;50>e;e++)for(let t=0;50>t;t++){const r=u.get(e,t);r===TERRAIN_MASK_SWAMP?c++:0===r&&a++}const l=c>a?"swamp":a>c?"plains":"mixed";return{name:e.name,lastSeen:Game.time,sources:s.length,controllerLevel:null!==(t=null==i?void 0:i.level)&&void 0!==t?t:0,owner:null===(r=null==i?void 0:i.owner)||void 0===r?void 0:r.username,reserver:null===(o=null==i?void 0:i.reservation)||void 0===o?void 0:o.username,mineralType:null==n?void 0:n.mineralType,threatLevel:0,scouted:1,terrain:l,isHighway:0,isSK:0,towerCount:e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER}).length,spawnCount:e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_SPAWN}).length}}updateRoomIntel(e,t){var r,o,s;e.lastSeen=Game.time;const n=t.controller;n&&(e.controllerLevel=null!==(r=n.level)&&void 0!==r?r:0,e.owner=null===(o=n.owner)||void 0===o?void 0:o.username,e.reserver=null===(s=n.reservation)||void 0===s?void 0:s.username);const i=t.find(FIND_HOSTILE_CREEPS).filter(e=>e.body.some(e=>e.type===ATTACK||e.type===RANGED_ATTACK||e.type===WORK));5>i.length?2>i.length?i.length>0?e.threatLevel=1:e.threatLevel=0:e.threatLevel=2:e.threatLevel=3,e.towerCount=t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_TOWER}).length,e.spawnCount=t.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_SPAWN}).length}trackGCLProgress(e){const t=Game.gcl.progress/Game.gcl.progressTotal*100;t<this.config.gclNotifyThreshold||Game.time%500!=0||Q.info(`GCL ${Game.gcl.level} progress: ${t.toFixed(1)}% (${Game.gcl.progress}/${Game.gcl.progressTotal})`,{subsystem:"Empire"}),e.objectives.targetRoomCount=Game.gcl.level}checkExpansionReadiness(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});if(t.length>=Game.gcl.level)return;const r=t.filter(e=>{var t,r;const o=null!==(r=null===(t=e.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0,s=void 0!==e.storage;return o>=this.config.minStableRcl&&s});if(0===r.length)return void(e.objectives.expansionPaused||(e.objectives.expansionPaused=1,Q.info("Expansion paused: waiting for stable room (RCL >= 4 with storage)",{subsystem:"Empire"})));const o=r.reduce((e,t)=>{var r,o;return e+(null!==(o=null===(r=t.storage)||void 0===r?void 0:r.store[RESOURCE_ENERGY])&&void 0!==o?o:0)},0)/r.length;5e4>o?e.objectives.expansionPaused||(e.objectives.expansionPaused=1,Q.info(`Expansion paused: insufficient energy reserves (${o.toFixed(0)} < 50000)`,{subsystem:"Empire"})):e.objectives.expansionPaused&&(e.objectives.expansionPaused=0,Q.info(`Expansion resumed: ${r.length} stable rooms with ${o.toFixed(0)} avg energy`,{subsystem:"Empire"}))}refreshNukeCandidates(e){if(Game.time%500==0&&(e.nukeCandidates=e.nukeCandidates.filter(e=>e.launched&&Game.time-e.launchTick>5e4?0:1),e.objectives.warMode&&0!==e.warTargets.length)){for(const t of e.warTargets){const r=e.roomIntel[t];if(!r||!r.scouted)continue;const o=e.nukeCandidates.find(e=>e.roomName===t);if(o&&!o.launched)continue;const s=this.scoreNukeCandidate(r);50>s||(e.nukeCandidates.push({roomName:t,score:s,launched:0,launchTick:0}),Q.info(`Added nuke candidate: ${t} (score: ${s})`,{subsystem:"Empire"}))}e.nukeCandidates.sort((e,t)=>t.score-e.score),e.nukeCandidates=e.nukeCandidates.slice(0,10)}}scoreNukeCandidate(e){var t,r;let o=0;return o+=10*e.controllerLevel,o+=15*(null!==(t=e.towerCount)&&void 0!==t?t:0),o+=20*(null!==(r=e.spawnCount)&&void 0!==r?r:0),e.isSK||e.isHighway?0:o}monitorClusterHealth(){if(Game.time%50!=0)return;const e=Ce.getClusters(),t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const r in e){const o=e[r],s=t.filter(e=>o.memberRooms.includes(e.name));if(0===s.length)continue;const n=s.reduce((e,t)=>{var r,o,s,n;return e+(null!==(o=null===(r=t.storage)||void 0===r?void 0:r.store[RESOURCE_ENERGY])&&void 0!==o?o:0)+(null!==(n=null===(s=t.terminal)||void 0===s?void 0:s.store[RESOURCE_ENERGY])&&void 0!==n?n:0)},0)/s.length,i=Game.cpu.getUsed()/t.length,a=i>2;3e4>n&&Game.time%500==0&&Q.warn(`Cluster ${r} has low energy: ${n.toFixed(0)} avg (threshold: 30000)`,{subsystem:"Empire"}),a&&Game.time%500==0&&Q.warn(`Cluster ${r} has high CPU usage: ${i.toFixed(2)} per room`,{subsystem:"Empire"}),o.metrics||(o.metrics={energyIncome:0,energyConsumption:0,energyBalance:0,warIndex:0,economyIndex:0});const c=Math.min(100,n/1e5*100),u=s.length/o.memberRooms.length*100;o.metrics.economyIndex=Math.round((c+u)/2),40>o.metrics.economyIndex&&Game.time%500==0&&Q.warn(`Cluster ${r} economy index low: ${o.metrics.economyIndex} - consider rebalancing`,{subsystem:"Empire"})}}assessPowerBankProfitability(e){var t,r;if(Game.time%100!=0)return;const o=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});if(0!==o.length)for(const s of e.powerBanks){if(s.active)continue;let e=1/0,n=null;for(const t of o){const r=Game.map.getRoomLinearDistance(t.name,s.roomName);e>r&&(e=r,n=t)}if(!n)continue;const i=s.decayTick-Game.time,a=100*e+s.power/2,c=i>1.5*a&&5>=e&&s.power>=1e3&&(null!==(r=null===(t=n.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0)>=7;c||Game.time%500!=0?c&&Game.time%500==0&&Q.info(`Profitable power bank in ${s.roomName}: power=${s.power}, distance=${e}, timeRemaining=${i}`,{subsystem:"Empire"}):Q.debug(`Power bank in ${s.roomName} not profitable: power=${s.power}, distance=${e}, timeRemaining=${i}, requiredTime=`+a.toFixed(0),{subsystem:"Empire"})}}};H([Rs("empire:manager","Empire Manager",{priority:me.MEDIUM,interval:30,minBucket:5e3,cpuBudget:.05})],an.prototype,"run",null),an=H([ys()],an);const cn=new an,un={updateInterval:20,minBucket:4e3,maxRemoteDistance:2,maxRemotesPerRoom:3,minRemoteSources:1,minRclForRemotes:3,minRclForClaiming:4,minGclProgressForClaim:.7,clusterExpansionDistance:5,minStableRoomPercentage:.6};let ln=class{constructor(e={}){this.lastRun=0,this.cachedUsername="",this.usernameLastTick=0,this.config={...un,...e}}run(){const e=Ce.getOvermind();this.lastRun=Game.time,this.updateRemoteAssignments(e),this.isExpansionReady(e)&&this.assignClaimerTargets(e),this.assignReserverTargets()}updateRemoteAssignments(e){var t,r,o;const s=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const n of s){const s=Ce.getSwarmState(n.name);if(!s)continue;if((null!==(r=null===(t=n.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0)<this.config.minRclForRemotes)continue;const i=null!==(o=s.remoteAssignments)&&void 0!==o?o:[],a=this.validateRemoteAssignments(i,e,n.name),c=this.calculateRemoteCapacity(n,s);if(a.length<c){const t=this.findRemoteCandidates(n.name,e,a),r=c-a.length,o=t.slice(0,r);for(const e of o)a.includes(e)||(a.push(e),Q.info(`Assigned remote room ${e} to ${n.name}`,{subsystem:"Expansion"}))}JSON.stringify(a)!==JSON.stringify(s.remoteAssignments)&&(s.remoteAssignments=a)}}calculateRemoteCapacity(e,t){var r,o;const s=null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0;if(4>s)return Math.min(1,this.config.maxRemotesPerRoom);if(7>s)return Math.min(2,this.config.maxRemotesPerRoom);const n=e.storage;return n&&5e4>n.store.getUsedCapacity(RESOURCE_ENERGY)?Math.min(1,this.config.maxRemotesPerRoom):2>t.danger?this.config.maxRemotesPerRoom:Math.min(1,this.config.maxRemotesPerRoom)}validateRemoteAssignments(e,t,r){return e.filter(e=>{const o=t.roomIntel[e];if(!o)return 1;let s=null;o.owner&&(Q.info(`Removing remote ${e} - now owned by ${o.owner}`,{subsystem:"Expansion"}),s="claimed");const n=this.getMyUsername();if(!s&&o.reserver&&o.reserver!==n&&(Q.info(`Removing remote ${e} - reserved by ${o.reserver}`,{subsystem:"Expansion"}),s="hostile"),s||3>o.threatLevel||(Q.info(`Removing remote ${e} - threat level ${o.threatLevel}`,{subsystem:"Expansion"}),s="hostile"),!s){const t=Game.map.getRoomLinearDistance(r,e);t>this.config.maxRemoteDistance&&(Q.info(`Removing remote ${e} - too far (${t})`,{subsystem:"Expansion"}),s="unreachable")}return s?(ge.emit("remote.lost",{homeRoom:r,remoteRoom:e,reason:s,source:r}),0):1})}findRemoteCandidates(e,t,r){const o=[],s=this.getMyUsername();for(const n in t.roomIntel){if(r.includes(n))continue;if(this.isRemoteAssignedElsewhere(n,e))continue;const i=t.roomIntel[n];if(!i.scouted)continue;if(i.owner)continue;if(i.reserver&&i.reserver!==s)continue;if(i.isHighway||i.isSK)continue;if(i.sources<this.config.minRemoteSources)continue;if(i.threatLevel>=2)continue;const a=Game.map.getRoomLinearDistance(e,n);if(1>a||a>this.config.maxRemoteDistance)continue;const c=this.scoreRemoteCandidate(i,a);o.push({roomName:n,score:c})}return o.sort((e,t)=>t.score-e.score),o.map(e=>e.roomName)}scoreRemoteCandidate(e,t){let r=0;return r+=50*e.sources,r-=20*t,r-=30*e.threatLevel,"plains"===e.terrain?r+=10:"swamp"===e.terrain&&(r-=10),r}isRemoteAssignedElsewhere(e,t){var r;const o=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const s of o){if(s.name===t)continue;const o=Ce.getSwarmState(s.name);if(null===(r=null==o?void 0:o.remoteAssignments)||void 0===r?void 0:r.includes(e))return 1}return 0}assignClaimerTargets(e){const t=this.getNextExpansionTarget(e);if(!t)return;if(Object.values(Game.creeps).some(e=>{const r=e.memory;return"claimer"===r.role&&r.targetRoom===t.roomName&&"claim"===r.task}))return;let r=0;for(const e of Object.values(Game.creeps)){const o=e.memory;if("claimer"===o.role&&!o.targetRoom){o.targetRoom=t.roomName,o.task="claim",Q.info(`Assigned claim target ${t.roomName} to ${e.name}`,{subsystem:"Expansion"}),t.claimed=1,r=1;break}}r||this.requestClaimerSpawn(t.roomName,e)}requestClaimerSpawn(e,t){const r=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}).filter(e=>{var t,r;return(null!==(r=null===(t=e.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0)>=this.config.minRclForClaiming});if(0===r.length)return;let o=null,s=999;for(const t of r){const r=Game.map.getRoomLinearDistance(t.name,e);s>r&&(s=r,o=t)}if(!o)return;const n=Ce.getSwarmState(o.name);n&&"defensive"!==n.posture&&"evacuate"!==n.posture&&2>n.danger&&"expand"!==n.posture&&(n.posture="expand",Q.info(`Set ${o.name} to expand posture for claiming ${e} (distance: ${s})`,{subsystem:"Expansion"}))}assignReserverTargets(){var e;for(const t of Object.values(Game.creeps)){const r=t.memory;if("claimer"!==r.role||r.targetRoom)continue;const o=r.homeRoom;if(!o)continue;const s=Ce.getSwarmState(o);if(null===(e=null==s?void 0:s.remoteAssignments)||void 0===e?void 0:e.length)for(const e of s.remoteAssignments)if(!this.hasReserverAssigned(e)){r.targetRoom=e,r.task="reserve",Q.info(`Assigned reserve target ${e} to ${t.name}`,{subsystem:"Expansion"});break}}}hasReserverAssigned(e){for(const t of Object.values(Game.creeps)){const r=t.memory;if("claimer"===r.role&&r.targetRoom===e&&"reserve"===r.task)return 1}return 0}isExpansionReady(e){if(e.objectives.expansionPaused)return 0;const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});if(t.length>=Game.gcl.level)return 0;const r=Game.gcl.progress/Game.gcl.progressTotal;if(r<this.config.minGclProgressForClaim)return Game.time%500==0&&Q.info(`Waiting for GCL progress: ${(100*r).toFixed(1)}% (need ${(100*this.config.minGclProgressForClaim).toFixed(0)}%)`,{subsystem:"Expansion"}),0;const o=t.filter(e=>{var t,r;return(null!==(r=null===(t=e.controller)||void 0===t?void 0:t.level)&&void 0!==r?r:0)>=this.config.minRclForClaiming}),s=o.length/t.length;return s<this.config.minStableRoomPercentage?(Game.time%500==0&&Q.info(`Waiting for room stability: ${o.length}/${t.length} rooms stable (${(100*s).toFixed(0)}%, need ${(100*this.config.minStableRoomPercentage).toFixed(0)}%)`,{subsystem:"Expansion"}),0):1}getNextExpansionTarget(e){const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});if(t.length>=Game.gcl.level)return null;const r=e.claimQueue.filter(e=>!e.claimed);if(0===r.length)return null;const o=r.map(e=>{const r=this.getMinDistanceToOwned(e.roomName,t),o=r>this.config.clusterExpansionDistance?0:100;return{...e,clusterScore:e.score+o,distanceToCluster:r}});if(o.sort((e,t)=>t.clusterScore-e.clusterScore),Game.time%100==0&&o.length>0){const e=o[0];Q.info(`Next expansion target: ${e.roomName} (score: ${e.score}, cluster bonus: ${e.clusterScore-e.score}, distance: ${e.distanceToCluster})`,{subsystem:"Expansion"})}return o[0]}getMinDistanceToOwned(e,t){if(0===t.length)return 999;let r=999;for(const o of t){const t=Game.map.getRoomLinearDistance(e,o.name);r>t&&(r=t)}return r}getMyUsername(){if(this.usernameLastTick!==Game.time||!this.cachedUsername){const e=Object.values(Game.spawns);e.length>0&&(this.cachedUsername=e[0].owner.username),this.usernameLastTick=Game.time}return this.cachedUsername}addRemoteRoom(e,t){const r=Ce.getSwarmState(e);return r?(r.remoteAssignments||(r.remoteAssignments=[]),r.remoteAssignments.includes(t)?(Q.warn(`Remote ${t} already assigned to ${e}`,{subsystem:"Expansion"}),0):(r.remoteAssignments.push(t),Q.info(`Manually added remote ${t} to ${e}`,{subsystem:"Expansion"}),1)):(Q.error(`Cannot add remote: ${e} not found`,{subsystem:"Expansion"}),0)}removeRemoteRoom(e,t){const r=Ce.getSwarmState(e);if(!(null==r?void 0:r.remoteAssignments))return 0;const o=r.remoteAssignments.indexOf(t);return-1===o?0:(r.remoteAssignments.splice(o,1),Q.info(`Manually removed remote ${t} from ${e}`,{subsystem:"Expansion"}),1)}};H([fs("expansion:manager","Expansion Manager",{priority:me.LOW,interval:20,minBucket:4e3,cpuBudget:.02})],ln.prototype,"run",null),ln=H([ys()],ln);const mn=new ln,pn={updateInterval:100,priceUpdateInterval:500,minBucket:7e3,minCredits:1e4,emergencyCredits:5e3,tradingCredits:5e4,warPriceMultiplier:2,buyPriceThreshold:.85,sellPriceThreshold:1.15,maxPriceHistory:30,rollingAverageWindow:10,lowPriceMultiplier:.9,highPriceMultiplier:1.1,trendChangeThreshold:.05,buyOpportunityAdjustment:1.02,sellOpportunityAdjustment:.98,sellThresholds:{[RESOURCE_ENERGY]:5e5,[RESOURCE_HYDROGEN]:2e4,[RESOURCE_OXYGEN]:2e4,[RESOURCE_UTRIUM]:2e4,[RESOURCE_LEMERGIUM]:2e4,[RESOURCE_KEANIUM]:2e4,[RESOURCE_ZYNTHIUM]:2e4,[RESOURCE_CATALYST]:2e4},buyThresholds:{[RESOURCE_ENERGY]:1e5,[RESOURCE_HYDROGEN]:5e3,[RESOURCE_OXYGEN]:5e3,[RESOURCE_UTRIUM]:5e3,[RESOURCE_LEMERGIUM]:5e3,[RESOURCE_KEANIUM]:5e3,[RESOURCE_ZYNTHIUM]:5e3,[RESOURCE_CATALYST]:5e3},trackedResources:[RESOURCE_ENERGY,RESOURCE_HYDROGEN,RESOURCE_OXYGEN,RESOURCE_UTRIUM,RESOURCE_LEMERGIUM,RESOURCE_KEANIUM,RESOURCE_ZYNTHIUM,RESOURCE_CATALYST,RESOURCE_GHODIUM,RESOURCE_POWER],criticalResources:[RESOURCE_ENERGY,RESOURCE_GHODIUM],emergencyBuyThreshold:5e3,orderExtensionAge:5e3,maxTransportCostRatio:.3};let dn=class{constructor(e={}){this.lastRun=0,this.config={...pn,...e}}run(){this.lastRun=Game.time,this.ensureMarketMemory(),Game.time%this.config.priceUpdateInterval===0&&this.updatePriceTracking(),this.updateOrderStats(),this.handleEmergencyBuying(),this.cancelOldOrders(),this.manageExistingOrders(),this.updateBuyOrders(),this.updateSellOrders(),this.executeDeal(),Game.time%200==0&&this.balanceResourcesAcrossRooms()}ensureMarketMemory(){const e=Ce.getOvermind();e.market||(e.market={resources:{},lastScan:0}),e.market.orders||(e.market.orders={}),void 0===e.market.totalProfit&&(e.market.totalProfit=0),e.market.lastBalance||(e.market.lastBalance=0)}updatePriceTracking(){const e=Ce.getOvermind();if(e.market){for(const e of this.config.trackedResources)this.updateResourcePrice(e);e.market.lastScan=Game.time,Q.debug(`Updated market prices for ${this.config.trackedResources.length} resources`,{subsystem:"Market"})}}updateResourcePrice(e){const t=Ce.getOvermind();if(!t.market)return;const r=Game.market.getHistory(e);if(0===r.length)return;const o=r[r.length-1];let s=t.market.resources[e];s||(s={resource:e,priceHistory:[],avgPrice:o.avgPrice,trend:0,lastUpdate:Game.time},t.market.resources[e]=s);const n={tick:Game.time,avgPrice:o.avgPrice,lowPrice:o.avgPrice*this.config.lowPriceMultiplier,highPrice:o.avgPrice*this.config.highPriceMultiplier};s.priceHistory.push(n),s.priceHistory.length>this.config.maxPriceHistory&&s.priceHistory.shift();const i=s.priceHistory.slice(-this.config.rollingAverageWindow);if(s.avgPrice=i.reduce((e,t)=>e+t.avgPrice,0)/i.length,s.priceHistory.length>=5){const e=s.priceHistory.slice(-5,-2).reduce((e,t)=>e+t.avgPrice,0)/3,t=(s.priceHistory.slice(-3).reduce((e,t)=>e+t.avgPrice,0)/3-e)/e;t>this.config.trendChangeThreshold?s.trend=1:t<-this.config.trendChangeThreshold?s.trend=-1:s.trend=0}if(i.length>=5){const e=s.avgPrice,t=i.reduce((t,r)=>t+Math.pow(r.avgPrice-e,2),0)/i.length,r=Math.sqrt(t);s.volatility=r/e}if(s.priceHistory.length>=3){const e=s.priceHistory.slice(-3),t=(e[2].avgPrice-e[0].avgPrice)/2;s.predictedPrice=e[2].avgPrice+t}s.lastUpdate=Game.time}getMarketData(e){var t;return null===(t=Ce.getOvermind().market)||void 0===t?void 0:t.resources[e]}isBuyOpportunity(e){const t=this.getMarketData(e);if(!t)return 0;const r=Game.market.getHistory(e);if(0===r.length)return 0;const o=r[r.length-1].avgPrice;return t.avgPrice*this.config.buyPriceThreshold>=o}isSellOpportunity(e){const t=this.getMarketData(e);if(!t)return 0;const r=Game.market.getHistory(e);return 0===r.length?0:r[r.length-1].avgPrice>=t.avgPrice*this.config.sellPriceThreshold}cancelOldOrders(){const e=Game.market.orders;for(const t in e){const r=e[t];Game.time-r.created>1e4&&(Game.market.cancelOrder(t),Q.info(`Cancelled old order: ${r.type} ${r.resourceType}`,{subsystem:"Market"})),100>r.remainingAmount&&Game.market.cancelOrder(t)}}updateBuyOrders(){var e,t,r;const o=Ce.getOvermind().objectives.warMode,s={};for(const r in Game.rooms){const o=Game.rooms[r];if(o.terminal&&(null===(e=o.controller)||void 0===e?void 0:e.my))for(const e in o.terminal.store)s[e]=(null!==(t=s[e])&&void 0!==t?t:0)+o.terminal.store[e]}for(const e in this.config.buyThresholds){const t=this.config.buyThresholds[e],n=null!==(r=s[e])&&void 0!==r?r:0;if(t>n){const r=this.isBuyOpportunity(e);o||r?this.createBuyOrder(e,t-n,o,r):Q.debug(`Skipping buy for ${e}: waiting for better price`,{subsystem:"Market"})}}}createBuyOrder(e,t,r,o){var s;if(Object.values(Game.market.orders).filter(t=>t.type===ORDER_BUY&&t.resourceType===e).length>0)return;const n=Game.market.getHistory(e);if(0===n.length)return;const i=n[n.length-1].avgPrice,a=this.getMarketData(e);let c;if(c=r?i*this.config.warPriceMultiplier:o&&a?i*this.config.buyOpportunityAdjustment:null!==(s=null==a?void 0:a.avgPrice)&&void 0!==s?s:i*this.config.highPriceMultiplier,Game.market.credits<this.config.minCredits)return;const u=Object.values(Game.rooms).find(e=>{var t;return e.terminal&&(null===(t=e.controller)||void 0===t?void 0:t.my)});if((null==u?void 0:u.terminal)&&Game.market.createOrder({type:ORDER_BUY,resourceType:e,price:c,totalAmount:Math.min(t,1e4),roomName:u.name})===OK){const s=o?" (LOW PRICE!)":r?" (WAR MODE)":"";Q.info(`Created buy order: ${t} ${e} at ${c.toFixed(3)} credits${s}`,{subsystem:"Market"})}}updateSellOrders(){var e,t,r;const o={};for(const r in Game.rooms){const s=Game.rooms[r];if(s.terminal&&(null===(e=s.controller)||void 0===e?void 0:e.my))for(const e in s.terminal.store)o[e]=(null!==(t=o[e])&&void 0!==t?t:0)+s.terminal.store[e]}for(const e in this.config.sellThresholds){const t=this.config.sellThresholds[e],s=null!==(r=o[e])&&void 0!==r?r:0;if(s>t){const r=this.isSellOpportunity(e);r?this.createSellOrder(e,s-t,r):Q.debug(`Holding ${e} surplus: waiting for better price`,{subsystem:"Market"})}}}createSellOrder(e,t,r){var o;if(Object.values(Game.market.orders).filter(t=>t.type===ORDER_SELL&&t.resourceType===e).length>0)return;const s=Game.market.getHistory(e);if(0===s.length)return;const n=s[s.length-1].avgPrice,i=this.getMarketData(e);let a;a=r&&i?n*this.config.sellOpportunityAdjustment:null!==(o=null==i?void 0:i.avgPrice)&&void 0!==o?o:n*this.config.lowPriceMultiplier;const c=Object.values(Game.rooms).find(t=>{var r;return t.terminal&&(null===(r=t.controller)||void 0===r?void 0:r.my)&&t.terminal.store[e]>1e3});if((null==c?void 0:c.terminal)&&Game.market.createOrder({type:ORDER_SELL,resourceType:e,price:a,totalAmount:Math.min(t,1e4),roomName:c.name})===OK){const o=r?" (HIGH PRICE!)":"";Q.info(`Created sell order: ${t} ${e} at ${a.toFixed(3)} credits${o}`,{subsystem:"Market"})}}updateOrderStats(){var e,t;const r=Ce.getOvermind();if(!(null===(e=r.market)||void 0===e?void 0:e.orders))return;const o=Game.market.orders;for(const e in r.market.orders){const s=r.market.orders[e],n=o[e];if(n){if(void 0!==n.totalAmount){const e=n.totalAmount-n.remainingAmount,t=e-s.totalTraded;t>0&&(s.totalTraded=e,s.totalValue+=t*n.price)}}else{if(s.totalTraded>0){const e="sell"===s.type?s.totalValue:-s.totalValue;r.market.totalProfit=(null!==(t=r.market.totalProfit)&&void 0!==t?t:0)+e,Q.info(`Order completed: ${s.resource} ${s.type} - Traded: ${s.totalTraded}, Value: ${s.totalValue.toFixed(0)}, Profit: ${e.toFixed(0)}`,{subsystem:"Market"})}delete r.market.orders[e]}}}executeDeal(){if(Game.time%50==0&&Ce.getOvermind().objectives.warMode){const e=[RESOURCE_CATALYZED_GHODIUM_ACID,RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,RESOURCE_CATALYZED_KEANIUM_ALKALIDE];for(const t of e){const e=Game.market.getAllOrders({type:ORDER_SELL,resourceType:t});if(e.length>0){e.sort((e,t)=>e.price-t.price);const r=e[0],o=Object.values(Game.rooms).find(e=>{var t;return e.terminal&&(null===(t=e.controller)||void 0===t?void 0:t.my)});if(o&&10>r.price){const e=Math.min(r.amount,1e3);Game.market.deal(r.id,e,o.name)===OK&&Q.info(`Bought ${e} ${t} for ${r.price.toFixed(3)} credits/unit`,{subsystem:"Market"})}}}}}handleEmergencyBuying(){var e,t,r;if(Ce.getOvermind(),Game.market.credits<this.config.emergencyCredits)return;const o={};for(const r in Game.rooms){const s=Game.rooms[r];if(s.terminal&&(null===(e=s.controller)||void 0===e?void 0:e.my))for(const e in s.terminal.store)o[e]=(null!==(t=o[e])&&void 0!==t?t:0)+s.terminal.store[e]}for(const e of this.config.criticalResources){const t=null!==(r=o[e])&&void 0!==r?r:0;t<this.config.emergencyBuyThreshold&&this.executeEmergencyBuy(e,this.config.emergencyBuyThreshold-t)}}executeEmergencyBuy(e,t){const r=Game.market.getAllOrders({type:ORDER_SELL,resourceType:e});if(0===r.length)return;const o=Object.values(Game.rooms).find(e=>{var t;return e.terminal&&(null===(t=e.controller)||void 0===t?void 0:t.my)});if(!(null==o?void 0:o.terminal))return;r.sort((e,t)=>(e.roomName?e.price+Game.market.calcTransactionCost(1e3,o.name,e.roomName)/1e3:e.price)-(t.roomName?t.price+Game.market.calcTransactionCost(1e3,o.name,t.roomName)/1e3:t.price));const s=r[0],n=Math.min(t,s.amount,1e4);Game.market.deal(s.id,n,o.name)===OK&&Q.warn(`EMERGENCY BUY: ${n} ${e} at ${s.price.toFixed(3)} credits/unit`,{subsystem:"Market"})}manageExistingOrders(){const e=Game.market.orders;for(const t in e){const r=e[t];if(Game.time-r.created<this.config.orderExtensionAge)continue;const o=r.resourceType;if("token"===o)continue;if(!this.config.trackedResources.includes(o))continue;if(!this.getMarketData(o))continue;const s=Game.market.getHistory(o);if(0===s.length)continue;const n=s[s.length-1].avgPrice;if(r.type===ORDER_BUY){const e=n*this.config.buyOpportunityAdjustment;r.price<.9*e&&r.remainingAmount>1e3&&(Game.market.extendOrder(t,Math.min(5e3,r.remainingAmount)),Q.debug(`Extended buy order for ${r.resourceType}: +${r.remainingAmount} at ${r.price.toFixed(3)}`,{subsystem:"Market"}))}if(r.type===ORDER_SELL){const e=n*this.config.sellOpportunityAdjustment;r.price>1.1*e&&r.remainingAmount>1e3&&(Game.market.extendOrder(t,Math.min(5e3,r.remainingAmount)),Q.debug(`Extended sell order for ${r.resourceType}: +${r.remainingAmount} at ${r.price.toFixed(3)}`,{subsystem:"Market"}))}}}checkArbitrageOpportunities(){if(Game.market.credits>=this.config.tradingCredits)for(const e of this.config.trackedResources){const t=Game.market.getAllOrders({type:ORDER_BUY,resourceType:e}),r=Game.market.getAllOrders({type:ORDER_SELL,resourceType:e});if(0===t.length||0===r.length)continue;t.sort((e,t)=>t.price-e.price),r.sort((e,t)=>e.price-t.price);const o=t[0],s=r[0],n=Object.values(Game.rooms).find(e=>{var t;return e.terminal&&(null===(t=e.controller)||void 0===t?void 0:t.my)});if(!(null==n?void 0:n.terminal)||!s.roomName||!o.roomName)continue;const i=Game.market.calcTransactionCost(1e3,n.name,s.roomName)/1e3,a=s.price+i,c=o.price-a;c>0&&i/s.price<this.config.maxTransportCostRatio&&Q.debug(`ARBITRAGE OPPORTUNITY: ${e} - Buy @ ${s.price.toFixed(3)}, Sell @ ${o.price.toFixed(3)}, Profit: ${c.toFixed(3)}/unit`,{subsystem:"Market"})}}balanceResourcesAcrossRooms(){var e;const t=Object.values(Game.rooms).filter(e=>{var t;return e.terminal&&(null===(t=e.controller)||void 0===t?void 0:t.my)});if(t.length>=2)for(const r of this.config.trackedResources){const o=[];for(const s of t){if(!s.terminal)continue;const t=null!==(e=s.terminal.store[r])&&void 0!==e?e:0;o.push({room:s,amount:t})}if(2>o.length)continue;const s=o.reduce((e,t)=>e+t.amount,0)/o.length;o.sort((e,t)=>t.amount-e.amount);const n=o[0],i=o[o.length-1],a=n.amount-i.amount;if(a>.5*s&&n.amount>5e3&&n.room.terminal&&i.room.terminal){const e=Math.min(Math.floor(a/2),1e4),t=Game.market.calcTransactionCost(e,n.room.name,i.room.name);(r===RESOURCE_ENERGY&&.1*e>t||r!==RESOURCE_ENERGY&&1e3>t)&&n.room.terminal.send(r,e,i.room.name)===OK&&Q.info(`Balanced ${e} ${r}: ${n.room.name} -> ${i.room.name} (cost: ${t} energy)`,{subsystem:"Market"})}}}};H([Rs("empire:market","Market Manager",{priority:me.LOW,interval:100,minBucket:7e3,cpuBudget:.02})],dn.prototype,"run",null),dn=H([ys()],dn);const gn=new dn,fn={updateInterval:500,minGhodium:5e3,minEnergy:3e5,minScore:50,siegeCoordinationWindow:1e3,nukeFlightTime:5e4,terminalPriority:5,donorRoomBuffer:1e3};let Rn=class{constructor(e={}){this.lastRun=0,this.nukerReadyLogged=new Set,this.config={...fn,...e}}run(){this.lastRun=Game.time,this.detectIncomingNukes(),this.manageNukeResources(),this.loadNukers(),this.evaluateNukeCandidates(),this.coordinateWithSieges(),this.launchNukes()}loadNukers(){var e;for(const t in Game.rooms){const r=Game.rooms[t];if(!(null===(e=r.controller)||void 0===e?void 0:e.my))continue;const o=r.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_NUKER})[0];if(!o)continue;const s=o.store.getFreeCapacity(RESOURCE_ENERGY),n=o.store.getFreeCapacity(RESOURCE_GHODIUM);(s>0||n>0)&&Q.debug(`Nuker in ${t} needs ${s} energy, ${n} ghodium`,{subsystem:"Nuke"})}}evaluateNukeCandidates(){const e=Ce.getOvermind();if(e.nukeCandidates=[],e.objectives.warMode){for(const t of e.warTargets){const r=this.scoreNukeCandidate(t);r.score<this.config.minScore||(e.nukeCandidates.push({roomName:t,score:r.score,launched:0,launchTick:0}),Q.info(`Nuke candidate: ${t} (score: ${r.score}) - ${r.reasons.join(", ")}`,{subsystem:"Nuke"}))}e.nukeCandidates.sort((e,t)=>t.score-e.score)}}scoreNukeCandidate(e){let t=0;const r=[],o=Ce.getOvermind().roomIntel[e];if(!o)return{roomName:e,score:0,reasons:["No intel"]};o.owner&&""!==o.owner&&(t+=30,r.push("Owned room")),2>o.threatLevel||(t+=20,r.push("High threat")),o.towerCount&&(t+=5*o.towerCount,r.push(o.towerCount+" towers")),o.spawnCount&&(t+=10*o.spawnCount,r.push(o.spawnCount+" spawns")),o.controllerLevel&&(t+=3*o.controllerLevel,r.push("RCL "+o.controllerLevel));const s=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});if(s.length>0){const o=Math.min(...s.map(t=>Game.map.getRoomLinearDistance(e,t.name)));t-=2*o,r.push(o+" rooms away")}return Ce.getOvermind().warTargets.includes(e)&&(t+=15,r.push("War target")),{roomName:e,score:t,reasons:r}}launchNukes(){var e;const t=Ce.getOvermind();if(!t.objectives.warMode)return;const r=[];for(const t in Game.rooms){const o=Game.rooms[t];if(!(null===(e=o.controller)||void 0===e?void 0:e.my))continue;const s=o.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_NUKER})[0];!s||s.store.getUsedCapacity(RESOURCE_ENERGY)<this.config.minEnergy||s.store.getUsedCapacity(RESOURCE_GHODIUM)<this.config.minGhodium||r.push(s)}if(0!==r.length)for(const e of t.nukeCandidates)if(!e.launched){for(const t of r){if(Game.map.getRoomLinearDistance(t.room.name,e.roomName)>10)continue;const o=new RoomPosition(25,25,e.roomName),s=t.launchNuke(o);if(s===OK){e.launched=1,e.launchTick=Game.time,Q.warn(`NUKE LAUNCHED from ${t.room.name} to ${e.roomName}!`,{subsystem:"Nuke"});const o=r.indexOf(t);o>-1&&r.splice(o,1);break}Q.error("Failed to launch nuke: "+s,{subsystem:"Nuke"})}if(0===r.length)break}}detectIncomingNukes(){var e;for(const t in Game.rooms){const r=Game.rooms[t];if(!(null===(e=r.controller)||void 0===e?void 0:e.my))continue;const o=Ce.getSwarmState(t);if(!o)continue;const s=r.find(FIND_NUKES);if(s.length>0&&!o.nukeDetected){o.nukeDetected=1,o.pheromones.defense=Math.min(100,o.pheromones.defense+50),o.danger=3;const e=Math.min(...s.map(e=>{var t;return null!==(t=e.timeToLand)&&void 0!==t?t:1/0}));Q.warn(`INCOMING NUKE DETECTED in ${t}! Impact in ${e} ticks (${s.length} nuke${s.length>1?"s":""})`,{subsystem:"Nuke"}),o.eventLog.push({type:"nuke_incoming",time:Game.time,details:`${s.length} nuke(s), impact in ${e} ticks`}),o.eventLog.length>20&&o.eventLog.shift()}else 0===s.length&&o.nukeDetected&&(o.nukeDetected=0,Q.info("Nuke threat cleared in "+t,{subsystem:"Nuke"}))}}manageNukeResources(){var e,t;if(Ce.getOvermind().objectives.warMode)for(const r in Game.rooms){const o=Game.rooms[r];if(!(null===(e=o.controller)||void 0===e?void 0:e.my))continue;const s=o.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_NUKER})[0];if(!s)continue;const n=o.terminal;if(!n||!n.my)continue;const i=s.store.getFreeCapacity(RESOURCE_ENERGY),a=s.store.getFreeCapacity(RESOURCE_GHODIUM);if(a>0){const e=null!==(t=n.store.getUsedCapacity(RESOURCE_GHODIUM))&&void 0!==t?t:0;a>e&&this.requestResourceTransfer(r,RESOURCE_GHODIUM,a-e)}const c=r+"-nuker";0===i&&0===a?this.nukerReadyLogged.has(c)||(Q.info(`Nuker in ${r} is fully loaded and ready to launch`,{subsystem:"Nuke"}),this.nukerReadyLogged.add(c)):this.nukerReadyLogged.delete(c)}}requestResourceTransfer(e,t,r){const o=this.findDonorRoom(e,t,r);o?(this.terminalManager||(this.terminalManager=require("../economy/terminalManager").terminalManager),this.terminalManager.requestTransfer(o,e,t,r,this.config.terminalPriority)&&Q.info(`Requested ${r} ${t} transfer from ${o} to ${e} for nuker`,{subsystem:"Nuke"})):Q.debug(`No donor room found for ${r} ${t} to ${e}`,{subsystem:"Nuke"})}findDonorRoom(e,t,r){var o,s,n,i;const a=[];for(const n in Game.rooms){const i=Game.rooms[n];if(!(null===(o=i.controller)||void 0===o?void 0:o.my)||n===e)continue;const c=i.terminal;if(!c||!c.my)continue;const u=null!==(s=c.store.getUsedCapacity(t))&&void 0!==s?s:0;if(u<r+this.config.donorRoomBuffer)continue;const l=Game.map.getRoomLinearDistance(n,e);a.push({room:n,amount:u,distance:l})}return 0===a.length?null:(a.sort((e,t)=>e.distance-t.distance),null!==(i=null===(n=a[0])||void 0===n?void 0:n.room)&&void 0!==i?i:null)}coordinateWithSieges(){const e=Ce.getOvermind();if(!e.objectives.warMode)return;const t=Ce.getClusters();for(const r of Object.values(t)){if(!r.squads||0===r.squads.length)continue;const t=r.squads.filter(e=>"siege"===e.type);for(const r of t){if("moving"!==r.state&&"attacking"!==r.state)continue;const t=r.targetRooms[0];if(!t)continue;const o=e.nukeCandidates.find(e=>e.roomName===t);if(!o)continue;if(o.launched)continue;const s=this.estimateSquadEta(r,t),n=s-this.config.nukeFlightTime+this.config.siegeCoordinationWindow;if(Game.time>=n){Q.info(`Nuke launch window opened for ${t} - siege squad ${r.id} ETA: ${s} ticks`,{subsystem:"Nuke"});const e=Ce.getSwarmState(t);e&&(e.pheromones.nukeTarget=Math.min(100,e.pheromones.nukeTarget+50))}}}}estimateSquadEta(e,t){const r=e.members.map(e=>Game.creeps[e]).filter(e=>null!=e);if(0===r.length)return 50*Game.map.getRoomLinearDistance(e.rallyRoom,t);const o=r.map(e=>50*Game.map.getRoomLinearDistance(e.room.name,t));return Math.min(...o)}};H([Rs("empire:nuke","Nuke Manager",{priority:me.LOW,interval:500,minBucket:8e3,cpuBudget:.01})],Rn.prototype,"run",null),Rn=H([ys()],Rn);const hn=new Rn,yn={minPower:1e3,maxDistance:5,minTicksRemaining:3e3,healerRatio:.5,minBucket:7e3,maxConcurrentOps:2};let En=class{constructor(e={}){this.operations=new Map,this.lastScan=0,this.config={...yn,...e}}run(){50>Game.time-this.lastScan||(this.scanForPowerBanks(),this.lastScan=Game.time),this.updateOperations(),this.evaluateOpportunities(),Game.time%100==0&&this.operations.size>0&&this.logStatus()}scanForPowerBanks(){var e,t;const r=Ce.getOvermind();for(const o in Game.rooms){const s=Game.rooms[o],n=o.match(/^[WE](\d+)[NS](\d+)$/);if(!n)continue;const i=parseInt(n[1],10),a=parseInt(n[2],10);if(i%10!=0&&a%10!=0)continue;const c=s.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_BANK});for(const s of c){const n=r.powerBanks.find(e=>e.roomName===o&&e.pos.x===s.pos.x&&e.pos.y===s.pos.y);if(n)n.power=s.power,n.decayTick=Game.time+(null!==(t=s.ticksToDecay)&&void 0!==t?t:5e3);else{const t={roomName:o,pos:{x:s.pos.x,y:s.pos.y},power:s.power,decayTick:Game.time+(null!==(e=s.ticksToDecay)&&void 0!==e?e:5e3),active:0};r.powerBanks.push(t),s.power<this.config.minPower||Q.info(`Power bank discovered in ${o}: ${s.power} power`,{subsystem:"PowerBank"})}}}r.powerBanks=r.powerBanks.filter(e=>e.decayTick>Game.time)}updateOperations(){for(const[e,t]of this.operations)switch(t.state){case"scouting":this.updateScoutingOp(t);break;case"attacking":this.updateAttackingOp(t);break;case"collecting":this.updateCollectingOp(t);break;case"complete":case"failed":Game.time-t.startedAt>1e4&&this.operations.delete(e)}}updateScoutingOp(e){var t;const r=Game.rooms[e.roomName];if(!r)return;const o=r.find(FIND_STRUCTURES,{filter:t=>t.structureType===STRUCTURE_POWER_BANK&&t.pos.x===e.pos.x&&t.pos.y===e.pos.y})[0];if(!o)return e.state="failed",void Q.warn(`Power bank in ${e.roomName} disappeared`,{subsystem:"PowerBank"});e.power=o.power,e.decayTick=Game.time+(null!==(t=o.ticksToDecay)&&void 0!==t?t:0),e.assignedCreeps.attackers.length>0&&(e.state="attacking",Q.info("Starting attack on power bank in "+e.roomName,{subsystem:"PowerBank"}))}updateAttackingOp(e){var t;const r=Game.rooms[e.roomName];if(e.assignedCreeps.attackers=e.assignedCreeps.attackers.filter(e=>Game.creeps[e]),e.assignedCreeps.healers=e.assignedCreeps.healers.filter(e=>Game.creeps[e]),!r)return void(0===e.assignedCreeps.attackers.length&&0===e.assignedCreeps.healers.length&&(e.state="failed"));const o=r.find(FIND_STRUCTURES,{filter:t=>t.structureType===STRUCTURE_POWER_BANK&&t.pos.x===e.pos.x&&t.pos.y===e.pos.y})[0];if(!o)return e.state="collecting",void Q.info(`Power bank destroyed in ${e.roomName}, collecting power`,{subsystem:"PowerBank"});const s=null!==(t=e.lastHits)&&void 0!==t?t:2e6;e.lastHits=o.hits,s>o.hits&&(e.damageDealt+=s-o.hits);const n=e.decayTick-Game.time,i=e.damageDealt/Math.max(1,Game.time-e.startedAt),a=o.hits/Math.max(1,i);a>.9*n&&Q.warn(`Power bank in ${e.roomName} may decay before completion (${Math.round(a)} > ${n})`,{subsystem:"PowerBank"}),e.estimatedCompletion=Game.time+Math.round(a)}updateCollectingOp(e){const t=Game.rooms[e.roomName];if(e.assignedCreeps.carriers=e.assignedCreeps.carriers.filter(e=>Game.creeps[e]),!t)return void(0===e.assignedCreeps.carriers.length&&(e.state="failed"));const r=t.find(FIND_DROPPED_RESOURCES,{filter:e=>e.resourceType===RESOURCE_POWER}),o=t.find(FIND_RUINS,{filter:e=>e.store.getUsedCapacity(RESOURCE_POWER)>0});0===r.length&&0===o.length&&(e.state="complete",Q.info(`Power bank operation complete in ${e.roomName}: ${e.powerCollected} power collected`,{subsystem:"PowerBank"}))}evaluateOpportunities(){var e,t;if(Array.from(this.operations.values()).filter(e=>"complete"!==e.state&&"failed"!==e.state).length>=this.config.maxConcurrentOps)return;const r=Ce.getOvermind(),o=Object.values(Game.rooms).filter(e=>{var t;return(null===(t=e.controller)||void 0===t?void 0:t.my)&&e.controller.level>=7});if(0===o.length)return;const s=r.powerBanks.filter(e=>e.active||this.operations.has(e.roomName)||e.power<this.config.minPower||e.decayTick-Game.time<this.config.minTicksRemaining||this.getMinDistanceToOwned(e.roomName,o)>this.config.maxDistance?0:1).map(e=>({entry:e,score:this.scorePowerBank(e,o)})).sort((e,t)=>t.score-e.score);if(s.length>0&&(null!==(t=null===(e=s[0])||void 0===e?void 0:e.score)&&void 0!==t?t:0)>0){const e=s[0];this.startOperation(e.entry,o)}}scorePowerBank(e,t){let r=0;r+=.01*e.power;const o=e.decayTick-Game.time;return o>4e3&&(r+=50),o>5e3&&(r+=30),r-=20*this.getMinDistanceToOwned(e.roomName,t),3e3>e.power||(r+=50),5e3>e.power||(r+=50),r}getMinDistanceToOwned(e,t){let r=1/0;for(const o of t){const t=Game.map.getRoomLinearDistance(e,o.name);r>t&&(r=t)}return r}startOperation(e,t){let r=null,o=1/0;for(const s of t){const t=Game.map.getRoomLinearDistance(e.roomName,s.name);o>t&&(o=t,r=s)}if(!r)return;const s={roomName:e.roomName,pos:e.pos,power:e.power,decayTick:e.decayTick,homeRoom:r.name,state:"scouting",assignedCreeps:{attackers:[],healers:[],carriers:[]},damageDealt:0,powerCollected:0,startedAt:Game.time,estimatedCompletion:0};this.operations.set(e.roomName,s),e.active=1,Q.info(`Started power bank operation in ${e.roomName} (${e.power} power, home: ${r.name})`,{subsystem:"PowerBank"})}assignCreep(e,t,r){const o=this.operations.get(t);if(!o)return 0;switch(r){case"attacker":o.assignedCreeps.attackers.includes(e)||o.assignedCreeps.attackers.push(e);break;case"healer":o.assignedCreeps.healers.includes(e)||o.assignedCreeps.healers.push(e);break;case"carrier":o.assignedCreeps.carriers.includes(e)||o.assignedCreeps.carriers.push(e)}return 1}recordPowerCollected(e,t){const r=this.operations.get(e);r&&(r.powerCollected+=t)}getActiveOperations(){return Array.from(this.operations.values()).filter(e=>"complete"!==e.state&&"failed"!==e.state)}getOperation(e){return this.operations.get(e)}getRequiredCreeps(e){const t=e.decayTick-Game.time,r=2e6-e.damageDealt,o=Math.ceil(r/(.8*t)/600),s=Math.ceil(o*this.config.healerRatio),n=Math.ceil(e.power/2e3);return{attackers:Math.max(1,o),healers:Math.max(1,s),carriers:Math.max(1,n)}}requestSpawns(e){let t=0,r=0,o=0;for(const[s,n]of this.operations){if(n.homeRoom!==e)continue;if("complete"===n.state||"failed"===n.state)continue;const s=this.getRequiredCreeps(n),i={attackers:n.assignedCreeps.attackers.filter(e=>Game.creeps[e]).length,healers:n.assignedCreeps.healers.filter(e=>Game.creeps[e]).length,carriers:n.assignedCreeps.carriers.filter(e=>Game.creeps[e]).length};"attacking"!==n.state&&"scouting"!==n.state||(t+=Math.max(0,s.attackers-i.attackers),r+=Math.max(0,s.healers-i.healers)),"collecting"!==n.state&&"attacking"!==n.state||(o+=Math.max(0,s.carriers-i.carriers))}return{powerHarvesters:t,healers:r,powerCarriers:o}}getProfitability(e,t){const r=Game.map.getRoomLinearDistance(e.roomName,t);e.decayTick,Game.time;const o=50*r+1667,s=7200+.1*o,n=10*e.power-s,i=o>0?n/o:0;return{power:e.power,energyCost:s,netProfit:n,profitPerTick:i}}logStatus(){const e=Array.from(this.operations.values()).filter(e=>"complete"!==e.state&&"failed"!==e.state);for(const t of e)Q.info(`Power bank op ${t.roomName}: ${t.state}, ${t.assignedCreeps.attackers.length}A/${t.assignedCreeps.healers.length}H/${t.assignedCreeps.carriers.length}C, ${Math.round(t.damageDealt/1e3)}k damage, ${t.powerCollected} collected`,{subsystem:"PowerBank"})}};H([Rs("empire:powerBank","Power Bank Harvesting",{priority:me.LOW,interval:50,minBucket:7e3,cpuBudget:.02})],En.prototype,"run",null),En=H([ys()],En);const Tn=new En,Cn={minGPL:1,minPowerReserve:1e4,energyPerPower:50,minEnergyReserve:1e5,gplMilestones:[1,2,5,10,15,20]};let vn=class{constructor(e={}){this.assignments=new Map,this.gplState=null,this.lastGPLUpdate=0,this.config={...Cn,...e}}run(){this.updateGPLState(),this.managePowerProcessing(),this.manageAssignments(),this.checkRespawnNeeds(),Game.time%100==0&&this.logStatus()}updateGPLState(){var e,t,r,o,s;if(!Game.gpl)return void(this.gplState=null);const n=Game.gpl.level,i=Game.gpl.progress,a=Game.gpl.progressTotal;let c=0;this.gplState&&this.gplState.currentProgress<i&&(c=i-this.gplState.currentProgress);const u=a-i,l=null!==(t=null===(e=this.gplState)||void 0===e?void 0:e.powerProcessedThisTick)&&void 0!==t?t:1,m=l>0?Math.ceil(u/l):1/0,p=null!==(r=this.config.gplMilestones.find(e=>e>n))&&void 0!==r?r:n+1;this.gplState={currentLevel:n,currentProgress:i,progressNeeded:a,powerProcessedThisTick:c,totalPowerProcessed:(null!==(s=null===(o=this.gplState)||void 0===o?void 0:o.totalPowerProcessed)&&void 0!==s?s:0)+c,ticksToNextLevel:m,targetMilestone:p,lastUpdate:Game.time},this.lastGPLUpdate!==n&&n>0&&(Q.info("GPL milestone reached: Level "+n,{subsystem:"PowerCreep"}),this.lastGPLUpdate=n)}managePowerProcessing(){const e=this.evaluatePowerProcessing();for(const t of e){if(!t.shouldProcess)continue;const e=Game.rooms[t.roomName];if(!e)continue;const r=e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN})[0];if(!r)continue;const o=r.store.getUsedCapacity(RESOURCE_POWER)>0,s=r.store.getUsedCapacity(RESOURCE_ENERGY)>=50;o&&s&&r.processPower()===OK&&Q.debug(`Processing power in ${t.roomName}: ${t.reason}`,{subsystem:"PowerCreep"})}}evaluatePowerProcessing(){var e,t,r;const o=[],s=Object.values(Game.rooms).filter(e=>{var t;return(null===(t=e.controller)||void 0===t?void 0:t.my)&&e.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN}).length>0});for(const n of s){const s=n.storage,i=n.terminal;if(!s&&!i)continue;const a=(null!==(e=null==s?void 0:s.store.getUsedCapacity(RESOURCE_POWER))&&void 0!==e?e:0)+(null!==(t=null==i?void 0:i.store.getUsedCapacity(RESOURCE_POWER))&&void 0!==t?t:0),c=null!==(r=null==s?void 0:s.store.getUsedCapacity(RESOURCE_ENERGY))&&void 0!==r?r:0;let u=0,l="",m=0;100>a?(u=0,l="Insufficient power (<100)"):c<this.config.minEnergyReserve?(u=0,l=`Insufficient energy (<${this.config.minEnergyReserve})`):this.gplState&&this.gplState.currentLevel<this.gplState.targetMilestone?(u=1,l=`GPL progression: ${this.gplState.currentLevel}  ${this.gplState.targetMilestone}`,m=100-Math.abs(this.gplState.currentLevel-this.gplState.targetMilestone)):a>this.config.minPowerReserve?(u=1,l=`Excess power (${a} > ${this.config.minPowerReserve})`,m=50):(u=0,l="Power reserved for power banks"),o.push({roomName:n.name,shouldProcess:u,reason:l,powerAvailable:a,energyAvailable:c,priority:m})}return o.sort((e,t)=>t.priority-e.priority)}manageAssignments(){for(const e in Game.powerCreeps){const t=Game.powerCreeps[e];if(!t)continue;let r=this.assignments.get(e);r?(r.level=t.level,r.spawned=void 0!==t.ticksToLive,r.spawned&&!r.lastRespawnTick&&(r.lastRespawnTick=Game.time)):(r=this.createAssignment(t),this.assignments.set(e,r))}this.considerNewPowerCreeps()}createAssignment(e){var t,r;e.powers[PWR_OPERATE_SPAWN];const o=void 0!==e.powers[PWR_DISRUPT_SPAWN]?"powerWarrior":"powerQueen",s=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});let n=null!==(r=null===(t=s[0])||void 0===t?void 0:t.name)&&void 0!==r?r:"";if("powerQueen"===o){const e=s.filter(e=>e.controller&&e.controller.level>=7).sort((e,t)=>{var r,o,s,n;const i=100*(null!==(o=null===(r=e.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0)+e.find(FIND_MY_STRUCTURES).length;return 100*(null!==(n=null===(s=t.controller)||void 0===s?void 0:s.level)&&void 0!==n?n:0)+t.find(FIND_MY_STRUCTURES).length-i})[0];e&&(n=e.name)}else{const e=s.map(e=>({room:e,swarm:Ce.getSwarmState(e.name)})).filter(e=>null!==e.swarm).sort((e,t)=>{const r=100*e.swarm.danger+e.swarm.metrics.hostileCount;return 100*t.swarm.danger+t.swarm.metrics.hostileCount-r})[0];e&&(n=e.room.name)}const i={name:e.name,className:e.className,role:o,assignedRoom:n,level:e.level,spawned:void 0!==e.ticksToLive,lastRespawnTick:void 0!==e.ticksToLive?Game.time:void 0,priority:"powerQueen"===o?100:80},a=e.memory;return a.homeRoom=n,a.role=o,Q.info(`Power creep ${e.name} assigned as ${o} to ${n}`,{subsystem:"PowerCreep"}),i}considerNewPowerCreeps(){if(!this.gplState||this.gplState.currentLevel<this.config.minGPL)return;const e=Object.keys(Game.powerCreeps).length,t=this.gplState.currentLevel;if(e>=t)return;const r=Array.from(this.assignments.values()).filter(e=>"powerQueen"===e.role).length,o=Array.from(this.assignments.values()).filter(e=>"powerWarrior"===e.role).length;if(Math.ceil(.7*t)>r||Math.floor(.3*t)>o){const e="operator_"+Game.time,t=POWER_CLASS.OPERATOR,r=PowerCreep.create(e,t);r===OK?Q.info(`Created new power creep: ${e} (${t})`,{subsystem:"PowerCreep"}):Q.warn("Failed to create power creep: "+r,{subsystem:"PowerCreep"})}}checkRespawnNeeds(){for(const[e,t]of this.assignments){const r=Game.powerCreeps[e];if(r)if(void 0===r.ticksToLive){const o=Game.rooms[t.assignedRoom];if(!o)continue;const s=o.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN})[0];s&&r.spawn(s)===OK&&(Q.info(`Power creep ${e} spawned at ${o.name}`,{subsystem:"PowerCreep"}),t.spawned=1,t.lastRespawnTick=Game.time)}else if(500>r.ticksToLive){const t=r.room;if(!t)continue;const o=t.find(FIND_MY_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_POWER_SPAWN})[0];o&&1>=r.pos.getRangeTo(o)&&r.renew(o)===OK&&Q.debug(`Power creep ${e} renewed`,{subsystem:"PowerCreep"})}}}getGPLState(){return this.gplState}getAssignments(){return Array.from(this.assignments.values())}getAssignment(e){return this.assignments.get(e)}reassignPowerCreep(e,t){const r=this.assignments.get(e);if(!r)return 0;r.assignedRoom=t;const o=Game.powerCreeps[e];return o&&(o.memory.homeRoom=t),Q.info(`Power creep ${e} reassigned to ${t}`,{subsystem:"PowerCreep"}),1}logStatus(){if(!this.gplState)return;const e=Array.from(this.assignments.values()).filter(e=>e.spawned),t=e.filter(e=>"powerQueen"===e.role).length,r=e.filter(e=>"powerWarrior"===e.role).length;Q.info(`Power System: GPL ${this.gplState.currentLevel} (${this.gplState.currentProgress}/${this.gplState.progressNeeded}), Operators: ${e.length}/${this.gplState.currentLevel} (${t} eco, ${r} combat)`,{subsystem:"PowerCreep"})}};H([Rs("empire:powerCreep","Power Creep Management",{priority:me.LOW,interval:20,minBucket:6e3,cpuBudget:.03})],vn.prototype,"run",null),vn=H([ys()],vn);const Sn=new vn;function Un(e,t){var r,o;if((null===(r=e.controller)||void 0===r?void 0:r.owner)&&!e.controller.my)return{lost:1,reason:"enemyOwned"};const s=function(){const e=Object.values(Game.spawns);return e.length>0?e[0].owner.username:""}();return(null===(o=e.controller)||void 0===o?void 0:o.reservation)&&e.controller.reservation.username!==s?{lost:1,reason:"enemyReserved"}:2>e.find(FIND_HOSTILE_CREEPS).filter(e=>e.body.some(e=>e.type===ATTACK||e.type===RANGED_ATTACK||e.type===WORK)).length?{lost:0}:{lost:1,reason:"hostile"}}function On(e,t,r){var o;const s=Ce.getSwarmState(e);if(!s)return;const n=null!==(o=s.remoteAssignments)&&void 0!==o?o:[],i=n.indexOf(t);if(-1!==i){n.splice(i,1),s.remoteAssignments=n;const o=Ce.getOvermind().roomIntel[t];o&&(o.threatLevel=3,o.lastSeen=Game.time),Q.warn(`Removed remote room ${t} from ${e} due to: ${r}`,{subsystem:"RemoteRoomManager"})}}function _n(e){var t;const r=Ce.getSwarmState(e);if(!r)return;const o=null!==(t=r.remoteAssignments)&&void 0!==t?t:[];if(0!==o.length)for(const t of o){const r=Game.rooms[t];if(!r)continue;const o=Un(r);o.lost&&o.reason&&On(e,t,o.reason)}}const An={updateInterval:50,minBucket:3e3,maxSitesPerRemotePerTick:2};let Mn=class{constructor(e={}){this.config={...An,...e}}run(){var e;const t=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const r of t){const t=Ce.getSwarmState(r.name);if(!t)continue;_n(r.name);const o=null!==(e=t.remoteAssignments)&&void 0!==e?e:[];if(0!==o.length){for(const e of o)this.planRemoteInfrastructure(r,e);this.placeRemoteRoads(r,o)}}}planRemoteInfrastructure(e,t){const r=Game.rooms[t];if(!r)return;const o=r.controller,s=this.getMyUsername();if(o){if(o.owner&&o.owner.username!==s)return;if(o.reservation&&o.reservation.username!==s)return}const n=r.find(FIND_SOURCES);let i=0;for(const e of n){if(i>=this.config.maxSitesPerRemotePerTick)break;this.placeSourceContainer(r,e)&&i++}}placeSourceContainer(e,t){if(t.pos.findInRange(FIND_STRUCTURES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length>0)return 0;if(t.pos.findInRange(FIND_CONSTRUCTION_SITES,1,{filter:e=>e.structureType===STRUCTURE_CONTAINER}).length>0)return 0;const r=this.findBestContainerPosition(t);if(!r)return Q.warn(`Could not find valid position for container at source ${t.id} in ${e.name}`,{subsystem:"RemoteInfra"}),0;if(e.find(FIND_CONSTRUCTION_SITES).length>=5)return 0;const o=e.createConstructionSite(r.x,r.y,STRUCTURE_CONTAINER);return o===OK?(Q.info(`Placed container construction site at source ${t.id} in ${e.name}`,{subsystem:"RemoteInfra"}),1):(Q.debug(`Failed to place container at source ${t.id} in ${e.name}: ${o}`,{subsystem:"RemoteInfra"}),0)}findBestContainerPosition(e){const t=e.room,r=t.getTerrain(),o=[];for(let s=-1;1>=s;s++)for(let n=-1;1>=n;n++){if(0===s&&0===n)continue;const i=e.pos.x+s,a=e.pos.y+n;if(1>i||i>48||1>a||a>48)continue;if(r.get(i,a)===TERRAIN_MASK_WALL)continue;if(new RoomPosition(i,a,t.name).lookFor(LOOK_STRUCTURES).length>0)continue;let c=0;for(let e=-1;1>=e;e++)for(let t=-1;1>=t;t++){if(0===e&&0===t)continue;const o=i+e,s=a+t;1>o||o>48||1>s||s>48||r.get(o,s)!==TERRAIN_MASK_WALL&&c++}o.push({x:i,y:a,score:c})}return 0===o.length?null:(o.sort((e,t)=>t.score-e.score),o[0])}placeRemoteRoads(e,t){const r=Yr(e,t),o=r.get(e.name);o&&this.placeRoadsInRoom(e,o);for(const e of t){const t=Game.rooms[e];if(!t)continue;const o=r.get(e);o&&this.placeRoadsInRoom(t,o)}}placeRoadsInRoom(e,t){const r=e.find(FIND_CONSTRUCTION_SITES),o=e.find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_ROAD});if(r.length>=5)return;const s=new Set(o.map(e=>`${e.pos.x},${e.pos.y}`)),n=new Set(r.filter(e=>e.structureType===STRUCTURE_ROAD).map(e=>`${e.pos.x},${e.pos.y}`)),i=e.getTerrain();let a=0;for(const o of t){if(a>=3)break;if(r.length+a>=5)break;if(s.has(o))continue;if(n.has(o))continue;const[t,c]=o.split(","),u=parseInt(t,10),l=parseInt(c,10);i.get(u,l)!==TERRAIN_MASK_WALL&&e.createConstructionSite(u,l,STRUCTURE_ROAD)===OK&&a++}a>0&&Q.debug(`Placed ${a} remote road construction sites in ${e.name}`,{subsystem:"RemoteInfra"})}getMyUsername(){const e=Object.values(Game.spawns);return e.length>0?e[0].owner.username:""}};H([fs("remote:infrastructure","Remote Infrastructure Manager",{priority:me.LOW,interval:50,minBucket:3e3,cpuBudget:.05})],Mn.prototype,"run",null),Mn=H([ys()],Mn);const Nn=new Mn;function bn(e){let t=0;for(let r=0;r<e.length;r++)t=(t<<5)-t+e.charCodeAt(r),t&=t;return Math.abs(t)}const wn={updateInterval:100,minBucket:5e3,maxCpuBudget:.02,defaultCpuLimit:20},In={core:1.5,frontier:.8,resource:1,backup:.5,war:1.2};let xn=class{constructor(e={}){this.lastRun=0,this.config={...wn,...e},this.interShardMemory={version:1,shards:{},globalTargets:{targetPowerLevel:0},tasks:[],lastSync:0,checksum:0}}initialize(){var e,t;try{const e=InterShardMemory.getLocal();if(e){const t=function(e){var t,r;try{const o=JSON.parse(e),s=bn(JSON.stringify(o.d));if(o.c!==s)return console.log("InterShardMemory checksum mismatch"),null;const n=o.d,i={c:"core",f:"frontier",r:"resource",b:"backup",w:"war"},a={l:"low",m:"medium",h:"high",c:"critical"},c={c:"colonize",r:"reinforce",t:"transfer",e:"evacuate"},u={p:"pending",a:"active",c:"complete",f:"failed"},l={},m=n.s;for(const e of m)l[e.n]={name:e.n,role:null!==(t=i[e.r])&&void 0!==t?t:"core",health:{cpuCategory:null!==(r=a[e.h.c])&&void 0!==r?r:"low",economyIndex:e.h.e,warIndex:e.h.w,commodityIndex:e.h.m,roomCount:e.h.rc,avgRCL:e.h.rl,creepCount:e.h.cc,lastUpdate:e.h.u},activeTasks:e.t,portals:e.p.map(e=>{const[t,r]=e.sp.split(",");return{sourceRoom:e.sr,sourcePos:{x:parseInt(null!=t?t:"0",10),y:parseInt(null!=r?r:"0",10)},targetShard:e.ts,targetRoom:e.tr,threatRating:e.th,lastScouted:0}})};const p=n.g,d=n.k,g={targetPowerLevel:p.pl};return p.ws&&(g.mainWarShard=p.ws),p.es&&(g.primaryEcoShard=p.es),p.ct&&(g.colonizationTarget=p.ct),{version:n.v,shards:l,globalTargets:g,tasks:d.map(e=>{var t,r;const o={id:e.i,type:null!==(t=c[e.y])&&void 0!==t?t:"colonize",sourceShard:e.ss,targetShard:e.ts,priority:e.p,status:null!==(r=u[e.st])&&void 0!==r?r:"pending",createdAt:0};return e.tr&&(o.targetRoom=e.tr),o}),lastSync:n.ls,checksum:o.c}}catch(e){return console.log("Failed to deserialize InterShardMemory"),null}}(e);t&&(this.interShardMemory=t,Q.debug("Loaded InterShardMemory",{subsystem:"Shard"}))}}catch(e){const t=e instanceof Error?e.message:e+"";Q.error("Failed to load InterShardMemory: "+t,{subsystem:"Shard"})}const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0";this.interShardMemory.shards[r]||(this.interShardMemory.shards[r]={name:r,role:"core",health:{cpuCategory:"low",economyIndex:50,warIndex:0,commodityIndex:0,roomCount:0,avgRCL:0,creepCount:0,lastUpdate:0},activeTasks:[],portals:[]})}run(){this.lastRun=Game.time,this.updateCurrentShardHealth(),this.processInterShardTasks(),this.scanForPortals(),this.autoAssignShardRole(),Object.keys(this.interShardMemory.shards).length>1&&this.distributeCpuLimits(),this.syncInterShardMemory(),Game.time%500==0&&this.logShardStatus()}updateCurrentShardHealth(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0",o=this.interShardMemory.shards[r];if(!o)return;const s=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),n=Game.cpu.getUsed()/Game.cpu.limit,i=.5>n?"low":.75>n?"medium":.9>n?"high":"critical",a=s.length>0?s.reduce((e,t)=>{var r,o;return e+(null!==(o=null===(r=t.controller)||void 0===r?void 0:r.level)&&void 0!==o?o:0)},0)/s.length:0;let c=0;for(const e of s){const t=e.storage;if(t){const e=t.store.getUsedCapacity(RESOURCE_ENERGY);c+=Math.min(100,e/5e3)}}c=s.length>0?c/s.length:0;let u=0;for(const e of s){const t=e.find(FIND_HOSTILE_CREEPS).length;u+=Math.min(100,10*t)}u=s.length>0?u/s.length:0,o.health={cpuCategory:i,economyIndex:Math.round(c),warIndex:Math.round(u),commodityIndex:0,roomCount:s.length,avgRCL:Math.round(10*a)/10,creepCount:Object.keys(Game.creeps).length,lastUpdate:Game.time}}processInterShardTasks(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0",o=this.interShardMemory.tasks.filter(e=>e.targetShard===r&&"pending"===e.status);for(const e of o)switch(e.type){case"colonize":this.handleColonizeTask(e);break;case"reinforce":this.handleReinforceTask(e);break;case"transfer":this.handleTransferTask(e);break;case"evacuate":this.handleEvacuateTask(e)}this.interShardMemory.tasks=this.interShardMemory.tasks.filter(e=>"pending"===e.status||"active"===e.status||5e3>Game.time-e.createdAt)}handleColonizeTask(e){var t;e.status="active";const r=null!==(t=e.targetRoom)&&void 0!==t?t:"unknown";Q.info(`Processing colonize task: ${r} from ${e.sourceShard}`,{subsystem:"Shard"})}handleReinforceTask(e){var t;e.status="active";const r=null!==(t=e.targetRoom)&&void 0!==t?t:"unknown";Q.info(`Processing reinforce task: ${r} from ${e.sourceShard}`,{subsystem:"Shard"})}handleTransferTask(e){e.status="active",Q.info("Processing transfer task from "+e.sourceShard,{subsystem:"Shard"})}handleEvacuateTask(e){var t;e.status="active";const r=null!==(t=e.targetRoom)&&void 0!==t?t:"unknown";Q.info(`Processing evacuate task: ${r} to ${e.targetShard}`,{subsystem:"Shard"})}scanForPortals(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0",o=this.interShardMemory.shards[r];if(o){for(const e in Game.rooms){const t=Game.rooms[e].find(FIND_STRUCTURES,{filter:e=>e.structureType===STRUCTURE_PORTAL});for(const r of t){const t=r.destination;if(t&&"shard"in t){const s=t.shard,n=t.room;if(!o.portals.find(t=>t.sourceRoom===e&&t.targetShard===s)){const t={sourceRoom:e,sourcePos:{x:r.pos.x,y:r.pos.y},targetShard:s,targetRoom:n,threatRating:0,lastScouted:Game.time};void 0!==r.ticksToDecay&&(t.decayTick=Game.time+r.ticksToDecay),o.portals.push(t),Q.info(`Discovered portal in ${e} to ${s}/${n}`,{subsystem:"Shard"})}}}}o.portals=o.portals.filter(e=>!e.decayTick||e.decayTick>Game.time)}}autoAssignShardRole(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0",o=this.interShardMemory.shards[r];if(!o)return;if("core"!==o.role)return;const s=o.health;let n="core";s.warIndex>50?n="war":3>s.roomCount&&4>s.avgRCL?n="frontier":s.economyIndex>70&&s.roomCount>=3?n="resource":Object.keys(this.interShardMemory.shards).length>1&&2>s.roomCount&&(n="backup"),n!==o.role&&(o.role=n,Q.info("Auto-assigned shard role: "+n,{subsystem:"Shard"}))}distributeCpuLimits(){try{const e=this.interShardMemory.shards,t=Object.keys(e),r=Game.cpu.shardLimits?Object.values(Game.cpu.shardLimits).reduce((e,t)=>e+t,0):this.config.defaultCpuLimit*t.length;let o=0;for(const r of t){const t=e[r];t&&(o+=In[t.role])}const s={};for(const n of t){const t=e[n];if(t){const e=In[t.role];s[n]=Math.max(5,Math.round(e/o*r))}}if(Game.cpu.shardLimits){const e=Game.cpu.shardLimits;t.some(t=>{var r,o;return(null!==(r=e[t])&&void 0!==r?r:0)!==(null!==(o=s[t])&&void 0!==o?o:0)})&&Game.cpu.setShardLimits(s)===OK&&Q.info("Updated shard CPU limits: "+JSON.stringify(s),{subsystem:"Shard"})}}catch(e){const t=e instanceof Error?e.message:e+"";Q.debug("Could not set shard limits: "+t,{subsystem:"Shard"})}}syncInterShardMemory(){try{this.interShardMemory.lastSync=Game.time;const e=function(e){const t={v:e.version,s:Object.entries(e.shards).map(([e,t])=>({n:e,r:t.role[0],h:{c:t.health.cpuCategory[0],e:Math.round(t.health.economyIndex),w:Math.round(t.health.warIndex),m:Math.round(t.health.commodityIndex),rc:t.health.roomCount,rl:Math.round(10*t.health.avgRCL)/10,cc:t.health.creepCount,u:t.health.lastUpdate},t:t.activeTasks,p:t.portals.map(e=>({sr:e.sourceRoom,sp:`${e.sourcePos.x},${e.sourcePos.y}`,ts:e.targetShard,tr:e.targetRoom,th:e.threatRating}))})),g:{pl:e.globalTargets.targetPowerLevel,ws:e.globalTargets.mainWarShard,es:e.globalTargets.primaryEcoShard,ct:e.globalTargets.colonizationTarget},k:e.tasks.map(e=>({i:e.id,y:e.type[0],ss:e.sourceShard,ts:e.targetShard,tr:e.targetRoom,p:e.priority,st:e.status[0]})),ls:e.lastSync},r=bn(JSON.stringify(t));return JSON.stringify({d:t,c:r})}(this.interShardMemory);if(e.length>102400)return Q.warn(`InterShardMemory size exceeds limit: ${e.length}/102400`,{subsystem:"Shard"}),void this.trimInterShardMemory();InterShardMemory.setLocal(e)}catch(e){const t=e instanceof Error?e.message:e+"";Q.error("Failed to sync InterShardMemory: "+t,{subsystem:"Shard"})}}trimInterShardMemory(){this.interShardMemory.tasks=this.interShardMemory.tasks.filter(e=>"pending"===e.status||"active"===e.status||1e3>Game.time-e.createdAt);for(const e in this.interShardMemory.shards){const t=this.interShardMemory.shards[e];t&&(t.portals=t.portals.filter(e=>1e4>Game.time-e.lastScouted))}}logShardStatus(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0",o=this.interShardMemory.shards[r];if(!o)return;const s=o.health;Q.info(`Shard ${r} (${o.role}): ${s.roomCount} rooms, RCL ${s.avgRCL}, CPU: ${s.cpuCategory}, Eco: ${s.economyIndex}%, War: ${s.warIndex}%`,{subsystem:"Shard"})}createTask(e,t,r,o=50){var s,n;const i=null!==(n=null===(s=Game.shard)||void 0===s?void 0:s.name)&&void 0!==n?n:"shard0",a={id:`${Game.time}-${Math.random().toString(36).substring(2,11)}`,type:e,sourceShard:i,targetShard:t,priority:o,status:"pending",createdAt:Game.time};r&&(a.targetRoom=r),this.interShardMemory.tasks.push(a),Q.info(`Created inter-shard task: ${e} to ${t}`,{subsystem:"Shard"})}getCurrentShardState(){var e,t;const r=null!==(t=null===(e=Game.shard)||void 0===e?void 0:e.name)&&void 0!==t?t:"shard0";return this.interShardMemory.shards[r]}getAllShards(){return Object.values(this.interShardMemory.shards)}getPortalsToShard(e){var t,r;const o=null!==(r=null===(t=Game.shard)||void 0===t?void 0:t.name)&&void 0!==r?r:"shard0",s=this.interShardMemory.shards[o];return s?s.portals.filter(t=>t.targetShard===e):[]}setShardRole(e){var t,r;const o=null!==(r=null===(t=Game.shard)||void 0===t?void 0:t.name)&&void 0!==r?r:"shard0",s=this.interShardMemory.shards[o];s&&(s.role=e,Q.info("Set shard role to: "+e,{subsystem:"Shard"}))}};H([Rs("empire:shard","Shard Manager",{priority:me.LOW,interval:100,minBucket:5e3,cpuBudget:.02})],xn.prototype,"run",null),xn=H([ys()],xn);const Gn=new xn,Pn={defaultTtl:1e3,maxPathsPerRoom:20,maxTotalPaths:200,cleanupInterval:100},kn=new class{constructor(e={}){this.pathCache=new Map,this.costMatrixCache=new Map,this.lastCleanup=0,this.config={...Pn,...e}}generateKey(e,t,r){var o;const s=null!==(o=null==r?void 0:r.ignoreCreeps)&&void 0!==o?o:1;return`${e.roomName}:${e.x},${e.y}:${t.roomName}:${t.x},${t.y}:${s+""}`}getPath(e,t,r){var o,s;const n=this.generateKey(e,t,{ignoreCreeps:void 0===(null==r?void 0:r.roomCallback)}),i=this.pathCache.get(n);if(i&&Game.time-i.createdAt<i.ttl)return i.lastUsed=Game.time,i.useCount++,i.path;const a=this,c=PathFinder.search(e,{pos:t,range:1},{plainCost:2,swampCost:10,roomCallback:null!==(o=null==r?void 0:r.roomCallback)&&void 0!==o?o:e=>a.getCostMatrix(e),maxRooms:null==r?void 0:r.maxRooms,maxOps:null==r?void 0:r.maxOps,heuristicWeight:null==r?void 0:r.heuristicWeight});return c.incomplete?null:(this.cachePath(n,c.path,null!==(s=null==r?void 0:r.ttl)&&void 0!==s?s:this.config.defaultTtl),Game.time-this.lastCleanup>this.config.cleanupInterval&&(this.cleanup(),this.lastCleanup=Game.time),c.path)}cachePath(e,t,r){this.pathCache.size<this.config.maxTotalPaths||this.evictLeastUsed();const o=this.serializePath(t);this.pathCache.set(e,{serialized:o,path:t,length:t.length,createdAt:Game.time,lastUsed:Game.time,useCount:1,ttl:r})}serializePath(e){if(0===e.length)return"";const t=[];let r=e[0].roomName,o=[];for(const s of e)s.roomName!==r&&(t.push(`${r}:${o.join(",")}`),r=s.roomName,o=[]),o.push(`${s.x}.${s.y}`);return t.push(`${r}:${o.join(",")}`),t.join("|")}deserializePath(e){if(!e)return[];const t=[],r=e.split("|");for(const e of r){const[r,o]=e.split(":");if(!r||!o)continue;const s=o.split(",");for(const e of s){const[o,s]=e.split(".");o&&s&&t.push(new RoomPosition(parseInt(o,10),parseInt(s,10),r))}}return t}getCostMatrix(e){const t=this.costMatrixCache.get(e);if(t&&50>Game.time-t.tick)return t.matrix;const r=Game.rooms[e];if(!r)return 0;const o=new PathFinder.CostMatrix,s=r.find(FIND_STRUCTURES);for(const e of s)e.structureType===STRUCTURE_ROAD?o.set(e.pos.x,e.pos.y,1):e.structureType===STRUCTURE_CONTAINER||e.structureType===STRUCTURE_RAMPART&&e.my||o.set(e.pos.x,e.pos.y,255);const n=r.find(FIND_CONSTRUCTION_SITES);for(const e of n)e.structureType!==STRUCTURE_ROAD&&e.structureType!==STRUCTURE_CONTAINER&&o.set(e.pos.x,e.pos.y,255);return this.costMatrixCache.set(e,{matrix:o,tick:Game.time}),o}invalidateCostMatrix(e){this.costMatrixCache.delete(e)}invalidateRoomPaths(e){for(const[t]of this.pathCache)t.includes(e)&&this.pathCache.delete(t)}evictLeastUsed(){const e=Array.from(this.pathCache.entries()).sort((e,t)=>e[1].lastUsed-t[1].lastUsed),t=Math.max(1,Math.floor(.1*e.length));for(let r=0;t>r;r++){const t=e[r];t&&this.pathCache.delete(t[0])}}cleanup(){for(const[e,t]of this.pathCache)Game.time-t.createdAt>t.ttl&&this.pathCache.delete(e);for(const[e,t]of this.costMatrixCache)Game.time-t.tick>500&&this.costMatrixCache.delete(e)}precacheRoomPaths(e){var t,r;const o=Game.rooms[e];if(!o||!(null===(t=o.controller)||void 0===t?void 0:t.my))return;const s=o.storage,n=o.find(FIND_MY_SPAWNS)[0],i=null!==(r=null==s?void 0:s.pos)&&void 0!==r?r:null==n?void 0:n.pos;if(!i)return;const a=o.find(FIND_SOURCES);for(const e of a)this.getPath(i,e.pos,{ttl:5e3});o.controller&&this.getPath(i,o.controller.pos,{ttl:5e3});const c=o.find(FIND_EXIT),u=new Map;for(const e of c){const t=`${Math.floor(e.x/10)},${Math.floor(e.y/10)}`;u.has(t)||u.set(t,e)}for(const e of u.values())this.getPath(i,e,{ttl:5e3});Q.debug(`Pre-cached ${a.length+1+u.size} paths for ${e}`,{subsystem:"PathCache"})}getStats(){let e=0;for(const t of this.pathCache.values())e+=t.useCount;return{pathCount:this.pathCache.size,matrixCount:this.costMatrixCache.size,avgUseCount:this.pathCache.size>0?e/this.pathCache.size:0,hitRate:0}}clear(){this.pathCache.clear(),this.costMatrixCache.clear()}};let Ln=class{generatePixel(){var e,t;if(Game.cpu.bucket>=PIXEL_CPU_COST){const r=null===(t=(e=Game.cpu).generatePixel)||void 0===t?void 0:t.call(e);r===OK?(ge.notifyPixelGenerated(),Q.info("Generated pixel from full CPU bucket",{subsystem:"Pixel"})):r===ERR_NOT_ENOUGH_RESOURCES&&Q.debug("Could not generate pixel: not enough CPU bucket",{subsystem:"Pixel"})}}cleanupMemory(){for(const e in Memory.creeps)Game.creeps[e]||delete Memory.creeps[e]}checkMemorySize(){const e=RawMemory.get().length,t=e/2097152*100;t>90?Q.error(`Memory usage critical: ${t.toFixed(1)}% (${e}/2097152 bytes)`,{subsystem:"Memory"}):t>75&&Q.warn(`Memory usage high: ${t.toFixed(1)}% (${e}/2097152 bytes)`,{subsystem:"Memory"})}updateMemorySegmentStats(){Se.run()}runPheromoneDiffusion(){const e=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),t=new Map;for(const r of e){const e=Ce.getSwarmState(r.name);e&&t.set(r.name,e)}Nr.applyDiffusion(t)}initializeLabConfigs(){const e=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const t of e)Ht.initialize(t.name)}precacheRoomPaths(){const e=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const t of e)kn.precacheRoomPaths(t.name)}};var Dn;H([(Dn={priority:me.LOW,minBucket:PIXEL_CPU_COST,cpuBudget:.001},gs({id:"core:pixelGeneration",name:"Pixel Generation",priority:me.HIGH,frequency:"high",minBucket:500,cpuBudget:.3,interval:1,...Dn}))],Ln.prototype,"generatePixel",null),H([Rs("core:memoryCleanup","Memory Cleanup",{priority:me.LOW,interval:50,minBucket:1e3,cpuBudget:.01})],Ln.prototype,"cleanupMemory",null),H([hs("core:memorySizeCheck","Memory Size Check",{interval:100,minBucket:1e3,cpuBudget:.005})],Ln.prototype,"checkMemorySize",null),H([fs("core:memorySegmentStats","Memory Segment Stats",{priority:me.IDLE,interval:10,minBucket:2e3,cpuBudget:.01})],Ln.prototype,"updateMemorySegmentStats",null),H([fs("cluster:pheromoneDiffusion","Pheromone Diffusion",{priority:me.MEDIUM,interval:10,minBucket:2e3,cpuBudget:.02})],Ln.prototype,"runPheromoneDiffusion",null),H([Rs("room:labConfig","Lab Config Manager",{priority:me.LOW,interval:200,minBucket:3e3,cpuBudget:.01})],Ln.prototype,"initializeLabConfigs",null),H([hs("room:pathCachePrecache","Path Cache Precache",{interval:1e3,minBucket:8e3,cpuBudget:.03})],Ln.prototype,"precacheRoomPaths",null),Ln=H([ys()],Ln);const $n=new Ln;function Yn(e,t,r){const o=e[t];if(!o)return;if(o.__nativeCallsTrackerWrapped)return;const s=Object.getOwnPropertyDescriptor(e,t);if(s&&0==s.configurable)console.log(`[NativeCallsTracker] Warning: Cannot wrap ${t} - property is not configurable`);else try{const s=function(...e){return kr.recordNativeCall(r),o.apply(this,e)};s.__nativeCallsTrackerWrapped=1,Object.defineProperty(e,t,{value:s,writable:1,enumerable:1,configurable:1})}catch(e){console.log(`[NativeCallsTracker] Warning: Failed to wrap ${t}: ${e}`)}}const Kn={lowBucketThreshold:2e3,highBucketThreshold:9e3,targetCpuUsage:.8,highFrequencyInterval:1,mediumFrequencyInterval:5,lowFrequencyInterval:20};new class{constructor(e={}){this.tasks=new Map,this.currentMode="normal",this.tickCpuUsed=0,this.config={...Kn,...e}}registerTask(e){this.tasks.set(e.name,{...e,lastRun:0})}unregisterTask(e){this.tasks.delete(e)}getBucketMode(){const e=ge.getBucketMode();return"critical"===e||"low"===e?"low":"high"===e?"high":"normal"}updateBucketMode(){const e=this.getBucketMode();e!==this.currentMode&&(Q.info(`Bucket mode changed: ${this.currentMode} -> ${e}`,{subsystem:"Scheduler"}),this.currentMode=e)}getCpuLimit(){const e=Game.cpu.limit;return"low"===this.currentMode?.5*e:e*this.config.targetCpuUsage}hasCpuBudget(){return Game.cpu.getUsed()<this.getCpuLimit()}getRemainingCpu(){return Math.max(0,this.getCpuLimit()-Game.cpu.getUsed())}shouldRunTask(e){if(Game.cpu.bucket<e.minBucket)return 0;const t=Game.time-e.lastRun;return this.getIntervalForFrequency(e.frequency)>t||"low"===this.currentMode&&"high"!==e.frequency?0:1}getIntervalForFrequency(e){switch(e){case"high":return this.config.highFrequencyInterval;case"medium":return this.config.mediumFrequencyInterval;case"low":return this.config.lowFrequencyInterval}}run(){this.updateBucketMode(),this.tickCpuUsed=0;const e=Array.from(this.tasks.values()).sort((e,t)=>t.priority-e.priority);for(const t of e){if(!this.shouldRunTask(t))continue;const e=Game.cpu.getUsed();if(e+this.getCpuLimit()*t.cpuBudget>this.getCpuLimit()&&"high"!==t.frequency)continue;try{t.execute(),t.lastRun=Game.time}catch(e){const r=e instanceof Error?e.message:e+"";Q.error(`Task ${t.name} failed: ${r}`,{subsystem:"Scheduler"})}const r=Game.cpu.getUsed()-e;if(this.tickCpuUsed+=r,!this.hasCpuBudget()){Q.warn("CPU budget exhausted, skipping remaining tasks",{subsystem:"Scheduler"});break}}}getTickCpuUsed(){return this.tickCpuUsed}getCurrentMode(){return this.currentMode}getTasks(){return Array.from(this.tasks.values())}};let Hn=0,Fn=0;function Wn(){if(Fn||function(){const e=ue();W({level:e.debug?D.DEBUG:D.INFO,cpuLogging:e.profiling}),kr.initialize(),e.profiling&&(function(){if(!PathFinder.search)return;if(PathFinder.search.__nativeCallsTrackerWrapped)return;const e=Object.getOwnPropertyDescriptor(PathFinder,"search");if(e&&0==e.configurable)return void console.log("[NativeCallsTracker] Warning: Cannot wrap PathFinder.search - property is not configurable");const t=PathFinder.search;try{const e=function(...e){return kr.recordNativeCall("pathfinderSearch"),t.apply(PathFinder,e)};e.__nativeCallsTrackerWrapped=1,Object.defineProperty(PathFinder,"search",{value:e,writable:1,enumerable:1,configurable:1})}catch(e){console.log("[NativeCallsTracker] Warning: Failed to wrap PathFinder.search: "+e)}}(),function(){const e=Creep.prototype;Yn(e,"moveTo","moveTo"),Yn(e,"move","move"),Yn(e,"harvest","harvest"),Yn(e,"transfer","transfer"),Yn(e,"withdraw","withdraw"),Yn(e,"build","build"),Yn(e,"repair","repair"),Yn(e,"upgradeController","upgradeController"),Yn(e,"attack","attack"),Yn(e,"rangedAttack","rangedAttack"),Yn(e,"heal","heal"),Yn(e,"dismantle","dismantle"),Yn(e,"say","say")}()),ge.on("structure.destroyed",e=>{const t=Ce.getSwarmState(e.roomName);t&&(Nr.onStructureDestroyed(t,e.structureType),Q.debug("Pheromone update: structure destroyed in "+e.roomName,{subsystem:"Pheromone",room:e.roomName}))}),ge.on("remote.lost",e=>{const t=Ce.getSwarmState(e.homeRoom);t&&(Nr.onRemoteSourceLost(t),Q.info("Pheromone update: remote source lost for "+e.homeRoom,{subsystem:"Pheromone",room:e.homeRoom}))}),Q.info("Pheromone event handlers initialized",{subsystem:"Pheromone"}),Fn=1}(),ge.updateFromCpuConfig(ue().cpu),Hn||(Q.info("Registering all processes with kernel...",{subsystem:"ProcessRegistry"}),function(...e){for(const t of e)Es(t);Q.info(`Registered decorated processes from ${e.length} instance(s)`,{subsystem:"ProcessDecorators"})}($n,Js,sn,cn,mn,Nn,gn,hn,Tn,Sn,Gn,qs,zs),Q.info(`Registered ${ge.getProcesses().length} processes with kernel`,{subsystem:"ProcessRegistry"}),ge.initialize(),Hn=1),kr.startTick(),"critical"===ge.getBucketMode())return Q.warn(`CRITICAL: CPU bucket at ${Game.cpu.bucket}, minimal processing`,{subsystem:"SwarmBot"}),St(),Qe(),Ut(),qe(),void kr.finalizeTick();qe();const e="_ownedRooms",t="_ownedRoomsTick",r=global,o=r[e],s=r[t];let n;o&&s===Game.time?n=o:(n=Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my}),r[e]=n,r[t]=Game.time),St(),Qe(),Ce.initialize(),kr.measureSubsystem("processSync",()=>{_r.syncCreepProcesses(),xo.syncRoomProcesses()}),kr.measureSubsystem("kernel",()=>{ge.run()}),kr.measureSubsystem("spawns",()=>{!function(){var e;for(const t of Object.values(Game.rooms))(null===(e=t.controller)||void 0===e?void 0:e.my)&&ms(t,Ce.getOrInitSwarmState(t.name))}()}),kr.measureSubsystem("moveRequests",()=>{!function(){for(const[,e]of ze){if(0===e.length)continue;e.sort((e,t)=>t.priority-e.priority);const t=e[0];if(!t)continue;const r=Game.rooms[t.targetPos.roomName];if(!r)continue;const o=r.lookForAt(LOOK_CREEPS,t.targetPos.x,t.targetPos.y).find(e=>e.my&&e.name!==t.requester.name);if(o&&rt(o,t.requester)){const e=it(o);e&&(o.move(o.pos.getDirectionTo(e)),OK)}}}()}),ge.hasCpuBudget()&&kr.measureSubsystem("powerCreeps",()=>{!function(){for(const e of Object.values(Game.powerCreeps))void 0!==e.ticksToLive&&Cr(e)}()}),ge.hasCpuBudget()&&kr.measureSubsystem("visualizations",()=>{!function(){if(!ue().visualizations)return;const e=global,t=e._ownedRooms,r=e._ownedRoomsTick,o=t&&r===Game.time?t:Object.values(Game.rooms).filter(e=>{var t;return null===(t=e.controller)||void 0===t?void 0:t.my});for(const e of o)try{Ge.draw(e)}catch(t){const r=t instanceof Error?t.message:t+"";Q.error(`Visualization error in ${e.name}: ${r}`,{subsystem:"visualizations",room:e.name})}try{De.draw()}catch(e){const t=e instanceof Error?e.message:e+"";Q.error("Map visualization error: "+t,{subsystem:"visualizations"})}}()}),Ut(),Ce.persistHeapCache(),kr.finalizeTick()}ee.initialize(),re(Yo),re(Ko),re(Ho),re(Fo),re(Wo),re(Bo),ee.exposeToGlobal();const Bn=K.wrapLoop(()=>{Wn()});exports.loop=Bn;
