"use strict";

var e = function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
};

function t(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}

function r(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function o(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}

function n(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
}

"function" == typeof SuppressedError && SuppressedError;

var a = "#555555", i = "#AAAAAA", s = "#FFE87B", c = "#F53547", l = "#181818", u = "#8FBB93";

"undefined" != typeof RoomVisual && (RoomVisual.prototype.structure = function(t, r, o, n) {
void 0 === n && (n = {});
var f = e({
opacity: 1
}, n);
switch (o) {
case STRUCTURE_EXTENSION:
this.circle(t, r, {
radius: .5,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .35,
fill: a,
opacity: f.opacity
});
break;

case STRUCTURE_SPAWN:
this.circle(t, r, {
radius: .65,
fill: l,
stroke: "#CCCCCC",
strokeWidth: .1,
opacity: f.opacity
}), this.circle(t, r, {
radius: .4,
fill: s,
opacity: f.opacity
});
break;

case STRUCTURE_POWER_SPAWN:
this.circle(t, r, {
radius: .65,
fill: l,
stroke: c,
strokeWidth: .1,
opacity: f.opacity
}), this.circle(t, r, {
radius: .4,
fill: s,
opacity: f.opacity
});
break;

case STRUCTURE_TOWER:
this.circle(t, r, {
radius: .6,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .45,
fill: a,
opacity: f.opacity
}), this.rect(t - .2, r - .3, .4, .6, {
fill: i,
opacity: f.opacity
});
break;

case STRUCTURE_STORAGE:
this.poly([ [ -.45, -.55 ], [ 0, -.65 ], [ .45, -.55 ], [ .55, 0 ], [ .45, .55 ], [ 0, .65 ], [ -.45, .55 ], [ -.55, 0 ] ].map(function(e) {
return [ e[0] + t, e[1] + r ];
}), {
stroke: u,
strokeWidth: .05,
fill: l,
opacity: f.opacity
}), this.rect(t - .35, r - .45, .7, .9, {
fill: s,
opacity: .6 * f.opacity
});
break;

case STRUCTURE_TERMINAL:
this.poly([ [ -.45, -.55 ], [ 0, -.65 ], [ .45, -.55 ], [ .55, 0 ], [ .45, .55 ], [ 0, .65 ], [ -.45, .55 ], [ -.55, 0 ] ].map(function(e) {
return [ e[0] + t, e[1] + r ];
}), {
stroke: u,
strokeWidth: .05,
fill: l,
opacity: f.opacity
}), this.circle(t, r, {
radius: .3,
fill: i,
opacity: f.opacity
}), this.rect(t - .15, r - .15, .3, .3, {
fill: a,
opacity: f.opacity
});
break;

case STRUCTURE_LAB:
this.circle(t, r, {
radius: .55,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .4,
fill: a,
opacity: f.opacity
}), this.rect(t - .15, r + .1, .3, .25, {
fill: i,
opacity: f.opacity
});
break;

case STRUCTURE_LINK:
this.circle(t, r, {
radius: .5,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .35,
fill: i,
opacity: f.opacity
});
break;

case STRUCTURE_NUKER:
this.circle(t, r, {
radius: .65,
fill: l,
stroke: "#ff0000",
strokeWidth: .1,
opacity: f.opacity
}), this.circle(t, r, {
radius: .4,
fill: "#ff0000",
opacity: .6 * f.opacity
});
break;

case STRUCTURE_OBSERVER:
this.circle(t, r, {
radius: .6,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .4,
fill: "#00ffff",
opacity: .6 * f.opacity
});
break;

case STRUCTURE_CONTAINER:
this.rect(t - .45, r - .45, .9, .9, {
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.rect(t - .35, r - .35, .7, .7, {
fill: "transparent",
stroke: a,
strokeWidth: .05,
opacity: f.opacity
});
break;

case STRUCTURE_ROAD:
this.circle(t, r, {
radius: .175,
fill: "#666",
opacity: f.opacity
});
break;

case STRUCTURE_RAMPART:
this.rect(t - .45, r - .45, .9, .9, {
fill: "transparent",
stroke: "#00ff00",
strokeWidth: .1,
opacity: f.opacity
});
break;

case STRUCTURE_WALL:
this.rect(t - .45, r - .45, .9, .9, {
fill: l,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
});
break;

case STRUCTURE_EXTRACTOR:
this.circle(t, r, {
radius: .6,
fill: l,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(t, r, {
radius: .45,
fill: a,
opacity: f.opacity
});
break;

default:
this.circle(t, r, {
radius: .5,
fill: a,
stroke: u,
strokeWidth: .05,
opacity: f.opacity
});
}
}, RoomVisual.prototype.speech = function(e, t, r, o) {
var n, a, i, s, c;
void 0 === o && (o = {});
var l = null !== (n = o.background) && void 0 !== n ? n : "#2ccf3b", u = null !== (a = o.textcolor) && void 0 !== a ? a : "#000000", f = null !== (i = o.textsize) && void 0 !== i ? i : .5, m = null !== (s = o.textfont) && void 0 !== s ? s : "Times New Roman", p = null !== (c = o.opacity) && void 0 !== c ? c : 1, d = f, y = e.length * d * .4 + .4, g = d + .4;
this.rect(t - y / 2, r - 1 - g, y, g, {
fill: l,
opacity: .9 * p
});
var h = [ [ t - .1, r - 1 ], [ t + .1, r - 1 ], [ t, r - .6 ] ];
this.poly(h, {
fill: l,
opacity: .9 * p,
stroke: "transparent"
}), this.text(e, t, r - 1 - g / 2 + .1, {
color: u,
font: "".concat(d, " ").concat(m),
opacity: p
});
}, RoomVisual.prototype.animatedPosition = function(e, t, r) {
var o, n, a, i;
void 0 === r && (r = {});
var s = null !== (o = r.color) && void 0 !== o ? o : "#ff0000", c = null !== (n = r.opacity) && void 0 !== n ? n : 1, l = null !== (a = r.radius) && void 0 !== a ? a : .75, u = null !== (i = r.frames) && void 0 !== i ? i : 6, f = Game.time % u, m = l * (1 - f / u), p = c * (f / u);
this.circle(e, t, {
radius: m,
fill: "transparent",
stroke: s,
strokeWidth: .1,
opacity: p
});
}, RoomVisual.prototype.resource = function(e, t, r, o) {
var n, a;
void 0 === o && (o = .25);
var i = null !== (a = ((n = {})[RESOURCE_ENERGY] = s, n[RESOURCE_POWER] = c, n[RESOURCE_HYDROGEN] = "#FFFFFF", 
n[RESOURCE_OXYGEN] = "#DDDDDD", n[RESOURCE_UTRIUM] = "#48C5E5", n[RESOURCE_LEMERGIUM] = "#24D490", 
n[RESOURCE_KEANIUM] = "#9269EC", n[RESOURCE_ZYNTHIUM] = "#D9B478", n[RESOURCE_CATALYST] = "#F26D6F", 
n[RESOURCE_GHODIUM] = "#FFFFFF", n)[e]) && void 0 !== a ? a : "#CCCCCC";
this.circle(t, r, {
radius: o,
fill: l,
opacity: .9
}), this.circle(t, r, {
radius: .8 * o,
fill: i,
opacity: .8
});
var u = e.length <= 2 ? e : e.substring(0, 2).toUpperCase();
this.text(u, t, r + .03, {
color: l,
font: "".concat(1.2 * o, " monospace"),
align: "center",
opacity: .9
});
});

var f = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {};

function m(e) {
if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e;
var t = e.default;
if ("function" == typeof t) {
var r = function e() {
var r = !1;
try {
r = this instanceof e;
} catch {}
return r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments);
};
r.prototype = t.prototype;
} else r = {};
return Object.defineProperty(r, "__esModule", {
value: !0
}), Object.keys(e).forEach(function(t) {
var o = Object.getOwnPropertyDescriptor(e, t);
Object.defineProperty(r, t, o.get ? o : {
enumerable: !0,
get: function() {
return e[t];
}
});
}), r;
}

var p, d, y = {}, g = {}, h = {}, v = {};

function R() {
if (p) return v;
p = 1;
const e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
return v.encode = function(t) {
if (0 <= t && t < e.length) return e[t];
throw new TypeError("Must be between 0 and 63: " + t);
}, v;
}

function E() {
if (d) return h;
d = 1;
const e = R();
return h.encode = function(t) {
let r, o = "", n = function(e) {
return e < 0 ? 1 + (-e << 1) : 0 + (e << 1);
}(t);
do {
r = 31 & n, n >>>= 5, n > 0 && (r |= 32), o += e.encode(r);
} while (n > 0);
return o;
}, h;
}

var T, S, C, b = {}, _ = {}, O = {
exports: {}
}, w = O.exports;

function x() {
return T || (T = 1, e = O, t = O.exports, function(r) {
var o = t && !t.nodeType && t, n = e && !e.nodeType && e, a = "object" == typeof f && f;
a.global !== a && a.window !== a && a.self !== a || (r = a);
var i, s, c = 2147483647, l = 36, u = /^xn--/, m = /[^\x20-\x7E]/, p = /[\x2E\u3002\uFF0E\uFF61]/g, d = {
overflow: "Overflow: input needs wider integers to process",
"not-basic": "Illegal input >= 0x80 (not a basic code point)",
"invalid-input": "Invalid input"
}, y = Math.floor, g = String.fromCharCode;
function h(e) {
throw new RangeError(d[e]);
}
function v(e, t) {
for (var r = e.length, o = []; r--; ) o[r] = t(e[r]);
return o;
}
function R(e, t) {
var r = e.split("@"), o = "";
return r.length > 1 && (o = r[0] + "@", e = r[1]), o + v((e = e.replace(p, ".")).split("."), t).join(".");
}
function E(e) {
for (var t, r, o = [], n = 0, a = e.length; n < a; ) (t = e.charCodeAt(n++)) >= 55296 && t <= 56319 && n < a ? 56320 == (64512 & (r = e.charCodeAt(n++))) ? o.push(((1023 & t) << 10) + (1023 & r) + 65536) : (o.push(t), 
n--) : o.push(t);
return o;
}
function T(e) {
return v(e, function(e) {
var t = "";
return e > 65535 && (t += g((e -= 65536) >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), 
t + g(e);
}).join("");
}
function S(e) {
return e - 48 < 10 ? e - 22 : e - 65 < 26 ? e - 65 : e - 97 < 26 ? e - 97 : l;
}
function C(e, t) {
return e + 22 + 75 * (e < 26) - ((0 != t) << 5);
}
function b(e, t, r) {
var o = 0;
for (e = r ? y(e / 700) : e >> 1, e += y(e / t); e > 455; o += l) e = y(e / 35);
return y(o + 36 * e / (e + 38));
}
function _(e) {
var t, r, o, n, a, i, s, u, f, m, p = [], d = e.length, g = 0, v = 128, R = 72;
for ((r = e.lastIndexOf("-")) < 0 && (r = 0), o = 0; o < r; ++o) e.charCodeAt(o) >= 128 && h("not-basic"), 
p.push(e.charCodeAt(o));
for (n = r > 0 ? r + 1 : 0; n < d; ) {
for (a = g, i = 1, s = l; n >= d && h("invalid-input"), ((u = S(e.charCodeAt(n++))) >= l || u > y((c - g) / i)) && h("overflow"), 
g += u * i, !(u < (f = s <= R ? 1 : s >= R + 26 ? 26 : s - R)); s += l) i > y(c / (m = l - f)) && h("overflow"), 
i *= m;
R = b(g - a, t = p.length + 1, 0 == a), y(g / t) > c - v && h("overflow"), v += y(g / t), 
g %= t, p.splice(g++, 0, v);
}
return T(p);
}
function O(e) {
var t, r, o, n, a, i, s, u, f, m, p, d, v, R, T, S = [];
for (d = (e = E(e)).length, t = 128, r = 0, a = 72, i = 0; i < d; ++i) (p = e[i]) < 128 && S.push(g(p));
for (o = n = S.length, n && S.push("-"); o < d; ) {
for (s = c, i = 0; i < d; ++i) (p = e[i]) >= t && p < s && (s = p);
for (s - t > y((c - r) / (v = o + 1)) && h("overflow"), r += (s - t) * v, t = s, 
i = 0; i < d; ++i) if ((p = e[i]) < t && ++r > c && h("overflow"), p == t) {
for (u = r, f = l; !(u < (m = f <= a ? 1 : f >= a + 26 ? 26 : f - a)); f += l) T = u - m, 
R = l - m, S.push(g(C(m + T % R, 0))), u = y(T / R);
S.push(g(C(u, 0))), a = b(r, v, o == n), r = 0, ++o;
}
++r, ++t;
}
return S.join("");
}
if (i = {
version: "1.4.1",
ucs2: {
decode: E,
encode: T
},
decode: _,
encode: O,
toASCII: function(e) {
return R(e, function(e) {
return m.test(e) ? "xn--" + O(e) : e;
});
},
toUnicode: function(e) {
return R(e, function(e) {
return u.test(e) ? _(e.slice(4).toLowerCase()) : e;
});
}
}, o && n) if (e.exports == o) n.exports = i; else for (s in i) i.hasOwnProperty(s) && (o[s] = i[s]); else r.punycode = i;
}(w)), O.exports;
var e, t;
}

function U() {
return C ? S : (C = 1, S = TypeError);
}

var M, A, k, N, P, I, G, L, D, F, B, j, H, W, Y, K, V, z, q, X, Q, Z, J, $, ee, te, re, oe, ne, ae, ie, se, ce, le, ue, fe, me, pe, de, ye, ge, he, ve, Re, Ee, Te, Se, Ce, be, _e, Oe, we, xe, Ue, Me, Ae, ke, Ne, Pe, Ie, Ge, Le, De, Fe, Be, je, He, We, Ye, Ke, Ve, ze, qe, Xe, Qe, Ze, Je, $e, et, tt, rt, ot, nt, at, it, st, ct, lt, ut, ft, mt, pt, dt = m(Object.freeze({
__proto__: null,
default: {}
}));

function yt() {
if (A) return M;
A = 1;
var e = "function" == typeof Map && Map.prototype, t = Object.getOwnPropertyDescriptor && e ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null, r = e && t && "function" == typeof t.get ? t.get : null, o = e && Map.prototype.forEach, n = "function" == typeof Set && Set.prototype, a = Object.getOwnPropertyDescriptor && n ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null, i = n && a && "function" == typeof a.get ? a.get : null, s = n && Set.prototype.forEach, c = "function" == typeof WeakMap && WeakMap.prototype ? WeakMap.prototype.has : null, l = "function" == typeof WeakSet && WeakSet.prototype ? WeakSet.prototype.has : null, u = "function" == typeof WeakRef && WeakRef.prototype ? WeakRef.prototype.deref : null, m = Boolean.prototype.valueOf, p = Object.prototype.toString, d = Function.prototype.toString, y = String.prototype.match, g = String.prototype.slice, h = String.prototype.replace, v = String.prototype.toUpperCase, R = String.prototype.toLowerCase, E = RegExp.prototype.test, T = Array.prototype.concat, S = Array.prototype.join, C = Array.prototype.slice, b = Math.floor, _ = "function" == typeof BigInt ? BigInt.prototype.valueOf : null, O = Object.getOwnPropertySymbols, w = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? Symbol.prototype.toString : null, x = "function" == typeof Symbol && "object" == typeof Symbol.iterator, U = "function" == typeof Symbol && Symbol.toStringTag && (Symbol.toStringTag, 
1) ? Symbol.toStringTag : null, k = Object.prototype.propertyIsEnumerable, N = ("function" == typeof Reflect ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(e) {
return e.__proto__;
} : null);
function P(e, t) {
if (e === 1 / 0 || e === -1 / 0 || e != e || e && e > -1e3 && e < 1e3 || E.call(/e/, t)) return t;
var r = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
if ("number" == typeof e) {
var o = e < 0 ? -b(-e) : b(e);
if (o !== e) {
var n = String(o), a = g.call(t, n.length + 1);
return h.call(n, r, "$&_") + "." + h.call(h.call(a, /([0-9]{3})/g, "$&_"), /_$/, "");
}
}
return h.call(t, r, "$&_");
}
var I = dt, G = I.custom, L = K(G) ? G : null, D = {
__proto__: null,
double: '"',
single: "'"
}, F = {
__proto__: null,
double: /(["\\])/g,
single: /(['\\])/g
};
function B(e, t, r) {
var o = r.quoteStyle || t, n = D[o];
return n + e + n;
}
function j(e) {
return h.call(String(e), /"/g, "&quot;");
}
function H(e) {
return !U || !("object" == typeof e && (U in e || void 0 !== e[U]));
}
function W(e) {
return "[object Array]" === q(e) && H(e);
}
function Y(e) {
return "[object RegExp]" === q(e) && H(e);
}
function K(e) {
if (x) return e && "object" == typeof e && e instanceof Symbol;
if ("symbol" == typeof e) return !0;
if (!e || "object" != typeof e || !w) return !1;
try {
return w.call(e), !0;
} catch (e) {}
return !1;
}
M = function e(t, n, a, p) {
var v = n || {};
if (z(v, "quoteStyle") && !z(D, v.quoteStyle)) throw new TypeError('option "quoteStyle" must be "single" or "double"');
if (z(v, "maxStringLength") && ("number" == typeof v.maxStringLength ? v.maxStringLength < 0 && v.maxStringLength !== 1 / 0 : null !== v.maxStringLength)) throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
var E = !z(v, "customInspect") || v.customInspect;
if ("boolean" != typeof E && "symbol" !== E) throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
if (z(v, "indent") && null !== v.indent && "\t" !== v.indent && !(parseInt(v.indent, 10) === v.indent && v.indent > 0)) throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
if (z(v, "numericSeparator") && "boolean" != typeof v.numericSeparator) throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
var b = v.numericSeparator;
if (void 0 === t) return "undefined";
if (null === t) return "null";
if ("boolean" == typeof t) return t ? "true" : "false";
if ("string" == typeof t) return Q(t, v);
if ("number" == typeof t) {
if (0 === t) return 1 / 0 / t > 0 ? "0" : "-0";
var O = String(t);
return b ? P(t, O) : O;
}
if ("bigint" == typeof t) {
var M = String(t) + "n";
return b ? P(t, M) : M;
}
var A = void 0 === v.depth ? 5 : v.depth;
if (void 0 === a && (a = 0), a >= A && A > 0 && "object" == typeof t) return W(t) ? "[Array]" : "[Object]";
var G, F = function(e, t) {
var r;
if ("\t" === e.indent) r = "\t"; else {
if (!("number" == typeof e.indent && e.indent > 0)) return null;
r = S.call(Array(e.indent + 1), " ");
}
return {
base: r,
prev: S.call(Array(t + 1), r)
};
}(v, a);
if (void 0 === p) p = []; else if (X(p, t) >= 0) return "[Circular]";
function V(t, r, o) {
if (r && (p = C.call(p)).push(r), o) {
var n = {
depth: v.depth
};
return z(v, "quoteStyle") && (n.quoteStyle = v.quoteStyle), e(t, n, a + 1, p);
}
return e(t, v, a + 1, p);
}
if ("function" == typeof t && !Y(t)) {
var Z = function(e) {
if (e.name) return e.name;
var t = y.call(d.call(e), /^function\s*([\w$]+)/);
return t ? t[1] : null;
}(t), oe = re(t, V);
return "[Function" + (Z ? ": " + Z : " (anonymous)") + "]" + (oe.length > 0 ? " { " + S.call(oe, ", ") + " }" : "");
}
if (K(t)) {
var ne = x ? h.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : w.call(t);
return "object" != typeof t || x ? ne : J(ne);
}
if ((G = t) && "object" == typeof G && ("undefined" != typeof HTMLElement && G instanceof HTMLElement || "string" == typeof G.nodeName && "function" == typeof G.getAttribute)) {
for (var ae = "<" + R.call(String(t.nodeName)), ie = t.attributes || [], se = 0; se < ie.length; se++) ae += " " + ie[se].name + "=" + B(j(ie[se].value), "double", v);
return ae += ">", t.childNodes && t.childNodes.length && (ae += "..."), ae + "</" + R.call(String(t.nodeName)) + ">";
}
if (W(t)) {
if (0 === t.length) return "[]";
var ce = re(t, V);
return F && !function(e) {
for (var t = 0; t < e.length; t++) if (X(e[t], "\n") >= 0) return !1;
return !0;
}(ce) ? "[" + te(ce, F) + "]" : "[ " + S.call(ce, ", ") + " ]";
}
if (function(e) {
return "[object Error]" === q(e) && H(e);
}(t)) {
var le = re(t, V);
return "cause" in Error.prototype || !("cause" in t) || k.call(t, "cause") ? 0 === le.length ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + S.call(le, ", ") + " }" : "{ [" + String(t) + "] " + S.call(T.call("[cause]: " + V(t.cause), le), ", ") + " }";
}
if ("object" == typeof t && E) {
if (L && "function" == typeof t[L] && I) return I(t, {
depth: A - a
});
if ("symbol" !== E && "function" == typeof t.inspect) return t.inspect();
}
if (function(e) {
if (!r || !e || "object" != typeof e) return !1;
try {
r.call(e);
try {
i.call(e);
} catch (e) {
return !0;
}
return e instanceof Map;
} catch (e) {}
return !1;
}(t)) {
var ue = [];
return o && o.call(t, function(e, r) {
ue.push(V(r, t, !0) + " => " + V(e, t));
}), ee("Map", r.call(t), ue, F);
}
if (function(e) {
if (!i || !e || "object" != typeof e) return !1;
try {
i.call(e);
try {
r.call(e);
} catch (e) {
return !0;
}
return e instanceof Set;
} catch (e) {}
return !1;
}(t)) {
var fe = [];
return s && s.call(t, function(e) {
fe.push(V(e, t));
}), ee("Set", i.call(t), fe, F);
}
if (function(e) {
if (!c || !e || "object" != typeof e) return !1;
try {
c.call(e, c);
try {
l.call(e, l);
} catch (e) {
return !0;
}
return e instanceof WeakMap;
} catch (e) {}
return !1;
}(t)) return $("WeakMap");
if (function(e) {
if (!l || !e || "object" != typeof e) return !1;
try {
l.call(e, l);
try {
c.call(e, c);
} catch (e) {
return !0;
}
return e instanceof WeakSet;
} catch (e) {}
return !1;
}(t)) return $("WeakSet");
if (function(e) {
if (!u || !e || "object" != typeof e) return !1;
try {
return u.call(e), !0;
} catch (e) {}
return !1;
}(t)) return $("WeakRef");
if (function(e) {
return "[object Number]" === q(e) && H(e);
}(t)) return J(V(Number(t)));
if (function(e) {
if (!e || "object" != typeof e || !_) return !1;
try {
return _.call(e), !0;
} catch (e) {}
return !1;
}(t)) return J(V(_.call(t)));
if (function(e) {
return "[object Boolean]" === q(e) && H(e);
}(t)) return J(m.call(t));
if (function(e) {
return "[object String]" === q(e) && H(e);
}(t)) return J(V(String(t)));
if ("undefined" != typeof window && t === window) return "{ [object Window] }";
if ("undefined" != typeof globalThis && t === globalThis || void 0 !== f && t === f) return "{ [object globalThis] }";
if (!function(e) {
return "[object Date]" === q(e) && H(e);
}(t) && !Y(t)) {
var me = re(t, V), pe = N ? N(t) === Object.prototype : t instanceof Object || t.constructor === Object, de = t instanceof Object ? "" : "null prototype", ye = !pe && U && Object(t) === t && U in t ? g.call(q(t), 8, -1) : de ? "Object" : "", ge = (pe || "function" != typeof t.constructor ? "" : t.constructor.name ? t.constructor.name + " " : "") + (ye || de ? "[" + S.call(T.call([], ye || [], de || []), ": ") + "] " : "");
return 0 === me.length ? ge + "{}" : F ? ge + "{" + te(me, F) + "}" : ge + "{ " + S.call(me, ", ") + " }";
}
return String(t);
};
var V = Object.prototype.hasOwnProperty || function(e) {
return e in this;
};
function z(e, t) {
return V.call(e, t);
}
function q(e) {
return p.call(e);
}
function X(e, t) {
if (e.indexOf) return e.indexOf(t);
for (var r = 0, o = e.length; r < o; r++) if (e[r] === t) return r;
return -1;
}
function Q(e, t) {
if (e.length > t.maxStringLength) {
var r = e.length - t.maxStringLength, o = "... " + r + " more character" + (r > 1 ? "s" : "");
return Q(g.call(e, 0, t.maxStringLength), t) + o;
}
var n = F[t.quoteStyle || "single"];
return n.lastIndex = 0, B(h.call(h.call(e, n, "\\$1"), /[\x00-\x1f]/g, Z), "single", t);
}
function Z(e) {
var t = e.charCodeAt(0), r = {
8: "b",
9: "t",
10: "n",
12: "f",
13: "r"
}[t];
return r ? "\\" + r : "\\x" + (t < 16 ? "0" : "") + v.call(t.toString(16));
}
function J(e) {
return "Object(" + e + ")";
}
function $(e) {
return e + " { ? }";
}
function ee(e, t, r, o) {
return e + " (" + t + ") {" + (o ? te(r, o) : S.call(r, ", ")) + "}";
}
function te(e, t) {
if (0 === e.length) return "";
var r = "\n" + t.prev + t.base;
return r + S.call(e, "," + r) + "\n" + t.prev;
}
function re(e, t) {
var r = W(e), o = [];
if (r) {
o.length = e.length;
for (var n = 0; n < e.length; n++) o[n] = z(e, n) ? t(e[n], e) : "";
}
var a, i = "function" == typeof O ? O(e) : [];
if (x) {
a = {};
for (var s = 0; s < i.length; s++) a["$" + i[s]] = i[s];
}
for (var c in e) z(e, c) && (r && String(Number(c)) === c && c < e.length || x && a["$" + c] instanceof Symbol || (E.call(/[^\w$]/, c) ? o.push(t(c, e) + ": " + t(e[c], e)) : o.push(c + ": " + t(e[c], e))));
if ("function" == typeof O) for (var l = 0; l < i.length; l++) k.call(e, i[l]) && o.push("[" + t(i[l]) + "]: " + t(e[i[l]], e));
return o;
}
return M;
}

function gt() {
return I ? P : (I = 1, P = Object);
}

function ht() {
return L ? G : (L = 1, G = Error);
}

function vt() {
return F ? D : (F = 1, D = EvalError);
}

function Rt() {
return j ? B : (j = 1, B = RangeError);
}

function Et() {
return W ? H : (W = 1, H = ReferenceError);
}

function Tt() {
return K ? Y : (K = 1, Y = SyntaxError);
}

function St() {
return z ? V : (z = 1, V = URIError);
}

function Ct() {
return X ? q : (X = 1, q = Math.abs);
}

function bt() {
return Z ? Q : (Z = 1, Q = Math.floor);
}

function _t() {
return $ ? J : ($ = 1, J = Math.max);
}

function Ot() {
return te ? ee : (te = 1, ee = Math.min);
}

function wt() {
return oe ? re : (oe = 1, re = Math.pow);
}

function xt() {
return ae ? ne : (ae = 1, ne = Math.round);
}

function Ut() {
return se ? ie : (se = 1, ie = Number.isNaN || function(e) {
return e != e;
});
}

function Mt() {
if (le) return ce;
le = 1;
var e = Ut();
return ce = function(t) {
return e(t) || 0 === t ? t : t < 0 ? -1 : 1;
};
}

function At() {
return fe ? ue : (fe = 1, ue = Object.getOwnPropertyDescriptor);
}

function kt() {
if (pe) return me;
pe = 1;
var e = At();
if (e) try {
e([], "length");
} catch (t) {
e = null;
}
return me = e;
}

function Nt() {
if (ye) return de;
ye = 1;
var e = Object.defineProperty || !1;
if (e) try {
e({}, "a", {
value: 1
});
} catch (t) {
e = !1;
}
return de = e;
}

function Pt() {
if (Re) return ve;
Re = 1;
var e = "undefined" != typeof Symbol && Symbol, t = he ? ge : (he = 1, ge = function() {
if ("function" != typeof Symbol || "function" != typeof Object.getOwnPropertySymbols) return !1;
if ("symbol" == typeof Symbol.iterator) return !0;
var e = {}, t = Symbol("test"), r = Object(t);
if ("string" == typeof t) return !1;
if ("[object Symbol]" !== Object.prototype.toString.call(t)) return !1;
if ("[object Symbol]" !== Object.prototype.toString.call(r)) return !1;
for (var o in e[t] = 42, e) return !1;
if ("function" == typeof Object.keys && 0 !== Object.keys(e).length) return !1;
if ("function" == typeof Object.getOwnPropertyNames && 0 !== Object.getOwnPropertyNames(e).length) return !1;
var n = Object.getOwnPropertySymbols(e);
if (1 !== n.length || n[0] !== t) return !1;
if (!Object.prototype.propertyIsEnumerable.call(e, t)) return !1;
if ("function" == typeof Object.getOwnPropertyDescriptor) {
var a = Object.getOwnPropertyDescriptor(e, t);
if (42 !== a.value || !0 !== a.enumerable) return !1;
}
return !0;
});
return ve = function() {
return "function" == typeof e && "function" == typeof Symbol && "symbol" == typeof e("foo") && "symbol" == typeof Symbol("bar") && t();
};
}

function It() {
return Te ? Ee : (Te = 1, Ee = "undefined" != typeof Reflect && Reflect.getPrototypeOf || null);
}

function Gt() {
return Ce ? Se : (Ce = 1, Se = gt().getPrototypeOf || null);
}

function Lt() {
if (_e) return be;
_e = 1;
var e = Object.prototype.toString, t = Math.max, r = function(e, t) {
for (var r = [], o = 0; o < e.length; o += 1) r[o] = e[o];
for (var n = 0; n < t.length; n += 1) r[n + e.length] = t[n];
return r;
};
return be = function(o) {
var n = this;
if ("function" != typeof n || "[object Function]" !== e.apply(n)) throw new TypeError("Function.prototype.bind called on incompatible " + n);
for (var a, i = function(e) {
for (var t = [], r = 1, o = 0; r < e.length; r += 1, o += 1) t[o] = e[r];
return t;
}(arguments), s = t(0, n.length - i.length), c = [], l = 0; l < s; l++) c[l] = "$" + l;
if (a = Function("binder", "return function (" + function(e) {
for (var t = "", r = 0; r < e.length; r += 1) t += e[r], r + 1 < e.length && (t += ",");
return t;
}(c) + "){ return binder.apply(this,arguments); }")(function() {
if (this instanceof a) {
var e = n.apply(this, r(i, arguments));
return Object(e) === e ? e : this;
}
return n.apply(o, r(i, arguments));
}), n.prototype) {
var u = function() {};
u.prototype = n.prototype, a.prototype = new u, u.prototype = null;
}
return a;
}, be;
}

function Dt() {
if (we) return Oe;
we = 1;
var e = Lt();
return Oe = Function.prototype.bind || e;
}

function Ft() {
return Ue ? xe : (Ue = 1, xe = Function.prototype.call);
}

function Bt() {
return Ae ? Me : (Ae = 1, Me = Function.prototype.apply);
}

function jt() {
if (Le) return Ge;
Le = 1;
var e = Dt(), t = U(), r = Ft(), o = function() {
if (Ie) return Pe;
Ie = 1;
var e = Dt(), t = Bt(), r = Ft(), o = Ne ? ke : (Ne = 1, ke = "undefined" != typeof Reflect && Reflect && Reflect.apply);
return Pe = o || e.call(r, t);
}();
return Ge = function(n) {
if (n.length < 1 || "function" != typeof n[0]) throw new t("a function is required");
return o(e, r, n);
};
}

function Ht() {
if (Fe) return De;
Fe = 1;
var e, t = jt(), r = kt();
try {
e = [].__proto__ === Array.prototype;
} catch (e) {
if (!e || "object" != typeof e || !("code" in e) || "ERR_PROTO_ACCESS" !== e.code) throw e;
}
var o = !!e && r && r(Object.prototype, "__proto__"), n = Object, a = n.getPrototypeOf;
return De = o && "function" == typeof o.get ? t([ o.get ]) : "function" == typeof a && function(e) {
return a(null == e ? e : n(e));
};
}

function Wt() {
if (je) return Be;
je = 1;
var e = It(), t = Gt(), r = Ht();
return Be = e ? function(t) {
return e(t);
} : t ? function(e) {
if (!e || "object" != typeof e && "function" != typeof e) throw new TypeError("getProto: not an object");
return t(e);
} : r ? function(e) {
return r(e);
} : null;
}

function Yt() {
if (We) return He;
We = 1;
var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, r = Dt();
return He = r.call(e, t);
}

function Kt() {
if (Ke) return Ye;
var e;
Ke = 1;
var t = gt(), r = ht(), o = vt(), n = Rt(), a = Et(), i = Tt(), s = U(), c = St(), l = Ct(), u = bt(), f = _t(), m = Ot(), p = wt(), d = xt(), y = Mt(), g = Function, h = function(e) {
try {
return g('"use strict"; return (' + e + ").constructor;")();
} catch (e) {}
}, v = kt(), R = Nt(), E = function() {
throw new s;
}, T = v ? function() {
try {
return E;
} catch (e) {
try {
return v(arguments, "callee").get;
} catch (e) {
return E;
}
}
}() : E, S = Pt()(), C = Wt(), b = Gt(), _ = It(), O = Bt(), w = Ft(), x = {}, M = "undefined" != typeof Uint8Array && C ? C(Uint8Array) : e, A = {
__proto__: null,
"%AggregateError%": "undefined" == typeof AggregateError ? e : AggregateError,
"%Array%": Array,
"%ArrayBuffer%": "undefined" == typeof ArrayBuffer ? e : ArrayBuffer,
"%ArrayIteratorPrototype%": S && C ? C([][Symbol.iterator]()) : e,
"%AsyncFromSyncIteratorPrototype%": e,
"%AsyncFunction%": x,
"%AsyncGenerator%": x,
"%AsyncGeneratorFunction%": x,
"%AsyncIteratorPrototype%": x,
"%Atomics%": "undefined" == typeof Atomics ? e : Atomics,
"%BigInt%": "undefined" == typeof BigInt ? e : BigInt,
"%BigInt64Array%": "undefined" == typeof BigInt64Array ? e : BigInt64Array,
"%BigUint64Array%": "undefined" == typeof BigUint64Array ? e : BigUint64Array,
"%Boolean%": Boolean,
"%DataView%": "undefined" == typeof DataView ? e : DataView,
"%Date%": Date,
"%decodeURI%": decodeURI,
"%decodeURIComponent%": decodeURIComponent,
"%encodeURI%": encodeURI,
"%encodeURIComponent%": encodeURIComponent,
"%Error%": r,
"%eval%": eval,
"%EvalError%": o,
"%Float16Array%": "undefined" == typeof Float16Array ? e : Float16Array,
"%Float32Array%": "undefined" == typeof Float32Array ? e : Float32Array,
"%Float64Array%": "undefined" == typeof Float64Array ? e : Float64Array,
"%FinalizationRegistry%": "undefined" == typeof FinalizationRegistry ? e : FinalizationRegistry,
"%Function%": g,
"%GeneratorFunction%": x,
"%Int8Array%": "undefined" == typeof Int8Array ? e : Int8Array,
"%Int16Array%": "undefined" == typeof Int16Array ? e : Int16Array,
"%Int32Array%": "undefined" == typeof Int32Array ? e : Int32Array,
"%isFinite%": isFinite,
"%isNaN%": isNaN,
"%IteratorPrototype%": S && C ? C(C([][Symbol.iterator]())) : e,
"%JSON%": "object" == typeof JSON ? JSON : e,
"%Map%": "undefined" == typeof Map ? e : Map,
"%MapIteratorPrototype%": "undefined" != typeof Map && S && C ? C((new Map)[Symbol.iterator]()) : e,
"%Math%": Math,
"%Number%": Number,
"%Object%": t,
"%Object.getOwnPropertyDescriptor%": v,
"%parseFloat%": parseFloat,
"%parseInt%": parseInt,
"%Promise%": "undefined" == typeof Promise ? e : Promise,
"%Proxy%": "undefined" == typeof Proxy ? e : Proxy,
"%RangeError%": n,
"%ReferenceError%": a,
"%Reflect%": "undefined" == typeof Reflect ? e : Reflect,
"%RegExp%": RegExp,
"%Set%": "undefined" == typeof Set ? e : Set,
"%SetIteratorPrototype%": "undefined" != typeof Set && S && C ? C((new Set)[Symbol.iterator]()) : e,
"%SharedArrayBuffer%": "undefined" == typeof SharedArrayBuffer ? e : SharedArrayBuffer,
"%String%": String,
"%StringIteratorPrototype%": S && C ? C(""[Symbol.iterator]()) : e,
"%Symbol%": S ? Symbol : e,
"%SyntaxError%": i,
"%ThrowTypeError%": T,
"%TypedArray%": M,
"%TypeError%": s,
"%Uint8Array%": "undefined" == typeof Uint8Array ? e : Uint8Array,
"%Uint8ClampedArray%": "undefined" == typeof Uint8ClampedArray ? e : Uint8ClampedArray,
"%Uint16Array%": "undefined" == typeof Uint16Array ? e : Uint16Array,
"%Uint32Array%": "undefined" == typeof Uint32Array ? e : Uint32Array,
"%URIError%": c,
"%WeakMap%": "undefined" == typeof WeakMap ? e : WeakMap,
"%WeakRef%": "undefined" == typeof WeakRef ? e : WeakRef,
"%WeakSet%": "undefined" == typeof WeakSet ? e : WeakSet,
"%Function.prototype.call%": w,
"%Function.prototype.apply%": O,
"%Object.defineProperty%": R,
"%Object.getPrototypeOf%": b,
"%Math.abs%": l,
"%Math.floor%": u,
"%Math.max%": f,
"%Math.min%": m,
"%Math.pow%": p,
"%Math.round%": d,
"%Math.sign%": y,
"%Reflect.getPrototypeOf%": _
};
if (C) try {
null.error;
} catch (e) {
var k = C(C(e));
A["%Error.prototype%"] = k;
}
var N = function e(t) {
var r;
if ("%AsyncFunction%" === t) r = h("async function () {}"); else if ("%GeneratorFunction%" === t) r = h("function* () {}"); else if ("%AsyncGeneratorFunction%" === t) r = h("async function* () {}"); else if ("%AsyncGenerator%" === t) {
var o = e("%AsyncGeneratorFunction%");
o && (r = o.prototype);
} else if ("%AsyncIteratorPrototype%" === t) {
var n = e("%AsyncGenerator%");
n && C && (r = C(n.prototype));
}
return A[t] = r, r;
}, P = {
__proto__: null,
"%ArrayBufferPrototype%": [ "ArrayBuffer", "prototype" ],
"%ArrayPrototype%": [ "Array", "prototype" ],
"%ArrayProto_entries%": [ "Array", "prototype", "entries" ],
"%ArrayProto_forEach%": [ "Array", "prototype", "forEach" ],
"%ArrayProto_keys%": [ "Array", "prototype", "keys" ],
"%ArrayProto_values%": [ "Array", "prototype", "values" ],
"%AsyncFunctionPrototype%": [ "AsyncFunction", "prototype" ],
"%AsyncGenerator%": [ "AsyncGeneratorFunction", "prototype" ],
"%AsyncGeneratorPrototype%": [ "AsyncGeneratorFunction", "prototype", "prototype" ],
"%BooleanPrototype%": [ "Boolean", "prototype" ],
"%DataViewPrototype%": [ "DataView", "prototype" ],
"%DatePrototype%": [ "Date", "prototype" ],
"%ErrorPrototype%": [ "Error", "prototype" ],
"%EvalErrorPrototype%": [ "EvalError", "prototype" ],
"%Float32ArrayPrototype%": [ "Float32Array", "prototype" ],
"%Float64ArrayPrototype%": [ "Float64Array", "prototype" ],
"%FunctionPrototype%": [ "Function", "prototype" ],
"%Generator%": [ "GeneratorFunction", "prototype" ],
"%GeneratorPrototype%": [ "GeneratorFunction", "prototype", "prototype" ],
"%Int8ArrayPrototype%": [ "Int8Array", "prototype" ],
"%Int16ArrayPrototype%": [ "Int16Array", "prototype" ],
"%Int32ArrayPrototype%": [ "Int32Array", "prototype" ],
"%JSONParse%": [ "JSON", "parse" ],
"%JSONStringify%": [ "JSON", "stringify" ],
"%MapPrototype%": [ "Map", "prototype" ],
"%NumberPrototype%": [ "Number", "prototype" ],
"%ObjectPrototype%": [ "Object", "prototype" ],
"%ObjProto_toString%": [ "Object", "prototype", "toString" ],
"%ObjProto_valueOf%": [ "Object", "prototype", "valueOf" ],
"%PromisePrototype%": [ "Promise", "prototype" ],
"%PromiseProto_then%": [ "Promise", "prototype", "then" ],
"%Promise_all%": [ "Promise", "all" ],
"%Promise_reject%": [ "Promise", "reject" ],
"%Promise_resolve%": [ "Promise", "resolve" ],
"%RangeErrorPrototype%": [ "RangeError", "prototype" ],
"%ReferenceErrorPrototype%": [ "ReferenceError", "prototype" ],
"%RegExpPrototype%": [ "RegExp", "prototype" ],
"%SetPrototype%": [ "Set", "prototype" ],
"%SharedArrayBufferPrototype%": [ "SharedArrayBuffer", "prototype" ],
"%StringPrototype%": [ "String", "prototype" ],
"%SymbolPrototype%": [ "Symbol", "prototype" ],
"%SyntaxErrorPrototype%": [ "SyntaxError", "prototype" ],
"%TypedArrayPrototype%": [ "TypedArray", "prototype" ],
"%TypeErrorPrototype%": [ "TypeError", "prototype" ],
"%Uint8ArrayPrototype%": [ "Uint8Array", "prototype" ],
"%Uint8ClampedArrayPrototype%": [ "Uint8ClampedArray", "prototype" ],
"%Uint16ArrayPrototype%": [ "Uint16Array", "prototype" ],
"%Uint32ArrayPrototype%": [ "Uint32Array", "prototype" ],
"%URIErrorPrototype%": [ "URIError", "prototype" ],
"%WeakMapPrototype%": [ "WeakMap", "prototype" ],
"%WeakSetPrototype%": [ "WeakSet", "prototype" ]
}, I = Dt(), G = Yt(), L = I.call(w, Array.prototype.concat), D = I.call(O, Array.prototype.splice), F = I.call(w, String.prototype.replace), B = I.call(w, String.prototype.slice), j = I.call(w, RegExp.prototype.exec), H = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, W = /\\(\\)?/g, Y = function(e, t) {
var r, o = e;
if (G(P, o) && (o = "%" + (r = P[o])[0] + "%"), G(A, o)) {
var n = A[o];
if (n === x && (n = N(o)), void 0 === n && !t) throw new s("intrinsic " + e + " exists, but is not available. Please file an issue!");
return {
alias: r,
name: o,
value: n
};
}
throw new i("intrinsic " + e + " does not exist!");
};
return Ye = function(e, t) {
if ("string" != typeof e || 0 === e.length) throw new s("intrinsic name must be a non-empty string");
if (arguments.length > 1 && "boolean" != typeof t) throw new s('"allowMissing" argument must be a boolean');
if (null === j(/^%?[^%]*%?$/, e)) throw new i("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
var r = function(e) {
var t = B(e, 0, 1), r = B(e, -1);
if ("%" === t && "%" !== r) throw new i("invalid intrinsic syntax, expected closing `%`");
if ("%" === r && "%" !== t) throw new i("invalid intrinsic syntax, expected opening `%`");
var o = [];
return F(e, H, function(e, t, r, n) {
o[o.length] = r ? F(n, W, "$1") : t || e;
}), o;
}(e), o = r.length > 0 ? r[0] : "", n = Y("%" + o + "%", t), a = n.name, c = n.value, l = !1, u = n.alias;
u && (o = u[0], D(r, L([ 0, 1 ], u)));
for (var f = 1, m = !0; f < r.length; f += 1) {
var p = r[f], d = B(p, 0, 1), y = B(p, -1);
if (('"' === d || "'" === d || "`" === d || '"' === y || "'" === y || "`" === y) && d !== y) throw new i("property names with quotes must have matching quotes");
if ("constructor" !== p && m || (l = !0), G(A, a = "%" + (o += "." + p) + "%")) c = A[a]; else if (null != c) {
if (!(p in c)) {
if (!t) throw new s("base intrinsic for " + e + " exists, but the property is not available.");
return;
}
if (v && f + 1 >= r.length) {
var g = v(c, p);
c = (m = !!g) && "get" in g && !("originalValue" in g.get) ? g.get : c[p];
} else m = G(c, p), c = c[p];
m && !l && (A[a] = c);
}
}
return c;
}, Ye;
}

function Vt() {
if (ze) return Ve;
ze = 1;
var e = Kt(), t = jt(), r = t([ e("%String.prototype.indexOf%") ]);
return Ve = function(o, n) {
var a = e(o, !!n);
return "function" == typeof a && r(o, ".prototype.") > -1 ? t([ a ]) : a;
};
}

function zt() {
if (Xe) return qe;
Xe = 1;
var e = Kt(), t = Vt(), r = yt(), o = U(), n = e("%Map%", !0), a = t("Map.prototype.get", !0), i = t("Map.prototype.set", !0), s = t("Map.prototype.has", !0), c = t("Map.prototype.delete", !0), l = t("Map.prototype.size", !0);
return qe = !!n && function() {
var e, t = {
assert: function(e) {
if (!t.has(e)) throw new o("Side channel does not contain " + r(e));
},
delete: function(t) {
if (e) {
var r = c(e, t);
return 0 === l(e) && (e = void 0), r;
}
return !1;
},
get: function(t) {
if (e) return a(e, t);
},
has: function(t) {
return !!e && s(e, t);
},
set: function(t, r) {
e || (e = new n), i(e, t, r);
}
};
return t;
};
}

function qt() {
if (tt) return et;
tt = 1;
var e = String.prototype.replace, t = /%20/g, r = "RFC3986";
return et = {
default: r,
formatters: {
RFC1738: function(r) {
return e.call(r, t, "+");
},
RFC3986: function(e) {
return String(e);
}
},
RFC1738: "RFC1738",
RFC3986: r
};
}

function Xt() {
if (ot) return rt;
ot = 1;
var e = qt(), t = Object.prototype.hasOwnProperty, r = Array.isArray, o = function() {
for (var e = [], t = 0; t < 256; ++t) e.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
return e;
}(), n = function(e, t) {
for (var r = t && t.plainObjects ? {
__proto__: null
} : {}, o = 0; o < e.length; ++o) void 0 !== e[o] && (r[o] = e[o]);
return r;
}, a = 1024;
return rt = {
arrayToObject: n,
assign: function(e, t) {
return Object.keys(t).reduce(function(e, r) {
return e[r] = t[r], e;
}, e);
},
combine: function(e, t) {
return [].concat(e, t);
},
compact: function(e) {
for (var t = [ {
obj: {
o: e
},
prop: "o"
} ], o = [], n = 0; n < t.length; ++n) for (var a = t[n], i = a.obj[a.prop], s = Object.keys(i), c = 0; c < s.length; ++c) {
var l = s[c], u = i[l];
"object" == typeof u && null !== u && -1 === o.indexOf(u) && (t.push({
obj: i,
prop: l
}), o.push(u));
}
return function(e) {
for (;e.length > 1; ) {
var t = e.pop(), o = t.obj[t.prop];
if (r(o)) {
for (var n = [], a = 0; a < o.length; ++a) void 0 !== o[a] && n.push(o[a]);
t.obj[t.prop] = n;
}
}
}(t), e;
},
decode: function(e, t, r) {
var o = e.replace(/\+/g, " ");
if ("iso-8859-1" === r) return o.replace(/%[0-9a-f]{2}/gi, unescape);
try {
return decodeURIComponent(o);
} catch (e) {
return o;
}
},
encode: function(t, r, n, i, s) {
if (0 === t.length) return t;
var c = t;
if ("symbol" == typeof t ? c = Symbol.prototype.toString.call(t) : "string" != typeof t && (c = String(t)), 
"iso-8859-1" === n) return escape(c).replace(/%u[0-9a-f]{4}/gi, function(e) {
return "%26%23" + parseInt(e.slice(2), 16) + "%3B";
});
for (var l = "", u = 0; u < c.length; u += a) {
for (var f = c.length >= a ? c.slice(u, u + a) : c, m = [], p = 0; p < f.length; ++p) {
var d = f.charCodeAt(p);
45 === d || 46 === d || 95 === d || 126 === d || d >= 48 && d <= 57 || d >= 65 && d <= 90 || d >= 97 && d <= 122 || s === e.RFC1738 && (40 === d || 41 === d) ? m[m.length] = f.charAt(p) : d < 128 ? m[m.length] = o[d] : d < 2048 ? m[m.length] = o[192 | d >> 6] + o[128 | 63 & d] : d < 55296 || d >= 57344 ? m[m.length] = o[224 | d >> 12] + o[128 | d >> 6 & 63] + o[128 | 63 & d] : (p += 1, 
d = 65536 + ((1023 & d) << 10 | 1023 & f.charCodeAt(p)), m[m.length] = o[240 | d >> 18] + o[128 | d >> 12 & 63] + o[128 | d >> 6 & 63] + o[128 | 63 & d]);
}
l += m.join("");
}
return l;
},
isBuffer: function(e) {
return !(!e || "object" != typeof e || !(e.constructor && e.constructor.isBuffer && e.constructor.isBuffer(e)));
},
isRegExp: function(e) {
return "[object RegExp]" === Object.prototype.toString.call(e);
},
maybeMap: function(e, t) {
if (r(e)) {
for (var o = [], n = 0; n < e.length; n += 1) o.push(t(e[n]));
return o;
}
return t(e);
},
merge: function e(o, a, i) {
if (!a) return o;
if ("object" != typeof a && "function" != typeof a) {
if (r(o)) o.push(a); else {
if (!o || "object" != typeof o) return [ o, a ];
(i && (i.plainObjects || i.allowPrototypes) || !t.call(Object.prototype, a)) && (o[a] = !0);
}
return o;
}
if (!o || "object" != typeof o) return [ o ].concat(a);
var s = o;
return r(o) && !r(a) && (s = n(o, i)), r(o) && r(a) ? (a.forEach(function(r, n) {
if (t.call(o, n)) {
var a = o[n];
a && "object" == typeof a && r && "object" == typeof r ? o[n] = e(a, r, i) : o.push(r);
} else o[n] = r;
}), o) : Object.keys(a).reduce(function(r, o) {
var n = a[o];
return t.call(r, o) ? r[o] = e(r[o], n, i) : r[o] = n, r;
}, s);
}
};
}

function Qt() {
if (at) return nt;
at = 1;
var e = function() {
if ($e) return Je;
$e = 1;
var e = U(), t = yt(), r = function() {
if (N) return k;
N = 1;
var e = yt(), t = U(), r = function(e, t, r) {
for (var o, n = e; null != (o = n.next); n = o) if (o.key === t) return n.next = o.next, 
r || (o.next = e.next, e.next = o), o;
};
return k = function() {
var o, n = {
assert: function(r) {
if (!n.has(r)) throw new t("Side channel does not contain " + e(r));
},
delete: function(e) {
var t = o && o.next, n = function(e, t) {
if (e) return r(e, t, !0);
}(o, e);
return n && t && t === n && (o = void 0), !!n;
},
get: function(e) {
return function(e, t) {
if (e) {
var o = r(e, t);
return o && o.value;
}
}(o, e);
},
has: function(e) {
return function(e, t) {
return !!e && !!r(e, t);
}(o, e);
},
set: function(e, t) {
o || (o = {
next: void 0
}), function(e, t, o) {
var n = r(e, t);
n ? n.value = o : e.next = {
key: t,
next: e.next,
value: o
};
}(o, e, t);
}
};
return n;
};
}(), o = zt(), n = function() {
if (Ze) return Qe;
Ze = 1;
var e = Kt(), t = Vt(), r = yt(), o = zt(), n = U(), a = e("%WeakMap%", !0), i = t("WeakMap.prototype.get", !0), s = t("WeakMap.prototype.set", !0), c = t("WeakMap.prototype.has", !0), l = t("WeakMap.prototype.delete", !0);
return Qe = a ? function() {
var e, t, u = {
assert: function(e) {
if (!u.has(e)) throw new n("Side channel does not contain " + r(e));
},
delete: function(r) {
if (a && r && ("object" == typeof r || "function" == typeof r)) {
if (e) return l(e, r);
} else if (o && t) return t.delete(r);
return !1;
},
get: function(r) {
return a && r && ("object" == typeof r || "function" == typeof r) && e ? i(e, r) : t && t.get(r);
},
has: function(r) {
return a && r && ("object" == typeof r || "function" == typeof r) && e ? c(e, r) : !!t && t.has(r);
},
set: function(r, n) {
a && r && ("object" == typeof r || "function" == typeof r) ? (e || (e = new a), 
s(e, r, n)) : o && (t || (t = o()), t.set(r, n));
}
};
return u;
} : o;
}(), a = n || o || r;
return Je = function() {
var r, o = {
assert: function(r) {
if (!o.has(r)) throw new e("Side channel does not contain " + t(r));
},
delete: function(e) {
return !!r && r.delete(e);
},
get: function(e) {
return r && r.get(e);
},
has: function(e) {
return !!r && r.has(e);
},
set: function(e, t) {
r || (r = a()), r.set(e, t);
}
};
return o;
};
}(), t = Xt(), r = qt(), o = Object.prototype.hasOwnProperty, n = {
brackets: function(e) {
return e + "[]";
},
comma: "comma",
indices: function(e, t) {
return e + "[" + t + "]";
},
repeat: function(e) {
return e;
}
}, a = Array.isArray, i = Array.prototype.push, s = function(e, t) {
i.apply(e, a(t) ? t : [ t ]);
}, c = Date.prototype.toISOString, l = r.default, u = {
addQueryPrefix: !1,
allowDots: !1,
allowEmptyArrays: !1,
arrayFormat: "indices",
charset: "utf-8",
charsetSentinel: !1,
commaRoundTrip: !1,
delimiter: "&",
encode: !0,
encodeDotInKeys: !1,
encoder: t.encode,
encodeValuesOnly: !1,
filter: void 0,
format: l,
formatter: r.formatters[l],
indices: !1,
serializeDate: function(e) {
return c.call(e);
},
skipNulls: !1,
strictNullHandling: !1
}, f = {}, m = function r(o, n, i, c, l, m, p, d, y, g, h, v, R, E, T, S, C, b) {
for (var _, O = o, w = b, x = 0, U = !1; void 0 !== (w = w.get(f)) && !U; ) {
var M = w.get(o);
if (x += 1, void 0 !== M) {
if (M === x) throw new RangeError("Cyclic object value");
U = !0;
}
void 0 === w.get(f) && (x = 0);
}
if ("function" == typeof g ? O = g(n, O) : O instanceof Date ? O = R(O) : "comma" === i && a(O) && (O = t.maybeMap(O, function(e) {
return e instanceof Date ? R(e) : e;
})), null === O) {
if (m) return y && !S ? y(n, u.encoder, C, "key", E) : n;
O = "";
}
if ("string" == typeof (_ = O) || "number" == typeof _ || "boolean" == typeof _ || "symbol" == typeof _ || "bigint" == typeof _ || t.isBuffer(O)) return y ? [ T(S ? n : y(n, u.encoder, C, "key", E)) + "=" + T(y(O, u.encoder, C, "value", E)) ] : [ T(n) + "=" + T(String(O)) ];
var A, k = [];
if (void 0 === O) return k;
if ("comma" === i && a(O)) S && y && (O = t.maybeMap(O, y)), A = [ {
value: O.length > 0 ? O.join(",") || null : void 0
} ]; else if (a(g)) A = g; else {
var N = Object.keys(O);
A = h ? N.sort(h) : N;
}
var P = d ? String(n).replace(/\./g, "%2E") : String(n), I = c && a(O) && 1 === O.length ? P + "[]" : P;
if (l && a(O) && 0 === O.length) return I + "[]";
for (var G = 0; G < A.length; ++G) {
var L = A[G], D = "object" == typeof L && L && void 0 !== L.value ? L.value : O[L];
if (!p || null !== D) {
var F = v && d ? String(L).replace(/\./g, "%2E") : String(L), B = a(O) ? "function" == typeof i ? i(I, F) : I : I + (v ? "." + F : "[" + F + "]");
b.set(o, x);
var j = e();
j.set(f, b), s(k, r(D, B, i, c, l, m, p, d, "comma" === i && S && a(O) ? null : y, g, h, v, R, E, T, S, C, j));
}
}
return k;
};
return nt = function(t, i) {
var c, l = t, f = function(e) {
if (!e) return u;
if (void 0 !== e.allowEmptyArrays && "boolean" != typeof e.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
if (void 0 !== e.encodeDotInKeys && "boolean" != typeof e.encodeDotInKeys) throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
if (null !== e.encoder && void 0 !== e.encoder && "function" != typeof e.encoder) throw new TypeError("Encoder has to be a function.");
var t = e.charset || u.charset;
if (void 0 !== e.charset && "utf-8" !== e.charset && "iso-8859-1" !== e.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
var i = r.default;
if (void 0 !== e.format) {
if (!o.call(r.formatters, e.format)) throw new TypeError("Unknown format option provided.");
i = e.format;
}
var s, c = r.formatters[i], l = u.filter;
if (("function" == typeof e.filter || a(e.filter)) && (l = e.filter), s = e.arrayFormat in n ? e.arrayFormat : "indices" in e ? e.indices ? "indices" : "repeat" : u.arrayFormat, 
"commaRoundTrip" in e && "boolean" != typeof e.commaRoundTrip) throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
var f = void 0 === e.allowDots ? !0 === e.encodeDotInKeys || u.allowDots : !!e.allowDots;
return {
addQueryPrefix: "boolean" == typeof e.addQueryPrefix ? e.addQueryPrefix : u.addQueryPrefix,
allowDots: f,
allowEmptyArrays: "boolean" == typeof e.allowEmptyArrays ? !!e.allowEmptyArrays : u.allowEmptyArrays,
arrayFormat: s,
charset: t,
charsetSentinel: "boolean" == typeof e.charsetSentinel ? e.charsetSentinel : u.charsetSentinel,
commaRoundTrip: !!e.commaRoundTrip,
delimiter: void 0 === e.delimiter ? u.delimiter : e.delimiter,
encode: "boolean" == typeof e.encode ? e.encode : u.encode,
encodeDotInKeys: "boolean" == typeof e.encodeDotInKeys ? e.encodeDotInKeys : u.encodeDotInKeys,
encoder: "function" == typeof e.encoder ? e.encoder : u.encoder,
encodeValuesOnly: "boolean" == typeof e.encodeValuesOnly ? e.encodeValuesOnly : u.encodeValuesOnly,
filter: l,
format: i,
formatter: c,
serializeDate: "function" == typeof e.serializeDate ? e.serializeDate : u.serializeDate,
skipNulls: "boolean" == typeof e.skipNulls ? e.skipNulls : u.skipNulls,
sort: "function" == typeof e.sort ? e.sort : null,
strictNullHandling: "boolean" == typeof e.strictNullHandling ? e.strictNullHandling : u.strictNullHandling
};
}(i);
"function" == typeof f.filter ? l = (0, f.filter)("", l) : a(f.filter) && (c = f.filter);
var p = [];
if ("object" != typeof l || null === l) return "";
var d = n[f.arrayFormat], y = "comma" === d && f.commaRoundTrip;
c || (c = Object.keys(l)), f.sort && c.sort(f.sort);
for (var g = e(), h = 0; h < c.length; ++h) {
var v = c[h], R = l[v];
f.skipNulls && null === R || s(p, m(R, v, d, y, f.allowEmptyArrays, f.strictNullHandling, f.skipNulls, f.encodeDotInKeys, f.encode ? f.encoder : null, f.filter, f.sort, f.allowDots, f.serializeDate, f.format, f.formatter, f.encodeValuesOnly, f.charset, g));
}
var E = p.join(f.delimiter), T = !0 === f.addQueryPrefix ? "?" : "";
return f.charsetSentinel && ("iso-8859-1" === f.charset ? T += "utf8=%26%2310003%3B&" : T += "utf8=%E2%9C%93&"), 
E.length > 0 ? T + E : "";
}, nt;
}

function Zt() {
if (st) return it;
st = 1;
var e = Xt(), t = Object.prototype.hasOwnProperty, r = Array.isArray, o = {
allowDots: !1,
allowEmptyArrays: !1,
allowPrototypes: !1,
allowSparse: !1,
arrayLimit: 20,
charset: "utf-8",
charsetSentinel: !1,
comma: !1,
decodeDotInKeys: !1,
decoder: e.decode,
delimiter: "&",
depth: 5,
duplicates: "combine",
ignoreQueryPrefix: !1,
interpretNumericEntities: !1,
parameterLimit: 1e3,
parseArrays: !0,
plainObjects: !1,
strictDepth: !1,
strictNullHandling: !1,
throwOnLimitExceeded: !1
}, n = function(e) {
return e.replace(/&#(\d+);/g, function(e, t) {
return String.fromCharCode(parseInt(t, 10));
});
}, a = function(e, t, r) {
if (e && "string" == typeof e && t.comma && e.indexOf(",") > -1) return e.split(",");
if (t.throwOnLimitExceeded && r >= t.arrayLimit) throw new RangeError("Array limit exceeded. Only " + t.arrayLimit + " element" + (1 === t.arrayLimit ? "" : "s") + " allowed in an array.");
return e;
}, i = function(r, o, n, i) {
if (r) {
var s = n.allowDots ? r.replace(/\.([^.[]+)/g, "[$1]") : r, c = /(\[[^[\]]*])/g, l = n.depth > 0 && /(\[[^[\]]*])/.exec(s), u = l ? s.slice(0, l.index) : s, f = [];
if (u) {
if (!n.plainObjects && t.call(Object.prototype, u) && !n.allowPrototypes) return;
f.push(u);
}
for (var m = 0; n.depth > 0 && null !== (l = c.exec(s)) && m < n.depth; ) {
if (m += 1, !n.plainObjects && t.call(Object.prototype, l[1].slice(1, -1)) && !n.allowPrototypes) return;
f.push(l[1]);
}
if (l) {
if (!0 === n.strictDepth) throw new RangeError("Input depth exceeded depth option of " + n.depth + " and strictDepth is true");
f.push("[" + s.slice(l.index) + "]");
}
return function(t, r, o, n) {
var i = 0;
if (t.length > 0 && "[]" === t[t.length - 1]) {
var s = t.slice(0, -1).join("");
i = Array.isArray(r) && r[s] ? r[s].length : 0;
}
for (var c = n ? r : a(r, o, i), l = t.length - 1; l >= 0; --l) {
var u, f = t[l];
if ("[]" === f && o.parseArrays) u = o.allowEmptyArrays && ("" === c || o.strictNullHandling && null === c) ? [] : e.combine([], c); else {
u = o.plainObjects ? {
__proto__: null
} : {};
var m = "[" === f.charAt(0) && "]" === f.charAt(f.length - 1) ? f.slice(1, -1) : f, p = o.decodeDotInKeys ? m.replace(/%2E/g, ".") : m, d = parseInt(p, 10);
o.parseArrays || "" !== p ? !isNaN(d) && f !== p && String(d) === p && d >= 0 && o.parseArrays && d <= o.arrayLimit ? (u = [])[d] = c : "__proto__" !== p && (u[p] = c) : u = {
0: c
};
}
c = u;
}
return c;
}(f, o, n, i);
}
};
return it = function(s, c) {
var l = function(t) {
if (!t) return o;
if (void 0 !== t.allowEmptyArrays && "boolean" != typeof t.allowEmptyArrays) throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
if (void 0 !== t.decodeDotInKeys && "boolean" != typeof t.decodeDotInKeys) throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
if (null !== t.decoder && void 0 !== t.decoder && "function" != typeof t.decoder) throw new TypeError("Decoder has to be a function.");
if (void 0 !== t.charset && "utf-8" !== t.charset && "iso-8859-1" !== t.charset) throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
if (void 0 !== t.throwOnLimitExceeded && "boolean" != typeof t.throwOnLimitExceeded) throw new TypeError("`throwOnLimitExceeded` option must be a boolean");
var r = void 0 === t.charset ? o.charset : t.charset, n = void 0 === t.duplicates ? o.duplicates : t.duplicates;
if ("combine" !== n && "first" !== n && "last" !== n) throw new TypeError("The duplicates option must be either combine, first, or last");
return {
allowDots: void 0 === t.allowDots ? !0 === t.decodeDotInKeys || o.allowDots : !!t.allowDots,
allowEmptyArrays: "boolean" == typeof t.allowEmptyArrays ? !!t.allowEmptyArrays : o.allowEmptyArrays,
allowPrototypes: "boolean" == typeof t.allowPrototypes ? t.allowPrototypes : o.allowPrototypes,
allowSparse: "boolean" == typeof t.allowSparse ? t.allowSparse : o.allowSparse,
arrayLimit: "number" == typeof t.arrayLimit ? t.arrayLimit : o.arrayLimit,
charset: r,
charsetSentinel: "boolean" == typeof t.charsetSentinel ? t.charsetSentinel : o.charsetSentinel,
comma: "boolean" == typeof t.comma ? t.comma : o.comma,
decodeDotInKeys: "boolean" == typeof t.decodeDotInKeys ? t.decodeDotInKeys : o.decodeDotInKeys,
decoder: "function" == typeof t.decoder ? t.decoder : o.decoder,
delimiter: "string" == typeof t.delimiter || e.isRegExp(t.delimiter) ? t.delimiter : o.delimiter,
depth: "number" == typeof t.depth || !1 === t.depth ? +t.depth : o.depth,
duplicates: n,
ignoreQueryPrefix: !0 === t.ignoreQueryPrefix,
interpretNumericEntities: "boolean" == typeof t.interpretNumericEntities ? t.interpretNumericEntities : o.interpretNumericEntities,
parameterLimit: "number" == typeof t.parameterLimit ? t.parameterLimit : o.parameterLimit,
parseArrays: !1 !== t.parseArrays,
plainObjects: "boolean" == typeof t.plainObjects ? t.plainObjects : o.plainObjects,
strictDepth: "boolean" == typeof t.strictDepth ? !!t.strictDepth : o.strictDepth,
strictNullHandling: "boolean" == typeof t.strictNullHandling ? t.strictNullHandling : o.strictNullHandling,
throwOnLimitExceeded: "boolean" == typeof t.throwOnLimitExceeded && t.throwOnLimitExceeded
};
}(c);
if ("" === s || null == s) return l.plainObjects ? {
__proto__: null
} : {};
for (var u = "string" == typeof s ? function(i, s) {
var c = {
__proto__: null
}, l = s.ignoreQueryPrefix ? i.replace(/^\?/, "") : i;
l = l.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
var u = s.parameterLimit === 1 / 0 ? void 0 : s.parameterLimit, f = l.split(s.delimiter, s.throwOnLimitExceeded ? u + 1 : u);
if (s.throwOnLimitExceeded && f.length > u) throw new RangeError("Parameter limit exceeded. Only " + u + " parameter" + (1 === u ? "" : "s") + " allowed.");
var m, p = -1, d = s.charset;
if (s.charsetSentinel) for (m = 0; m < f.length; ++m) 0 === f[m].indexOf("utf8=") && ("utf8=%E2%9C%93" === f[m] ? d = "utf-8" : "utf8=%26%2310003%3B" === f[m] && (d = "iso-8859-1"), 
p = m, m = f.length);
for (m = 0; m < f.length; ++m) if (m !== p) {
var y, g, h = f[m], v = h.indexOf("]="), R = -1 === v ? h.indexOf("=") : v + 1;
-1 === R ? (y = s.decoder(h, o.decoder, d, "key"), g = s.strictNullHandling ? null : "") : (y = s.decoder(h.slice(0, R), o.decoder, d, "key"), 
g = e.maybeMap(a(h.slice(R + 1), s, r(c[y]) ? c[y].length : 0), function(e) {
return s.decoder(e, o.decoder, d, "value");
})), g && s.interpretNumericEntities && "iso-8859-1" === d && (g = n(String(g))), 
h.indexOf("[]=") > -1 && (g = r(g) ? [ g ] : g);
var E = t.call(c, y);
E && "combine" === s.duplicates ? c[y] = e.combine(c[y], g) : E && "last" !== s.duplicates || (c[y] = g);
}
return c;
}(s, l) : s, f = l.plainObjects ? {
__proto__: null
} : {}, m = Object.keys(u), p = 0; p < m.length; ++p) {
var d = m[p], y = i(d, u[d], l, "string" == typeof s);
f = e.merge(f, y, l);
}
return !0 === l.allowSparse ? f : e.compact(f);
};
}

function Jt() {
if (lt) return ct;
lt = 1;
var e = Qt(), t = Zt();
return ct = {
formats: qt(),
parse: t,
stringify: e
};
}

function $t() {
return mt || (mt = 1, ft = "function" == typeof URL ? URL : function() {
if (ut) return _;
ut = 1;
var e = x();
function t() {
this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, 
this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, 
this.path = null, this.href = null;
}
var r = /^([a-z0-9.+-]+:)/i, o = /:[0-9]*$/, n = /^(\/\/?(?!\/)[^?\s]*)(\?[^\s]*)?$/, a = [ "{", "}", "|", "\\", "^", "`" ].concat([ "<", ">", '"', "`", " ", "\r", "\n", "\t" ]), i = [ "'" ].concat(a), s = [ "%", "/", "?", ";", "#" ].concat(i), c = [ "/", "?", "#" ], l = /^[+a-z0-9A-Z_-]{0,63}$/, u = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, f = {
javascript: !0,
"javascript:": !0
}, m = {
javascript: !0,
"javascript:": !0
}, p = {
http: !0,
https: !0,
ftp: !0,
gopher: !0,
file: !0,
"http:": !0,
"https:": !0,
"ftp:": !0,
"gopher:": !0,
"file:": !0
}, d = Jt();
function y(e, r, o) {
if (e && "object" == typeof e && e instanceof t) return e;
var n = new t;
return n.parse(e, r, o), n;
}
return t.prototype.parse = function(t, o, a) {
if ("string" != typeof t) throw new TypeError("Parameter 'url' must be a string, not " + typeof t);
var y = t.indexOf("?"), g = -1 !== y && y < t.indexOf("#") ? "?" : "#", h = t.split(g);
h[0] = h[0].replace(/\\/g, "/");
var v = t = h.join(g);
if (v = v.trim(), !a && 1 === t.split("#").length) {
var R = n.exec(v);
if (R) return this.path = v, this.href = v, this.pathname = R[1], R[2] ? (this.search = R[2], 
this.query = o ? d.parse(this.search.substr(1)) : this.search.substr(1)) : o && (this.search = "", 
this.query = {}), this;
}
var E = r.exec(v);
if (E) {
var T = (E = E[0]).toLowerCase();
this.protocol = T, v = v.substr(E.length);
}
if (a || E || v.match(/^\/\/[^@/]+@[^@/]+/)) {
var S = "//" === v.substr(0, 2);
!S || E && m[E] || (v = v.substr(2), this.slashes = !0);
}
if (!m[E] && (S || E && !p[E])) {
for (var C, b, _ = -1, O = 0; O < c.length; O++) -1 !== (w = v.indexOf(c[O])) && (-1 === _ || w < _) && (_ = w);
for (-1 !== (b = -1 === _ ? v.lastIndexOf("@") : v.lastIndexOf("@", _)) && (C = v.slice(0, b), 
v = v.slice(b + 1), this.auth = decodeURIComponent(C)), _ = -1, O = 0; O < s.length; O++) {
var w;
-1 !== (w = v.indexOf(s[O])) && (-1 === _ || w < _) && (_ = w);
}
-1 === _ && (_ = v.length), this.host = v.slice(0, _), v = v.slice(_), this.parseHost(), 
this.hostname = this.hostname || "";
var x = "[" === this.hostname[0] && "]" === this.hostname[this.hostname.length - 1];
if (!x) for (var U = this.hostname.split(/\./), M = (O = 0, U.length); O < M; O++) {
var A = U[O];
if (A && !A.match(l)) {
for (var k = "", N = 0, P = A.length; N < P; N++) A.charCodeAt(N) > 127 ? k += "x" : k += A[N];
if (!k.match(l)) {
var I = U.slice(0, O), G = U.slice(O + 1), L = A.match(u);
L && (I.push(L[1]), G.unshift(L[2])), G.length && (v = "/" + G.join(".") + v), this.hostname = I.join(".");
break;
}
}
}
this.hostname.length > 255 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), 
x || (this.hostname = e.toASCII(this.hostname));
var D = this.port ? ":" + this.port : "", F = this.hostname || "";
this.host = F + D, this.href += this.host, x && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), 
"/" !== v[0] && (v = "/" + v));
}
if (!f[T]) for (O = 0, M = i.length; O < M; O++) {
var B = i[O];
if (-1 !== v.indexOf(B)) {
var j = encodeURIComponent(B);
j === B && (j = escape(B)), v = v.split(B).join(j);
}
}
var H = v.indexOf("#");
-1 !== H && (this.hash = v.substr(H), v = v.slice(0, H));
var W = v.indexOf("?");
if (-1 !== W ? (this.search = v.substr(W), this.query = v.substr(W + 1), o && (this.query = d.parse(this.query)), 
v = v.slice(0, W)) : o && (this.search = "", this.query = {}), v && (this.pathname = v), 
p[T] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
D = this.pathname || "";
var Y = this.search || "";
this.path = D + Y;
}
return this.href = this.format(), this;
}, t.prototype.format = function() {
var e = this.auth || "";
e && (e = (e = encodeURIComponent(e)).replace(/%3A/i, ":"), e += "@");
var t = this.protocol || "", r = this.pathname || "", o = this.hash || "", n = !1, a = "";
this.host ? n = e + this.host : this.hostname && (n = e + (-1 === this.hostname.indexOf(":") ? this.hostname : "[" + this.hostname + "]"), 
this.port && (n += ":" + this.port)), this.query && "object" == typeof this.query && Object.keys(this.query).length && (a = d.stringify(this.query, {
arrayFormat: "repeat",
addQueryPrefix: !1
}));
var i = this.search || a && "?" + a || "";
return t && ":" !== t.substr(-1) && (t += ":"), this.slashes || (!t || p[t]) && !1 !== n ? (n = "//" + (n || ""), 
r && "/" !== r.charAt(0) && (r = "/" + r)) : n || (n = ""), o && "#" !== o.charAt(0) && (o = "#" + o), 
i && "?" !== i.charAt(0) && (i = "?" + i), t + n + (r = r.replace(/[?#]/g, function(e) {
return encodeURIComponent(e);
})) + (i = i.replace("#", "%23")) + o;
}, t.prototype.resolve = function(e) {
return this.resolveObject(y(e, !1, !0)).format();
}, t.prototype.resolveObject = function(e) {
if ("string" == typeof e) {
var r = new t;
r.parse(e, !1, !0), e = r;
}
for (var o = new t, n = Object.keys(this), a = 0; a < n.length; a++) {
var i = n[a];
o[i] = this[i];
}
if (o.hash = e.hash, "" === e.href) return o.href = o.format(), o;
if (e.slashes && !e.protocol) {
for (var s = Object.keys(e), c = 0; c < s.length; c++) {
var l = s[c];
"protocol" !== l && (o[l] = e[l]);
}
return p[o.protocol] && o.hostname && !o.pathname && (o.pathname = "/", o.path = o.pathname), 
o.href = o.format(), o;
}
if (e.protocol && e.protocol !== o.protocol) {
if (!p[e.protocol]) {
for (var u = Object.keys(e), f = 0; f < u.length; f++) {
var d = u[f];
o[d] = e[d];
}
return o.href = o.format(), o;
}
if (o.protocol = e.protocol, e.host || m[e.protocol]) o.pathname = e.pathname; else {
for (var y = (e.pathname || "").split("/"); y.length && !(e.host = y.shift()); ) ;
e.host || (e.host = ""), e.hostname || (e.hostname = ""), "" !== y[0] && y.unshift(""), 
y.length < 2 && y.unshift(""), o.pathname = y.join("/");
}
if (o.search = e.search, o.query = e.query, o.host = e.host || "", o.auth = e.auth, 
o.hostname = e.hostname || e.host, o.port = e.port, o.pathname || o.search) {
var g = o.pathname || "", h = o.search || "";
o.path = g + h;
}
return o.slashes = o.slashes || e.slashes, o.href = o.format(), o;
}
var v = o.pathname && "/" === o.pathname.charAt(0), R = e.host || e.pathname && "/" === e.pathname.charAt(0), E = R || v || o.host && e.pathname, T = E, S = o.pathname && o.pathname.split("/") || [], C = (y = e.pathname && e.pathname.split("/") || [], 
o.protocol && !p[o.protocol]);
if (C && (o.hostname = "", o.port = null, o.host && ("" === S[0] ? S[0] = o.host : S.unshift(o.host)), 
o.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && ("" === y[0] ? y[0] = e.host : y.unshift(e.host)), 
e.host = null), E = E && ("" === y[0] || "" === S[0])), R) o.host = e.host || "" === e.host ? e.host : o.host, 
o.hostname = e.hostname || "" === e.hostname ? e.hostname : o.hostname, o.search = e.search, 
o.query = e.query, S = y; else if (y.length) S || (S = []), S.pop(), S = S.concat(y), 
o.search = e.search, o.query = e.query; else if (null != e.search) return C && (o.host = S.shift(), 
o.hostname = o.host, (x = !!(o.host && o.host.indexOf("@") > 0) && o.host.split("@")) && (o.auth = x.shift(), 
o.hostname = x.shift(), o.host = o.hostname)), o.search = e.search, o.query = e.query, 
null === o.pathname && null === o.search || (o.path = (o.pathname ? o.pathname : "") + (o.search ? o.search : "")), 
o.href = o.format(), o;
if (!S.length) return o.pathname = null, o.search ? o.path = "/" + o.search : o.path = null, 
o.href = o.format(), o;
for (var b = S.slice(-1)[0], _ = (o.host || e.host || S.length > 1) && ("." === b || ".." === b) || "" === b, O = 0, w = S.length; w >= 0; w--) "." === (b = S[w]) ? S.splice(w, 1) : ".." === b ? (S.splice(w, 1), 
O++) : O && (S.splice(w, 1), O--);
if (!E && !T) for (;O--; O) S.unshift("..");
!E || "" === S[0] || S[0] && "/" === S[0].charAt(0) || S.unshift(""), _ && "/" !== S.join("/").substr(-1) && S.push("");
var x, U = "" === S[0] || S[0] && "/" === S[0].charAt(0);
return C && (o.hostname = U ? "" : S.length ? S.shift() : "", o.host = o.hostname, 
(x = !!(o.host && o.host.indexOf("@") > 0) && o.host.split("@")) && (o.auth = x.shift(), 
o.hostname = x.shift(), o.host = o.hostname)), (E = E || o.host && S.length) && !U && S.unshift(""), 
S.length > 0 ? o.pathname = S.join("/") : (o.pathname = null, o.path = null), null === o.pathname && null === o.search || (o.path = (o.pathname ? o.pathname : "") + (o.search ? o.search : "")), 
o.auth = e.auth || o.auth, o.slashes = o.slashes || e.slashes, o.href = o.format(), 
o;
}, t.prototype.parseHost = function() {
var e = this.host, t = o.exec(e);
t && (":" !== (t = t[0]) && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), 
e && (this.hostname = e);
}, _.parse = y, _.resolve = function(e, t) {
return y(e, !1, !0).resolve(t);
}, _.resolveObject = function(e, t) {
return e ? y(e, !1, !0).resolveObject(t) : t;
}, _.format = function(e) {
return "string" == typeof e && (e = y(e)), e instanceof t ? e.format() : t.prototype.format.call(e);
}, _.Url = t, _;
}().URL), ft;
}

function er() {
if (pt) return b;
pt = 1;
const e = $t();
b.getArg = function(e, t, r) {
if (t in e) return e[t];
if (3 === arguments.length) return r;
throw new Error('"' + t + '" is a required argument.');
};
const t = !("__proto__" in Object.create(null));
function r(e) {
return e;
}
function o(e) {
if (!e) return !1;
const t = e.length;
if (t < 9) return !1;
if (95 !== e.charCodeAt(t - 1) || 95 !== e.charCodeAt(t - 2) || 111 !== e.charCodeAt(t - 3) || 116 !== e.charCodeAt(t - 4) || 111 !== e.charCodeAt(t - 5) || 114 !== e.charCodeAt(t - 6) || 112 !== e.charCodeAt(t - 7) || 95 !== e.charCodeAt(t - 8) || 95 !== e.charCodeAt(t - 9)) return !1;
for (let r = t - 10; r >= 0; r--) if (36 !== e.charCodeAt(r)) return !1;
return !0;
}
function n(e, t) {
return e === t ? 0 : null === e ? 1 : null === t ? -1 : e > t ? 1 : -1;
}
b.toSetString = t ? r : function(e) {
return o(e) ? "$" + e : e;
}, b.fromSetString = t ? r : function(e) {
return o(e) ? e.slice(1) : e;
}, b.compareByGeneratedPositionsInflated = function(e, t) {
let r = e.generatedLine - t.generatedLine;
return 0 !== r ? r : (r = e.generatedColumn - t.generatedColumn, 0 !== r ? r : (r = n(e.source, t.source), 
0 !== r ? r : (r = e.originalLine - t.originalLine, 0 !== r ? r : (r = e.originalColumn - t.originalColumn, 
0 !== r ? r : n(e.name, t.name)))));
}, b.parseSourceMapInput = function(e) {
return JSON.parse(e.replace(/^\)]}'[^\n]*\n/, ""));
};
const a = "http://host";
function i(t) {
return r => {
const o = u(r), n = c(r), a = new e(r, n);
t(a);
const i = a.toString();
return "absolute" === o ? i : "scheme-relative" === o ? i.slice(5) : "path-absolute" === o ? i.slice(11) : f(n, i);
};
}
function s(t, r) {
return new e(t, r).toString();
}
function c(e) {
const t = e.split("..").length - 1, r = function(e, t) {
let r = 0;
for (;;) {
const e = "p" + r++;
if (-1 === t.indexOf(e)) return e;
}
}(0, e);
let o = `${a}/`;
for (let e = 0; e < t; e++) o += `${r}/`;
return o;
}
const l = /^[A-Za-z0-9\+\-\.]+:/;
function u(e) {
return "/" === e[0] ? "/" === e[1] ? "scheme-relative" : "path-absolute" : l.test(e) ? "absolute" : "path-relative";
}
function f(t, r) {
"string" == typeof t && (t = new e(t)), "string" == typeof r && (r = new e(r));
const o = r.pathname.split("/"), n = t.pathname.split("/");
for (n.length > 0 && !n[n.length - 1] && n.pop(); o.length > 0 && n.length > 0 && o[0] === n[0]; ) o.shift(), 
n.shift();
return n.map(() => "..").concat(o).join("/") + r.search + r.hash;
}
const m = i(e => {
e.pathname = e.pathname.replace(/\/?$/, "/");
}), p = i(t => {
t.href = new e(".", t.toString()).toString();
}), d = i(e => {});
function y(e, t) {
const r = u(t), o = u(e);
if (e = m(e), "absolute" === r) return s(t, void 0);
if ("absolute" === o) return s(t, e);
if ("scheme-relative" === r) return d(t);
if ("scheme-relative" === o) return s(t, s(e, a)).slice(5);
if ("path-absolute" === r) return d(t);
if ("path-absolute" === o) return s(t, s(e, a)).slice(11);
const n = c(t + e);
return f(n, s(t, s(e, n)));
}
return b.normalize = d, b.join = y, b.relative = function(t, r) {
const o = function(t, r) {
if (u(t) !== u(r)) return null;
const o = c(t + r), n = new e(t, o), a = new e(r, o);
try {
new e("", a.toString());
} catch (e) {
return null;
}
return a.protocol !== n.protocol || a.user !== n.user || a.password !== n.password || a.hostname !== n.hostname || a.port !== n.port ? null : f(n, a);
}(t, r);
return "string" == typeof o ? o : d(r);
}, b.computeSourceURL = function(e, t, r) {
e && "path-absolute" === u(t) && (t = t.replace(/^\//, ""));
let o = d(t || "");
return e && (o = y(e, o)), r && (o = y(p(r), o)), o;
}, b;
}

var tr, rr = {};

function or() {
if (tr) return rr;
tr = 1;
class e {
constructor() {
this._array = [], this._set = new Map;
}
static fromArray(t, r) {
const o = new e;
for (let e = 0, n = t.length; e < n; e++) o.add(t[e], r);
return o;
}
size() {
return this._set.size;
}
add(e, t) {
const r = this.has(e), o = this._array.length;
r && !t || this._array.push(e), r || this._set.set(e, o);
}
has(e) {
return this._set.has(e);
}
indexOf(e) {
const t = this._set.get(e);
if (t >= 0) return t;
throw new Error('"' + e + '" is not in the set.');
}
at(e) {
if (e >= 0 && e < this._array.length) return this._array[e];
throw new Error("No element indexed by " + e);
}
toArray() {
return this._array.slice();
}
}
return rr.ArraySet = e, rr;
}

var nr, ar, ir = {};

function sr() {
if (ar) return g;
ar = 1;
const e = E(), t = er(), r = or().ArraySet, o = function() {
if (nr) return ir;
nr = 1;
const e = er();
return ir.MappingList = class {
constructor() {
this._array = [], this._sorted = !0, this._last = {
generatedLine: -1,
generatedColumn: 0
};
}
unsortedForEach(e, t) {
this._array.forEach(e, t);
}
add(t) {
!function(t, r) {
const o = t.generatedLine, n = r.generatedLine, a = t.generatedColumn, i = r.generatedColumn;
return n > o || n == o && i >= a || e.compareByGeneratedPositionsInflated(t, r) <= 0;
}(this._last, t) ? (this._sorted = !1, this._array.push(t)) : (this._last = t, this._array.push(t));
}
toArray() {
return this._sorted || (this._array.sort(e.compareByGeneratedPositionsInflated), 
this._sorted = !0), this._array;
}
}, ir;
}().MappingList;
class n {
constructor(e) {
e || (e = {}), this._file = t.getArg(e, "file", null), this._sourceRoot = t.getArg(e, "sourceRoot", null), 
this._skipValidation = t.getArg(e, "skipValidation", !1), this._sources = new r, 
this._names = new r, this._mappings = new o, this._sourcesContents = null;
}
static fromSourceMap(e) {
const r = e.sourceRoot, o = new n({
file: e.file,
sourceRoot: r
});
return e.eachMapping(function(e) {
const n = {
generated: {
line: e.generatedLine,
column: e.generatedColumn
}
};
null != e.source && (n.source = e.source, null != r && (n.source = t.relative(r, n.source)), 
n.original = {
line: e.originalLine,
column: e.originalColumn
}, null != e.name && (n.name = e.name)), o.addMapping(n);
}), e.sources.forEach(function(n) {
let a = n;
null != r && (a = t.relative(r, n)), o._sources.has(a) || o._sources.add(a);
const i = e.sourceContentFor(n);
null != i && o.setSourceContent(n, i);
}), o;
}
addMapping(e) {
const r = t.getArg(e, "generated"), o = t.getArg(e, "original", null);
let n = t.getArg(e, "source", null), a = t.getArg(e, "name", null);
this._skipValidation || this._validateMapping(r, o, n, a), null != n && (n = String(n), 
this._sources.has(n) || this._sources.add(n)), null != a && (a = String(a), this._names.has(a) || this._names.add(a)), 
this._mappings.add({
generatedLine: r.line,
generatedColumn: r.column,
originalLine: o && o.line,
originalColumn: o && o.column,
source: n,
name: a
});
}
setSourceContent(e, r) {
let o = e;
null != this._sourceRoot && (o = t.relative(this._sourceRoot, o)), null != r ? (this._sourcesContents || (this._sourcesContents = Object.create(null)), 
this._sourcesContents[t.toSetString(o)] = r) : this._sourcesContents && (delete this._sourcesContents[t.toSetString(o)], 
0 === Object.keys(this._sourcesContents).length && (this._sourcesContents = null));
}
applySourceMap(e, o, n) {
let a = o;
if (null == o) {
if (null == e.file) throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map\'s "file" property. Both were omitted.');
a = e.file;
}
const i = this._sourceRoot;
null != i && (a = t.relative(i, a));
const s = this._mappings.toArray().length > 0 ? new r : this._sources, c = new r;
this._mappings.unsortedForEach(function(r) {
if (r.source === a && null != r.originalLine) {
const o = e.originalPositionFor({
line: r.originalLine,
column: r.originalColumn
});
null != o.source && (r.source = o.source, null != n && (r.source = t.join(n, r.source)), 
null != i && (r.source = t.relative(i, r.source)), r.originalLine = o.line, r.originalColumn = o.column, 
null != o.name && (r.name = o.name));
}
const o = r.source;
null == o || s.has(o) || s.add(o);
const l = r.name;
null == l || c.has(l) || c.add(l);
}, this), this._sources = s, this._names = c, e.sources.forEach(function(r) {
const o = e.sourceContentFor(r);
null != o && (null != n && (r = t.join(n, r)), null != i && (r = t.relative(i, r)), 
this.setSourceContent(r, o));
}, this);
}
_validateMapping(e, t, r, o) {
if (t && "number" != typeof t.line && "number" != typeof t.column) throw new Error("original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.");
if (e && "line" in e && "column" in e && e.line > 0 && e.column >= 0 && !t && !r && !o) ; else if (!(e && "line" in e && "column" in e && t && "line" in t && "column" in t && e.line > 0 && e.column >= 0 && t.line > 0 && t.column >= 0 && r)) throw new Error("Invalid mapping: " + JSON.stringify({
generated: e,
source: r,
original: t,
name: o
}));
}
_serializeMappings() {
let r, o, n, a, i = 0, s = 1, c = 0, l = 0, u = 0, f = 0, m = "";
const p = this._mappings.toArray();
for (let d = 0, y = p.length; d < y; d++) {
if (o = p[d], r = "", o.generatedLine !== s) for (i = 0; o.generatedLine !== s; ) r += ";", 
s++; else if (d > 0) {
if (!t.compareByGeneratedPositionsInflated(o, p[d - 1])) continue;
r += ",";
}
r += e.encode(o.generatedColumn - i), i = o.generatedColumn, null != o.source && (a = this._sources.indexOf(o.source), 
r += e.encode(a - f), f = a, r += e.encode(o.originalLine - 1 - l), l = o.originalLine - 1, 
r += e.encode(o.originalColumn - c), c = o.originalColumn, null != o.name && (n = this._names.indexOf(o.name), 
r += e.encode(n - u), u = n)), m += r;
}
return m;
}
_generateSourcesContent(e, r) {
return e.map(function(e) {
if (!this._sourcesContents) return null;
null != r && (e = t.relative(r, e));
const o = t.toSetString(e);
return Object.prototype.hasOwnProperty.call(this._sourcesContents, o) ? this._sourcesContents[o] : null;
}, this);
}
toJSON() {
const e = {
version: this._version,
sources: this._sources.toArray(),
names: this._names.toArray(),
mappings: this._serializeMappings()
};
return null != this._file && (e.file = this._file), null != this._sourceRoot && (e.sourceRoot = this._sourceRoot), 
this._sourcesContents && (e.sourcesContent = this._generateSourcesContent(e.sources, e.sourceRoot)), 
e;
}
toString() {
return JSON.stringify(this.toJSON());
}
}
return n.prototype._version = 3, g.SourceMapGenerator = n, g;
}

var cr, lr = {}, ur = {};

function fr() {
return cr || (cr = 1, function(e) {
function t(r, o, n, a, i, s) {
const c = Math.floor((o - r) / 2) + r, l = i(n, a[c], !0);
return 0 === l ? c : l > 0 ? o - c > 1 ? t(c, o, n, a, i, s) : s === e.LEAST_UPPER_BOUND ? o < a.length ? o : -1 : c : c - r > 1 ? t(r, c, n, a, i, s) : s == e.LEAST_UPPER_BOUND ? c : r < 0 ? -1 : r;
}
e.GREATEST_LOWER_BOUND = 1, e.LEAST_UPPER_BOUND = 2, e.search = function(r, o, n, a) {
if (0 === o.length) return -1;
let i = t(-1, o.length, r, o, n, a || e.GREATEST_LOWER_BOUND);
if (i < 0) return -1;
for (;i - 1 >= 0 && 0 === n(o[i], o[i - 1], !0); ) --i;
return i;
};
}(ur)), ur;
}

var mr, pr, dr, yr, gr = {
exports: {}
};

function hr() {
if (mr) return gr.exports;
mr = 1;
let e = null;
return gr.exports = function() {
if ("string" == typeof e) return fetch(e).then(e => e.arrayBuffer());
if (e instanceof ArrayBuffer) return Promise.resolve(e);
throw new Error("You must provide the string URL or ArrayBuffer contents of lib/mappings.wasm by calling SourceMapConsumer.initialize({ 'lib/mappings.wasm': ... }) before using SourceMapConsumer");
}, gr.exports.initialize = t => {
e = t;
}, gr.exports;
}

function vr() {
if (dr) return pr;
dr = 1;
const e = hr();
function t() {
this.generatedLine = 0, this.generatedColumn = 0, this.lastGeneratedColumn = null, 
this.source = null, this.originalLine = null, this.originalColumn = null, this.name = null;
}
let r = null;
return pr = function() {
if (r) return r;
const o = [];
return r = e().then(e => WebAssembly.instantiate(e, {
env: {
mapping_callback(e, r, n, a, i, s, c, l, u, f) {
const m = new t;
m.generatedLine = e + 1, m.generatedColumn = r, n && (m.lastGeneratedColumn = a - 1), 
i && (m.source = s, m.originalLine = c + 1, m.originalColumn = l, u && (m.name = f)), 
o[o.length - 1](m);
},
start_all_generated_locations_for() {
console.time("all_generated_locations_for");
},
end_all_generated_locations_for() {
console.timeEnd("all_generated_locations_for");
},
start_compute_column_spans() {
console.time("compute_column_spans");
},
end_compute_column_spans() {
console.timeEnd("compute_column_spans");
},
start_generated_location_for() {
console.time("generated_location_for");
},
end_generated_location_for() {
console.timeEnd("generated_location_for");
},
start_original_location_for() {
console.time("original_location_for");
},
end_original_location_for() {
console.timeEnd("original_location_for");
},
start_parse_mappings() {
console.time("parse_mappings");
},
end_parse_mappings() {
console.timeEnd("parse_mappings");
},
start_sort_by_generated_location() {
console.time("sort_by_generated_location");
},
end_sort_by_generated_location() {
console.timeEnd("sort_by_generated_location");
},
start_sort_by_original_location() {
console.time("sort_by_original_location");
},
end_sort_by_original_location() {
console.timeEnd("sort_by_original_location");
}
}
})).then(e => ({
exports: e.instance.exports,
withMappingCallback: (e, t) => {
o.push(e);
try {
t();
} finally {
o.pop();
}
}
})).then(null, e => {
throw r = null, e;
}), r;
};
}

var Rr, Er, Tr = {};

function Sr() {
return Er || (Er = 1, y.SourceMapGenerator = sr().SourceMapGenerator, y.SourceMapConsumer = function() {
if (yr) return lr;
yr = 1;
const e = er(), t = fr(), r = or().ArraySet;
E();
const o = hr(), n = vr(), a = Symbol("smcInternal");
class i {
constructor(t, r) {
return t == a ? Promise.resolve(this) : function(t, r) {
let o = t;
"string" == typeof t && (o = e.parseSourceMapInput(t));
const n = null != o.sections ? new c(o, r) : new s(o, r);
return Promise.resolve(n);
}(t, r);
}
static initialize(e) {
o.initialize(e["lib/mappings.wasm"]);
}
static fromSourceMap(e, t) {
return function(e, t) {
return s.fromSourceMap(e, t);
}(e, t);
}
static async with(e, t, r) {
const o = await new i(e, t);
try {
return await r(o);
} finally {
o.destroy();
}
}
eachMapping(e, t, r) {
throw new Error("Subclasses must implement eachMapping");
}
allGeneratedPositionsFor(e) {
throw new Error("Subclasses must implement allGeneratedPositionsFor");
}
destroy() {
throw new Error("Subclasses must implement destroy");
}
}
i.prototype._version = 3, i.GENERATED_ORDER = 1, i.ORIGINAL_ORDER = 2, i.GREATEST_LOWER_BOUND = 1, 
i.LEAST_UPPER_BOUND = 2, lr.SourceMapConsumer = i;
class s extends i {
constructor(t, o) {
return super(a).then(a => {
let i = t;
"string" == typeof t && (i = e.parseSourceMapInput(t));
const s = e.getArg(i, "version"), c = e.getArg(i, "sources").map(String), l = e.getArg(i, "names", []), u = e.getArg(i, "sourceRoot", null), f = e.getArg(i, "sourcesContent", null), m = e.getArg(i, "mappings"), p = e.getArg(i, "file", null), d = e.getArg(i, "x_google_ignoreList", null);
if (s != a._version) throw new Error("Unsupported version: " + s);
return a._sourceLookupCache = new Map, a._names = r.fromArray(l.map(String), !0), 
a._sources = r.fromArray(c, !0), a._absoluteSources = r.fromArray(a._sources.toArray().map(function(t) {
return e.computeSourceURL(u, t, o);
}), !0), a.sourceRoot = u, a.sourcesContent = f, a._mappings = m, a._sourceMapURL = o, 
a.file = p, a.x_google_ignoreList = d, a._computedColumnSpans = !1, a._mappingsPtr = 0, 
a._wasm = null, n().then(e => (a._wasm = e, a));
});
}
_findSourceIndex(t) {
const r = this._sourceLookupCache.get(t);
if ("number" == typeof r) return r;
const o = e.computeSourceURL(null, t, this._sourceMapURL);
if (this._absoluteSources.has(o)) {
const e = this._absoluteSources.indexOf(o);
return this._sourceLookupCache.set(t, e), e;
}
const n = e.computeSourceURL(this.sourceRoot, t, this._sourceMapURL);
if (this._absoluteSources.has(n)) {
const e = this._absoluteSources.indexOf(n);
return this._sourceLookupCache.set(t, e), e;
}
return -1;
}
static fromSourceMap(e, t) {
return new s(e.toString());
}
get sources() {
return this._absoluteSources.toArray();
}
_getMappingsPtr() {
return 0 === this._mappingsPtr && this._parseMappings(), this._mappingsPtr;
}
_parseMappings() {
const e = this._mappings, t = e.length, r = this._wasm.exports.allocate_mappings(t) >>> 0, o = new Uint8Array(this._wasm.exports.memory.buffer, r, t);
for (let r = 0; r < t; r++) o[r] = e.charCodeAt(r);
const n = this._wasm.exports.parse_mappings(r);
if (!n) {
const e = this._wasm.exports.get_last_error();
let t = `Error parsing mappings (code ${e}): `;
switch (e) {
case 1:
t += "the mappings contained a negative line, column, source index, or name index";
break;

case 2:
t += "the mappings contained a number larger than 2**32";
break;

case 3:
t += "reached EOF while in the middle of parsing a VLQ";
break;

case 4:
t += "invalid base 64 character while parsing a VLQ";
break;

default:
t += "unknown error code";
}
throw new Error(t);
}
this._mappingsPtr = n;
}
eachMapping(e, t, r) {
const o = t || null, n = r || i.GENERATED_ORDER;
this._wasm.withMappingCallback(t => {
null !== t.source && (t.source = this._absoluteSources.at(t.source), null !== t.name && (t.name = this._names.at(t.name))), 
this._computedColumnSpans && null === t.lastGeneratedColumn && (t.lastGeneratedColumn = 1 / 0), 
e.call(o, t);
}, () => {
switch (n) {
case i.GENERATED_ORDER:
this._wasm.exports.by_generated_location(this._getMappingsPtr());
break;

case i.ORIGINAL_ORDER:
this._wasm.exports.by_original_location(this._getMappingsPtr());
break;

default:
throw new Error("Unknown order of iteration.");
}
});
}
allGeneratedPositionsFor(t) {
let r = e.getArg(t, "source");
const o = e.getArg(t, "line"), n = t.column || 0;
if (r = this._findSourceIndex(r), r < 0) return [];
if (o < 1) throw new Error("Line numbers must be >= 1");
if (n < 0) throw new Error("Column numbers must be >= 0");
const a = [];
return this._wasm.withMappingCallback(e => {
let t = e.lastGeneratedColumn;
this._computedColumnSpans && null === t && (t = 1 / 0), a.push({
line: e.generatedLine,
column: e.generatedColumn,
lastColumn: t
});
}, () => {
this._wasm.exports.all_generated_locations_for(this._getMappingsPtr(), r, o - 1, "column" in t, n);
}), a;
}
destroy() {
0 !== this._mappingsPtr && (this._wasm.exports.free_mappings(this._mappingsPtr), 
this._mappingsPtr = 0);
}
computeColumnSpans() {
this._computedColumnSpans || (this._wasm.exports.compute_column_spans(this._getMappingsPtr()), 
this._computedColumnSpans = !0);
}
originalPositionFor(t) {
const r = {
generatedLine: e.getArg(t, "line"),
generatedColumn: e.getArg(t, "column")
};
if (r.generatedLine < 1) throw new Error("Line numbers must be >= 1");
if (r.generatedColumn < 0) throw new Error("Column numbers must be >= 0");
let o, n = e.getArg(t, "bias", i.GREATEST_LOWER_BOUND);
if (null == n && (n = i.GREATEST_LOWER_BOUND), this._wasm.withMappingCallback(e => o = e, () => {
this._wasm.exports.original_location_for(this._getMappingsPtr(), r.generatedLine - 1, r.generatedColumn, n);
}), o && o.generatedLine === r.generatedLine) {
let t = e.getArg(o, "source", null);
null !== t && (t = this._absoluteSources.at(t));
let r = e.getArg(o, "name", null);
return null !== r && (r = this._names.at(r)), {
source: t,
line: e.getArg(o, "originalLine", null),
column: e.getArg(o, "originalColumn", null),
name: r
};
}
return {
source: null,
line: null,
column: null,
name: null
};
}
hasContentsOfAllSources() {
return !!this.sourcesContent && this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(e) {
return null == e;
});
}
sourceContentFor(e, t) {
if (!this.sourcesContent) return null;
const r = this._findSourceIndex(e);
if (r >= 0) return this.sourcesContent[r];
if (t) return null;
throw new Error('"' + e + '" is not in the SourceMap.');
}
generatedPositionFor(t) {
let r = e.getArg(t, "source");
if (r = this._findSourceIndex(r), r < 0) return {
line: null,
column: null,
lastColumn: null
};
const o = {
source: r,
originalLine: e.getArg(t, "line"),
originalColumn: e.getArg(t, "column")
};
if (o.originalLine < 1) throw new Error("Line numbers must be >= 1");
if (o.originalColumn < 0) throw new Error("Column numbers must be >= 0");
let n, a = e.getArg(t, "bias", i.GREATEST_LOWER_BOUND);
if (null == a && (a = i.GREATEST_LOWER_BOUND), this._wasm.withMappingCallback(e => n = e, () => {
this._wasm.exports.generated_location_for(this._getMappingsPtr(), o.source, o.originalLine - 1, o.originalColumn, a);
}), n && n.source === o.source) {
let t = n.lastGeneratedColumn;
return this._computedColumnSpans && null === t && (t = 1 / 0), {
line: e.getArg(n, "generatedLine", null),
column: e.getArg(n, "generatedColumn", null),
lastColumn: t
};
}
return {
line: null,
column: null,
lastColumn: null
};
}
}
s.prototype.consumer = i, lr.BasicSourceMapConsumer = s;
class c extends i {
constructor(t, r) {
return super(a).then(o => {
let n = t;
"string" == typeof t && (n = e.parseSourceMapInput(t));
const a = e.getArg(n, "version"), s = e.getArg(n, "sections");
if (a != o._version) throw new Error("Unsupported version: " + a);
let c = {
line: -1,
column: 0
};
return Promise.all(s.map(t => {
if (t.url) throw new Error("Support for url field in sections not implemented.");
const o = e.getArg(t, "offset"), n = e.getArg(o, "line"), a = e.getArg(o, "column");
if (n < c.line || n === c.line && a < c.column) throw new Error("Section offsets must be ordered and non-overlapping.");
return c = o, new i(e.getArg(t, "map"), r).then(e => ({
generatedOffset: {
generatedLine: n + 1,
generatedColumn: a + 1
},
consumer: e
}));
})).then(e => (o._sections = e, o));
});
}
get sources() {
const e = [];
for (let t = 0; t < this._sections.length; t++) for (let r = 0; r < this._sections[t].consumer.sources.length; r++) e.push(this._sections[t].consumer.sources[r]);
return e;
}
originalPositionFor(r) {
const o = {
generatedLine: e.getArg(r, "line"),
generatedColumn: e.getArg(r, "column")
}, n = t.search(o, this._sections, function(e, t) {
return e.generatedLine - t.generatedOffset.generatedLine || e.generatedColumn - (t.generatedOffset.generatedColumn - 1);
}), a = this._sections[n];
return a ? a.consumer.originalPositionFor({
line: o.generatedLine - (a.generatedOffset.generatedLine - 1),
column: o.generatedColumn - (a.generatedOffset.generatedLine === o.generatedLine ? a.generatedOffset.generatedColumn - 1 : 0),
bias: r.bias
}) : {
source: null,
line: null,
column: null,
name: null
};
}
hasContentsOfAllSources() {
return this._sections.every(function(e) {
return e.consumer.hasContentsOfAllSources();
});
}
sourceContentFor(e, t) {
for (let t = 0; t < this._sections.length; t++) {
const r = this._sections[t].consumer.sourceContentFor(e, !0);
if (r) return r;
}
if (t) return null;
throw new Error('"' + e + '" is not in the SourceMap.');
}
_findSectionIndex(e) {
for (let t = 0; t < this._sections.length; t++) {
const {consumer: r} = this._sections[t];
if (-1 !== r._findSourceIndex(e)) return t;
}
return -1;
}
generatedPositionFor(t) {
const r = this._findSectionIndex(e.getArg(t, "source")), o = r >= 0 ? this._sections[r] : null, n = r >= 0 && r + 1 < this._sections.length ? this._sections[r + 1] : null, a = o && o.consumer.generatedPositionFor(t);
if (a && null !== a.line) {
const e = o.generatedOffset.generatedLine - 1, t = o.generatedOffset.generatedColumn - 1;
return 1 === a.line && (a.column += t, "number" == typeof a.lastColumn && (a.lastColumn += t)), 
a.lastColumn === 1 / 0 && n && a.line === n.generatedOffset.generatedLine && (a.lastColumn = n.generatedOffset.generatedColumn - 2), 
a.line += e, a;
}
return {
line: null,
column: null,
lastColumn: null
};
}
allGeneratedPositionsFor(t) {
const r = this._findSectionIndex(e.getArg(t, "source")), o = r >= 0 ? this._sections[r] : null, n = r >= 0 && r + 1 < this._sections.length ? this._sections[r + 1] : null;
return o ? o.consumer.allGeneratedPositionsFor(t).map(e => {
const t = o.generatedOffset.generatedLine - 1, r = o.generatedOffset.generatedColumn - 1;
return 1 === e.line && (e.column += r, "number" == typeof e.lastColumn && (e.lastColumn += r)), 
e.lastColumn === 1 / 0 && n && e.line === n.generatedOffset.generatedLine && (e.lastColumn = n.generatedOffset.generatedColumn - 2), 
e.line += t, e;
}) : [];
}
eachMapping(e, t, r) {
this._sections.forEach((o, n) => {
const a = n + 1 < this._sections.length ? this._sections[n + 1] : null, {generatedOffset: i} = o, s = i.generatedLine - 1, c = i.generatedColumn - 1;
o.consumer.eachMapping(function(t) {
1 === t.generatedLine && (t.generatedColumn += c, "number" == typeof t.lastGeneratedColumn && (t.lastGeneratedColumn += c)), 
t.lastGeneratedColumn === 1 / 0 && a && t.generatedLine === a.generatedOffset.generatedLine && (t.lastGeneratedColumn = a.generatedOffset.generatedColumn - 2), 
t.generatedLine += s, e.call(this, t);
}, t, r);
});
}
computeColumnSpans() {
for (let e = 0; e < this._sections.length; e++) this._sections[e].consumer.computeColumnSpans();
}
destroy() {
for (let e = 0; e < this._sections.length; e++) this._sections[e].consumer.destroy();
}
}
return lr.IndexedSourceMapConsumer = c, lr;
}().SourceMapConsumer, y.SourceNode = function() {
if (Rr) return Tr;
Rr = 1;
const e = sr().SourceMapGenerator, t = er(), r = /(\r?\n)/, o = "$$$isSourceNode$$$";
class n {
constructor(e, t, r, n, a) {
this.children = [], this.sourceContents = {}, this.line = null == e ? null : e, 
this.column = null == t ? null : t, this.source = null == r ? null : r, this.name = null == a ? null : a, 
this[o] = !0, null != n && this.add(n);
}
static fromStringWithSourceMap(e, o, a) {
const i = new n, s = e.split(r);
let c = 0;
const l = function() {
return e() + (e() || "");
function e() {
return c < s.length ? s[c++] : void 0;
}
};
let u, f = 1, m = 0, p = null;
return o.eachMapping(function(e) {
if (null !== p) {
if (!(f < e.generatedLine)) {
u = s[c] || "";
const t = u.substr(0, e.generatedColumn - m);
return s[c] = u.substr(e.generatedColumn - m), m = e.generatedColumn, d(p, t), void (p = e);
}
d(p, l()), f++, m = 0;
}
for (;f < e.generatedLine; ) i.add(l()), f++;
m < e.generatedColumn && (u = s[c] || "", i.add(u.substr(0, e.generatedColumn)), 
s[c] = u.substr(e.generatedColumn), m = e.generatedColumn), p = e;
}, this), c < s.length && (p && d(p, l()), i.add(s.splice(c).join(""))), o.sources.forEach(function(e) {
const r = o.sourceContentFor(e);
null != r && (null != a && (e = t.join(a, e)), i.setSourceContent(e, r));
}), i;
function d(e, r) {
if (null === e || void 0 === e.source) i.add(r); else {
const o = a ? t.join(a, e.source) : e.source;
i.add(new n(e.originalLine, e.originalColumn, o, r, e.name));
}
}
}
add(e) {
if (Array.isArray(e)) e.forEach(function(e) {
this.add(e);
}, this); else {
if (!e[o] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
e && this.children.push(e);
}
return this;
}
prepend(e) {
if (Array.isArray(e)) for (let t = e.length - 1; t >= 0; t--) this.prepend(e[t]); else {
if (!e[o] && "string" != typeof e) throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + e);
this.children.unshift(e);
}
return this;
}
walk(e) {
let t;
for (let r = 0, n = this.children.length; r < n; r++) t = this.children[r], t[o] ? t.walk(e) : "" !== t && e(t, {
source: this.source,
line: this.line,
column: this.column,
name: this.name
});
}
join(e) {
let t, r;
const o = this.children.length;
if (o > 0) {
for (t = [], r = 0; r < o - 1; r++) t.push(this.children[r]), t.push(e);
t.push(this.children[r]), this.children = t;
}
return this;
}
replaceRight(e, t) {
const r = this.children[this.children.length - 1];
return r[o] ? r.replaceRight(e, t) : "string" == typeof r ? this.children[this.children.length - 1] = r.replace(e, t) : this.children.push("".replace(e, t)), 
this;
}
setSourceContent(e, r) {
this.sourceContents[t.toSetString(e)] = r;
}
walkSourceContents(e) {
for (let t = 0, r = this.children.length; t < r; t++) this.children[t][o] && this.children[t].walkSourceContents(e);
const r = Object.keys(this.sourceContents);
for (let o = 0, n = r.length; o < n; o++) e(t.fromSetString(r[o]), this.sourceContents[r[o]]);
}
toString() {
let e = "";
return this.walk(function(t) {
e += t;
}), e;
}
toStringWithSourceMap(t) {
const r = {
code: "",
line: 1,
column: 0
}, o = new e(t);
let n = !1, a = null, i = null, s = null, c = null;
return this.walk(function(e, t) {
r.code += e, null !== t.source && null !== t.line && null !== t.column ? (a === t.source && i === t.line && s === t.column && c === t.name || o.addMapping({
source: t.source,
original: {
line: t.line,
column: t.column
},
generated: {
line: r.line,
column: r.column
},
name: t.name
}), a = t.source, i = t.line, s = t.column, c = t.name, n = !0) : n && (o.addMapping({
generated: {
line: r.line,
column: r.column
}
}), a = null, n = !1);
for (let i = 0, s = e.length; i < s; i++) 10 === e.charCodeAt(i) ? (r.line++, r.column = 0, 
i + 1 === s ? (a = null, n = !1) : n && o.addMapping({
source: t.source,
original: {
line: t.line,
column: t.column
},
generated: {
line: r.line,
column: r.column
},
name: t.name
})) : r.column++;
}), this.walkSourceContents(function(e, t) {
o.setSourceContent(e, t);
}), {
code: r.code,
map: o
};
}
}
return Tr.SourceNode = n, Tr;
}().SourceNode), y;
}

var Cr, br = Sr();

!function(e) {
e[e.DEBUG = 0] = "DEBUG", e[e.INFO = 1] = "INFO", e[e.WARN = 2] = "WARN", e[e.ERROR = 3] = "ERROR", 
e[e.NONE = 4] = "NONE";
}(Cr || (Cr = {}));

var _r = {
level: Cr.INFO,
cpuLogging: !1,
enableBatching: !0,
maxBatchSize: 50
}, Or = e({}, _r), wr = [];

function xr(t) {
Or = e(e({}, Or), t);
}

function Ur() {
return e({}, Or);
}

function Mr(e) {
Or.enableBatching ? (wr.push(e), wr.length >= Or.maxBatchSize && Ar()) : console.log(e);
}

function Ar() {
0 !== wr.length && (console.log(wr.join("\n")), wr = []);
}

var kr = new Set([ "type", "level", "message", "tick", "subsystem", "room", "creep", "processId", "shard" ]);

function Nr(e, t, r, o) {
void 0 === o && (o = "log");
var n = {
type: o,
level: e,
message: t,
tick: "undefined" != typeof Game ? Game.time : 0,
shard: "undefined" != typeof Game && Game.shard ? Game.shard.name : "shard0"
};
if (r && (r.shard && (n.shard = r.shard), r.subsystem && (n.subsystem = r.subsystem), 
r.room && (n.room = r.room), r.creep && (n.creep = r.creep), r.processId && (n.processId = r.processId), 
r.meta)) for (var a in r.meta) kr.has(a) || (n[a] = r.meta[a]);
return JSON.stringify(n);
}

function Pr(e, t) {
Or.level <= Cr.DEBUG && Mr(Nr("DEBUG", e, t));
}

function Ir(e, t) {
Or.level <= Cr.INFO && Mr(Nr("INFO", e, t));
}

function Gr(e, t) {
Or.level <= Cr.WARN && Mr(Nr("WARN", e, t));
}

function Lr(e, t) {
Or.level <= Cr.ERROR && Mr(Nr("ERROR", e, t));
}

function Dr(e, t, r) {
if (!Or.cpuLogging) return t();
var o = Game.cpu.getUsed(), n = t(), a = Game.cpu.getUsed() - o;
return Pr("".concat(e, ": ").concat(a.toFixed(3), " CPU"), r), n;
}

var Fr = new Set([ "type", "key", "value", "tick", "unit", "subsystem", "room", "shard" ]);

function Br(e, t, r, o) {
var n = {
type: "stat",
key: e,
value: t,
tick: "undefined" != typeof Game ? Game.time : 0,
shard: "undefined" != typeof Game && Game.shard ? Game.shard.name : "shard0"
};
if (r && (n.unit = r), o && (o.shard && (n.shard = o.shard), o.subsystem && (n.subsystem = o.subsystem), 
o.room && (n.room = o.room), o.meta)) for (var a in o.meta) Fr.has(a) || (n[a] = o.meta[a]);
Mr(JSON.stringify(n));
}

function jr(t) {
return {
debug: function(r, o) {
Pr(r, "string" == typeof o ? {
subsystem: t,
room: o
} : e({
subsystem: t
}, o));
},
info: function(r, o) {
Ir(r, "string" == typeof o ? {
subsystem: t,
room: o
} : e({
subsystem: t
}, o));
},
warn: function(r, o) {
Gr(r, "string" == typeof o ? {
subsystem: t,
room: o
} : e({
subsystem: t
}, o));
},
error: function(r, o) {
Lr(r, "string" == typeof o ? {
subsystem: t,
room: o
} : e({
subsystem: t
}, o));
},
stat: function(r, o, n, a) {
Br(r, o, n, "string" == typeof a ? {
subsystem: t,
room: a
} : e({
subsystem: t
}, a));
},
measureCpu: function(r, o, n) {
return Dr(r, o, "string" == typeof n ? {
subsystem: t,
room: n
} : e({
subsystem: t
}, n));
}
};
}

var Hr = {
debug: Pr,
info: Ir,
warn: Gr,
error: Lr,
stat: Br,
measureCpu: Dr,
configure: xr,
getConfig: Ur,
createLogger: jr,
flush: Ar
}, Wr = Object.freeze({
__proto__: null,
get LogLevel() {
return Cr;
},
configureLogger: xr,
createLogger: jr,
debug: Pr,
error: Lr,
flushLogs: Ar,
getLoggerConfig: Ur,
info: Ir,
logger: Hr,
measureCpu: Dr,
stat: Br,
warn: Gr
}), Yr = -1;

function Kr() {
var e = global;
return e._heapCache && e._heapCache.tick === Game.time || (e._heapCache ? e._heapCache.tick = Game.time : e._heapCache = {
tick: Game.time,
entries: new Map,
rehydrated: !1
}), e._heapCache;
}

function Vr() {
return Memory._heapCache || (Memory._heapCache = {
version: 1,
lastSync: Game.time,
data: {}
}), Memory._heapCache;
}

var zr = function() {
function e() {
this.lastPersistenceTick = 0;
}
return e.prototype.initialize = function() {
var e = Kr();
e.rehydrated || (this.rehydrateFromMemory(), e.rehydrated = !0);
}, e.prototype.rehydrateFromMemory = function() {
var e, t, n = Kr(), a = Vr(), i = 0, s = 0;
try {
for (var c = r(Object.entries(a.data)), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = u[0], m = u[1];
void 0 !== m.ttl && m.ttl !== Yr && Game.time - m.lastModified > m.ttl ? s++ : (n.entries.set(f, {
value: m.value,
lastModified: m.lastModified,
dirty: !1,
ttl: m.ttl
}), i++);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
i > 0 && Game.time % 100 == 0 && Hr.info("Rehydrated ".concat(i, " entries from Memory"), {
subsystem: "HeapCache",
meta: {
rehydratedCount: i,
expiredCount: s
}
});
}, e.prototype.get = function(e) {
var t = Kr(), r = t.entries.get(e);
if (r) return void 0 !== r.ttl && r.ttl !== Yr && Game.time - r.lastModified > r.ttl ? void t.entries.delete(e) : r.value;
var o = Vr(), n = o.data[e];
return n ? void 0 !== n.ttl && n.ttl !== Yr && Game.time - n.lastModified > n.ttl ? void delete o.data[e] : (t.entries.set(e, {
value: n.value,
lastModified: n.lastModified,
dirty: !1,
ttl: n.ttl
}), n.value) : void 0;
}, e.prototype.set = function(e, t, r) {
Kr().entries.set(e, {
value: t,
lastModified: Game.time,
dirty: !0,
ttl: null != r ? r : 1e3
});
}, e.prototype.delete = function(e) {
Kr().entries.delete(e), delete Vr().data[e];
}, e.prototype.has = function(e) {
return void 0 !== this.get(e);
}, e.prototype.clear = function() {
Kr().entries.clear(), Vr().data = {};
}, e.prototype.persist = function(e) {
var t, n;
if (void 0 === e && (e = !1), !e && Game.time - this.lastPersistenceTick < 10) return 0;
var a = Kr(), i = Vr(), s = 0;
try {
for (var c = r(a.entries), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = u[0], m = u[1];
m.dirty && (i.data[f] = {
value: m.value,
lastModified: m.lastModified,
ttl: m.ttl
}, m.dirty = !1, s++);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (t) throw t.error;
}
}
return i.lastSync = Game.time, this.lastPersistenceTick = Game.time, s;
}, e.prototype.getStats = function() {
var e, t, o = Kr(), n = Vr(), a = 0;
try {
for (var i = r(o.entries.values()), s = i.next(); !s.done; s = i.next()) s.value.dirty && a++;
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return {
heapSize: o.entries.size,
memorySize: Object.keys(n.data).length,
dirtyEntries: a,
lastSync: n.lastSync
};
}, e.prototype.keys = function() {
var e = Kr();
return Array.from(e.entries.keys());
}, e.prototype.values = function() {
var e = Kr();
return Array.from(e.entries.values()).map(function(e) {
return e.value;
});
}, e.prototype.cleanExpired = function() {
var e, t, n, a, i = Kr(), s = Vr(), c = 0;
try {
for (var l = r(i.entries), u = l.next(); !u.done; u = l.next()) {
var f = o(u.value, 2), m = f[0], p = f[1];
void 0 !== p.ttl && p.ttl !== Yr && Game.time - p.lastModified > p.ttl && (i.entries.delete(m), 
c++);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
try {
for (var d = r(Object.entries(s.data)), y = d.next(); !y.done; y = d.next()) {
var g = o(y.value, 2), h = (m = g[0], g[1]);
void 0 !== h.ttl && h.ttl !== Yr && Game.time - h.lastModified > h.ttl && (delete s.data[m], 
c++);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
return c;
}, e;
}(), qr = new zr, Xr = "errorMapper_sourceMapAvailable";

function Qr(e) {
return null == e ? "" : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}

var Zr, Jr = function() {
function e() {}
return Object.defineProperty(e, "consumer", {
get: function() {
var e;
if (void 0 === this._consumer) {
if (!1 === qr.get(Xr)) return this._consumer = null, this._sourceMapAvailable = !1, 
null;
try {
var t = qr.get("errorMapper_sourceMapData");
if (!t) return this._consumer = null, this._sourceMapAvailable = !1, qr.set(Xr, !1, 1 / 0), 
null;
try {
this._consumer = new br.SourceMapConsumer(t), this._sourceMapAvailable = !0, qr.set(Xr, !0, 1 / 0);
} catch (e) {
console.log("SourceMapConsumer requires async initialization - source maps disabled"), 
this._consumer = null, this._sourceMapAvailable = !1, qr.set(Xr, !1, 1 / 0);
}
} catch (e) {
this._consumer = null, this._sourceMapAvailable = !1, qr.set(Xr, !1, 1 / 0);
}
}
return null !== (e = this._consumer) && void 0 !== e ? e : null;
},
enumerable: !1,
configurable: !0
}), e.sourceMappedStackTrace = function(e) {
var t = e instanceof Error ? e.stack : e;
if (Object.prototype.hasOwnProperty.call(this.cache, t)) return this.cache[t];
var r = this.consumer;
if (!r) {
var o = e.toString();
return this.cache[t] = o, o;
}
for (var n, a = /^\s+at\s+(.+?\s+)?\(?([0-z._\-\\\/]+):(\d+):(\d+)\)?$/gm, i = e.toString(); (n = a.exec(t)) && "main" === n[2]; ) {
var s = r.originalPositionFor({
column: parseInt(n[4], 10),
line: parseInt(n[3], 10)
});
if (null == s.line) break;
s.name ? i += "\n    at ".concat(s.name, " (").concat(s.source, ":").concat(s.line, ":").concat(s.column, ")") : n[1] ? i += "\n    at ".concat(n[1], " (").concat(s.source, ":").concat(s.line, ":").concat(s.column, ")") : i += "\n    at ".concat(s.source, ":").concat(s.line, ":").concat(s.column);
}
return this.cache[t] = i, i;
}, e.wrapLoop = function(e) {
var t = this;
return function() {
try {
e();
} catch (e) {
if (!(e instanceof Error)) throw e;
"sim" in Game.rooms ? console.log("<span style='color:red'>".concat("Source maps don't work in the simulator - displaying original error", "<br>").concat(Qr(e.stack), "</span>")) : console.log("<span style='color:red'>".concat(Qr(t.sourceMappedStackTrace(e)), "</span>"));
}
};
}, e.cache = {}, e;
}(), $r = [], eo = function() {
function t() {
this.commands = new Map, this.initialized = !1, this.lazyLoadEnabled = !1, this.commandsRegistered = !1, 
this.commandsExposed = !1;
}
return t.prototype.register = function(t, r) {
var o;
this.commands.has(t.name) && Hr.warn('Command "'.concat(t.name, '" is already registered, overwriting'), {
subsystem: "CommandRegistry"
}), this.commands.set(t.name, {
metadata: e(e({}, t), {
category: null !== (o = t.category) && void 0 !== o ? o : "General"
}),
handler: r
}), Hr.debug('Registered command "'.concat(t.name, '"'), {
subsystem: "CommandRegistry"
});
}, t.prototype.unregister = function(e) {
var t = this.commands.delete(e);
return t && Hr.debug('Unregistered command "'.concat(e, '"'), {
subsystem: "CommandRegistry"
}), t;
}, t.prototype.getCommand = function(e) {
return this.lazyLoadEnabled && !this.commandsRegistered && this.triggerLazyLoad(), 
this.commands.get(e);
}, t.prototype.getCommands = function() {
return this.lazyLoadEnabled && !this.commandsRegistered && this.triggerLazyLoad(), 
Array.from(this.commands.values());
}, t.prototype.getCommandsByCategory = function() {
var e, t, n, a, i, s;
this.lazyLoadEnabled && !this.commandsRegistered && this.triggerLazyLoad();
var c = new Map;
try {
for (var l = r(this.commands.values()), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = null !== (i = f.metadata.category) && void 0 !== i ? i : "General", p = null !== (s = c.get(m)) && void 0 !== s ? s : [];
p.push(f), c.set(m, p);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
try {
for (var d = r(c), y = d.next(); !y.done; y = d.next()) {
var g = o(y.value, 2), h = (m = g[0], g[1]);
c.set(m, h.sort(function(e, t) {
return e.metadata.name.localeCompare(t.metadata.name);
}));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
return c;
}, t.prototype.execute = function(e) {
for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
this.lazyLoadEnabled && !this.commandsRegistered && this.triggerLazyLoad();
var a = this.commands.get(e);
if (!a) return 'Command "'.concat(e, '" not found. Use help() to see available commands.');
try {
return a.handler.apply(a, n([], o(t), !1));
} catch (t) {
var i = t instanceof Error ? t.message : String(t);
return Hr.error('Error executing command "'.concat(e, '": ').concat(i), {
subsystem: "CommandRegistry"
}), "Error: ".concat(i);
}
}, t.prototype.generateHelp = function() {
var e, t, o, n, a, i, s, c = this.getCommandsByCategory(), l = [ "=== Available Console Commands ===", "" ], u = Array.from(c.keys()).sort(function(e, t) {
return "General" === e ? -1 : "General" === t ? 1 : e.localeCompare(t);
});
try {
for (var f = r(u), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = c.get(p);
if (d && 0 !== d.length) {
l.push("--- ".concat(p, " ---"));
try {
for (var y = (o = void 0, r(d)), g = y.next(); !g.done; g = y.next()) {
var h = g.value, v = null !== (s = h.metadata.usage) && void 0 !== s ? s : "".concat(h.metadata.name, "()");
if (l.push("  ".concat(v)), l.push("    ".concat(h.metadata.description)), h.metadata.examples && h.metadata.examples.length > 0) {
l.push("    Examples:");
try {
for (var R = (a = void 0, r(h.metadata.examples)), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
l.push("      ".concat(T));
}
} catch (e) {
a = {
error: e
};
} finally {
try {
E && !E.done && (i = R.return) && i.call(R);
} finally {
if (a) throw a.error;
}
}
}
l.push("");
}
} catch (e) {
o = {
error: e
};
} finally {
try {
g && !g.done && (n = y.return) && n.call(y);
} finally {
if (o) throw o.error;
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
m && !m.done && (t = f.return) && t.call(f);
} finally {
if (e) throw e.error;
}
}
return l.join("\n");
}, t.prototype.generateCommandHelp = function(e) {
var t, o, n, a;
this.lazyLoadEnabled && !this.commandsRegistered && this.triggerLazyLoad();
var i = this.commands.get(e);
if (!i) return 'Command "'.concat(e, '" not found. Use help() to see available commands.');
var s = [ "=== ".concat(i.metadata.name, " ==="), "", "Description: ".concat(i.metadata.description), "Usage: ".concat(null !== (n = i.metadata.usage) && void 0 !== n ? n : "".concat(i.metadata.name, "()")), "Category: ".concat(null !== (a = i.metadata.category) && void 0 !== a ? a : "General") ];
if (i.metadata.examples && i.metadata.examples.length > 0) {
s.push(""), s.push("Examples:");
try {
for (var c = r(i.metadata.examples), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
s.push("  ".concat(u));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
}
return s.join("\n");
}, t.prototype.exposeToGlobal = function() {
var e, t, n = this, a = global;
if (!this.commandsExposed || this.lazyLoadEnabled && this.commandsRegistered) {
try {
for (var i = r(this.commands), s = i.next(); !s.done; s = i.next()) {
var c = o(s.value, 2), l = c[0], u = c[1];
a[l] = u.handler;
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
this.commandsExposed = !0, Hr.debug("Exposed ".concat(this.commands.size, " commands to global scope"), {
subsystem: "CommandRegistry"
});
}
a.help = function(e) {
return n.lazyLoadEnabled && !n.commandsRegistered && n.triggerLazyLoad(), e ? n.generateCommandHelp(e) : n.generateHelp();
};
}, t.prototype.initialize = function() {
var e = this;
this.initialized || (this.register({
name: "help",
description: "Show available commands and their descriptions",
usage: "help() or help('commandName')",
examples: [ "help()", "help('setLogLevel')" ],
category: "System"
}, function() {
for (var t = [], r = 0; r < arguments.length; r++) t[r] = arguments[r];
var o = t[0];
return void 0 !== o ? e.generateCommandHelp(String(o)) : e.generateHelp();
}), this.initialized = !0, Hr.info("Command registry initialized", {
subsystem: "CommandRegistry"
}));
}, t.prototype.enableLazyLoading = function(e) {
this.lazyLoadEnabled = !0, this.registrationCallback = e, Hr.info("Console commands lazy loading enabled", {
subsystem: "CommandRegistry"
});
}, t.prototype.triggerLazyLoad = function() {
!this.commandsRegistered && this.registrationCallback && (Hr.debug("Lazy loading console commands on first access", {
subsystem: "CommandRegistry"
}), this.commandsRegistered = !0, this.registrationCallback(), this.exposeToGlobal());
}, t.prototype.getCommandCount = function() {
return this.commands.size;
}, t.prototype.isInitialized = function() {
return this.initialized;
}, t.prototype.reset = function() {
this.commands.clear(), this.initialized = !1, this.lazyLoadEnabled = !1, this.commandsRegistered = !1, 
this.commandsExposed = !1, this.registrationCallback = void 0;
}, t;
}(), to = new eo;

function ro(e) {
return function(t, r, o) {
$r.push({
metadata: e,
methodName: String(r),
target: t
});
};
}

function oo(e) {
var t, o, n = Object.getPrototypeOf(e);
try {
for (var a = r($r), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
if (no(s.target, n)) {
var c = e[s.methodName];
if ("function" == typeof c) {
var l = c.bind(e);
to.register(s.metadata, l), Hr.debug('Registered decorated command "'.concat(s.metadata.name, '"'), {
subsystem: "CommandRegistry"
});
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
}

function no(e, t) {
return null !== t && (e === t || Object.getPrototypeOf(e) === t || e === Object.getPrototypeOf(t));
}

!function(e) {
e[e.CRITICAL = 100] = "CRITICAL", e[e.HIGH = 75] = "HIGH", e[e.NORMAL = 50] = "NORMAL", 
e[e.LOW = 25] = "LOW", e[e.BACKGROUND = 10] = "BACKGROUND";
}(Zr || (Zr = {}));

var ao, io = {
"hostile.detected": Zr.CRITICAL,
"nuke.detected": Zr.CRITICAL,
"safemode.activated": Zr.CRITICAL,
"structure.destroyed": Zr.HIGH,
"hostile.cleared": Zr.HIGH,
"creep.died": Zr.HIGH,
"energy.critical": Zr.HIGH,
"spawn.emergency": Zr.HIGH,
"posture.change": Zr.HIGH,
"spawn.completed": Zr.NORMAL,
"rcl.upgrade": Zr.NORMAL,
"construction.complete": Zr.NORMAL,
"remote.lost": Zr.NORMAL,
"squad.formed": Zr.NORMAL,
"squad.dissolved": Zr.NORMAL,
"market.transaction": Zr.LOW,
"pheromone.update": Zr.LOW,
"cluster.update": Zr.LOW,
"expansion.candidate": Zr.LOW,
"powerbank.discovered": Zr.LOW,
"cpu.spike": Zr.BACKGROUND,
"bucket.modeChange": Zr.BACKGROUND
}, so = {
maxEventsPerTick: 50,
maxQueueSize: 200,
lowBucketThreshold: 2e3,
criticalBucketThreshold: 1e3,
maxEventAge: 100,
enableLogging: !1,
statsLogInterval: 100,
enableCoalescing: !0
}, co = function() {
function t(t) {
void 0 === t && (t = {}), this.handlers = new Map, this.eventQueue = [], this.handlerIdCounter = 0, 
this.stats = {
eventsEmitted: 0,
eventsProcessed: 0,
eventsDeferred: 0,
eventsDropped: 0,
handlersInvoked: 0,
eventsCoalesced: 0
}, this.tickEvents = new Map, this.config = e(e({}, so), t);
}
return t.prototype.on = function(e, t, r) {
var o, n, a, i, s = this;
void 0 === r && (r = {});
var c = {
handler: t,
priority: null !== (o = r.priority) && void 0 !== o ? o : Zr.NORMAL,
minBucket: null !== (n = r.minBucket) && void 0 !== n ? n : 0,
once: null !== (a = r.once) && void 0 !== a && a,
id: "handler_".concat(++this.handlerIdCounter)
}, l = null !== (i = this.handlers.get(e)) && void 0 !== i ? i : [];
return l.push(c), l.sort(function(e, t) {
return t.priority - e.priority;
}), this.handlers.set(e, l), this.config.enableLogging && Hr.debug('EventBus: Registered handler for "'.concat(e, '" (id: ').concat(c.id, ")"), {
subsystem: "EventBus"
}), function() {
return s.off(e, c.id);
};
}, t.prototype.once = function(t, r, o) {
return void 0 === o && (o = {}), this.on(t, r, e(e({}, o), {
once: !0
}));
}, t.prototype.off = function(e, t) {
var r = this.handlers.get(e);
if (r) {
var o = r.findIndex(function(e) {
return e.id === t;
});
-1 !== o && (r.splice(o, 1), this.config.enableLogging && Hr.debug('EventBus: Unregistered handler "'.concat(t, '" from "').concat(e, '"'), {
subsystem: "EventBus"
}));
}
}, t.prototype.offAll = function(e) {
this.handlers.delete(e), this.config.enableLogging && Hr.debug('EventBus: Removed all handlers for "'.concat(e, '"'), {
subsystem: "EventBus"
});
}, t.prototype.getCoalescingKey = function(e, t) {
var r = [ e ], o = function(e, t) {
return "object" == typeof e && null !== e && t in e;
};
return o(t, "roomName") && "string" == typeof t.roomName && r.push(t.roomName), 
o(t, "processId") && "string" == typeof t.processId && r.push(t.processId), o(t, "squadId") && "string" == typeof t.squadId && r.push(t.squadId), 
o(t, "clusterId") && "string" == typeof t.clusterId && r.push(t.clusterId), r.join(":");
}, t.prototype.emit = function(t, r, o) {
var n, a, i, s;
void 0 === o && (o = {});
var c = e(e({}, r), {
tick: Game.time
}), l = null !== (a = null !== (n = o.priority) && void 0 !== n ? n : io[t]) && void 0 !== a ? a : Zr.NORMAL, u = null !== (i = o.immediate) && void 0 !== i ? i : l >= Zr.CRITICAL, f = null === (s = o.allowCoalescing) || void 0 === s || s;
if (this.config.enableCoalescing && f && !u) {
var m = this.getCoalescingKey(t, c), p = this.tickEvents.get(m);
if (p) return p.count++, this.stats.eventsCoalesced++, void (this.config.enableLogging && Hr.debug('EventBus: Coalesced "'.concat(t, '" (count: ').concat(p.count, ")"), {
subsystem: "EventBus"
}));
this.tickEvents.set(m, {
name: t,
payload: c,
priority: l,
count: 1
});
}
this.stats.eventsEmitted++, this.config.enableLogging && Hr.debug('EventBus: Emitting "'.concat(t, '" (priority: ').concat(l, ", immediate: ").concat(String(u), ")"), {
subsystem: "EventBus"
});
var d = Game.cpu.bucket;
u || d >= this.config.lowBucketThreshold ? this.processEvent(t, c) : d >= this.config.criticalBucketThreshold ? this.queueEvent(t, c, l) : l >= Zr.CRITICAL ? this.processEvent(t, c) : (this.stats.eventsDropped++, 
this.config.enableLogging && Hr.warn('EventBus: Dropped event "'.concat(t, '" due to critical bucket'), {
subsystem: "EventBus"
}));
}, t.prototype.processEvent = function(e, t) {
var o, n, a, i, s = this.handlers.get(e);
if (s && 0 !== s.length) {
var c = Game.cpu.bucket, l = [];
try {
for (var u = r(s), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (!(c < m.minBucket)) try {
m.handler(t), this.stats.handlersInvoked++, m.once && l.push(m.id);
} catch (t) {
var p = t instanceof Error ? t.message : String(t);
Hr.error('EventBus: Handler error for "'.concat(e, '": ').concat(p), {
subsystem: "EventBus"
});
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
try {
for (var d = r(l), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
this.off(e, g);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
y && !y.done && (i = d.return) && i.call(d);
} finally {
if (a) throw a.error;
}
}
this.stats.eventsProcessed++;
}
}, t.prototype.queueEvent = function(e, t, r) {
if (this.eventQueue.length >= this.config.maxQueueSize) {
var o = this.eventQueue.map(function(e, t) {
return {
event: e,
index: t
};
}).filter(function(e) {
return e.event.priority < Zr.HIGH;
}).sort(function(e, t) {
return e.event.queuedAt - t.event.queuedAt;
})[0];
if (!(o && o.event.priority < r)) return void this.stats.eventsDropped++;
this.eventQueue.splice(o.index, 1), this.stats.eventsDropped++;
}
var n = {
name: e,
payload: t,
priority: r,
queuedAt: Game.time
};
this.eventQueue.push(n), this.eventQueue.sort(function(e, t) {
return t.priority !== e.priority ? t.priority - e.priority : e.queuedAt - t.queuedAt;
}), this.stats.eventsDeferred++;
}, t.prototype.startTick = function() {
this.tickEvents.clear();
}, t.prototype.processQueue = function() {
var e = this, t = Game.cpu.bucket;
if (!(t < this.config.criticalBucketThreshold)) {
var r = this.config.maxEventsPerTick;
t < this.config.lowBucketThreshold && (r = Math.floor(r / 2));
var o = Game.time;
this.eventQueue = this.eventQueue.filter(function(t) {
return !(o - t.queuedAt > e.config.maxEventAge && (e.stats.eventsDropped++, 1));
});
for (var n = 0; this.eventQueue.length > 0 && n < r; ) {
var a = this.eventQueue.shift();
a && (this.processEvent(a.name, a.payload), n++);
}
}
}, t.prototype.getStats = function() {
var t, o, n = 0;
try {
for (var a = r(this.handlers.values()), i = a.next(); !i.done; i = a.next()) n += i.value.length;
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
return e(e({}, this.stats), {
queueSize: this.eventQueue.length,
handlerCount: n
});
}, t.prototype.resetStats = function() {
this.stats = {
eventsEmitted: 0,
eventsProcessed: 0,
eventsDeferred: 0,
eventsDropped: 0,
handlersInvoked: 0,
eventsCoalesced: 0
};
}, t.prototype.getConfig = function() {
return e({}, this.config);
}, t.prototype.updateConfig = function(t) {
this.config = e(e({}, this.config), t);
}, t.prototype.clear = function() {
this.handlers.clear(), this.eventQueue = [], this.resetStats();
}, t.prototype.getHandlerCount = function(e) {
var t, r;
return null !== (r = null === (t = this.handlers.get(e)) || void 0 === t ? void 0 : t.length) && void 0 !== r ? r : 0;
}, t.prototype.hasHandlers = function(e) {
return this.getHandlerCount(e) > 0;
}, t.prototype.logStats = function() {
if (Game.time % this.config.statsLogInterval === 0) {
var e = this.getStats();
Hr.debug("EventBus stats: ".concat(e.eventsEmitted, " emitted, ").concat(e.eventsProcessed, " processed, ") + "".concat(e.eventsDeferred, " deferred, ").concat(e.eventsDropped, " dropped, ") + "".concat(e.eventsCoalesced, " coalesced, ") + "".concat(e.queueSize, " queued, ").concat(e.handlerCount, " handlers"), {
subsystem: "EventBus"
});
}
}, t;
}(), lo = new co, uo = {
pheromone: {
updateInterval: 5,
decayFactors: {
expand: .95,
harvest: .9,
build: .92,
upgrade: .93,
defense: .97,
war: .98,
siege: .99,
logistics: .91,
nukeTarget: .99
},
diffusionRates: {
expand: .3,
harvest: .1,
build: .15,
upgrade: .1,
defense: .4,
war: .5,
siege: .6,
logistics: .2,
nukeTarget: .1
},
maxValue: 100,
minValue: 0
},
war: {
dangerThresholds: {
level1HostileCount: 1,
level2HostileCount: 3,
level2DamageThreshold: 100,
level3DamageThreshold: 500
},
postureThresholds: {
defensivePosture: 30,
warPosture: 50,
expandPosture: 40
},
economyStabilityRatio: 1.2,
warSustainedTicks: 100
},
nuke: {
minEnemyRCL: 5,
minThreatLevel: 2,
minNukeScore: 35,
scoring: {
enemyRCLWeight: 2,
hostileStructuresWeight: 3,
warPheromoneWeight: 1.5,
distancePenalty: .5
},
evaluationInterval: 200
},
expansion: {
minEnergySurplus: 1e3,
minBucketForClaim: 8e3,
maxRemoteDistance: 2,
maxClaimDistance: 5,
scoring: {
sourcesWeight: 20,
mineralWeight: 10,
distancePenalty: 5,
hostilePenalty: 30,
terrainPenalty: 2,
highwayBonus: 15
}
},
cpu: {
bucketThresholds: {
lowMode: 2e3,
highMode: 9e3
},
budgets: {
rooms: .4,
creeps: .3,
strategic: .1,
market: .1,
visualization: .1
},
taskFrequencies: {
pheromoneUpdate: 5,
clusterLogic: 10,
strategicDecisions: 20,
marketScan: 100,
nukeEvaluation: 200,
memoryCleanup: 50
}
},
market: {
maxCreditsPerTick: 1e5,
minCreditReserve: 5e4,
safetyBuffer: {
energy: 5e4,
baseMinerals: 5e3
},
priceTolerance: {
buy: .1,
sell: .1,
emergency: .5
},
scanInterval: 100,
tradeCooldown: 10
},
spawn: {
bodyCosts: (ao = {}, ao[MOVE] = 50, ao[WORK] = 100, ao[CARRY] = 50, ao[ATTACK] = 80, 
ao[RANGED_ATTACK] = 150, ao[HEAL] = 250, ao[CLAIM] = 600, ao[TOUGH] = 10, ao),
minCreepCounts: {
harvester: 2,
hauler: 2,
upgrader: 1,
builder: 1
},
rolePriorities: {
harvester: 100,
hauler: 90,
queenCarrier: 85,
builder: 70,
upgrader: 60,
guard: 80,
healer: 75,
scout: 40,
claimer: 50
}
},
boost: {
roleBoosts: {
harvester: [ "UO" ],
upgrader: [ "GH", "GH2O", "XGH2O" ],
guard: [ "UH", "LO" ],
healer: [ "LO", "LHO2", "XLHO2" ],
soldier: [ "UH", "KO", "XZHO2" ]
},
boostPriority: [ "XLHO2", "XUH2O", "XZHO2", "XGH2O" ],
minBoostAmount: 30
},
debug: !1,
profiling: !0,
visualizations: !0,
lazyLoadConsoleCommands: !0
}, fo = e({}, uo);

function mo() {
return fo;
}

function po(t) {
fo = e(e({}, fo), t);
}

var yo, go = {}, ho = {}, vo = {};

function Ro() {
if (yo) return vo;
yo = 1;
var e, t, r = vo && vo.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, o = vo && vo.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
}, n = vo && vo.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function a(e) {
return {
debug: function(t) {
for (var n = [], a = 1; a < arguments.length; a++) n[a - 1] = arguments[a];
return console.log.apply(console, o([ "[".concat(e, "]"), t ], r(n), !1));
},
info: function(t) {
for (var n = [], a = 1; a < arguments.length; a++) n[a - 1] = arguments[a];
return console.log.apply(console, o([ "[".concat(e, "]"), t ], r(n), !1));
},
warn: function(t) {
for (var n = [], a = 1; a < arguments.length; a++) n[a - 1] = arguments[a];
return console.log.apply(console, o([ "[".concat(e, "] WARN:"), t ], r(n), !1));
},
error: function(t) {
for (var n = [], a = 1; a < arguments.length; a++) n[a - 1] = arguments[a];
return console.log.apply(console, o([ "[".concat(e, "] ERROR:"), t ], r(n), !1));
}
};
}
return Object.defineProperty(vo, "__esModule", {
value: !0
}), vo.globalCache = vo.shardManager = vo.VisualizationLayer = vo.PheromoneState = vo.memoryManager = vo.logger = void 0, 
vo.createLogger = a, vo.getRoomFindCacheStats = function() {
return {
rooms: 0,
totalEntries: 0,
hits: 0,
misses: 0,
invalidations: 0,
size: 0,
hitRate: 0
};
}, vo.getBodyPartCacheStats = function() {
return {
hits: 0,
misses: 0,
size: 0,
hitRate: 0
};
}, vo.getObjectCacheStats = function() {
return {
hits: 0,
misses: 0,
size: 0,
hitRate: 0
};
}, vo.getPathCacheStats = function() {
return {
hits: 0,
misses: 0,
size: 0,
maxSize: 0,
evictions: 0,
hitRate: 0
};
}, vo.getRoleCacheStats = function() {
return {
totalEntries: 0
};
}, vo.logger = a("stats"), vo.memoryManager = {
getRoomMemory: function(e) {
var t;
return (null === (t = Memory.rooms) || void 0 === t ? void 0 : t[e]) || {};
},
getCreepMemory: function(e) {
var t;
return (null === (t = Memory.creeps) || void 0 === t ? void 0 : t[e]) || {};
},
getAllRoomMemories: function() {
var e, t, o = new Map;
if (Memory.rooms) try {
for (var a = n(Object.entries(Memory.rooms)), i = a.next(); !i.done; i = a.next()) {
var s = r(i.value, 2), c = s[0], l = s[1];
o.set(c, l);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return o;
},
getSwarmState: function(e) {
return {};
}
}, function(e) {
e.ACTIVE = "active", e.DECAY = "decay", e.INACTIVE = "inactive";
}(e || (vo.PheromoneState = e = {})), function(e) {
e.PHEROMONES = "pheromones", e.PATHS = "paths", e.TARGETS = "targets", e.DEBUG = "debug";
}(t || (vo.VisualizationLayer = t = {})), vo.shardManager = {
getCurrentShard: function() {
var e;
return (null === (e = Game.shard) || void 0 === e ? void 0 : e.name) || "shard0";
},
getAllShards: function() {
var e;
return [ (null === (e = Game.shard) || void 0 === e ? void 0 : e.name) || "shard0" ];
},
getCurrentShardState: function() {
return {};
}
}, vo.globalCache = {
getCacheStats: function() {
return {
hits: 0,
misses: 0,
hitRate: 0,
size: 0,
evictions: 0
};
}
}, vo;
}

var Eo, To = {};

function So() {
return Eo || (Eo = 1, function(e) {
function t(e, t) {
var r = t.roomScaling, o = r.minRooms, n = r.scaleFactor, a = r.maxMultiplier, i = Math.max(e, o), s = 1 + Math.log(i / o) / Math.log(n);
return Math.max(1, Math.min(a, s));
}
function r(e, t) {
var r = t.bucketMultipliers, o = r.highThreshold, n = r.lowThreshold, a = r.criticalThreshold, i = r.highMultiplier, s = r.lowMultiplier, c = r.criticalMultiplier;
return e >= o ? i : e < a ? c : e < n ? s : 1;
}
function o(o, n, a, i) {
void 0 === i && (i = e.DEFAULT_ADAPTIVE_CONFIG);
var s = i.baseFrequencyBudgets[o] * t(n, i) * r(a, i);
return Math.max(.01, Math.min(1, s));
}
function n(t, r, n) {
return void 0 === n && (n = e.DEFAULT_ADAPTIVE_CONFIG), {
high: o("high", t, r, n),
medium: o("medium", t, r, n),
low: o("low", t, r, n)
};
}
function a() {
var e = Object.keys(Game.rooms).length;
return Math.max(1, e);
}
function i() {
return Game.cpu.bucket;
}
Object.defineProperty(e, "__esModule", {
value: !0
}), e.DEFAULT_ADAPTIVE_CONFIG = void 0, e.calculateRoomScalingMultiplier = t, e.calculateBucketMultiplier = r, 
e.calculateAdaptiveBudget = o, e.calculateAdaptiveBudgets = n, e.getCurrentRoomCount = a, 
e.getCurrentBucket = i, e.getAdaptiveBudgets = function(t) {
return void 0 === t && (t = e.DEFAULT_ADAPTIVE_CONFIG), n(a(), i(), t);
}, e.getAdaptiveBudgetInfo = function(o) {
void 0 === o && (o = e.DEFAULT_ADAPTIVE_CONFIG);
var s = a(), c = i();
return {
roomCount: s,
bucket: c,
roomMultiplier: t(s, o),
bucketMultiplier: r(c, o),
budgets: n(s, c, o),
baseBudgets: o.baseFrequencyBudgets
};
}, e.DEFAULT_ADAPTIVE_CONFIG = {
baseFrequencyBudgets: {
high: .25,
medium: .06,
low: .05
},
roomScaling: {
minRooms: 1,
scaleFactor: 20,
maxMultiplier: 2.5
},
bucketMultipliers: {
highThreshold: 9e3,
lowThreshold: 2e3,
criticalThreshold: 500,
highMultiplier: 1.2,
lowMultiplier: .6,
criticalMultiplier: .3
}
};
}(To)), To;
}

var Co, bo, _o = {};

function Oo() {
return Co || (Co = 1, function(e) {
var t = _o && _o.__assign || function() {
return t = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, t.apply(this, arguments);
};
Object.defineProperty(e, "__esModule", {
value: !0
}), e.pathfindingMetrics = void 0, e.trackPathfindingCall = function(t, r, o) {
var n = Game.cpu.getUsed(), a = o(), i = Game.cpu.getUsed() - n;
return e.pathfindingMetrics.recordCall(t, r, i), a;
};
var r = function() {
function e() {
this.metrics = {
totalCalls: 0,
cacheHits: 0,
cacheMisses: 0,
cacheHitRate: 0,
cpuUsed: 0,
avgCpuPerCall: 0,
cpuSaved: 0,
callsByType: {
moveTo: 0,
pathFinderSearch: 0,
findPath: 0,
moveByPath: 0
}
};
}
return e.prototype.recordCall = function(e, t, r) {
if (this.metrics.totalCalls++, this.metrics.callsByType[e]++, this.metrics.cpuUsed += r, 
t) {
this.metrics.cacheHits++;
var o = Math.max(.5 - r, 0);
this.metrics.cpuSaved += o;
} else this.metrics.cacheMisses++;
}, e.prototype.getMetrics = function() {
return this.metrics.cacheHitRate = this.metrics.totalCalls > 0 ? this.metrics.cacheHits / this.metrics.totalCalls : 0, 
this.metrics.avgCpuPerCall = this.metrics.totalCalls > 0 ? this.metrics.cpuUsed / this.metrics.totalCalls : 0, 
t({}, this.metrics);
}, e.prototype.reset = function() {
this.metrics = {
totalCalls: 0,
cacheHits: 0,
cacheMisses: 0,
cacheHitRate: 0,
cpuUsed: 0,
avgCpuPerCall: 0,
cpuSaved: 0,
callsByType: {
moveTo: 0,
pathFinderSearch: 0,
findPath: 0,
moveByPath: 0
}
};
}, e;
}();
e.pathfindingMetrics = new r;
}(_o)), _o;
}

var wo, xo, Uo, Mo, Ao, ko = {}, No = {}, Po = {}, Io = (Mo || (Mo = 1, function(e) {
var t = go && go.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = go && go.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
};
Object.defineProperty(e, "__esModule", {
value: !0
}), e.VisualizationLayer = e.resetMetrics = e.getEfficiencySummary = e.recordTaskComplete = e.recordHealing = e.recordDamage = e.recordUpgrade = e.recordRepair = e.recordBuild = e.recordTransfer = e.recordHarvest = e.getMetrics = e.initializeMetrics = e.DEFAULT_ADAPTIVE_CONFIG = e.calculateAdaptiveBudgets = e.calculateAdaptiveBudget = e.getAdaptiveBudgets = e.getAdaptiveBudgetInfo = e.calculateBucketMultiplier = e.calculateRoomScalingMultiplier = e.trackPathfindingCall = e.pathfindingMetrics = e.memorySegmentStats = e.MemorySegmentStats = e.unifiedStats = e.UnifiedStatsManager = void 0;
var o = function() {
if (bo) return ho;
bo = 1;
var e = ho && ho.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = ho && ho.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = ho && ho.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(ho, "__esModule", {
value: !0
}), ho.unifiedStats = ho.UnifiedStatsManager = void 0;
var o = Ro(), n = So(), a = Oo(), i = {
enabled: !0,
smoothingFactor: .1,
trackNativeCalls: !0,
logInterval: 100,
segmentUpdateInterval: 10,
segmentId: 90,
maxHistoryPoints: 1e3,
budgetLimits: {
ecoRoom: .1,
warRoom: .25,
overmind: 1
},
budgetAlertThresholds: {
warning: .8,
critical: 1
},
anomalyDetection: {
enabled: !0,
spikeThreshold: 2,
minSamples: 10
}
}, s = function() {
function s(t) {
void 0 === t && (t = {}), this.subsystemMeasurements = new Map, this.roomMeasurements = new Map, 
this.lastSegmentUpdate = 0, this.segmentRequested = !1, this.skippedProcessesThisTick = 0, 
this.config = e(e({}, i), t), this.currentSnapshot = this.createEmptySnapshot(), 
this.nativeCallsThisTick = this.createEmptyNativeCalls();
}
return s.prototype.initialize = function() {
void 0 === RawMemory.segments[this.config.segmentId] && (RawMemory.setActiveSegments([ this.config.segmentId ]), 
this.segmentRequested = !0), o.logger.info("Unified stats system initialized", {
subsystem: "Stats"
});
}, s.prototype.preserveRoomStats = function() {
var e, t = null === (e = this.currentSnapshot) || void 0 === e ? void 0 : e.rooms;
if (!t) return {};
var r = {};
for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && Game.rooms[o] && (r[o] = t[o]);
return r;
}, s.prototype.startTick = function() {
if (this.config.enabled) {
RawMemory.setActiveSegments([ this.config.segmentId ]), this.segmentRequested = !0;
var e = this.preserveRoomStats();
this.currentSnapshot = this.createEmptySnapshot(), this.currentSnapshot.rooms = e, 
this.nativeCallsThisTick = this.createEmptyNativeCalls(), this.subsystemMeasurements.clear(), 
this.roomMeasurements.clear(), this.skippedProcessesThisTick = 0, a.pathfindingMetrics.reset();
}
}, s.prototype.finalizeTick = function() {
var t, r, n, a, i, s, c, l, u, f, m, p, d, y, g, h;
if (this.config.enabled) {
this.currentSnapshot.cpu = {
used: Game.cpu.getUsed(),
limit: Game.cpu.limit,
bucket: Game.cpu.bucket,
percent: Game.cpu.limit > 0 ? Game.cpu.getUsed() / Game.cpu.limit * 100 : 0,
heapUsed: (null !== (a = null === (n = null === (r = (t = Game.cpu).getHeapStatistics) || void 0 === r ? void 0 : r.call(t)) || void 0 === n ? void 0 : n.used_heap_size) && void 0 !== a ? a : 0) / 1024 / 1024
}, this.currentSnapshot.progression = {
gcl: {
level: Game.gcl.level,
progress: Game.gcl.progress,
progressTotal: Game.gcl.progressTotal,
progressPercent: Game.gcl.progressTotal > 0 ? Game.gcl.progress / Game.gcl.progressTotal * 100 : 0
},
gpl: {
level: null !== (s = null === (i = Game.gpl) || void 0 === i ? void 0 : i.level) && void 0 !== s ? s : 0,
progress: null !== (l = null === (c = Game.gpl) || void 0 === c ? void 0 : c.progress) && void 0 !== l ? l : 0,
progressTotal: null !== (f = null === (u = Game.gpl) || void 0 === u ? void 0 : u.progressTotal) && void 0 !== f ? f : 0,
progressPercent: (null !== (p = null === (m = Game.gpl) || void 0 === m ? void 0 : m.progressTotal) && void 0 !== p ? p : 0) > 0 ? (null !== (y = null === (d = Game.gpl) || void 0 === d ? void 0 : d.progress) && void 0 !== y ? y : 0) / (null !== (h = null === (g = Game.gpl) || void 0 === g ? void 0 : g.progressTotal) && void 0 !== h ? h : 0) * 100 : 0
}
}, this.finalizeEmpireStats(), this.finalizeSubsystemStats(), this.finalizeCacheStats(), 
this.finalizePathfindingStats(), this.currentSnapshot.native = e({}, this.nativeCallsThisTick), 
this.finalizeCreepStats(), this.currentSnapshot.tick = Game.time, this.currentSnapshot.timestamp = Date.now();
var v = this.validateBudgets(), R = this.detectAnomalies();
if (v.alerts.length > 0) {
var E = v.alerts.filter(function(e) {
return "critical" === e.severity;
}), T = v.alerts.filter(function(e) {
return "warning" === e.severity;
});
E.length > 0 && o.logger.error("CPU Budget: ".concat(E.length, " critical violations detected"), {
subsystem: "CPUBudget",
meta: {
violations: E.map(function(e) {
return "".concat(e.target, ": ").concat((100 * e.percentUsed).toFixed(1), "% (").concat(e.cpuUsed.toFixed(3), "/").concat(e.budgetLimit, ")");
})
}
}), T.length > 0 && o.logger.warn("CPU Budget: ".concat(T.length, " warnings (80% of limit)"), {
subsystem: "CPUBudget",
meta: {
warnings: T.map(function(e) {
return "".concat(e.target, ": ").concat((100 * e.percentUsed).toFixed(1), "%");
})
}
});
}
R.length > 0 && o.logger.warn("CPU Anomalies: ".concat(R.length, " detected"), {
subsystem: "CPUProfiler",
meta: {
anomalies: R.map(function(e) {
return "".concat(e.target, " (").concat(e.type, "): ").concat(e.current.toFixed(3), " CPU (").concat(e.multiplier.toFixed(1), "x baseline)").concat(e.context ? " - ".concat(e.context) : "");
})
}
}), this.publishToMemory(), this.publishToConsole(), Game.time - this.lastSegmentUpdate >= this.config.segmentUpdateInterval && (this.updateSegment(), 
this.lastSegmentUpdate = Game.time), this.config.logInterval > 0 && Game.time % this.config.logInterval === 0 && this.logSummary();
}
}, s.prototype.startRoom = function(e) {
return this.config.enabled ? Game.cpu.getUsed() : 0;
}, s.prototype.endRoom = function(e, t) {
if (this.config.enabled) {
var r = Game.cpu.getUsed() - t;
this.roomMeasurements.set(e, r);
}
}, s.prototype.measureSubsystem = function(e, t) {
var r;
if (!this.config.enabled) return t();
var o = Game.cpu.getUsed(), n = t(), a = Game.cpu.getUsed() - o, i = null !== (r = this.subsystemMeasurements.get(e)) && void 0 !== r ? r : [];
return i.push(a), this.subsystemMeasurements.set(e, i), n;
}, s.prototype.recordNativeCall = function(e) {
this.config.enabled && this.config.trackNativeCalls && (this.nativeCallsThisTick[e]++, 
this.nativeCallsThisTick.total++);
}, s.prototype.recordProcess = function(e) {
this.config.enabled && (this.currentSnapshot.processes[e.id] = {
id: e.id,
name: e.name,
priority: e.priority,
frequency: e.frequency,
state: e.state,
totalCpu: e.stats.totalCpu,
runCount: e.stats.runCount,
avgCpu: e.stats.avgCpu,
maxCpu: e.stats.maxCpu,
lastRunTick: e.stats.lastRunTick,
skippedCount: e.stats.skippedCount,
errorCount: e.stats.errorCount,
cpuBudget: e.cpuBudget,
minBucket: e.minBucket,
tickModulo: e.tickModulo,
tickOffset: e.tickOffset
});
}, s.prototype.collectProcessStats = function(e) {
var t = this;
this.config.enabled && e.forEach(function(e) {
t.recordProcess(e);
});
}, s.prototype.setSkippedProcesses = function(e) {
this.config.enabled && (this.skippedProcessesThisTick = Math.max(0, e));
}, s.prototype.collectKernelBudgetStats = function(e) {
if (this.config.enabled) {
var t = e.getConfig();
if (t.enableAdaptiveBudgets) {
var r = Object.keys(Game.rooms).length, o = Game.cpu.bucket, a = e.getProcesses().reduce(function(e, t) {
return e + t.cpuBudget;
}, 0), i = e.getTickCpuUsed(), s = a > 0 ? i / a : 0;
this.currentSnapshot.kernelBudgets = {
adaptiveBudgetsEnabled: !0,
roomCount: r,
roomMultiplier: (0, n.calculateRoomScalingMultiplier)(r, t.adaptiveBudgetConfig),
bucketMultiplier: (0, n.calculateBucketMultiplier)(o, t.adaptiveBudgetConfig),
budgets: {
high: t.frequencyCpuBudgets.high || 0,
medium: t.frequencyCpuBudgets.medium || 0,
low: t.frequencyCpuBudgets.low || 0
},
totalAllocated: a,
totalUsed: i,
utilizationRatio: s
};
} else a = e.getProcesses().reduce(function(e, t) {
return e + t.cpuBudget;
}, 0), i = e.getTickCpuUsed(), this.currentSnapshot.kernelBudgets = {
adaptiveBudgetsEnabled: !1,
roomCount: Object.keys(Game.rooms).length,
roomMultiplier: 1,
bucketMultiplier: 1,
budgets: {
high: t.frequencyCpuBudgets.high || 0,
medium: t.frequencyCpuBudgets.medium || 0,
low: t.frequencyCpuBudgets.low || 0
},
totalAllocated: a,
totalUsed: i,
utilizationRatio: a > 0 ? i / a : 0
};
}
}, s.prototype.recordCreep = function(e, t, r, o) {
var n, a, i;
if (void 0 === o && (o = 0), this.config.enabled) {
var s = e.memory;
this.currentSnapshot.creeps[e.name] = {
name: e.name,
role: null !== (n = s.role) && void 0 !== n ? n : "unknown",
homeRoom: null !== (a = s.homeRoom) && void 0 !== a ? a : e.room.name,
currentRoom: e.room.name,
cpu: t,
action: r,
ticksToLive: null !== (i = e.ticksToLive) && void 0 !== i ? i : 0,
hits: e.hits,
hitsMax: e.hitsMax,
bodyParts: e.body.length,
fatigue: e.fatigue,
actionsThisTick: o
};
}
}, s.prototype.recordRoom = function(e, n) {
var a, i, s, c, l, u, f, m, p, d, y, g, h, v, R;
if (this.config.enabled) {
var E = o.memoryManager.getSwarmState(e.name), T = Object.values(Game.creeps).filter(function(t) {
return t.room.name === e.name;
}).length, S = e.find(FIND_HOSTILE_CREEPS), C = this.currentSnapshot.rooms[e.name];
if (C || (C = {
name: e.name,
rcl: null !== (c = null === (s = e.controller) || void 0 === s ? void 0 : s.level) && void 0 !== c ? c : 0,
energy: {
available: e.energyAvailable,
capacity: e.energyCapacityAvailable,
storage: null !== (u = null === (l = e.storage) || void 0 === l ? void 0 : l.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== u ? u : 0,
terminal: null !== (m = null === (f = e.terminal) || void 0 === f ? void 0 : f.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== m ? m : 0
},
controller: {
progress: null !== (d = null === (p = e.controller) || void 0 === p ? void 0 : p.progress) && void 0 !== d ? d : 0,
progressTotal: null !== (g = null === (y = e.controller) || void 0 === y ? void 0 : y.progressTotal) && void 0 !== g ? g : 1,
progressPercent: 0
},
creeps: T,
hostiles: S.length,
brain: {
danger: null !== (h = null == E ? void 0 : E.danger) && void 0 !== h ? h : 0,
postureCode: this.postureToCode(null !== (v = null == E ? void 0 : E.posture) && void 0 !== v ? v : "eco"),
colonyLevelCode: this.colonyLevelToCode(null !== (R = null == E ? void 0 : E.colonyLevel) && void 0 !== R ? R : "seedNest")
},
pheromones: {},
metrics: {
energyHarvested: 0,
energySpawning: 0,
energyConstruction: 0,
energyRepair: 0,
energyTower: 0,
energyAvailableForSharing: 0,
energyCapacityTotal: 0,
energyNeed: 0,
controllerProgress: 0,
hostileCount: S.length,
damageReceived: 0,
constructionSites: 0
},
profiler: {
avgCpu: n,
peakCpu: n,
samples: 1
}
}, this.currentSnapshot.rooms[e.name] = C), C.controller.progressPercent = C.controller.progressTotal > 0 ? C.controller.progress / C.controller.progressTotal * 100 : 0, 
E) {
try {
for (var b = t(Object.entries(E.pheromones)), _ = b.next(); !_.done; _ = b.next()) {
var O = r(_.value, 2), w = O[0], x = O[1];
C.pheromones[w] = x;
}
} catch (e) {
a = {
error: e
};
} finally {
try {
_ && !_.done && (i = b.return) && i.call(b);
} finally {
if (a) throw a.error;
}
}
C.metrics = {
energyHarvested: E.metrics.energyHarvested,
energySpawning: E.metrics.energySpawning,
energyConstruction: E.metrics.energyConstruction,
energyRepair: E.metrics.energyRepair,
energyTower: E.metrics.energyTower,
energyAvailableForSharing: E.metrics.energyAvailable,
energyCapacityTotal: E.metrics.energyCapacity,
energyNeed: E.metrics.energyNeed,
controllerProgress: E.metrics.controllerProgress,
hostileCount: E.metrics.hostileCount,
damageReceived: E.metrics.damageReceived,
constructionSites: E.metrics.constructionSites
};
}
var U = this.getProfilerMemory().rooms[e.name];
U && (C.profiler.avgCpu = U.avgCpu * (1 - this.config.smoothingFactor) + n * this.config.smoothingFactor, 
C.profiler.peakCpu = Math.max(U.peakCpu, n), C.profiler.samples = U.samples + 1), 
this.getProfilerMemory().rooms[e.name] = {
avgCpu: C.profiler.avgCpu,
peakCpu: C.profiler.peakCpu,
samples: C.profiler.samples,
lastTick: Game.time
};
}
}, s.prototype.isWarRoom = function(e) {
var t = o.memoryManager.getSwarmState(e);
return !!t && ("war" === t.posture || "siege" === t.posture || t.danger >= 2);
}, s.prototype.validateBudgets = function() {
var e, o, n = {
roomsEvaluated: 0,
roomsWithinBudget: 0,
roomsOverBudget: 0,
alerts: [],
anomalies: [],
tick: Game.time
};
try {
for (var a = t(Object.entries(this.currentSnapshot.rooms)), i = a.next(); !i.done; i = a.next()) {
var s = r(i.value, 2), c = s[0], l = s[1];
n.roomsEvaluated++;
var u = this.isWarRoom(c) ? this.config.budgetLimits.warRoom : this.config.budgetLimits.ecoRoom, f = l.profiler.avgCpu, m = f / u;
m >= this.config.budgetAlertThresholds.critical ? (n.roomsOverBudget++, n.alerts.push({
severity: "critical",
target: c,
targetType: "room",
cpuUsed: f,
budgetLimit: u,
percentUsed: m,
tick: Game.time
})) : m >= this.config.budgetAlertThresholds.warning ? (n.alerts.push({
severity: "warning",
target: c,
targetType: "room",
cpuUsed: f,
budgetLimit: u,
percentUsed: m,
tick: Game.time
}), n.roomsWithinBudget++) : n.roomsWithinBudget++;
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (e) throw e.error;
}
}
return n;
}, s.prototype.detectAnomalies = function() {
var e, n, a, i, s, c, l, u;
if (!this.config.anomalyDetection.enabled) return [];
var f = [];
try {
for (var m = t(Object.entries(this.currentSnapshot.rooms)), p = m.next(); !p.done; p = m.next()) {
var d = r(p.value, 2), y = d[0], g = d[1];
if (!(g.profiler.samples < this.config.anomalyDetection.minSamples)) {
var h = null !== (s = this.roomMeasurements.get(y)) && void 0 !== s ? s : 0;
if (!((O = g.profiler.avgCpu) < .01)) {
var v = h / O;
if (v >= this.config.anomalyDetection.spikeThreshold) {
var R = o.memoryManager.getSwarmState(y), E = R ? "RCL ".concat(null !== (u = null === (l = null === (c = Game.rooms[y]) || void 0 === c ? void 0 : c.controller) || void 0 === l ? void 0 : l.level) && void 0 !== u ? u : 0, ", posture: ").concat(R.posture, ", danger: ").concat(R.danger) : void 0;
f.push({
type: "spike",
target: y,
targetType: "room",
current: h,
baseline: O,
multiplier: v,
tick: Game.time,
context: E
});
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (e) throw e.error;
}
}
try {
for (var T = t(Object.entries(this.currentSnapshot.processes)), S = T.next(); !S.done; S = T.next()) {
var C = r(S.value, 2), b = C[0], _ = C[1];
if (!(_.runCount < this.config.anomalyDetection.minSamples)) {
h = _.maxCpu;
var O = _.avgCpu;
if (!(Game.time - _.lastRunTick > 100 || O < .01) && (h >= O * this.config.anomalyDetection.spikeThreshold && f.push({
type: "spike",
target: b,
targetType: "process",
current: h,
baseline: O,
multiplier: h / O,
tick: Game.time,
context: "".concat(_.name, " (").concat(_.frequency, ")")
}), _.cpuBudget > 0)) {
var w = O / _.cpuBudget;
w >= 1.5 && f.push({
type: "sustained_high",
target: b,
targetType: "process",
current: O,
baseline: _.cpuBudget,
multiplier: w,
tick: Game.time,
context: "".concat(_.name, " (").concat(_.frequency, ")")
});
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
S && !S.done && (i = T.return) && i.call(T);
} finally {
if (a) throw a.error;
}
}
return f;
}, s.prototype.createEmptySnapshot = function() {
return {
tick: Game.time,
timestamp: Date.now(),
cpu: {
used: 0,
limit: 0,
bucket: 0,
percent: 0,
heapUsed: 0
},
progression: {
gcl: {
level: 0,
progress: 0,
progressTotal: 1,
progressPercent: 0
},
gpl: {
level: 0,
progress: 0,
progressTotal: 0,
progressPercent: 0
}
},
empire: {
rooms: 0,
creeps: 0,
powerCreeps: {
total: 0,
spawned: 0,
eco: 0,
combat: 0
},
energy: {
storage: 0,
terminal: 0,
available: 0,
capacity: 0
},
credits: 0,
skippedProcesses: 0
},
rooms: {},
subsystems: {},
roles: {},
native: this.createEmptyNativeCalls(),
processes: {},
creeps: {},
kernelBudgets: {
adaptiveBudgetsEnabled: !1,
roomCount: 0,
roomMultiplier: 1,
bucketMultiplier: 1,
budgets: {
high: 0,
medium: 0,
low: 0
},
totalAllocated: 0,
totalUsed: 0,
utilizationRatio: 0
},
cache: {
roomFind: {
rooms: 0,
totalEntries: 0,
hits: 0,
misses: 0,
invalidations: 0,
hitRate: 0
},
bodyPart: {
size: 0
},
object: {
size: 0
},
path: {
size: 0,
maxSize: 0,
hits: 0,
misses: 0,
evictions: 0,
hitRate: 0
},
role: {
totalEntries: 0
},
global: {
hits: 0,
misses: 0,
hitRate: 0,
size: 0,
evictions: 0
}
},
pathfinding: {
totalCalls: 0,
cacheHits: 0,
cacheMisses: 0,
cacheHitRate: 0,
cpuUsed: 0,
avgCpuPerCall: 0,
cpuSaved: 0,
callsByType: {
moveTo: 0,
pathFinderSearch: 0,
findPath: 0,
moveByPath: 0
}
}
};
}, s.prototype.createEmptyNativeCalls = function() {
return {
pathfinderSearch: 0,
moveTo: 0,
move: 0,
harvest: 0,
transfer: 0,
withdraw: 0,
build: 0,
repair: 0,
upgradeController: 0,
attack: 0,
rangedAttack: 0,
heal: 0,
dismantle: 0,
say: 0,
total: 0
};
}, s.prototype.finalizeEmpireStats = function() {
var e, t = Object.values(this.currentSnapshot.rooms), r = Object.keys(Game.creeps).length, n = Object.values(Game.powerCreeps), a = n.filter(function(e) {
return void 0 !== e.ticksToLive;
}), i = n.filter(function(e) {
return "powerQueen" === e.memory.role;
}), s = n.filter(function(e) {
return "powerWarrior" === e.memory.role;
});
try {
var c = o.shardManager.getCurrentShardState();
c && (e = {
name: c.name,
role: c.role,
cpuUsage: c.health.cpuUsage,
cpuCategory: c.health.cpuCategory,
bucketLevel: c.health.bucketLevel,
economyIndex: c.health.economyIndex,
warIndex: c.health.warIndex,
avgRCL: c.health.avgRCL,
portalsCount: c.portals.length,
activeTasksCount: c.activeTasks.length
});
} catch (e) {}
this.currentSnapshot.empire = {
rooms: t.length,
creeps: r,
powerCreeps: {
total: n.length,
spawned: a.length,
eco: i.length,
combat: s.length
},
energy: {
storage: t.reduce(function(e, t) {
return e + t.energy.storage;
}, 0),
terminal: t.reduce(function(e, t) {
return e + t.energy.terminal;
}, 0),
available: t.reduce(function(e, t) {
return e + t.energy.available;
}, 0),
capacity: t.reduce(function(e, t) {
return e + t.energy.capacity;
}, 0)
},
credits: Game.market.credits,
skippedProcesses: this.skippedProcessesThisTick,
shard: e
};
}, s.prototype.finalizeSubsystemStats = function() {
var e, o, n, a, i, s, c, l, u, f = this.getProfilerMemory(), m = function(e, r) {
var o, m, d = r.reduce(function(e, t) {
return e + t;
}, 0), y = e.startsWith("role:"), g = y ? e.substring(5) : e;
if (y) {
var h = Object.values(Game.creeps).filter(function(e) {
return e.memory.role === g;
}), v = h.length, R = 0, E = 0, T = 0, S = 0, C = 0;
try {
for (var b = (o = void 0, t(h)), _ = b.next(); !_.done; _ = b.next()) {
var O = _.value, w = O.memory, x = null !== (a = null === (n = w.state) || void 0 === n ? void 0 : n.action) && void 0 !== a ? a : "idle", U = null !== (i = w.working) && void 0 !== i ? i : "idle" !== x;
C += O.body.length, S += null !== (s = O.ticksToLive) && void 0 !== s ? s : 0, O.spawning ? R++ : U && "idle" !== x ? T++ : E++;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
_ && !_.done && (m = b.return) && m.call(b);
} finally {
if (o) throw o.error;
}
}
var M = r.length > 0 ? d / r.length : 0, A = (N = null === (c = f.roles) || void 0 === c ? void 0 : c[g]) ? N.avgCpu * (1 - p.config.smoothingFactor) + M * p.config.smoothingFactor : M, k = N ? Math.max(N.peakCpu, M) : M;
p.currentSnapshot.roles[g] = {
name: g,
count: v,
avgCpu: A,
peakCpu: k,
calls: r.length,
samples: (null !== (l = null == N ? void 0 : N.samples) && void 0 !== l ? l : 0) + 1,
spawningCount: R,
idleCount: E,
activeCount: T,
avgTicksToLive: v > 0 ? S / v : 0,
totalBodyParts: C
}, f.roles || (f.roles = {}), f.roles[g] = {
avgCpu: A,
peakCpu: k,
samples: p.currentSnapshot.roles[g].samples,
callsThisTick: r.length
};
} else {
var N;
A = (N = f.subsystems[g]) ? N.avgCpu * (1 - p.config.smoothingFactor) + d * p.config.smoothingFactor : d, 
k = N ? Math.max(N.peakCpu, d) : d, p.currentSnapshot.subsystems[g] = {
name: g,
avgCpu: A,
peakCpu: k,
calls: r.length,
samples: (null !== (u = null == N ? void 0 : N.samples) && void 0 !== u ? u : 0) + 1
}, f.subsystems[g] = {
avgCpu: A,
peakCpu: k,
samples: p.currentSnapshot.subsystems[g].samples,
callsThisTick: r.length
};
}
}, p = this;
try {
for (var d = t(this.subsystemMeasurements), y = d.next(); !y.done; y = d.next()) {
var g = r(y.value, 2);
m(g[0], g[1]);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
y && !y.done && (o = d.return) && o.call(d);
} finally {
if (e) throw e.error;
}
}
}, s.prototype.finalizeCreepStats = function() {
var e, r, o, n, a, i, s;
try {
for (var c = t(Object.values(Game.creeps)), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (!this.currentSnapshot.creeps[u.name]) {
var f = u.memory, m = null !== (n = null === (o = f.state) || void 0 === o ? void 0 : o.action) && void 0 !== n ? n : f.working ? "working" : "idle";
this.currentSnapshot.creeps[u.name] = {
name: u.name,
role: null !== (a = f.role) && void 0 !== a ? a : "unknown",
homeRoom: null !== (i = f.homeRoom) && void 0 !== i ? i : u.room.name,
currentRoom: u.room.name,
cpu: 0,
action: m,
ticksToLive: null !== (s = u.ticksToLive) && void 0 !== s ? s : 0,
hits: u.hits,
hitsMax: u.hitsMax,
bodyParts: u.body.length,
fatigue: u.fatigue,
actionsThisTick: 0
};
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (r = c.return) && r.call(c);
} finally {
if (e) throw e.error;
}
}
}, s.prototype.finalizeCacheStats = function() {
var e = (0, o.getRoomFindCacheStats)(), t = (0, o.getBodyPartCacheStats)(), r = (0, 
o.getObjectCacheStats)(), n = (0, o.getPathCacheStats)(), a = (0, o.getRoleCacheStats)(), i = o.globalCache.getCacheStats();
this.currentSnapshot.cache = {
roomFind: e,
bodyPart: {
size: t.size
},
object: {
size: r.size
},
path: n,
role: a,
global: i
};
}, s.prototype.finalizePathfindingStats = function() {
this.currentSnapshot.pathfinding = a.pathfindingMetrics.getMetrics();
}, s.prototype.publishToConsole = function() {
var e = Memory;
if (e.stats && "object" == typeof e.stats) {
var t = {
type: "stats",
tick: "undefined" != typeof Game ? Game.time : 0,
data: e.stats
};
console.log(JSON.stringify(t));
}
}, s.prototype.publishToMemory = function() {
var o, n, a, i, s, c, l, u, f, m, p = Memory, d = this.currentSnapshot;
p.stats = {
tick: d.tick,
timestamp: d.timestamp,
cpu: {
used: d.cpu.used,
limit: d.cpu.limit,
bucket: d.cpu.bucket,
percent: d.cpu.percent,
heap_mb: d.cpu.heapUsed
},
kernel: {
adaptive_budgets_enabled: d.kernelBudgets.adaptiveBudgetsEnabled,
room_count: d.kernelBudgets.roomCount,
room_multiplier: d.kernelBudgets.roomMultiplier,
bucket_multiplier: d.kernelBudgets.bucketMultiplier,
budget_high: d.kernelBudgets.budgets.high,
budget_medium: d.kernelBudgets.budgets.medium,
budget_low: d.kernelBudgets.budgets.low,
total_allocated: d.kernelBudgets.totalAllocated,
total_used: d.kernelBudgets.totalUsed,
utilization_ratio: d.kernelBudgets.utilizationRatio
},
gcl: {
level: d.progression.gcl.level,
progress: d.progression.gcl.progress,
progress_total: d.progression.gcl.progressTotal,
progress_percent: d.progression.gcl.progressPercent
},
gpl: {
level: d.progression.gpl.level,
progress: d.progression.gpl.progress,
progress_total: d.progression.gpl.progressTotal,
progress_percent: d.progression.gpl.progressPercent
},
empire: {
rooms: d.empire.rooms,
creeps: d.empire.creeps,
power_creeps: {
total: d.empire.powerCreeps.total,
spawned: d.empire.powerCreeps.spawned,
eco: d.empire.powerCreeps.eco,
combat: d.empire.powerCreeps.combat
},
energy: {
storage: d.empire.energy.storage,
terminal: d.empire.energy.terminal,
available: d.empire.energy.available,
capacity: d.empire.energy.capacity
},
credits: d.empire.credits,
skipped_processes: d.empire.skippedProcesses,
shard: d.empire.shard ? {
name: d.empire.shard.name,
role: d.empire.shard.role,
cpu_usage: d.empire.shard.cpuUsage,
cpu_category: d.empire.shard.cpuCategory,
bucket_level: d.empire.shard.bucketLevel,
economy_index: d.empire.shard.economyIndex,
war_index: d.empire.shard.warIndex,
avg_rcl: d.empire.shard.avgRCL,
portals_count: d.empire.shard.portalsCount,
active_tasks_count: d.empire.shard.activeTasksCount
} : void 0
},
rooms: {},
subsystems: {},
roles: {},
native: {
pathfinder_search: d.native.pathfinderSearch,
move_to: d.native.moveTo,
move: d.native.move,
harvest: d.native.harvest,
transfer: d.native.transfer,
withdraw: d.native.withdraw,
build: d.native.build,
repair: d.native.repair,
upgrade_controller: d.native.upgradeController,
attack: d.native.attack,
ranged_attack: d.native.rangedAttack,
heal: d.native.heal,
dismantle: d.native.dismantle,
say: d.native.say,
total: d.native.total
}
};
try {
for (var y = t(Object.entries(d.rooms)), g = y.next(); !g.done; g = y.next()) {
var h = r(g.value, 2), v = h[0], R = h[1];
p.stats.rooms[v] = {
rcl: R.rcl,
energy: {
available: R.energy.available,
capacity: R.energy.capacity,
storage: R.energy.storage,
terminal: R.energy.terminal
},
controller: {
progress: R.controller.progress,
progress_total: R.controller.progressTotal,
progress_percent: R.controller.progressPercent
},
creeps: R.creeps,
hostiles: R.hostiles,
brain: {
danger: R.brain.danger,
posture_code: R.brain.postureCode,
colony_level_code: R.brain.colonyLevelCode
},
pheromones: e({}, R.pheromones),
metrics: {
energy: {
harvested: R.metrics.energyHarvested,
spawning: R.metrics.energySpawning,
construction: R.metrics.energyConstruction,
repair: R.metrics.energyRepair,
tower: R.metrics.energyTower,
available_for_sharing: R.metrics.energyAvailableForSharing,
capacity_total: R.metrics.energyCapacityTotal,
need: R.metrics.energyNeed
},
controller_progress: R.metrics.controllerProgress,
hostile_count: R.metrics.hostileCount,
damage_received: R.metrics.damageReceived,
construction_sites: R.metrics.constructionSites
},
profiler: {
avg_cpu: R.profiler.avgCpu,
peak_cpu: R.profiler.peakCpu,
samples: R.profiler.samples
}
};
}
} catch (e) {
o = {
error: e
};
} finally {
try {
g && !g.done && (n = y.return) && n.call(y);
} finally {
if (o) throw o.error;
}
}
try {
for (var E = t(Object.entries(d.subsystems)), T = E.next(); !T.done; T = E.next()) {
var S = r(T.value, 2), C = S[0], b = S[1];
p.stats.subsystems[C] = {
avg_cpu: b.avgCpu,
peak_cpu: b.peakCpu,
calls: b.calls,
samples: b.samples
};
}
} catch (e) {
a = {
error: e
};
} finally {
try {
T && !T.done && (i = E.return) && i.call(E);
} finally {
if (a) throw a.error;
}
}
try {
for (var _ = t(Object.entries(d.roles)), O = _.next(); !O.done; O = _.next()) {
var w = r(O.value, 2), x = (C = w[0], w[1]);
p.stats.roles[C] = {
count: x.count,
avg_cpu: x.avgCpu,
peak_cpu: x.peakCpu,
calls: x.calls,
samples: x.samples,
spawning_count: x.spawningCount,
idle_count: x.idleCount,
active_count: x.activeCount,
avg_ticks_to_live: x.avgTicksToLive,
total_body_parts: x.totalBodyParts
};
}
} catch (e) {
s = {
error: e
};
} finally {
try {
O && !O.done && (c = _.return) && c.call(_);
} finally {
if (s) throw s.error;
}
}
p.stats.processes = {};
try {
for (var U = t(Object.entries(d.processes)), M = U.next(); !M.done; M = U.next()) {
var A = r(M.value, 2), k = A[0], N = A[1];
p.stats.processes[k] = {
name: N.name,
priority: N.priority,
frequency: N.frequency,
state: N.state,
total_cpu: N.totalCpu,
run_count: N.runCount,
avg_cpu: N.avgCpu,
max_cpu: N.maxCpu,
last_run_tick: N.lastRunTick,
skipped_count: N.skippedCount,
error_count: N.errorCount,
cpu_budget: N.cpuBudget,
min_bucket: N.minBucket
};
}
} catch (e) {
l = {
error: e
};
} finally {
try {
M && !M.done && (u = U.return) && u.call(U);
} finally {
if (l) throw l.error;
}
}
p.stats.creeps = {};
try {
for (var P = t(Object.entries(d.creeps)), I = P.next(); !I.done; I = P.next()) {
var G = r(I.value, 2), L = (C = G[0], G[1]);
p.stats.creeps[C] = {
role: L.role,
home_room: L.homeRoom,
current_room: L.currentRoom,
cpu: L.cpu,
action: L.action,
ticks_to_live: L.ticksToLive,
hits: L.hits,
hits_max: L.hitsMax,
body_parts: L.bodyParts,
fatigue: L.fatigue,
actions_this_tick: L.actionsThisTick
};
}
} catch (e) {
f = {
error: e
};
} finally {
try {
I && !I.done && (m = P.return) && m.call(P);
} finally {
if (f) throw f.error;
}
}
}, s.prototype.updateSegment = function() {
if (this.config.enabled) if (void 0 !== RawMemory.segments[this.config.segmentId]) {
this.segmentRequested = !1;
var e = 102400, t = [], r = RawMemory.segments[this.config.segmentId];
if (r) try {
var n = JSON.parse(r);
Array.isArray(n) && (t = n);
} catch (e) {
var a = e instanceof Error ? e.message : String(e);
o.logger.error("Failed to parse stats segment: ".concat(a), {
subsystem: "Stats"
});
}
t.push(this.currentSnapshot), t.length > this.config.maxHistoryPoints && (t = t.slice(-this.config.maxHistoryPoints));
var i = JSON.stringify(t);
if (i.length > e) {
for (o.logger.warn("Stats segment size ".concat(i.length, " exceeds ").concat(e, " bytes, trimming history"), {
subsystem: "Stats"
}); i.length > e && t.length > 1; ) t.shift(), i = JSON.stringify(t);
if (i.length > e) return void o.logger.error("Failed to persist stats segment within ".concat(e, " bytes after trimming"), {
subsystem: "Stats"
});
}
try {
RawMemory.segments[this.config.segmentId] = i;
} catch (e) {
a = e instanceof Error ? e.message : String(e), o.logger.error("Failed to save stats segment: ".concat(a), {
subsystem: "Stats"
});
}
} else this.segmentRequested || (RawMemory.setActiveSegments([ this.config.segmentId ]), 
this.segmentRequested = !0);
}, s.prototype.getProfilerMemory = function() {
var e = Memory;
return e.stats && "object" == typeof e.stats || (e.stats = {}), e.stats.profiler || (e.stats.profiler = {
rooms: {},
subsystems: {},
roles: {},
tickCount: 0,
lastUpdate: 0
}), e.stats.profiler;
}, s.prototype.logSummary = function() {
var e, r, n, a, i, s, c, l, u, f, m = this.currentSnapshot;
o.logger.info("=== Unified Stats Summary ==="), o.logger.info("CPU: ".concat(m.cpu.used.toFixed(2), "/").concat(m.cpu.limit, " (").concat(m.cpu.percent.toFixed(1), "%) | Bucket: ").concat(m.cpu.bucket)), 
o.logger.info("Empire: ".concat(m.empire.rooms, " rooms, ").concat(m.empire.creeps, " creeps, ").concat(m.empire.credits, " credits"));
var p = Object.values(m.subsystems).sort(function(e, t) {
return t.avgCpu - e.avgCpu;
}).slice(0, 5);
if (p.length > 0) {
o.logger.info("Top Subsystems:");
try {
for (var d = t(p), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
o.logger.info("  ".concat(g.name, ": ").concat(g.avgCpu.toFixed(3), " CPU"));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
y && !y.done && (r = d.return) && r.call(d);
} finally {
if (e) throw e.error;
}
}
}
var h = Object.values(m.roles).sort(function(e, t) {
return t.avgCpu - e.avgCpu;
}).slice(0, 5);
if (h.length > 0) {
o.logger.info("Top Roles:");
try {
for (var v = t(h), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
o.logger.info("  ".concat(E.name, ": ").concat(E.count, " creeps, ").concat(E.avgCpu.toFixed(3), " CPU"));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
R && !R.done && (a = v.return) && a.call(v);
} finally {
if (n) throw n.error;
}
}
}
var T = Object.values(m.processes).sort(function(e, t) {
return t.avgCpu - e.avgCpu;
}).slice(0, 5);
if (T.length > 0) {
o.logger.info("Top Processes:");
try {
for (var S = t(T), C = S.next(); !C.done; C = S.next()) {
var b = C.value;
o.logger.info("  ".concat(b.name, ": ").concat(b.avgCpu.toFixed(3), " CPU (runs: ").concat(b.runCount, ", state: ").concat(b.state, ")"));
}
} catch (e) {
i = {
error: e
};
} finally {
try {
C && !C.done && (s = S.return) && s.call(S);
} finally {
if (i) throw i.error;
}
}
}
var _ = Object.values(m.rooms).sort(function(e, t) {
return t.profiler.avgCpu - e.profiler.avgCpu;
}).slice(0, 5);
if (_.length > 0) {
o.logger.info("Top Rooms by CPU:");
try {
for (var O = t(_), w = O.next(); !w.done; w = O.next()) {
var x = w.value;
o.logger.info("  ".concat(x.name, ": ").concat(x.profiler.avgCpu.toFixed(3), " CPU (RCL ").concat(x.rcl, ")"));
}
} catch (e) {
c = {
error: e
};
} finally {
try {
w && !w.done && (l = O.return) && l.call(O);
} finally {
if (c) throw c.error;
}
}
}
var U = Object.values(m.creeps).sort(function(e, t) {
return t.cpu - e.cpu;
}).slice(0, 5);
if (U.length > 0) {
o.logger.info("Top Creeps by CPU:");
try {
for (var M = t(U), A = M.next(); !A.done; A = M.next()) {
var k = A.value;
o.logger.info("  ".concat(k.name, " (").concat(k.role, "): ").concat(k.cpu.toFixed(3), " CPU in ").concat(k.currentRoom));
}
} catch (e) {
u = {
error: e
};
} finally {
try {
A && !A.done && (f = M.return) && f.call(M);
} finally {
if (u) throw u.error;
}
}
}
this.config.trackNativeCalls && o.logger.info("Native calls: ".concat(m.native.total, " total"));
}, s.prototype.postureToCode = function(e) {
var t;
return null !== (t = {
eco: 0,
expand: 1,
defensive: 2,
war: 3,
siege: 4,
evacuate: 5,
nukePrep: 6
}[e]) && void 0 !== t ? t : -1;
}, s.prototype.postureCodeToName = function(e) {
var t;
return null !== (t = s.POSTURE_NAMES[e]) && void 0 !== t ? t : "eco";
}, s.prototype.colonyLevelToCode = function(e) {
var t;
return null !== (t = {
seedNest: 1,
foragingExpansion: 2,
matureColony: 3,
fortifiedHive: 4,
empireDominance: 5
}[e]) && void 0 !== t ? t : 0;
}, s.prototype.getSnapshot = function() {
return this.currentSnapshot;
}, s.prototype.setEnabled = function(e) {
this.config.enabled = e;
}, s.prototype.isEnabled = function() {
return this.config.enabled;
}, s.prototype.reset = function() {
var e;
this.currentSnapshot = this.createEmptySnapshot();
var t = Memory;
(null === (e = t.stats) || void 0 === e ? void 0 : e.profiler) && (t.stats.profiler = {
rooms: {},
subsystems: {},
roles: {},
tickCount: 0,
lastUpdate: 0
});
}, s.prototype.getCurrentSnapshot = function() {
return e({}, this.currentSnapshot);
}, s.POSTURE_NAMES = [ "eco", "expand", "defensive", "war", "siege", "evacuate", "nukePrep" ], 
s;
}();
return ho.UnifiedStatsManager = s, ho.unifiedStats = new s, ho;
}();
Object.defineProperty(e, "UnifiedStatsManager", {
enumerable: !0,
get: function() {
return o.UnifiedStatsManager;
}
}), Object.defineProperty(e, "unifiedStats", {
enumerable: !0,
get: function() {
return o.unifiedStats;
}
});
var n = function() {
if (wo) return ko;
wo = 1;
var e = ko && ko.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = ko && ko.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = ko && ko.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, o = ko && ko.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(ko, "__esModule", {
value: !0
}), ko.memorySegmentStats = ko.MemorySegmentStats = void 0;
var n = Ro(), a = {
primarySegment: 90,
backupSegment: 91,
retentionPeriod: 1e4,
updateInterval: 50,
maxDataPoints: 1e3
}, i = function() {
function i(t) {
void 0 === t && (t = {}), this.statsData = null, this.segmentRequested = !1, this.lastUpdate = 0, 
this.config = e(e({}, a), t);
}
return i.prototype.initialize = function() {
RawMemory.setActiveSegments([ this.config.primarySegment ]), this.segmentRequested = !0;
}, i.prototype.run = function() {
this.segmentRequested && void 0 !== RawMemory.segments[this.config.primarySegment] && (this.loadFromSegment(), 
this.segmentRequested = !1), Game.time - this.lastUpdate >= this.config.updateInterval && (this.updateStats(), 
this.lastUpdate = Game.time);
}, i.prototype.loadFromSegment = function() {
var e = RawMemory.segments[this.config.primarySegment];
if (e && 0 !== e.length) try {
this.statsData = JSON.parse(e), n.logger.debug("Loaded stats from segment", {
subsystem: "Stats"
});
} catch (e) {
var t = e instanceof Error ? e.message : String(e);
n.logger.error("Failed to parse stats segment: ".concat(t), {
subsystem: "Stats"
}), this.statsData = this.createDefaultStatsData();
} else this.statsData = this.createDefaultStatsData();
}, i.prototype.createDefaultStatsData = function() {
return {
version: 1,
lastUpdate: Game.time,
history: [],
series: {}
};
}, i.prototype.updateStats = function() {
this.statsData || (this.statsData = this.createDefaultStatsData());
var e = this.collectGlobalStats();
for (this.statsData.history.push(e); this.statsData.history.length > this.config.maxDataPoints; ) this.statsData.history.shift();
var t = Game.time - this.config.retentionPeriod;
this.statsData.history = this.statsData.history.filter(function(e) {
return e.tick >= t;
}), this.updateMetricSeries("cpu", e.cpuUsed), this.updateMetricSeries("bucket", e.cpuBucket), 
this.updateMetricSeries("creeps", e.totalCreeps), this.updateMetricSeries("rooms", e.totalRooms), 
this.publishStatsToMemory(e), this.saveToSegment();
}, i.prototype.publishStatsToMemory = function(e) {
var o, a, i, s, c = Memory;
c.stats && "object" == typeof c.stats || (c.stats = {});
var l = c.stats;
l["stats.cpu.used"] = e.cpuUsed, l["stats.cpu.limit"] = e.cpuLimit, l["stats.cpu.bucket"] = e.cpuBucket, 
l["stats.cpu.percent"] = e.cpuLimit > 0 ? e.cpuUsed / e.cpuLimit * 100 : 0, l["stats.gcl.level"] = e.gclLevel, 
l["stats.gcl.progress"] = e.gclProgress, l["stats.gcl.progress_total"] = e.gclProgressTotal, 
l["stats.gpl.level"] = e.gplLevel, l["stats.empire.creeps"] = e.totalCreeps, l["stats.empire.rooms"] = e.totalRooms;
var u = e.rooms.reduce(function(e, t) {
return {
storage: e.storage + t.storageEnergy,
terminal: e.terminal + t.terminalEnergy,
available: e.available + t.energyAvailable,
capacity: e.capacity + t.energyCapacity
};
}, {
storage: 0,
terminal: 0,
available: 0,
capacity: 0
});
l["stats.empire.energy.storage"] = u.storage, l["stats.empire.energy.terminal"] = u.terminal, 
l["stats.empire.energy.available"] = u.available, l["stats.empire.energy.capacity"] = u.capacity;
try {
for (var f = t(e.rooms), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = "stats.room.".concat(p.roomName);
l["".concat(d, ".rcl")] = p.rcl, l["".concat(d, ".energy.available")] = p.energyAvailable, 
l["".concat(d, ".energy.capacity")] = p.energyCapacity, l["".concat(d, ".storage.energy")] = p.storageEnergy, 
l["".concat(d, ".terminal.energy")] = p.terminalEnergy, l["".concat(d, ".creeps")] = p.creepCount, 
l["".concat(d, ".controller.progress")] = p.controllerProgress, l["".concat(d, ".controller.progress_total")] = p.controllerProgressTotal, 
l["".concat(d, ".controller.progress_percent")] = p.controllerProgressTotal > 0 ? p.controllerProgress / p.controllerProgressTotal * 100 : 0;
var y = n.memoryManager.getSwarmState(p.roomName);
if (y) {
if (l["".concat(d, ".brain.danger")] = y.danger, l["".concat(d, ".brain.posture_code")] = this.postureToCode(y.posture), 
l["".concat(d, ".brain.colony_level_code")] = this.colonyLevelToCode(y.colonyLevel), 
y.pheromones) try {
for (var g = (i = void 0, t(Object.entries(y.pheromones))), h = g.next(); !h.done; h = g.next()) {
var v = r(h.value, 2), R = v[0], E = v[1];
l["".concat(d, ".pheromone.").concat(R)] = E;
}
} catch (e) {
i = {
error: e
};
} finally {
try {
h && !h.done && (s = g.return) && s.call(g);
} finally {
if (i) throw i.error;
}
}
var T = y.metrics;
T && (l["".concat(d, ".metrics.energy.harvested")] = T.energyHarvested, l["".concat(d, ".metrics.energy.spawning")] = T.energySpawning, 
l["".concat(d, ".metrics.energy.construction")] = T.energyConstruction, l["".concat(d, ".metrics.energy.repair")] = T.energyRepair, 
l["".concat(d, ".metrics.energy.tower")] = T.energyTower, l["".concat(d, ".metrics.energy.available_for_sharing")] = T.energyAvailable, 
l["".concat(d, ".metrics.energy.capacity_total")] = T.energyCapacity, l["".concat(d, ".metrics.energy.need")] = T.energyNeed, 
l["".concat(d, ".metrics.controller_progress")] = T.controllerProgress, l["".concat(d, ".metrics.hostile_count")] = T.hostileCount, 
l["".concat(d, ".metrics.damage_received")] = T.damageReceived, l["".concat(d, ".metrics.construction_sites")] = T.constructionSites);
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (o) throw o.error;
}
}
l["stats.system.tick"] = e.tick, l["stats.system.timestamp"] = Date.now();
}, i.prototype.collectGlobalStats = function() {
var e, t, r, o, n = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), a = new Map;
for (var i in Game.creeps) {
var s = Game.creeps[i];
if (!s.spawning && (null === (e = s.room.controller) || void 0 === e ? void 0 : e.my)) {
var c = null !== (t = a.get(s.room.name)) && void 0 !== t ? t : 0;
a.set(s.room.name, c + 1);
}
}
var l = n.map(function(e) {
var t, r, o, n, i, s, c, l, u, f, m;
return {
roomName: e.name,
rcl: null !== (r = null === (t = e.controller) || void 0 === t ? void 0 : t.level) && void 0 !== r ? r : 0,
energyAvailable: e.energyAvailable,
energyCapacity: e.energyCapacityAvailable,
storageEnergy: null !== (n = null === (o = e.storage) || void 0 === o ? void 0 : o.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== n ? n : 0,
terminalEnergy: null !== (s = null === (i = e.terminal) || void 0 === i ? void 0 : i.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== s ? s : 0,
creepCount: null !== (c = a.get(e.name)) && void 0 !== c ? c : 0,
controllerProgress: null !== (u = null === (l = e.controller) || void 0 === l ? void 0 : l.progress) && void 0 !== u ? u : 0,
controllerProgressTotal: null !== (m = null === (f = e.controller) || void 0 === f ? void 0 : f.progressTotal) && void 0 !== m ? m : 1
};
});
return {
tick: Game.time,
cpuUsed: Game.cpu.getUsed(),
cpuLimit: Game.cpu.limit,
cpuBucket: Game.cpu.bucket,
gclLevel: Game.gcl.level,
gclProgress: Game.gcl.progress,
gclProgressTotal: Game.gcl.progressTotal,
gplLevel: null !== (o = null === (r = Game.gpl) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0,
totalCreeps: Object.keys(Game.creeps).length,
totalRooms: n.length,
rooms: l,
metrics: {}
};
}, i.prototype.updateMetricSeries = function(e, t) {
if (this.statsData) {
var n = this.statsData.series[e];
n || (n = {
name: e,
data: [],
lastUpdate: Game.time,
min: t,
max: t,
avg: t
}, this.statsData.series[e] = n), n.data.push({
tick: Game.time,
value: t
}), n.lastUpdate = Game.time;
var a = Game.time - this.config.retentionPeriod;
for (n.data = n.data.filter(function(e) {
return e.tick >= a;
}); n.data.length > this.config.maxDataPoints; ) n.data.shift();
n.data.length > 0 && (n.min = Math.min.apply(Math, o([], r(n.data.map(function(e) {
return e.value;
})), !1)), n.max = Math.max.apply(Math, o([], r(n.data.map(function(e) {
return e.value;
})), !1)), n.avg = n.data.reduce(function(e, t) {
return e + t.value;
}, 0) / n.data.length);
}
}, i.prototype.saveToSegment = function() {
var e, r, o, a;
if (this.statsData) {
var i = 102400;
try {
this.statsData.lastUpdate = Game.time;
var s = JSON.stringify(this.statsData);
if (s.length > i) {
for (n.logger.warn("Stats data exceeds segment limit: ".concat(s.length, " bytes, trimming..."), {
subsystem: "Stats"
}); s.length > i && this.statsData.history.length > 10; ) this.statsData.history.shift(), 
s = JSON.stringify(this.statsData);
if (s.length > i) try {
for (var c = t(Object.keys(this.statsData.series)), l = c.next(); !l.done; l = c.next()) for (var u = l.value, f = this.statsData.series[u]; f.data.length > 10 && s.length > i; ) f.data.shift(), 
s = JSON.stringify(this.statsData);
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (r = c.return) && r.call(c);
} finally {
if (e) throw e.error;
}
}
if (s.length > i) {
n.logger.warn("Stats data still exceeds limit after trimming, clearing history", {
subsystem: "Stats"
}), this.statsData.history = this.statsData.history.slice(-5);
try {
for (var m = t(Object.keys(this.statsData.series)), p = m.next(); !p.done; p = m.next()) u = p.value, 
this.statsData.series[u].data = this.statsData.series[u].data.slice(-5);
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (o) throw o.error;
}
}
s = JSON.stringify(this.statsData);
}
}
RawMemory.segments[this.config.primarySegment] = s;
} catch (e) {
var d = e instanceof Error ? e.message : String(e);
n.logger.error("Failed to save stats segment: ".concat(d), {
subsystem: "Stats"
});
}
}
}, i.prototype.recordMetric = function(e, t) {
this.updateMetricSeries(e, t);
}, i.prototype.getLatestStats = function() {
var e;
return this.statsData && 0 !== this.statsData.history.length && null !== (e = this.statsData.history[this.statsData.history.length - 1]) && void 0 !== e ? e : null;
}, i.prototype.getMetricSeries = function(e) {
var t, r;
return null !== (r = null === (t = this.statsData) || void 0 === t ? void 0 : t.series[e]) && void 0 !== r ? r : null;
}, i.prototype.getMetricNames = function() {
var e, t;
return Object.keys(null !== (t = null === (e = this.statsData) || void 0 === e ? void 0 : e.series) && void 0 !== t ? t : {});
}, i.prototype.getHistory = function(e) {
if (!this.statsData) return [];
var t = this.statsData.history;
return e ? t.slice(-e) : t;
}, i.prototype.getRoomHistory = function(e, t) {
if (!this.statsData) return [];
var r = this.statsData.history.map(function(t) {
return t.rooms.find(function(t) {
return t.roomName === e;
});
}).filter(function(e) {
return void 0 !== e;
});
return t ? r.slice(-t) : r;
}, i.prototype.exportForGraphana = function() {
var e, r, o = this.getLatestStats();
if (!o) return "{}";
var n = {
timestamp: (new Date).toISOString(),
tick: o.tick,
cpu: {
used: o.cpuUsed,
limit: o.cpuLimit,
bucket: o.cpuBucket
},
gcl: {
level: o.gclLevel,
progress: o.gclProgress,
progressTotal: o.gclProgressTotal
},
gpl: {
level: o.gplLevel
},
empire: {
totalCreeps: o.totalCreeps,
totalRooms: o.totalRooms
},
rooms: {}
};
try {
for (var a = t(o.rooms), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
n.rooms[s.roomName] = {
rcl: s.rcl,
energyAvailable: s.energyAvailable,
energyCapacity: s.energyCapacity,
storageEnergy: s.storageEnergy,
terminalEnergy: s.terminalEnergy,
creepCount: s.creepCount,
controllerProgress: s.controllerProgress,
controllerProgressTotal: s.controllerProgressTotal
};
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (r = a.return) && r.call(a);
} finally {
if (e) throw e.error;
}
}
return JSON.stringify(n, null, 2);
}, i.prototype.clear = function() {
this.statsData = this.createDefaultStatsData(), this.saveToSegment();
}, i.prototype.postureToCode = function(e) {
var t;
return null !== (t = {
eco: 0,
expand: 1,
defensive: 2,
war: 3,
siege: 4,
evacuate: 5,
nukePrep: 6
}[e]) && void 0 !== t ? t : -1;
}, i.prototype.colonyLevelToCode = function(e) {
var t;
return null !== (t = {
seedNest: 1,
foragingExpansion: 2,
matureColony: 3,
fortifiedHive: 4,
empireDominance: 5
}[e]) && void 0 !== t ? t : 0;
}, i;
}();
return ko.MemorySegmentStats = i, ko.memorySegmentStats = new i, ko;
}();
Object.defineProperty(e, "MemorySegmentStats", {
enumerable: !0,
get: function() {
return n.MemorySegmentStats;
}
}), Object.defineProperty(e, "memorySegmentStats", {
enumerable: !0,
get: function() {
return n.memorySegmentStats;
}
});
var a = Oo();
Object.defineProperty(e, "pathfindingMetrics", {
enumerable: !0,
get: function() {
return a.pathfindingMetrics;
}
}), Object.defineProperty(e, "trackPathfindingCall", {
enumerable: !0,
get: function() {
return a.trackPathfindingCall;
}
});
var i = So();
Object.defineProperty(e, "calculateRoomScalingMultiplier", {
enumerable: !0,
get: function() {
return i.calculateRoomScalingMultiplier;
}
}), Object.defineProperty(e, "calculateBucketMultiplier", {
enumerable: !0,
get: function() {
return i.calculateBucketMultiplier;
}
}), Object.defineProperty(e, "getAdaptiveBudgetInfo", {
enumerable: !0,
get: function() {
return i.getAdaptiveBudgetInfo;
}
}), Object.defineProperty(e, "getAdaptiveBudgets", {
enumerable: !0,
get: function() {
return i.getAdaptiveBudgets;
}
}), Object.defineProperty(e, "calculateAdaptiveBudget", {
enumerable: !0,
get: function() {
return i.calculateAdaptiveBudget;
}
}), Object.defineProperty(e, "calculateAdaptiveBudgets", {
enumerable: !0,
get: function() {
return i.calculateAdaptiveBudgets;
}
}), Object.defineProperty(e, "DEFAULT_ADAPTIVE_CONFIG", {
enumerable: !0,
get: function() {
return i.DEFAULT_ADAPTIVE_CONFIG;
}
});
var s = function() {
if (xo) return No;
function e(e) {
e._metrics || (e._metrics = {
tasksCompleted: 0,
energyTransferred: 0,
energyHarvested: 0,
buildProgress: 0,
repairProgress: 0,
upgradeProgress: 0,
damageDealt: 0,
healingDone: 0
});
}
function t(t) {
return e(t), t._metrics;
}
return xo = 1, Object.defineProperty(No, "__esModule", {
value: !0
}), No.initializeMetrics = e, No.getMetrics = t, No.recordHarvest = function(e, r) {
t(e).energyHarvested += r;
}, No.recordTransfer = function(e, r) {
t(e).energyTransferred += r;
}, No.recordBuild = function(e, r) {
t(e).buildProgress += r;
}, No.recordRepair = function(e, r) {
t(e).repairProgress += r;
}, No.recordUpgrade = function(e, r) {
t(e).upgradeProgress += r;
}, No.recordDamage = function(e, r) {
t(e).damageDealt += r;
}, No.recordHealing = function(e, r) {
t(e).healingDone += r;
}, No.recordTaskComplete = function(e) {
t(e).tasksCompleted += 1;
}, No.getEfficiencySummary = function(e) {
if (!e._metrics) return "No metrics available";
var t = e._metrics, r = [];
return t.tasksCompleted > 0 && r.push("".concat(t.tasksCompleted, " tasks")), t.energyHarvested > 0 && r.push("".concat(t.energyHarvested, " harvested")), 
t.energyTransferred > 0 && r.push("".concat(t.energyTransferred, " transferred")), 
t.buildProgress > 0 && r.push("".concat(t.buildProgress, " built")), t.repairProgress > 0 && r.push("".concat(t.repairProgress, " repaired")), 
t.upgradeProgress > 0 && r.push("".concat(t.upgradeProgress, " upgraded")), t.damageDealt > 0 && r.push("".concat(t.damageDealt, " damage")), 
t.healingDone > 0 && r.push("".concat(t.healingDone, " healing")), r.length > 0 ? r.join(", ") : "No activity";
}, No.resetMetrics = function(e) {
e._metrics = {
tasksCompleted: 0,
energyTransferred: 0,
energyHarvested: 0,
buildProgress: 0,
repairProgress: 0,
upgradeProgress: 0,
damageDealt: 0,
healingDone: 0
};
}, No;
}();
Object.defineProperty(e, "initializeMetrics", {
enumerable: !0,
get: function() {
return s.initializeMetrics;
}
}), Object.defineProperty(e, "getMetrics", {
enumerable: !0,
get: function() {
return s.getMetrics;
}
}), Object.defineProperty(e, "recordHarvest", {
enumerable: !0,
get: function() {
return s.recordHarvest;
}
}), Object.defineProperty(e, "recordTransfer", {
enumerable: !0,
get: function() {
return s.recordTransfer;
}
}), Object.defineProperty(e, "recordBuild", {
enumerable: !0,
get: function() {
return s.recordBuild;
}
}), Object.defineProperty(e, "recordRepair", {
enumerable: !0,
get: function() {
return s.recordRepair;
}
}), Object.defineProperty(e, "recordUpgrade", {
enumerable: !0,
get: function() {
return s.recordUpgrade;
}
}), Object.defineProperty(e, "recordDamage", {
enumerable: !0,
get: function() {
return s.recordDamage;
}
}), Object.defineProperty(e, "recordHealing", {
enumerable: !0,
get: function() {
return s.recordHealing;
}
}), Object.defineProperty(e, "recordTaskComplete", {
enumerable: !0,
get: function() {
return s.recordTaskComplete;
}
}), Object.defineProperty(e, "getEfficiencySummary", {
enumerable: !0,
get: function() {
return s.getEfficiencySummary;
}
}), Object.defineProperty(e, "resetMetrics", {
enumerable: !0,
get: function() {
return s.resetMetrics;
}
}), r((Uo || (Uo = 1, Object.defineProperty(Po, "__esModule", {
value: !0
})), Po), e);
var c = Ro();
Object.defineProperty(e, "VisualizationLayer", {
enumerable: !0,
get: function() {
return c.VisualizationLayer;
}
});
}(go)), go);

!function(e) {
e[e.CRITICAL = 100] = "CRITICAL", e[e.HIGH = 75] = "HIGH", e[e.MEDIUM = 50] = "MEDIUM", 
e[e.LOW = 25] = "LOW", e[e.IDLE = 10] = "IDLE";
}(Ao || (Ao = {}));

var Go = {
targetCpuUsage: .98,
reservedCpuFraction: .02,
enableStats: !0,
statsLogInterval: 100,
budgetWarningThreshold: 1.5,
budgetWarningInterval: 500,
enableAdaptiveBudgets: !0,
adaptiveBudgetConfig: Io.DEFAULT_ADAPTIVE_CONFIG
};

function Lo(t) {
var r, o, n = t.bucketThresholds.highMode, a = t.bucketThresholds.lowMode, i = function(e) {
return Math.max(0, Math.floor(e / 2));
}(a), s = (r = t.taskFrequencies, {
high: 1,
medium: Math.max(1, Math.min(r.clusterLogic, r.pheromoneUpdate)),
low: Math.max(r.marketScan, r.nukeEvaluation, r.memoryCleanup)
}), c = (t.bucketThresholds, {
high: 0,
medium: 0,
low: 0
}), l = {
high: (o = t.budgets).rooms,
medium: o.strategic,
low: Math.max(o.market, o.visualization)
};
return e(e({}, Go), {
lowBucketThreshold: a,
highBucketThreshold: n,
criticalBucketThreshold: i,
frequencyIntervals: s,
frequencyMinBucket: c,
frequencyCpuBudgets: l
});
}

var Do, Fo, Bo, jo, Ho, Wo, Yo = function() {
function t(t) {
this.processes = new Map, this.bucketMode = "normal", this.tickCpuUsed = 0, this.initialized = !1, 
this.lastExecutedProcessId = null, this.lastExecutedIndex = -1, this.processQueue = [], 
this.queueDirty = !0, this.skippedProcessesThisTick = 0, this.config = e({}, t), 
this.validateConfig(), this.frequencyDefaults = this.buildFrequencyDefaults();
}
return t.prototype.registerProcess = function(e) {
var t, r, o, n, a, i = null !== (t = e.frequency) && void 0 !== t ? t : "medium", s = this.frequencyDefaults[i];
if (void 0 !== e.tickModulo) {
if (e.tickModulo < 0) throw Hr.error('Kernel: Cannot register process "'.concat(e.name, '" - tickModulo must be non-negative (got ').concat(e.tickModulo, ")"), {
subsystem: "Kernel"
}), new Error("Invalid tickModulo: ".concat(e.tickModulo, " (must be >= 0)"));
if (void 0 !== e.tickOffset && e.tickOffset >= e.tickModulo) throw Hr.error('Kernel: Cannot register process "'.concat(e.name, '" - tickOffset (').concat(e.tickOffset, ") must be less than tickModulo (").concat(e.tickModulo, ")"), {
subsystem: "Kernel"
}), new Error("Invalid tickOffset: ".concat(e.tickOffset, " (must be < tickModulo ").concat(e.tickModulo, ")"));
}
var c = null !== (r = e.interval) && void 0 !== r ? r : s.interval, l = Math.floor(.1 * c), u = Math.floor(Math.random() * (2 * l + 1)) - l, f = Math.max(1, c + u), m = {
id: e.id,
name: e.name,
priority: null !== (o = e.priority) && void 0 !== o ? o : Ao.MEDIUM,
frequency: i,
minBucket: null !== (n = e.minBucket) && void 0 !== n ? n : s.minBucket,
cpuBudget: null !== (a = e.cpuBudget) && void 0 !== a ? a : s.cpuBudget,
interval: f,
tickModulo: e.tickModulo,
tickOffset: e.tickOffset,
execute: e.execute,
state: "idle",
stats: {
totalCpu: 0,
runCount: 0,
avgCpu: 0,
maxCpu: 0,
lastRunTick: 0,
skippedCount: 0,
errorCount: 0,
consecutiveErrors: 0,
lastSuccessfulRunTick: 0,
healthScore: 100,
suspendedUntil: null,
suspensionReason: null
}
};
this.processes.set(e.id, m), this.queueDirty = !0, Hr.debug('Kernel: Registered process "'.concat(m.name, '" (').concat(m.id, ") with interval ").concat(f, " (base: ").concat(c, ", jitter: ").concat(u > 0 ? "+" : "").concat(u, ")"), {
subsystem: "Kernel"
});
}, t.prototype.unregisterProcess = function(e) {
var t = this.processes.delete(e);
return t && (this.queueDirty = !0, Hr.debug("Kernel: Unregistered process ".concat(e), {
subsystem: "Kernel"
})), t;
}, t.prototype.getProcess = function(e) {
return this.processes.get(e);
}, t.prototype.getProcesses = function() {
return Array.from(this.processes.values());
}, t.prototype.initialize = function() {
this.initialized || (Hr.info("Kernel initialized with ".concat(this.processes.size, " processes"), {
subsystem: "Kernel"
}), this.initialized = !0);
}, t.prototype.updateBucketMode = function() {
var e, t = Game.cpu.bucket;
if ((e = t < this.config.criticalBucketThreshold ? "critical" : t < this.config.lowBucketThreshold ? "low" : t > this.config.highBucketThreshold ? "high" : "normal") !== this.bucketMode && (Hr.info("Kernel: Bucket mode changed from ".concat(this.bucketMode, " to ").concat(e, " (bucket: ").concat(t, ")"), {
subsystem: "Kernel"
}), this.bucketMode = e), Game.time % 100 == 0 && ("low" === this.bucketMode || "critical" === this.bucketMode)) {
var r = this.processes.size;
Hr.info("Bucket ".concat(this.bucketMode.toUpperCase(), " mode: ").concat(t, "/10000 bucket. ") + "Running all ".concat(r, " processes normally (bucket mode is informational only)"), {
subsystem: "Kernel"
});
}
}, t.prototype.validateConfig = function() {
this.config.criticalBucketThreshold >= this.config.lowBucketThreshold && (Hr.warn("Kernel: Adjusting critical bucket threshold ".concat(this.config.criticalBucketThreshold, " to stay below low threshold ").concat(this.config.lowBucketThreshold), {
subsystem: "Kernel"
}), this.config.criticalBucketThreshold = Math.max(0, this.config.lowBucketThreshold - 1)), 
this.config.lowBucketThreshold >= this.config.highBucketThreshold && (Hr.warn("Kernel: Adjusting high bucket threshold ".concat(this.config.highBucketThreshold, " to stay above low threshold ").concat(this.config.lowBucketThreshold), {
subsystem: "Kernel"
}), this.config.highBucketThreshold = this.config.lowBucketThreshold + 1);
}, t.prototype.buildFrequencyDefaults = function() {
return {
high: {
interval: this.config.frequencyIntervals.high,
minBucket: this.config.frequencyMinBucket.high,
cpuBudget: this.config.frequencyCpuBudgets.high
},
medium: {
interval: this.config.frequencyIntervals.medium,
minBucket: this.config.frequencyMinBucket.medium,
cpuBudget: this.config.frequencyCpuBudgets.medium
},
low: {
interval: this.config.frequencyIntervals.low,
minBucket: this.config.frequencyMinBucket.low,
cpuBudget: this.config.frequencyCpuBudgets.low
}
};
}, t.prototype.updateAdaptiveBudgets = function() {
if (this.config.enableAdaptiveBudgets) {
var e = Io.getAdaptiveBudgets(this.config.adaptiveBudgetConfig);
if (this.config.frequencyCpuBudgets = e, this.frequencyDefaults = this.buildFrequencyDefaults(), 
Game.time % 500 == 0) {
var t = Object.keys(Game.rooms).length, r = Game.cpu.bucket;
Hr.info("Adaptive budgets updated: rooms=".concat(t, ", bucket=").concat(r, ", ") + "high=".concat(e.high.toFixed(3), ", medium=").concat(e.medium.toFixed(3), ", low=").concat(e.low.toFixed(3)), {
subsystem: "Kernel"
});
}
}
}, t.prototype.getBucketMode = function() {
return this.updateBucketMode(), this.bucketMode;
}, t.prototype.getCpuLimit = function() {
return Game.cpu.limit * this.config.targetCpuUsage;
}, t.prototype.hasCpuBudget = function() {
var e = Game.cpu.getUsed(), t = this.getCpuLimit();
return t - e > t * this.config.reservedCpuFraction;
}, t.prototype.getRemainingCpu = function() {
var e = this.getCpuLimit(), t = e * this.config.reservedCpuFraction;
return Math.max(0, e - Game.cpu.getUsed() - t);
}, t.prototype.rebuildProcessQueue = function() {
var e = this;
this.processQueue = Array.from(this.processes.values()).sort(function(e, t) {
return t.priority - e.priority;
}), this.queueDirty = !1, this.lastExecutedProcessId ? this.lastExecutedIndex = this.processQueue.findIndex(function(t) {
return t.id === e.lastExecutedProcessId;
}) : this.lastExecutedIndex = -1;
}, t.prototype.shouldRunProcess = function(e) {
var t;
if ("suspended" === e.state && null !== e.stats.suspendedUntil) {
if (!(Game.time >= e.stats.suspendedUntil)) {
if (Game.time % 100 == 0) {
var r = e.stats.suspendedUntil - Game.time;
Hr.debug('Kernel: Process "'.concat(e.name, '" suspended (').concat(r, " ticks remaining)"), {
subsystem: "Kernel"
});
}
return !1;
}
e.state = "idle", e.stats.suspendedUntil = null;
var o = e.stats.suspensionReason;
e.stats.suspensionReason = null, Hr.info('Kernel: Process "'.concat(e.name, '" automatically resumed after suspension. ') + "Previous reason: ".concat(o, ". Consecutive errors: ").concat(e.stats.consecutiveErrors), {
subsystem: "Kernel",
processId: e.id
}), this.emit("process.recovered", {
processId: e.id,
processName: e.name,
previousReason: o || "Unknown",
consecutiveErrors: e.stats.consecutiveErrors
}, {
priority: 50
});
}
if (void 0 !== e.tickModulo && e.tickModulo > 0) {
var n = null !== (t = e.tickOffset) && void 0 !== t ? t : 0;
if ((Game.time + n) % e.tickModulo !== 0) return !1;
}
if (e.stats.runCount > 0) {
var a = Game.time - e.stats.lastRunTick;
if (a < e.interval) return Game.time % 100 == 0 && e.priority >= Ao.HIGH && Hr.debug('Kernel: Process "'.concat(e.name, '" skipped (interval: ').concat(a, "/").concat(e.interval, " ticks)"), {
subsystem: "Kernel"
}), !1;
}
return !0;
}, t.prototype.calculateHealthScore = function(e) {
if (0 === e.runCount) return 100;
var t = (e.runCount - e.errorCount) / e.runCount * 100;
return Game.time - e.lastSuccessfulRunTick < 100 && e.lastSuccessfulRunTick > 0 && (t += 20), 
t -= 15 * e.consecutiveErrors, Math.max(0, Math.min(100, t));
}, t.prototype.executeProcess = function(e) {
var t = Game.cpu.getUsed();
e.state = "running";
try {
e.execute(), e.state = "idle", e.stats.consecutiveErrors = 0, e.stats.lastSuccessfulRunTick = Game.time;
} catch (t) {
e.state = "error", e.stats.errorCount++, e.stats.consecutiveErrors++;
var r = t instanceof Error ? t.message : String(t);
Hr.error('Kernel: Process "'.concat(e.name, '" error: ').concat(r), {
subsystem: "Kernel"
}), t instanceof Error && t.stack && Hr.error(t.stack, {
subsystem: "Kernel"
});
var o = e.stats.consecutiveErrors;
if (o >= 10) e.stats.suspendedUntil = Number.MAX_SAFE_INTEGER, e.stats.suspensionReason = "Circuit breaker: ".concat(o, " consecutive failures (permanent)"), 
e.state = "suspended", Hr.error('Kernel: Process "'.concat(e.name, '" permanently suspended after ').concat(o, " consecutive failures"), {
subsystem: "Kernel",
processId: e.id
}), this.emit("process.suspended", {
processId: e.id,
processName: e.name,
reason: e.stats.suspensionReason,
consecutive: o,
permanent: !0
}, {
immediate: !0,
priority: 100
}); else if (o >= 3) {
var n = Math.min(1e3, Math.pow(2, o));
e.stats.suspendedUntil = Game.time + n, e.stats.suspensionReason = "".concat(o, " consecutive failures (auto-resume in ").concat(n, " ticks)"), 
e.state = "suspended", Hr.warn('Kernel: Process "'.concat(e.name, '" suspended for ').concat(n, " ticks after ").concat(o, " consecutive failures"), {
subsystem: "Kernel",
processId: e.id,
meta: {
errorCount: e.stats.errorCount,
resumeAt: e.stats.suspendedUntil
}
}), this.emit("process.suspended", {
processId: e.id,
processName: e.name,
reason: e.stats.suspensionReason,
consecutive: o,
permanent: !1,
resumeAt: e.stats.suspendedUntil
}, {
immediate: !0,
priority: 75
});
}
}
var a = Game.cpu.getUsed() - t;
this.config.enableStats && (e.stats.totalCpu += a, e.stats.runCount++, e.stats.avgCpu = e.stats.totalCpu / e.stats.runCount, 
e.stats.maxCpu = Math.max(e.stats.maxCpu, a), e.stats.lastRunTick = Game.time, e.stats.healthScore = this.calculateHealthScore(e.stats)), 
this.tickCpuUsed += a;
var i = this.getCpuLimit() * e.cpuBudget, s = a / i;
s > this.config.budgetWarningThreshold && Game.time % this.config.budgetWarningInterval === 0 && Hr.warn('Kernel: Process "'.concat(e.name, '" exceeded CPU budget: ').concat(a.toFixed(3), " > ").concat(i.toFixed(3), " (").concat((100 * s).toFixed(0), "%)"), {
subsystem: "Kernel"
});
}, t.prototype.run = function() {
if (this.updateBucketMode(), this.updateAdaptiveBudgets(), this.tickCpuUsed = 0, 
this.skippedProcessesThisTick = 0, lo.processQueue(), this.queueDirty && (this.rebuildProcessQueue(), 
Hr.info("Kernel: Rebuilt process queue with ".concat(this.processQueue.length, " processes"), {
subsystem: "Kernel"
})), 0 !== this.processQueue.length) {
Game.time % 10 == 0 && Hr.info("Kernel: Running ".concat(this.processQueue.length, " registered processes"), {
subsystem: "Kernel"
});
for (var e = 0, t = 0, r = 0, o = 0, n = (this.lastExecutedIndex + 1) % this.processQueue.length, a = 0; a < this.processQueue.length; a++) {
var i = (n + a) % this.processQueue.length, s = this.processQueue[i];
if (this.shouldRunProcess(s)) {
if (!this.hasCpuBudget()) {
r = this.processQueue.length - e - t, Hr.warn("Kernel: CPU budget exhausted after ".concat(e, " processes. ").concat(r, " processes deferred to next tick. Used: ").concat(Game.cpu.getUsed().toFixed(2), "/").concat(this.getCpuLimit().toFixed(2)), {
subsystem: "Kernel"
});
break;
}
this.executeProcess(s), e++, this.lastExecutedProcessId = s.id, this.lastExecutedIndex = i;
} else this.config.enableStats && s.stats.skippedCount++, t++, this.skippedProcessesThisTick++, 
s.stats.runCount > 0 && Game.time - s.stats.lastRunTick < s.interval && o++;
}
this.config.enableStats && Game.time % this.config.statsLogInterval === 0 && (this.logStats(e, t, o, r), 
lo.logStats());
} else Hr.warn("Kernel: No processes registered in queue", {
subsystem: "Kernel"
});
}, t.prototype.logStats = function(e, t, r, o) {
var n = Game.cpu.bucket, a = (n / 1e4 * 100).toFixed(1), i = Game.cpu.getUsed(), s = this.getCpuLimit();
if (Hr.info("Kernel: ".concat(e, " ran, ").concat(t, " skipped (interval: ").concat(r, ", CPU: ").concat(o, "), ") + "CPU: ".concat(i.toFixed(2), "/").concat(s.toFixed(2), " (").concat((i / s * 100).toFixed(1), "%), bucket: ").concat(n, "/10000 (").concat(a, "%), mode: ").concat(this.bucketMode), {
subsystem: "Kernel"
}), t > 10) {
var c = this.processQueue.filter(function(e) {
return e.stats.skippedCount > 100;
}).sort(function(e, t) {
return t.stats.skippedCount - e.stats.skippedCount;
}).slice(0, 5);
c.length > 0 && Hr.warn("Kernel: Top skipped processes: ".concat(c.map(function(e) {
return "".concat(e.name, "(").concat(e.stats.skippedCount, ", interval:").concat(e.interval, ")");
}).join(", ")), {
subsystem: "Kernel"
});
}
}, t.prototype.getTickCpuUsed = function() {
return this.tickCpuUsed;
}, t.prototype.getSkippedProcessesThisTick = function() {
return this.skippedProcessesThisTick;
}, t.prototype.suspendProcess = function(e) {
var t = this.processes.get(e);
return !!t && (t.state = "suspended", Hr.info('Kernel: Suspended process "'.concat(t.name, '"'), {
subsystem: "Kernel"
}), !0);
}, t.prototype.resumeProcess = function(e) {
var t = this.processes.get(e);
if (t && "suspended" === t.state) {
t.state = "idle", t.stats.suspendedUntil = null;
var r = t.stats.suspensionReason;
return t.stats.suspensionReason = null, Hr.info('Kernel: Manually resumed process "'.concat(t.name, '". ') + "Previous reason: ".concat(r, ". Consecutive errors: ").concat(t.stats.consecutiveErrors), {
subsystem: "Kernel",
processId: e
}), this.emit("process.recovered", {
processId: t.id,
processName: t.name,
previousReason: r || "Unknown",
consecutiveErrors: t.stats.consecutiveErrors,
manual: !0
}, {
priority: 50
}), !0;
}
return !1;
}, t.prototype.getStatsSummary = function() {
var e = Array.from(this.processes.values()), t = e.filter(function(e) {
return "suspended" !== e.state;
}), r = e.filter(function(e) {
return "suspended" === e.state;
}), a = e.reduce(function(e, t) {
return e + t.stats.totalCpu;
}, 0), i = e.length > 0 ? a / e.length : 0, s = n([], o(e), !1).sort(function(e, t) {
return t.stats.avgCpu - e.stats.avgCpu;
}).slice(0, 5).map(function(e) {
return {
name: e.name,
avgCpu: e.stats.avgCpu
};
}), c = n([], o(e), !1).filter(function(e) {
return e.stats.healthScore < 50;
}).sort(function(e, t) {
return e.stats.healthScore - t.stats.healthScore;
}).slice(0, 5).map(function(e) {
return {
name: e.name,
healthScore: e.stats.healthScore,
consecutiveErrors: e.stats.consecutiveErrors
};
}), l = e.reduce(function(e, t) {
return e + t.stats.healthScore;
}, 0), u = e.length > 0 ? l / e.length : 100;
return {
totalProcesses: e.length,
activeProcesses: t.length,
suspendedProcesses: r.length,
totalCpuUsed: a,
avgCpuPerProcess: i,
topCpuProcesses: s,
unhealthyProcesses: c,
avgHealthScore: u
};
}, t.prototype.resetStats = function() {
var e, t;
try {
for (var o = r(this.processes.values()), n = o.next(); !n.done; n = o.next()) n.value.stats = {
totalCpu: 0,
runCount: 0,
avgCpu: 0,
maxCpu: 0,
lastRunTick: 0,
skippedCount: 0,
errorCount: 0,
consecutiveErrors: 0,
lastSuccessfulRunTick: 0,
healthScore: 100,
suspendedUntil: null,
suspensionReason: null
};
} catch (t) {
e = {
error: t
};
} finally {
try {
n && !n.done && (t = o.return) && t.call(o);
} finally {
if (e) throw e.error;
}
}
Hr.info("Kernel: Reset all process statistics", {
subsystem: "Kernel"
});
}, t.prototype.getDistributionStats = function() {
var e, t, o = Array.from(this.processes.values()), n = o.filter(function(e) {
return void 0 !== e.tickModulo && e.tickModulo > 0;
}), a = o.filter(function(e) {
return !e.tickModulo || 0 === e.tickModulo;
}), i = {};
try {
for (var s = r(n), c = s.next(); !c.done; c = s.next()) {
var l = c.value.tickModulo;
i[l] = (i[l] || 0) + 1;
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
var u = a.length + n.reduce(function(e, t) {
return e + 1 / (t.tickModulo || 1);
}, 0), f = o.length, m = f > 0 ? (f - u) / f * 100 : 0;
return {
totalProcesses: o.length,
distributedProcesses: n.length,
everyTickProcesses: a.length,
distributionRatio: o.length > 0 ? n.length / o.length : 0,
moduloCounts: i,
averageTickLoad: u,
estimatedCpuReduction: m
};
}, t.prototype.getConfig = function() {
return e({}, this.config);
}, t.prototype.getFrequencyDefaults = function(t) {
return e({}, this.frequencyDefaults[t]);
}, t.prototype.updateConfig = function(t) {
this.config = e(e({}, this.config), t), this.validateConfig(), this.frequencyDefaults = this.buildFrequencyDefaults();
}, t.prototype.updateFromCpuConfig = function(e) {
this.updateConfig(Lo(e));
}, t.prototype.on = function(e, t, r) {
return void 0 === r && (r = {}), lo.on(e, t, r);
}, t.prototype.once = function(e, t, r) {
return void 0 === r && (r = {}), lo.once(e, t, r);
}, t.prototype.emit = function(e, t, r) {
void 0 === r && (r = {}), lo.emit(e, t, r);
}, t.prototype.offAll = function(e) {
lo.offAll(e);
}, t.prototype.processEvents = function() {
lo.processQueue();
}, t.prototype.getEventStats = function() {
return lo.getStats();
}, t.prototype.hasEventHandlers = function(e) {
return lo.hasHandlers(e);
}, t.prototype.getEventBus = function() {
return lo;
}, t;
}(), Ko = new Yo(Lo(mo().cpu)), Vo = Object.freeze({
__proto__: null,
Kernel: Yo,
get ProcessPriority() {
return Ao;
},
buildKernelConfigFromCpu: Lo,
createHighFrequencyProcess: function(e, t, r, o) {
void 0 === o && (o = Ao.HIGH);
var n = Ko.getFrequencyDefaults("high");
return {
id: e,
name: t,
execute: r,
priority: o,
frequency: "high",
minBucket: n.minBucket,
cpuBudget: n.cpuBudget,
interval: n.interval
};
},
createLowFrequencyProcess: function(e, t, r, o) {
void 0 === o && (o = Ao.LOW);
var n = Ko.getFrequencyDefaults("low");
return {
id: e,
name: t,
execute: r,
priority: o,
frequency: "low",
minBucket: n.minBucket,
cpuBudget: n.cpuBudget,
interval: n.interval
};
},
createMediumFrequencyProcess: function(e, t, r, o) {
void 0 === o && (o = Ao.MEDIUM);
var n = Ko.getFrequencyDefaults("medium");
return {
id: e,
name: t,
execute: r,
priority: o,
frequency: "medium",
minBucket: n.minBucket,
cpuBudget: n.cpuBudget,
interval: n.interval
};
},
kernel: Ko
}), zo = {}, qo = {}, Xo = {}, Qo = {}, Zo = {}, Jo = {}, $o = {};

function en() {
if (jo) return $o;
jo = 1;
var e, t = $o && $o.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = $o && $o.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty($o, "__esModule", {
value: !0
}), $o.cachedRoomFind = i, $o.invalidateRoomCache = function(e) {
var t = n();
t.entries.get(e) && (t.entries.delete(e), t.stats.invalidations++);
}, $o.invalidateFindType = function(e, t, r) {
var o = n(), i = o.entries.get(e);
if (i) {
var s = a(t, r);
i.delete(s), o.stats.invalidations++;
}
}, $o.invalidateStructureCache = function(e) {
var o, a, i, s, c = n(), l = c.entries.get(e);
if (l) {
var u = [ FIND_STRUCTURES, FIND_MY_STRUCTURES, FIND_HOSTILE_STRUCTURES, FIND_MY_SPAWNS, FIND_MY_CONSTRUCTION_SITES, FIND_CONSTRUCTION_SITES ];
try {
for (var f = t(u), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
try {
for (var d = (i = void 0, t(l)), y = d.next(); !y.done; y = d.next()) {
var g = r(y.value, 1)[0];
g.startsWith(String(p)) && (l.delete(g), c.stats.invalidations++);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
y && !y.done && (s = d.return) && s.call(d);
} finally {
if (i) throw i.error;
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (o) throw o.error;
}
}
}
}, $o.getRoomFindCacheStats = function() {
var e, r, o = n(), a = 0;
try {
for (var i = t(o.entries.values()), s = i.next(); !s.done; s = i.next()) a += s.value.size;
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (r = i.return) && r.call(i);
} finally {
if (e) throw e.error;
}
}
var c = o.stats.hits + o.stats.misses, l = c > 0 ? o.stats.hits / c : 0;
return {
rooms: o.entries.size,
totalEntries: a,
hits: o.stats.hits,
misses: o.stats.misses,
invalidations: o.stats.invalidations,
hitRate: l
};
}, $o.clearRoomFindCache = function() {
var e = f;
e._roomFindCache && (e._roomFindCache.entries.clear(), e._roomFindCache.stats = {
hits: 0,
misses: 0,
invalidations: 0
});
}, $o.cachedFindSources = function(e) {
return i(e, FIND_SOURCES);
}, $o.cachedFindHostileCreeps = function(e) {
return i(e, FIND_HOSTILE_CREEPS);
}, $o.cachedFindStructures = function(e, t) {
return t ? i(e, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === t;
},
filterKey: t
}) : i(e, FIND_STRUCTURES);
}, $o.cachedFindMyStructures = function(e, t) {
return t ? i(e, FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === t;
},
filterKey: t
}) : i(e, FIND_MY_STRUCTURES);
}, $o.cachedFindConstructionSites = function(e, t) {
return void 0 === t && (t = !0), i(e, t ? FIND_MY_CONSTRUCTION_SITES : FIND_CONSTRUCTION_SITES);
}, $o.cachedFindDroppedResources = function(e, t) {
return t ? i(e, FIND_DROPPED_RESOURCES, {
filter: function(e) {
return e.resourceType === t;
},
filterKey: t
}) : i(e, FIND_DROPPED_RESOURCES);
};
var o = ((e = {})[FIND_SOURCES] = 5e3, e[FIND_MINERALS] = 5e3, e[FIND_DEPOSITS] = 100, 
e[FIND_STRUCTURES] = 50, e[FIND_MY_STRUCTURES] = 50, e[FIND_HOSTILE_STRUCTURES] = 20, 
e[FIND_MY_SPAWNS] = 100, e[FIND_MY_CONSTRUCTION_SITES] = 20, e[FIND_CONSTRUCTION_SITES] = 20, 
e[FIND_CREEPS] = 5, e[FIND_MY_CREEPS] = 5, e[FIND_HOSTILE_CREEPS] = 3, e[FIND_DROPPED_RESOURCES] = 5, 
e[FIND_TOMBSTONES] = 10, e[FIND_RUINS] = 10, e[FIND_FLAGS] = 50, e[FIND_NUKES] = 20, 
e[FIND_POWER_CREEPS] = 10, e[FIND_MY_POWER_CREEPS] = 10, e);
function n() {
var e, t, r = f;
if (!r._roomFindCache || r._roomFindCache.tick !== Game.time) {
var o = null !== (t = null === (e = r._roomFindCache) || void 0 === e ? void 0 : e.stats) && void 0 !== t ? t : {
hits: 0,
misses: 0,
invalidations: 0
};
r._roomFindCache = {
tick: Game.time,
entries: new Map,
stats: o
};
}
return r._roomFindCache;
}
function a(e, t) {
return t ? "".concat(e, ":").concat(t) : String(e);
}
function i(e, t, r) {
var i, s, c = n(), l = a(t, null == r ? void 0 : r.filterKey), u = c.entries.get(e.name);
u || (u = new Map, c.entries.set(e.name, u));
var f, m = u.get(l);
if (m && Game.time - m.tick < m.ttl) return c.stats.hits++, m.results;
c.stats.misses++, f = (null == r ? void 0 : r.filter) ? e.find(t, {
filter: r.filter
}) : e.find(t);
var p = null !== (s = null !== (i = null == r ? void 0 : r.ttl) && void 0 !== i ? i : o[t]) && void 0 !== s ? s : 20;
return u.set(l, {
results: f,
tick: Game.time,
ttl: p
}), f;
}
return $o;
}

var tn, rn, on, nn, an, sn, cn, ln, un, fn, mn, pn, dn, yn = {}, gn = {}, hn = m(Object.freeze({
__proto__: null,
default: {}
})), vn = {}, Rn = {}, En = {}, Tn = {}, Sn = {}, Cn = {}, bn = {}, _n = {}, On = {}, wn = {}, xn = {}, Un = {};

function Mn() {
if (dn) return Un;
dn = 1;
var e = Un && Un.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, t = Un && Un.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(Un, "__esModule", {
value: !0
}), Un.random = function() {
return a().next();
}, Un.randomInt = i, Un.shuffle = function(r) {
for (var o, n = t([], e(r), !1), i = a(), s = n.length - 1; s > 0; s--) {
var c = i.nextInt(0, s + 1);
o = e([ n[c], n[s] ], 2), n[s] = o[0], n[c] = o[1];
}
return n;
}, Un.pick = function(e) {
return 0 === e.length ? void 0 : e[i(0, e.length)];
}, Un.createSeededRandom = function(e) {
var t = new r(e);
return {
next: function() {
return t.next();
},
nextInt: function(e, r) {
return t.nextInt(e, r);
}
};
}, Un.resetRandom = function() {
o = null, n = -1;
};
var r = function() {
function e(e) {
this.state = e;
}
return e.prototype.next = function() {
var e = this.state += 1831565813;
return e = Math.imul(e ^ e >>> 15, 1 | e), (((e ^= e + Math.imul(e ^ e >>> 7, 61 | e)) ^ e >>> 14) >>> 0) / 4294967296;
}, e.prototype.nextInt = function(e, t) {
return Math.floor(this.next() * (t - e)) + e;
}, e.prototype.reset = function(e) {
this.state = e;
}, e;
}(), o = null, n = -1;
function a() {
var e = "undefined" != typeof Game ? Game.time : 0;
return o && n === e || (o = new r(2654435761 * e), n = e), o;
}
function i(e, t) {
return a().nextInt(e, t);
}
return Un;
}

var An, kn, Nn, Pn, In = {}, Gn = {}, Ln = {}, Dn = {};

function Fn() {
if (Pn) return Dn;
Pn = 1;
var e = Dn && Dn.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, t = Dn && Dn.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(Dn, "__esModule", {
value: !0
}), Dn.createElement = void 0, Dn.colorful = o, Dn.createLink = function(e, t, r) {
return void 0 === r && (r = !0), '<a href="'.concat(t, '" target="').concat(r ? "_blank" : "_self", '">').concat(e, "</a>");
}, Dn.log = function(e, t, r, n) {
void 0 === t && (t = []), void 0 === r && (r = null), void 0 === n && (n = !1);
var a = t.length > 0 ? "".concat(t.join(" "), " ") : "";
a = o(a, r, !0);
var i = "".concat(a).concat(e);
return console.log(i), n && Game.notify(i), OK;
};
var r = {
red: "#ef9a9a",
green: "#6b9955",
yellow: "#c5c599",
blue: "#8dc5e3"
};
function o(e, t, o) {
void 0 === t && (t = null), void 0 === o && (o = !1);
var n = t ? "color: ".concat(r[t], ";") : "";
return '<text style="'.concat([ n, o ? "font-weight: bolder;" : "" ].join(" "), '">').concat(e, "</text>");
}
return Dn.createElement = {
customStyle: function() {
return "<style>\n      input {\n        background-color: #2b2b2b;\n        border: none;\n        border-bottom: 1px solid #888;\n        padding: 3px;\n        color: #ccc;\n      }\n      select {\n        border: none;\n        background-color: #2b2b2b;\n        color: #ccc;\n      }\n      button {\n        border: 1px solid #888;\n        cursor: pointer;\n        background-color: #2b2b2b;\n        color: #ccc;\n      }\n    </style>".replace(/\n/g, "");
},
input: function(e) {
return "".concat(e.label || "", ' <input name="').concat(e.name, '" placeholder="').concat(e.placeholder || "", '"/>');
},
select: function(r) {
var o = [ "".concat(r.label || "", ' <select name="').concat(r.name, '">') ];
return o.push.apply(o, t([], e(r.options.map(function(e) {
return ' <option value="'.concat(e.value, '">').concat(e.label, "</option>");
})), !1)), o.push("</select>"), o.join("");
},
button: function(e) {
return '<button onclick="'.concat((t = e.command, "angular.element(document.body).injector().get('Console').sendCommand('(".concat(t, ")()', 1)")), '">').concat(e.content, "</button>");
var t;
},
form: function(r, o, n) {
var a = this, i = r + Game.time.toString(), s = [ this.customStyle(), "<form name='".concat(i, "'>") ];
s.push.apply(s, t([], e(o.map(function(e) {
switch (e.type) {
case "input":
return a.input(e) + "    ";

case "select":
return a.select(e) + "    ";
}
})), !1));
var c = "(() => {\n      const form = document.forms['".concat(i, "']\n      let formDatas = {}\n      [").concat(o.map(function(e) {
return "'".concat(e.name, "'");
}).toString(), "].map(eleName => formDatas[eleName] = form[eleName].value)\n      angular.element(document.body).injector().get('Console').sendCommand(`(").concat(n.command, ")(${JSON.stringify(formDatas)})`, 1)\n    })()");
return s.push('<button type="button" onclick="'.concat(c.replace(/\n/g, ";"), '">').concat(n.content, "</button>")), 
s.push("</form>"), s.join("");
}
}, Dn;
}

var Bn, jn, Hn, Wn, Yn, Kn, Vn, zn = {}, qn = (Hn || (Hn = 1, Wn = zo, Yn = zo && zo.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), Kn = zo && zo.__exportStar || function(e, t) {
for (var r in e) "default" === r || Object.prototype.hasOwnProperty.call(t, r) || Yn(t, e, r);
}, Object.defineProperty(Wn, "__esModule", {
value: !0
}), Kn(function() {
return Wo || (Wo = 1, e = qo, t = qo && qo.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = qo && qo.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r(function() {
if (Do) return Xo;
Do = 1;
var e = Xo && Xo.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function t() {
var e = f;
return e._bodyPartCache && e._bodyPartCache.tick === Game.time || (e._bodyPartCache = {
tick: Game.time,
data: new Map
}), e._bodyPartCache;
}
function r(r) {
var o, n, a, i, s = t(), c = s.data.get(r.name);
if (c) return c;
var l = new Map, u = new Map, f = 0, m = 0, p = 0, d = 0, y = 0;
try {
for (var g = e(r.body), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
l.set(v.type, (null !== (a = l.get(v.type)) && void 0 !== a ? a : 0) + 1), v.hits > 0 && (u.set(v.type, (null !== (i = u.get(v.type)) && void 0 !== i ? i : 0) + 1), 
v.type === ATTACK ? f += 30 : v.type === RANGED_ATTACK ? f += 10 : v.type === HEAL ? m += 12 : v.type === CARRY && (y += 50), 
v.type === MOVE ? p++ : d++);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
h && !h.done && (n = g.return) && n.call(g);
} finally {
if (o) throw o.error;
}
}
var R = {
counts: l,
activeCounts: u,
damagePotential: f,
healPotential: m,
moveParts: p,
nonMoveParts: d,
carryCapacity: y
};
return s.data.set(r.name, R), R;
}
function o(e, t, o) {
var n;
void 0 === o && (o = !1);
var a = r(e);
return null !== (n = (o ? a.activeCounts : a.counts).get(t)) && void 0 !== n ? n : 0;
}
return Object.defineProperty(Xo, "__esModule", {
value: !0
}), Xo.getCachedBodyPartCount = o, Xo.hasCachedBodyPart = function(e, t, r) {
return void 0 === r && (r = !1), o(e, t, r) > 0;
}, Xo.getCachedDamagePotential = function(e) {
return r(e).damagePotential;
}, Xo.getCachedHealPotential = function(e) {
return r(e).healPotential;
}, Xo.getCachedCarryCapacity = function(e) {
return r(e).carryCapacity;
}, Xo.getCachedMoveRatio = function(e) {
var t = r(e), o = t.moveParts + t.nonMoveParts;
return {
moveParts: t.moveParts,
nonMoveParts: t.nonMoveParts,
ratio: o > 0 ? t.moveParts / o : 0
};
}, Xo.getBodyPartCacheStats = function() {
var e = t();
return {
size: e.data.size,
tick: e.tick
};
}, Xo.clearBodyPartCache = function() {
var e = f;
e._bodyPartCache && e._bodyPartCache.data.clear();
}, Xo;
}(), e), r(function() {
if (Fo) return Qo;
Fo = 1, Object.defineProperty(Qo, "__esModule", {
value: !0
}), Qo.findCachedClosest = function(n, a, i, s) {
if (void 0 === s && (s = t), 0 === a.length) return o(n, i), null;
if (1 === a.length) return a[0];
var c = n.memory, l = c[e], u = null == l ? void 0 : l[i];
if (u && Game.time - u.t < s && u.k === i) {
var f = Game.getObjectById(u.i);
if (f && a.some(function(e) {
return e.id === f.id;
}) && n.pos.getRangeTo(f.pos) <= r) return f;
}
var m = n.pos.findClosestByRange(a);
return m ? (c[e] || (c[e] = {}), c[e][i] = {
i: m.id,
t: Game.time,
k: i
}) : o(n, i), m;
}, Qo.clearCache = o, Qo.clearCacheOnStateChange = function(e) {
o(e);
};
var e = "_ct", t = 10, r = 20;
function o(t, r) {
var o, n = null !== (o = t.memory) && void 0 !== o ? o : {}, a = n[e];
a && (r ? delete a[r] : delete n[e]);
}
return Qo;
}(), e), r(function() {
if (Bo) return Zo;
Bo = 1;
var e = Zo && Zo.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Zo, "__esModule", {
value: !0
}), Zo.getCachedObjectById = l, Zo.getCachedStorage = function(e) {
var t;
return e.storage && null !== (t = l(e.storage.id)) && void 0 !== t ? t : void 0;
}, Zo.getCachedTerminal = function(e) {
var t;
return e.terminal && null !== (t = l(e.terminal.id)) && void 0 !== t ? t : void 0;
}, Zo.getCachedController = function(e) {
var t;
return e.controller && null !== (t = l(e.controller.id)) && void 0 !== t ? t : void 0;
}, Zo.prefetchRoomObjects = u, Zo.getObjectCacheStats = function() {
var e = c();
return {
size: e.objects.size,
tick: e.tick
};
}, Zo.getCacheStatistics = function() {
var e = c(), t = e.stats.hits + e.stats.misses, r = t > 0 ? e.stats.hits / t * 100 : 0;
return e.objects.size > i && console.log("[ObjectCache] WARN: Cache size exceeds warning threshold: ".concat(e.objects.size, " entries, threshold: ").concat(i)), 
{
hits: e.stats.hits,
misses: e.stats.misses,
hitRate: r,
size: e.objects.size,
cpuSaved: e.stats.hits * a
};
}, Zo.getCachedStructure = function(e) {
return l(e, t);
}, Zo.getCachedCreep = function(e) {
return l(e, o);
}, Zo.getCachedSource = function(e) {
return l(e, r);
}, Zo.warmCache = function() {
var r, o, n, a, i;
for (var s in Game.cpu.getUsed(), Game.rooms) {
var l = Game.rooms[s];
if (null === (i = l.controller) || void 0 === i ? void 0 : i.my) {
u(l);
var f = l.find(FIND_MY_SPAWNS), m = l.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
}), p = c(), d = Game.time;
try {
for (var y = (r = void 0, e(f)), g = y.next(); !g.done; g = y.next()) {
var h = g.value;
p.objects.set(h.id, {
value: h,
expiresAt: d + t,
lastAccessed: d
});
}
} catch (e) {
r = {
error: e
};
} finally {
try {
g && !g.done && (o = y.return) && o.call(y);
} finally {
if (r) throw r.error;
}
}
try {
for (var v = (n = void 0, e(m)), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
p.objects.set(E.id, {
value: E,
expiresAt: d + t,
lastAccessed: d
});
}
} catch (e) {
n = {
error: e
};
} finally {
try {
R && !R.done && (a = v.return) && a.call(v);
} finally {
if (n) throw n.error;
}
}
}
}
}, Zo.clearObjectCache = function() {
var e = f;
e._objectCache && (e._objectCache.objects.clear(), e._objectCache.stats = {
hits: 0,
misses: 0
});
}, Zo.resetCacheStats = function() {
var e = f;
e._objectCache && (e._objectCache.stats = {
hits: 0,
misses: 0
});
};
var t = 10, r = 5, o = 1, n = 1, a = .001, i = 1e4, s = 12e3;
function c() {
var e = f;
return e._objectCache || (e._objectCache = {
tick: Game.time,
objects: new Map,
stats: {
hits: 0,
misses: 0
}
}), e._objectCache.tick = Game.time, e._objectCache;
}
function l(e, a) {
if (!e) return null;
var i = c(), l = Game.time, u = i.objects.get(e);
if (u && u.expiresAt > l) return u.lastAccessed = l, i.stats.hits++, u.value;
i.stats.misses++;
var f = Game.getObjectById(e), m = null != a ? a : function(e) {
return e ? "structureType" in e ? t : e instanceof Source || e instanceof Mineral ? r : e instanceof Creep ? o : n : n;
}(f);
return i.objects.set(e, {
value: f,
expiresAt: l + m,
lastAccessed: l
}), i.objects.size > s && function(e) {
var t = e.objects.size - 1e4;
if (!(t <= 0)) {
for (var r = Array.from(e.objects.entries()).sort(function(e, t) {
return e[1].lastAccessed - t[1].lastAccessed;
}), o = 0; o < t && o < r.length; o++) e.objects.delete(r[o][0]);
console.log("[ObjectCache] WARN: Cache LRU eviction: removed ".concat(t, " entries, size: ").concat(e.objects.size, ", threshold: ").concat(s));
}
}(i), f;
}
function u(o) {
var n, a, i;
if (null === (i = o.controller) || void 0 === i ? void 0 : i.my) {
var s = c(), l = Game.time, u = function(e, t) {
(null == e ? void 0 : e.id) && s.objects.set(e.id, {
value: e,
expiresAt: l + t,
lastAccessed: l
});
};
o.storage && u(o.storage, t), o.terminal && u(o.terminal, t), o.controller && u(o.controller, t);
var f = o.find(FIND_SOURCES);
try {
for (var m = e(f), p = m.next(); !p.done; p = m.next()) u(p.value, r);
} catch (e) {
n = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (n) throw n.error;
}
}
}
}
return Zo;
}(), e), r(function() {
if (Ho) return Jo;
Ho = 1;
var e = Jo && Jo.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = Jo && Jo.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(Jo, "__esModule", {
value: !0
}), Jo.getRoleCache = s, Jo.setRoleCache = c, Jo.deleteRoleCache = l, Jo.hasRoleCache = function(e, t, r) {
return void 0 !== s(e, t, r);
}, Jo.clearRoleTypeCache = function(e) {
n().entries.delete(e);
}, Jo.clearAllRoleCache = function() {
var e = f;
e._roleCache && e._roleCache.entries.clear();
}, Jo.getRoleCacheStats = function() {
var r, o, a, i, s = n(), c = 0, l = 0, u = {};
try {
for (var f = e(s.entries), m = f.next(); !m.done; m = f.next()) {
var p = t(m.value, 2), d = p[0], y = p[1], g = 0;
try {
for (var h = (a = void 0, e(y.values())), v = h.next(); !v.done; v = h.next()) {
var R = v.value;
c++, g += R.size, l += R.size;
}
} catch (e) {
a = {
error: e
};
} finally {
try {
v && !v.done && (i = h.return) && i.call(h);
} finally {
if (a) throw a.error;
}
}
u[d] = g;
}
} catch (e) {
r = {
error: e
};
} finally {
try {
m && !m.done && (o = f.return) && o.call(f);
} finally {
if (r) throw r.error;
}
}
return {
roles: s.entries.size,
creeps: c,
totalEntries: l,
entriesByRole: u
};
}, Jo.getCachedRepairTarget = function(e, t) {
var r = s(e, "builder", "repairTarget");
if (r) {
var o = Game.getObjectById(r);
if (o && o.hits < o.hitsMax) return o;
}
var n = t();
return n && c(e, "builder", "repairTarget", n.id), n;
}, Jo.getCachedBuildTarget = function(e, t) {
var r = s(e, "builder", "buildTarget");
if (r) {
var o = Game.getObjectById(r);
if (o) return o;
}
var n = t();
return n && c(e, "builder", "buildTarget", n.id), n;
}, Jo.getAssignedSource = function(e, t) {
var r = s(e, "miner", "assignedSource");
return !r && t && (c(e, "miner", "assignedSource", t, 200), r = t), r ? Game.getObjectById(r) : null;
}, Jo.getSourceContainer = function(e, t) {
var o = "sourceContainer:".concat(t.id), n = s(e, "miner", o);
if (n && (i = Game.getObjectById(n))) return i;
var a = t.room;
if (!a) return null;
var i, l = (0, r.cachedRoomFind)(a, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
},
filterKey: STRUCTURE_CONTAINER
}).filter(function(e) {
return t.pos.getRangeTo(e) <= 1;
});
return l.length > 0 ? (c(e, "miner", o, (i = l[0]).id, 100), i) : null;
}, Jo.getControllerEnergySource = function(e, t) {
var o = "controllerSource:".concat(t.id), n = s(e, "upgrader", o);
if (n) {
var a = Game.getObjectById(n);
if (a) return a;
}
var i = t.room;
if (!i) return null;
var l = (0, r.cachedRoomFind)(i, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK;
},
filterKey: STRUCTURE_LINK
}).filter(function(e) {
return t.pos.getRangeTo(e) <= 3 && e.store.getUsedCapacity(RESOURCE_ENERGY) > 0;
});
if (l.length > 0) {
var u = l[0];
return c(e, "upgrader", o, u.id, 100), u;
}
var f = (0, r.cachedRoomFind)(i, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
},
filterKey: STRUCTURE_CONTAINER
}).filter(function(e) {
return t.pos.getRangeTo(e) <= 3 && e.store.getUsedCapacity(RESOURCE_ENERGY) > 0;
});
if (f.length > 0) {
var m = f[0];
return c(e, "upgrader", o, m.id, 100), m;
}
return null;
}, Jo.clearTargetCaches = function(t, r, o) {
var n, a;
try {
for (var i = e(o), s = i.next(); !s.done; s = i.next()) l(t, r, s.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
s && !s.done && (a = i.return) && a.call(i);
} finally {
if (n) throw n.error;
}
}
};
var r = en(), o = {
assignedSource: 100,
assignedController: 100,
assignedMineral: 100,
assignedRoom: 50,
sourceContainer: 50,
controllerContainer: 50,
controllerLink: 50,
repairTarget: 10,
buildTarget: 10,
pickupTarget: 5,
deliveryTarget: 5,
combatTarget: 3,
harvestPath: 50,
deliveryRoute: 20,
default: 10
};
function n() {
var e = f;
return e._roleCache && e._roleCache.tick === Game.time || (e._roleCache = {
tick: Game.time,
entries: new Map
}), e._roleCache;
}
function a(e) {
var t = n(), r = t.entries.get(e);
return r || (r = new Map, t.entries.set(e, r)), r;
}
function i(e, t) {
var r = a(e), o = r.get(t);
return o || (o = new Map, r.set(t, o)), o;
}
function s(e, t, r) {
var o = i(t, e.name), n = o.get(r);
if (n) {
if (!(Game.time - n.tick >= n.ttl)) return n.value;
o.delete(r);
}
}
function c(e, t, r, n, a) {
var s, c = i(t, e.name), l = null !== (s = null != a ? a : o[r]) && void 0 !== s ? s : o.default;
c.set(r, {
value: n,
tick: Game.time,
ttl: l
});
}
function l(e, t, r) {
r ? i(t, e.name).delete(r) : a(t).delete(e.name);
}
return Jo;
}(), e), r(en(), e)), qo;
var e, t, r;
}(), Wn), Kn(function() {
return on || (on = 1, e = yn, t = yn && yn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = yn && yn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r(function() {
if (tn) return gn;
tn = 1;
var e = gn && gn.__awaiter || function(e, t, r, o) {
return new (r || (r = Promise))(function(n, a) {
function i(e) {
try {
c(o.next(e));
} catch (e) {
a(e);
}
}
function s(e) {
try {
c(o.throw(e));
} catch (e) {
a(e);
}
}
function c(e) {
var t;
e.done ? n(e.value) : (t = e.value, t instanceof r ? t : new r(function(e) {
e(t);
})).then(i, s);
}
c((o = o.apply(e, t || [])).next());
});
}, t = gn && gn.__generator || function(e, t) {
var r, o, n, a = {
label: 0,
sent: function() {
if (1 & n[0]) throw n[1];
return n[1];
},
trys: [],
ops: []
}, i = Object.create(("function" == typeof Iterator ? Iterator : Object).prototype);
return i.next = s(0), i.throw = s(1), i.return = s(2), "function" == typeof Symbol && (i[Symbol.iterator] = function() {
return this;
}), i;
function s(s) {
return function(c) {
return function(s) {
if (r) throw new TypeError("Generator is already executing.");
for (;i && (i = 0, s[0] && (a = 0)), a; ) try {
if (r = 1, o && (n = 2 & s[0] ? o.return : s[0] ? o.throw || ((n = o.return) && n.call(o), 
0) : o.next) && !(n = n.call(o, s[1])).done) return n;
switch (o = 0, n && (s = [ 2 & s[0], n.value ]), s[0]) {
case 0:
case 1:
n = s;
break;

case 4:
return a.label++, {
value: s[1],
done: !1
};

case 5:
a.label++, o = s[1], s = [ 0 ];
continue;

case 7:
s = a.ops.pop(), a.trys.pop();
continue;

default:
if (!((n = (n = a.trys).length > 0 && n[n.length - 1]) || 6 !== s[0] && 2 !== s[0])) {
a = 0;
continue;
}
if (3 === s[0] && (!n || s[1] > n[0] && s[1] < n[3])) {
a.label = s[1];
break;
}
if (6 === s[0] && a.label < n[1]) {
a.label = n[1], n = s;
break;
}
if (n && a.label < n[2]) {
a.label = n[2], a.ops.push(s);
break;
}
n[2] && a.ops.pop(), a.trys.pop();
continue;
}
s = t.call(e, a);
} catch (e) {
s = [ 6, e ], o = 0;
} finally {
r = n = 0;
}
if (5 & s[0]) throw s[1];
return {
value: s[0] ? s[1] : void 0,
done: !0
};
}([ s, c ]);
};
}
};
Object.defineProperty(gn, "__esModule", {
value: !0
}), gn.ErrorMapper = void 0;
var r = Sr();
function o(e) {
return null == e ? "" : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#39;");
}
var n = function() {
function n() {}
return n.getConsumer = function() {
return e(this, void 0, void 0, function() {
var e, o, n;
return t(this, function(t) {
switch (t.label) {
case 0:
if (null != this._consumer) return [ 3, 2 ];
if (o = void 0, "string" == typeof (e = hn)) try {
o = JSON.parse(e);
} catch (e) {
throw new Error("Failed to parse source map JSON: ".concat(e instanceof Error ? e.message : String(e)));
} else o = e;
return n = this, [ 4, new r.SourceMapConsumer(o) ];

case 1:
n._consumer = t.sent(), t.label = 2;

case 2:
return [ 2, this._consumer ];
}
});
});
}, n.sourceMappedStackTrace = function(r) {
return e(this, void 0, void 0, function() {
var e, o, n, a, i, s;
return t(this, function(t) {
switch (t.label) {
case 0:
return e = r instanceof Error ? r.stack : r, Object.prototype.hasOwnProperty.call(this.cache, e) ? [ 2, this.cache[e] ] : (o = /^\s+at\s+(.+?\s+)?\(?([0-z._\-\\\/]+):(\d+):(\d+)\)?$/gm, 
a = r.toString(), [ 4, this.getConsumer() ]);

case 1:
for (i = t.sent(); (n = o.exec(e)) && "main" === n[2] && null != (s = i.originalPositionFor({
column: parseInt(n[4], 10),
line: parseInt(n[3], 10)
})).line; ) s.name ? a += "\n    at ".concat(s.name, " (").concat(s.source, ":").concat(s.line, ":").concat(s.column, ")") : n[1] ? a += "\n    at ".concat(n[1], " (").concat(s.source, ":").concat(s.line, ":").concat(s.column, ")") : a += "\n    at ".concat(s.source, ":").concat(s.line, ":").concat(s.column);
return this.cache[e] = a, [ 2, a ];
}
});
});
}, n.wrapLoop = function(e) {
var t = this;
return function() {
try {
e();
} catch (e) {
if (!(e instanceof Error)) throw e;
"sim" in Game.rooms ? console.log("<span style='color:red'>".concat("Source maps don't work in the simulator - displaying original error", "<br>").concat(o(e.stack), "</span>")) : t.sourceMappedStackTrace(e).then(function(e) {
console.log("<span style='color:red'>".concat(o(e), "</span>"));
}).catch(function(t) {
console.log("<span style='color:red'>Error mapping stack trace: ".concat(t, "<br>").concat(o(e.stack), "</span>"));
});
}
};
}, n.cache = {}, n;
}();
return gn.ErrorMapper = n, gn;
}(), e), r(function() {
if (rn) return vn;
function e(e, t, r, o) {
var n = o instanceof Error ? o.message : String(o);
console.log("[SafeFind] WARN: SafeFind error in ".concat(e, "(").concat(String(t), ") at ").concat(r, ": ").concat(n));
}
return rn = 1, Object.defineProperty(vn, "__esModule", {
value: !0
}), vn.safeFind = function(t, r, o) {
try {
return t.find(r, o);
} catch (o) {
return e("room.find", r, t.name, o), [];
}
}, vn.safeFindClosestByRange = function(t, r, o) {
try {
return t.findClosestByRange(r, o);
} catch (o) {
return e("pos.findClosestByRange", r, "".concat(t.roomName, ":").concat(String(t.x), ",").concat(String(t.y)), o), 
null;
}
}, vn.safeFindInRange = function(t, r, o, n) {
try {
return t.findInRange(r, o, n);
} catch (o) {
return e("pos.findInRange", r, "".concat(t.roomName, ":").concat(String(t.x), ",").concat(String(t.y)), o), 
[];
}
}, vn.safeFindClosestByPath = function(t, r, o) {
try {
return t.findClosestByPath(r, o);
} catch (o) {
return e("pos.findClosestByPath", r, "".concat(t.roomName, ":").concat(String(t.x), ",").concat(String(t.y)), o), 
null;
}
}, vn;
}(), e)), yn;
var e, t, r;
}(), Wn), Kn(function() {
return an || (an = 1, e = Rn, t = Rn && Rn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = Rn && Rn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r((nn || (nn = 1, Object.defineProperty(En, "__esModule", {
value: !0
})), En), e)), Rn;
var e, t, r;
}(), Wn), Kn(function() {
return cn || (cn = 1, e = Tn, t = Tn && Tn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = Tn && Tn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r(function() {
if (sn) return Sn;
sn = 1, Object.defineProperty(Sn, "__esModule", {
value: !0
}), Sn.canSkipBehaviorEvaluation = function(o, n, a, i) {
var s, c, l = null !== (s = null == i ? void 0 : i.minStateAge) && void 0 !== s ? s : e;
return !!(null !== (c = null == i ? void 0 : i.idleEligibleRoles) && void 0 !== c ? c : t).has(a) && !(!n || !n.startTick) && !(Game.time - n.startTick < l) && !!n.targetId && r(o, n.targetId);
}, Sn.isTargetStillValid = r, Sn.isCreepActivelyWorking = function(e) {
if (e.fatigue > 0) return !0;
var t = e.store.getCapacity();
if (t > 0) {
var r = e.store.getUsedCapacity();
if (r > 0 && r < t) return !0;
}
return !1;
};
var e = 3, t = new Set([ "harvester", "upgrader", "mineralHarvester", "builder" ]);
function r(e, t, r) {
var o = Game.getObjectById(t);
return !!o && "pos" in o && o.pos instanceof RoomPosition && !(void 0 !== r && e.pos.getRangeTo(o.pos) > r);
}
return Sn;
}(), e)), Tn;
var e, t, r;
}(), Wn), Kn(function() {
return mn || (mn = 1, e = Cn, t = Cn && Cn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = Cn && Cn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r((ln || (ln = 1, function(e) {
var t, r, o = bn && bn.__assign || function() {
return o = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, o.apply(this, arguments);
}, n = bn && bn.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(e, "__esModule", {
value: !0
}), e.globalScheduler = e.ComputationScheduler = e.TaskPriority = void 0, e.scheduleTask = function(t, o, n, a, i) {
void 0 === a && (a = r.MEDIUM), e.globalScheduler.register({
id: t,
interval: o,
execute: n,
priority: a,
maxCpu: i,
skippable: a !== r.CRITICAL
});
}, e.unscheduleTask = function(t) {
e.globalScheduler.unregister(t);
}, e.runScheduledTasks = function(t) {
return e.globalScheduler.run(t);
}, e.getSchedulerStats = function() {
return e.globalScheduler.getStats();
}, function(e) {
e[e.CRITICAL = 0] = "CRITICAL", e[e.HIGH = 1] = "HIGH", e[e.MEDIUM = 2] = "MEDIUM", 
e[e.LOW = 3] = "LOW";
}(r || (e.TaskPriority = r = {}));
var a, i = {
bucketThresholds: (t = {}, t[r.CRITICAL] = 0, t[r.HIGH] = 2e3, t[r.MEDIUM] = 5e3, 
t[r.LOW] = 8e3, t),
defaultMaxCpu: 5,
logExecution: !1
}, s = function() {
function e(e) {
var t;
this.tasks = new Map, this.stats = {
totalTasks: 0,
tasksByPriority: (t = {}, t[r.CRITICAL] = 0, t[r.HIGH] = 0, t[r.MEDIUM] = 0, t[r.LOW] = 0, 
t),
executedThisTick: 0,
skippedThisTick: 0,
deferredThisTick: 0,
cpuUsed: 0
}, this.config = o(o({}, i), e);
}
return e.prototype.register = function(e) {
var t, r, n = o(o({}, e), {
lastRun: Game.time - e.interval,
maxCpu: null !== (t = e.maxCpu) && void 0 !== t ? t : this.config.defaultMaxCpu,
skippable: null === (r = e.skippable) || void 0 === r || r
});
this.tasks.set(e.id, n), this.updateStats();
}, e.prototype.unregister = function(e) {
this.tasks.delete(e), this.updateStats();
}, e.prototype.run = function(e) {
var t, a, i, s = Game.cpu.getUsed(), c = Game.cpu.bucket, l = null != e ? e : 1 / 0;
this.stats.executedThisTick = 0, this.stats.skippedThisTick = 0, this.stats.deferredThisTick = 0;
var u = Array.from(this.tasks.values()).sort(function(e, t) {
return e.priority - t.priority;
}), f = 0;
try {
for (var m = n(u), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (!(Game.time - d.lastRun < d.interval)) {
if (d.priority !== r.CRITICAL && c < this.config.bucketThresholds[d.priority]) {
this.stats.skippedThisTick++;
continue;
}
var y = null !== (i = d.maxCpu) && void 0 !== i ? i : this.config.defaultMaxCpu;
if (f + y > l && d.skippable) this.stats.deferredThisTick++; else {
var g = Game.cpu.getUsed();
try {
d.execute(), d.lastRun = Game.time, this.stats.executedThisTick++;
var h = Game.cpu.getUsed() - g;
f += h, h > y && console.log("[Scheduler] WARN: Task ".concat(d.id, " exceeded CPU budget: ").concat(h.toFixed(2), " > ").concat(y));
} catch (e) {
console.log("[Scheduler] ERROR: Error executing task ".concat(d.id, ": ").concat(String(e))), 
d.lastRun = Game.time;
}
if (f > l) break;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (t) throw t.error;
}
}
return this.stats.cpuUsed = Game.cpu.getUsed() - s, o({}, this.stats);
}, e.prototype.forceRun = function(e) {
var t = this.tasks.get(e);
if (!t) return !1;
try {
return t.execute(), t.lastRun = Game.time, !0;
} catch (t) {
return console.log("[Scheduler] ERROR: Error force-executing task ".concat(e, ": ").concat(String(t))), 
!1;
}
}, e.prototype.resetTask = function(e) {
var t = this.tasks.get(e);
t && (t.lastRun = Game.time - t.interval);
}, e.prototype.getStats = function() {
return o({}, this.stats);
}, e.prototype.getTasks = function() {
return Array.from(this.tasks.values());
}, e.prototype.hasTask = function(e) {
return this.tasks.has(e);
}, e.prototype.clear = function() {
this.tasks.clear(), this.updateStats();
}, e.prototype.updateStats = function() {
var e, t, o;
this.stats.totalTasks = this.tasks.size, this.stats.tasksByPriority = ((e = {})[r.CRITICAL] = 0, 
e[r.HIGH] = 0, e[r.MEDIUM] = 0, e[r.LOW] = 0, e);
try {
for (var a = n(this.tasks.values()), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
this.stats.tasksByPriority[s.priority]++;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
}, e;
}();
e.ComputationScheduler = s, e.globalScheduler = ((a = f)._computationScheduler || (a._computationScheduler = new s), 
a._computationScheduler);
}(bn)), bn), e), r(function() {
if (un) return _n;
un = 1;
var e = _n && _n.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function t(e, t, r, o) {
return Math.max(Math.abs(e - r), Math.abs(t - o));
}
return Object.defineProperty(_n, "__esModule", {
value: !0
}), _n.throttle = function(e, t, r) {
if (void 0 === r && (r = 0), (Game.time + r) % t === 0) return e();
}, _n.throttleWithDefault = function(e, t, r, o) {
return void 0 === o && (o = 0), (Game.time + o) % t === 0 ? e() : r;
}, _n.filterWithMemoization = function(e, t, r) {
var o = new Map;
return e.filter(function(e) {
var n = t(e), a = o.get(n);
if (void 0 !== a) return a;
var i = r(e);
return o.set(n, i), i;
});
}, _n.chebyshevDistance = t, _n.isWithinRange = function(e, t, r, o, n) {
return Math.abs(e - r) <= n && Math.abs(t - o) <= n;
}, _n.findClosestByRangeFast = function(r, o) {
var n, a;
if (0 === o.length) return null;
var i = null, s = 1 / 0;
try {
for (var c = e(o), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (u.pos.roomName === r.roomName) {
var f = t(r.x, r.y, u.pos.x, u.pos.y);
f < s && (s = f, i = u);
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
l && !l.done && (a = c.return) && a.call(c);
} finally {
if (n) throw n.error;
}
}
return i;
}, _n.sumValues = function(t, r) {
var o, n, a = 0;
try {
for (var i = e(t), s = i.next(); !s.done; s = i.next()) a += r(s.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}, _n.groupBy = function(t, r) {
var o, n, a = new Map;
try {
for (var i = e(t), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = r(c), u = a.get(l);
u ? u.push(c) : a.set(l, [ c ]);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}, _n.isLowBucket = function(e) {
return void 0 === e && (e = 2e3), Game.cpu.bucket < e;
}, _n.hasCpuBudget = function(e, t) {
void 0 === e && (e = 0), void 0 === t && (t = .8);
var r = Game.cpu.getUsed();
return Game.cpu.limit * t - r >= e;
}, _n;
}(), e), r(function() {
if (fn) return On;
fn = 1;
var e = On && On.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function t() {
var e = f;
return e._findInRangeCache && e._findInRangeCache.tick === Game.time || (e._findInRangeCache = {
tick: Game.time,
results: new Map
}), e._findInRangeCache;
}
return Object.defineProperty(On, "__esModule", {
value: !0
}), On.cachedFindInRange = function(e, r, o, n) {
if (0 === r.length) return [];
if (n) {
var a = t().results.get(n);
if (a) return a;
}
var i = r.filter(function(t) {
return e.getRangeTo(t.pos) <= o;
});
return n && t().results.set(n, i), i;
}, On.optimizedFindClosest = function(e, t) {
return 0 === t.length ? null : 1 === t.length ? t[0] : e.findClosestByRange(t);
}, On.findStructuresByType = function(e, t, r) {
var o = e.find(FIND_STRUCTURES), n = new Set(t), a = o.filter(function(e) {
return n.has(e.structureType);
});
return r && (a = a.filter(r)), a;
}, On.findPrioritizedConstructionSites = function(e) {
var t, r = e.find(FIND_MY_CONSTRUCTION_SITES);
if (r.length <= 1) return r;
var o = ((t = {})[STRUCTURE_SPAWN] = 100, t[STRUCTURE_EXTENSION] = 90, t[STRUCTURE_TOWER] = 80, 
t[STRUCTURE_STORAGE] = 70, t[STRUCTURE_TERMINAL] = 65, t[STRUCTURE_LINK] = 60, t[STRUCTURE_CONTAINER] = 50, 
t[STRUCTURE_ROAD] = 30, t[STRUCTURE_RAMPART] = 20, t[STRUCTURE_WALL] = 10, t);
return r.sort(function(e, t) {
var r, n, a = null !== (r = o[e.structureType]) && void 0 !== r ? r : 40;
return (null !== (n = o[t.structureType]) && void 0 !== n ? n : 40) - a;
});
}, On.findDamagedStructures = function(e, t, r) {
return void 0 === t && (t = .75), void 0 === r && (r = !0), e.find(FIND_STRUCTURES).filter(function(e) {
return (!r || e.structureType !== STRUCTURE_WALL && e.structureType !== STRUCTURE_RAMPART) && e.hits < e.hitsMax * t;
});
}, On.findEnergySources = function(t, r, o) {
var n, a, i, s;
void 0 === o && (o = 50);
var c = [], l = r.find(FIND_DROPPED_RESOURCES, {
filter: function(e) {
return e.resourceType === RESOURCE_ENERGY && e.amount >= o;
}
});
try {
for (var u = e(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
c.push({
target: m,
amount: m.amount,
range: t.getRangeTo(m.pos)
});
}
} catch (e) {
n = {
error: e
};
} finally {
try {
f && !f.done && (a = u.return) && a.call(u);
} finally {
if (n) throw n.error;
}
}
var p = r.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getUsedCapacity(RESOURCE_ENERGY) >= o;
}
});
try {
for (var d = e(p), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
c.push({
target: g,
amount: g.store.getUsedCapacity(RESOURCE_ENERGY),
range: t.getRangeTo(g.pos)
});
}
} catch (e) {
i = {
error: e
};
} finally {
try {
y && !y.done && (s = d.return) && s.call(d);
} finally {
if (i) throw i.error;
}
}
return r.storage && r.storage.store.getUsedCapacity(RESOURCE_ENERGY) >= o && c.push({
target: r.storage,
amount: r.storage.store.getUsedCapacity(RESOURCE_ENERGY),
range: t.getRangeTo(r.storage.pos)
}), r.terminal && r.terminal.store.getUsedCapacity(RESOURCE_ENERGY) >= o && c.push({
target: r.terminal,
amount: r.terminal.store.getUsedCapacity(RESOURCE_ENERGY),
range: t.getRangeTo(r.terminal.pos)
}), c.sort(function(e, t) {
return e.range - t.range;
});
}, On.findHostilesByThreat = function(t, r) {
var o = t.find(FIND_HOSTILE_CREEPS);
if (0 === o.length) return [];
var n = o.map(function(t) {
var o, n, a = 0;
try {
for (var i = e(t.body), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
c.hits > 0 && (c.type === ATTACK ? a += 30 : c.type === RANGED_ATTACK ? a += 10 : c.type === HEAL ? a += 15 : c.type === WORK && (a += 5));
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return {
creep: t,
threat: a,
range: r ? r.getRangeTo(t.pos) : 50
};
});
return n.sort(function(e, t) {
return t.threat !== e.threat ? t.threat - e.threat : e.range - t.range;
});
}, On.getFindOptimizationStats = function() {
var e = t();
return {
cacheSize: e.results.size,
tick: e.tick
};
}, On.clearFindCache = function() {
var e = f;
e._findInRangeCache && e._findInRangeCache.results.clear();
}, On;
}(), e)), Cn;
var e, t, r;
}(), Wn), Kn((pn || (pn = 1, Object.defineProperty(wn, "__esModule", {
value: !0
})), wn), Wn), Kn(function() {
return Nn || (Nn = 1, e = xn, t = xn && xn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = xn && xn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r(Mn(), e), r(function() {
if (An) return In;
An = 1;
var e = In && In.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(In, "__esModule", {
value: !0
}), In.clearTargetAssignments = function() {
t.clear();
}, In.findDistributedTarget = function(t, n, a) {
var i, s;
if (0 === n.length) return null;
if (1 === n.length) return o(t, n[0], a), n[0];
var c = r(t.room.name), l = null, u = 1 / 0, f = 1 / 0;
try {
for (var m = e(n), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = "".concat(a, ":").concat(d.id), g = (c.assignments.get(y) || []).length, h = t.pos.getRangeTo(d.pos);
(g < u || g === u && h < f) && (l = d, u = g, f = h);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
p && !p.done && (s = m.return) && s.call(m);
} finally {
if (i) throw i.error;
}
}
return l && o(t, l, a), l;
}, In.registerAssignment = o, In.getAssignmentCount = function(e, t, o) {
var n = r(e), a = "".concat(o, ":").concat(t);
return (n.assignments.get(a) || []).length;
}, In.getAssignedCreeps = function(e, t, o) {
var n = r(e), a = "".concat(o, ":").concat(t);
return n.assignments.get(a) || [];
};
var t = new Map;
function r(e) {
var r = t.get(e);
return r && r.tick === Game.time || (r = {
assignments: new Map,
tick: Game.time
}, t.set(e, r)), r;
}
function o(e, t, o) {
var n = r(e.room.name), a = "".concat(o, ":").concat(t.id), i = n.assignments.get(a) || [];
i.includes(e.name) || (i.push(e.name), n.assignments.set(a, i));
}
return In;
}(), e), r(function() {
if (kn) return Gn;
kn = 1;
var e = Gn && Gn.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = Gn && Gn.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, r = Gn && Gn.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(Gn, "__esModule", {
value: !0
}), Gn.weightedSelection = n, Gn.weightedSelectionEntry = function(e) {
var t = n(e);
return void 0 === t ? void 0 : e.find(function(e) {
return e.key === t;
});
}, Gn.selectTopN = function(e, o) {
return r([], t(e), !1).sort(function(e, t) {
return t.weight - e.weight;
}).slice(0, o).map(function(e) {
return e.key;
});
}, Gn.selectTopNEntries = function(e, o) {
return r([], t(e), !1).sort(function(e, t) {
return t.weight - e.weight;
}).slice(0, o);
}, Gn.normalizeWeights = function(e) {
var t = e.filter(function(e) {
return e.weight > 0;
}), r = t.reduce(function(e, t) {
return e + t.weight;
}, 0);
return r <= 0 ? [] : t.map(function(e) {
return {
key: e.key,
weight: e.weight / r
};
});
}, Gn.scaleWeights = function(e, t) {
return e.map(function(e) {
return {
key: e.key,
weight: Math.max(0, e.weight * t)
};
});
}, Gn.addBonusWeight = function(e, t, r) {
return e.map(function(e) {
return {
key: e.key,
weight: t(e) ? Math.max(0, e.weight + r) : e.weight
};
});
}, Gn.combineWeights = function(r, o) {
var n, a, i, s, c;
void 0 === o && (o = function(e) {
return e.reduce(function(e, t) {
return e + t;
}, 0);
});
var l = new Map;
try {
for (var u = e(r), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
try {
for (var p = (i = void 0, e(m)), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = null !== (c = l.get(y.key)) && void 0 !== c ? c : [];
g.push(y.weight), l.set(y.key, g);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
d && !d.done && (s = p.return) && s.call(p);
} finally {
if (i) throw i.error;
}
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
f && !f.done && (a = u.return) && a.call(u);
} finally {
if (n) throw n.error;
}
}
return Array.from(l.entries()).map(function(e) {
var r = t(e, 2), n = r[0], a = r[1];
return {
key: n,
weight: o(a)
};
});
}, Gn.fromRecord = function(e) {
return Object.entries(e).map(function(e) {
var r = t(e, 2);
return {
key: r[0],
weight: r[1]
};
});
}, Gn.toRecord = function(t) {
var r, o, n = {};
try {
for (var a = e(t), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
n[s.key] = s.weight;
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
return n;
}, Gn.filterByMinWeight = function(e, t) {
return e.filter(function(e) {
return e.weight >= t;
});
}, Gn.getHighest = function(e) {
return 0 === e.length ? void 0 : e.reduce(function(e, t) {
return t.weight > e.weight ? t : e;
});
}, Gn.getLowest = function(e) {
var t = e.filter(function(e) {
return e.weight > 0;
});
return 0 === t.length ? void 0 : t.reduce(function(e, t) {
return t.weight < e.weight ? t : e;
});
}, Gn.applyDecay = function(e, t) {
return e.map(function(e) {
return {
key: e.key,
weight: e.weight * t
};
});
}, Gn.clampWeights = function(e, t, r) {
return e.map(function(e) {
return {
key: e.key,
weight: Math.max(t, Math.min(r, e.weight))
};
});
};
var o = Mn();
function n(t) {
var r, n, a, i = t.filter(function(e) {
return e.weight > 0;
});
if (0 !== i.length) {
var s = i.reduce(function(e, t) {
return e + t.weight;
}, 0);
if (!(s <= 0)) {
var c = (0, o.random)() * s;
try {
for (var l = e(i), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if ((c -= f.weight) <= 0) return f.key;
}
} catch (e) {
r = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (r) throw r.error;
}
}
return null === (a = i[i.length - 1]) || void 0 === a ? void 0 : a.key;
}
}
}
return Gn;
}(), e)), xn;
var e, t, r;
}(), Wn), Kn(function() {
return jn || (jn = 1, e = Ln, t = Ln && Ln.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = Ln && Ln.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
}, Object.defineProperty(e, "__esModule", {
value: !0
}), r(Fn(), e), r(function() {
if (Bn) return zn;
Bn = 1, Object.defineProperty(zn, "__esModule", {
value: !0
}), zn.createHelp = function() {
for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
return o() + n() + '<div class="module-help">'.concat(e.map(t).join(""), "</div>");
};
var e = Fn(), t = function(t) {
var o = t.api.map(r).join("");
return '<div class="module-container">\n    <div class="module-info">\n      <span class="module-title">'.concat((0, 
e.colorful)(t.name, "yellow"), '</span>\n      <span class="module-describe">').concat((0, 
e.colorful)(t.describe, "green"), '</span>\n    </div>\n    <div class="module-api-list">').concat(o, "</div>\n  </div>").replace(/\n/g, "");
}, r = function(t) {
var r = [];
t.describe && r.push((0, e.colorful)(t.describe, "green")), t.params && r.push(t.params.map(function(t) {
return "  - ".concat((0, e.colorful)(t.name, "blue"), ": ").concat((0, e.colorful)(t.desc, "green"));
}).map(function(e) {
return '<div class="api-content-line">'.concat(e, "</div>");
}).join(""));
var o = t.params ? t.params.map(function(t) {
return (0, e.colorful)(t.name, "blue");
}).join(", ") : "", n = (0, e.colorful)(t.functionName, "yellow") + (t.commandType ? "" : "(".concat(o, ")"));
r.push(n);
var a = r.map(function(e) {
return '<div class="api-content-line">'.concat(e, "</div>");
}).join(""), i = "".concat(t.functionName).concat(Game.time);
return '\n  <div class="api-container">\n    <label for="'.concat(i, '">').concat(t.title, " ").concat((0, 
e.colorful)(t.functionName, "yellow", !0), '</label>\n    <input id="').concat(i, '" type="checkbox" />\n    <div class="api-content">').concat(a, "</div>\n  </div>\n  ").replace(/\n/g, "");
}, o = function() {
return "\n  <style>\n  .module-help {\n    display: flex;\n    flex-flow: column nowrap;\n  }\n  .module-container {\n    padding: 0px 10px 10px 10px;\n    display: flex;\n    flex-flow: column nowrap;\n  }\n  .module-info {\n    margin: 5px;\n    display: flex;\n    flex-flow: row nowrap;\n    align-items: baseline;\n  }\n  .module-title {\n    font-size: 19px;\n    font-weight: bolder;\n    margin-left: -15px;\n  }\n  .module-api-list {\n    display: flex;\n    flex-flow: row wrap;\n  }\n  </style>".replace(/\n/g, "");
}, n = function() {
return "\n  <style>\n  .api-content-line {\n    width: max-content;\n    padding-right: 15px;\n  }\n  .api-container {\n    margin: 5px;\n    width: 250px;\n    background-color: #2b2b2b;\n    overflow: hidden;\n    display: flex;\n    flex-flow: column;\n  }\n\n  .api-container label {\n    transition: all 0.1s;\n    min-width: 300px;\n  }\n\n  /* Hide checkbox */\n  .api-container input {\n    display: none;\n  }\n\n  .api-container label {\n    cursor: pointer;\n    display: block;\n    padding: 10px;\n    background-color: #3b3b3b;\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .api-container label:hover, label:focus {\n    background-color: #525252;\n  }\n\n  /* Collapsed state */\n  .api-container input + .api-content {\n    overflow: hidden;\n    transition: all 0.1s;\n    width: auto;\n    max-height: 0px;\n    padding: 0px 10px;\n  }\n\n  /* Expanded state when checkbox is checked */\n  .api-container input:checked + .api-content {\n    max-height: 200px;\n    padding: 10px;\n    background-color: #1c1c1c;\n    overflow-x: auto;\n  }\n  </style>".replace(/\n/g, "");
};
return zn;
}(), e)), Ln;
var e, t, r;
}(), Wn)), zo), Xn = {}, Qn = {};

function Zn() {
return Vn || (Vn = 1, Object.defineProperty(Qn, "__esModule", {
value: !0
}), Qn.VisualizationLayer = void 0, function(e) {
e[e.None = 0] = "None", e[e.Pheromones = 1] = "Pheromones", e[e.Paths = 2] = "Paths", 
e[e.Traffic = 4] = "Traffic", e[e.Defense = 8] = "Defense", e[e.Economy = 16] = "Economy", 
e[e.Construction = 32] = "Construction", e[e.Performance = 64] = "Performance";
}(e || (Qn.VisualizationLayer = e = {}))), Qn;
var e;
}

var Jn, $n, ea = {}, ta = {};

function ra() {
if (Jn) return ta;
function e(e) {
try {
return JSON.stringify(e);
} catch (t) {
try {
return String(e);
} catch (e) {
return "[Unserializable]";
}
}
}
return Jn = 1, Object.defineProperty(ta, "__esModule", {
value: !0
}), ta.createLogger = function(t) {
return {
info: function(r, o) {
o ? console.log("[".concat(t, "] ").concat(r), e(o)) : console.log("[".concat(t, "] ").concat(r));
},
warn: function(r, o) {
o ? console.log("[".concat(t, "] WARN: ").concat(r), e(o)) : console.log("[".concat(t, "] WARN: ").concat(r));
},
error: function(r, o) {
o ? console.log("[".concat(t, "] ERROR: ").concat(r), e(o)) : console.log("[".concat(t, "] ERROR: ").concat(r));
},
debug: function(r, o) {
o ? console.log("[".concat(t, "] DEBUG: ").concat(r), e(o)) : console.log("[".concat(t, "] DEBUG: ").concat(r));
}
};
}, ta;
}

function oa() {
if ($n) return ea;
$n = 1;
var e = ea && ea.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = ea && ea.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = ea && ea.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(ea, "__esModule", {
value: !0
}), ea.visualizationManager = ea.VisualizationManager = void 0, ea.getVisualizationManager = s;
var o = Zn(), n = (0, ra().createLogger)("VisualizationManager"), a = function() {
function a() {
this.perfSamples = {}, this.config = this.loadConfig();
}
return a.prototype.loadConfig = function() {
var e = Memory;
return e.visualConfig || (e.visualConfig = this.createDefaultConfig()), e.visualConfig;
}, a.prototype.saveConfig = function() {
Memory.visualConfig = this.config;
}, a.prototype.createDefaultConfig = function() {
return {
enabledLayers: o.VisualizationLayer.Pheromones | o.VisualizationLayer.Defense,
mode: "presentation",
layerCosts: {
pheromones: 0,
paths: 0,
traffic: 0,
defense: 0,
economy: 0,
construction: 0
},
totalCost: 0,
cache: {
terrain: {},
structures: {}
},
lastCacheClear: Game.time
};
}, a.prototype.isLayerEnabled = function(e) {
return 0 !== (this.config.enabledLayers & e);
}, a.prototype.enableLayer = function(e) {
this.config.enabledLayers |= e, this.saveConfig();
}, a.prototype.disableLayer = function(e) {
this.config.enabledLayers &= ~e, this.saveConfig();
}, a.prototype.toggleLayer = function(e) {
this.config.enabledLayers ^= e, this.saveConfig();
}, a.prototype.setMode = function(e) {
switch (this.config.mode = e, e) {
case "debug":
this.config.enabledLayers = o.VisualizationLayer.Pheromones | o.VisualizationLayer.Paths | o.VisualizationLayer.Traffic | o.VisualizationLayer.Defense | o.VisualizationLayer.Economy | o.VisualizationLayer.Construction | o.VisualizationLayer.Performance;
break;

case "presentation":
this.config.enabledLayers = o.VisualizationLayer.Pheromones | o.VisualizationLayer.Defense | o.VisualizationLayer.Economy;
break;

case "minimal":
this.config.enabledLayers = o.VisualizationLayer.Defense;
break;

case "performance":
this.config.enabledLayers = o.VisualizationLayer.None;
}
this.saveConfig(), n.info("Visualization mode set to: ".concat(e));
}, a.prototype.updateFromFlags = function() {
var e, a, i = Game.flags, s = {
viz_pheromones: o.VisualizationLayer.Pheromones,
viz_paths: o.VisualizationLayer.Paths,
viz_traffic: o.VisualizationLayer.Traffic,
viz_defense: o.VisualizationLayer.Defense,
viz_economy: o.VisualizationLayer.Economy,
viz_construction: o.VisualizationLayer.Construction,
viz_performance: o.VisualizationLayer.Performance
}, c = function(e, t) {
Object.values(i).some(function(t) {
return t.name === e;
}) && !l.isLayerEnabled(t) && (l.enableLayer(t), n.info("Enabled layer ".concat(o.VisualizationLayer[t], " via flag")));
}, l = this;
try {
for (var u = t(Object.entries(s)), f = u.next(); !f.done; f = u.next()) {
var m = r(f.value, 2);
c(m[0], m[1]);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
f && !f.done && (a = u.return) && a.call(u);
} finally {
if (e) throw e.error;
}
}
}, a.prototype.trackLayerCost = function(e, t) {
this.perfSamples[e] || (this.perfSamples[e] = []), this.perfSamples[e].push(t), 
this.perfSamples[e].length > 10 && this.perfSamples[e].shift();
var r = this.perfSamples[e], o = r.reduce(function(e, t) {
return e + t;
}, 0) / r.length;
this.config.layerCosts[e] = o, this.config.totalCost = Object.values(this.config.layerCosts).reduce(function(e, t) {
return e + t;
}, 0);
var a = Game.cpu.limit, i = this.config.totalCost / a * 100;
i > 10 && n.warn("Visualization using ".concat(i.toFixed(1), "% of CPU budget"));
}, a.prototype.getCachedTerrain = function(e) {
var t = this.config.cache.terrain[e];
return !t || Game.time > t.ttl ? null : t.data;
}, a.prototype.cacheTerrain = function(e, t) {
this.config.cache.terrain[e] = {
data: t,
ttl: Game.time + 100
};
}, a.prototype.getCachedStructures = function(e) {
var t = this.config.cache.structures[e];
return !t || Game.time > t.ttl ? null : t.data;
}, a.prototype.cacheStructures = function(e, t) {
this.config.cache.structures[e] = {
data: t,
ttl: Game.time + 100
};
}, a.prototype.clearCache = function(e) {
e ? (delete this.config.cache.terrain[e], delete this.config.cache.structures[e]) : (this.config.cache = {
terrain: {},
structures: {}
}, this.config.lastCacheClear = Game.time), this.saveConfig();
}, a.prototype.getConfig = function() {
return e({}, this.config);
}, a.prototype.getPerformanceMetrics = function() {
var t = Game.cpu.limit;
return {
totalCost: this.config.totalCost,
layerCosts: e({}, this.config.layerCosts),
percentOfBudget: this.config.totalCost / t * 100
};
}, a.prototype.measureCost = function(e) {
var t = Game.cpu.getUsed();
return {
result: e(),
cost: Game.cpu.getUsed() - t
};
}, a;
}();
ea.VisualizationManager = a;
var i = null;
function s() {
return null === i && (i = new a), i;
}
return ea.visualizationManager = s(), ea;
}

var na, aa, ia, sa, ca, la, ua = {}, fa = {}, ma = {}, pa = {}, da = (ca || (ca = 1, 
function(e) {
var t = Xn && Xn.__createBinding || (Object.create ? function(e, t, r, o) {
void 0 === o && (o = r);
var n = Object.getOwnPropertyDescriptor(t, r);
n && !("get" in n ? !t.__esModule : n.writable || n.configurable) || (n = {
enumerable: !0,
get: function() {
return t[r];
}
}), Object.defineProperty(e, o, n);
} : function(e, t, r, o) {
void 0 === o && (o = r), e[o] = t[r];
}), r = Xn && Xn.__exportStar || function(e, r) {
for (var o in e) "default" === o || Object.prototype.hasOwnProperty.call(r, o) || t(r, e, o);
};
Object.defineProperty(e, "__esModule", {
value: !0
}), e.createLogger = e.initializeRoomVisualExtensions = e.renderCompactBudgetStatus = e.renderBudgetDashboard = e.MapVisualizer = e.RoomVisualizer = e.VisualizationManager = e.getVisualizationManager = e.visualizationManager = void 0, 
r(Zn(), e);
var o = oa();
Object.defineProperty(e, "visualizationManager", {
enumerable: !0,
get: function() {
return o.visualizationManager;
}
}), Object.defineProperty(e, "getVisualizationManager", {
enumerable: !0,
get: function() {
return o.getVisualizationManager;
}
}), Object.defineProperty(e, "VisualizationManager", {
enumerable: !0,
get: function() {
return o.VisualizationManager;
}
});
var n = function() {
if (na) return ua;
na = 1;
var e = ua && ua.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = ua && ua.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = ua && ua.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(ua, "__esModule", {
value: !0
}), ua.roomVisualizer = ua.RoomVisualizer = void 0;
var o = Zn(), n = ra(), a = oa();
(0, n.createLogger)("RoomVisualizer");
var i = {
showPheromones: !0,
showPaths: !1,
showCombat: !0,
showResourceFlow: !1,
showSpawnQueue: !0,
showRoomStats: !0,
showStructures: !1,
opacity: .5
}, s = {
expand: "#00ff00",
harvest: "#ffff00",
build: "#ff8800",
upgrade: "#0088ff",
defense: "#ff0000",
war: "#ff00ff",
siege: "#880000",
logistics: "#00ffff",
nukeTarget: "#ff0088"
}, c = function() {
function n(t, r) {
void 0 === t && (t = {}), this.config = e(e({}, i), t), this.memoryManager = r;
}
return n.prototype.setMemoryManager = function(e) {
this.memoryManager = e;
}, n.prototype.draw = function(e) {
var t, r = this, n = new RoomVisual(e.name), i = null === (t = this.memoryManager) || void 0 === t ? void 0 : t.getOrInitSwarmState(e.name);
if (a.visualizationManager.updateFromFlags(), this.config.showRoomStats && this.drawRoomStats(n, e, i), 
this.config.showPheromones && a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Pheromones) && i) {
var s = a.visualizationManager.measureCost(function() {
r.drawPheromoneBars(n, i), r.drawPheromoneHeatmap(n, i);
}).cost;
a.visualizationManager.trackLayerCost("pheromones", s);
}
this.config.showCombat && a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Defense) && (s = a.visualizationManager.measureCost(function() {
r.drawCombatInfo(n, e);
}).cost, a.visualizationManager.trackLayerCost("defense", s)), this.config.showSpawnQueue && this.drawSpawnQueue(n, e), 
this.config.showResourceFlow && a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Economy) && (s = a.visualizationManager.measureCost(function() {
r.drawResourceFlow(n, e);
}).cost, a.visualizationManager.trackLayerCost("economy", s)), this.config.showPaths && a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Paths) && (s = a.visualizationManager.measureCost(function() {
r.drawTrafficPaths(n, e);
}).cost, a.visualizationManager.trackLayerCost("paths", s)), this.config.showStructures && a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Construction) && (s = a.visualizationManager.measureCost(function() {
r.drawEnhancedStructures(n, e);
}).cost, a.visualizationManager.trackLayerCost("construction", s)), (null == i ? void 0 : i.collectionPoint) && this.drawCollectionPoint(n, i), 
a.visualizationManager.isLayerEnabled(o.VisualizationLayer.Performance) && this.drawPerformanceMetrics(n);
}, n.prototype.drawRoomStats = function(e, t, r) {
var o, n, a, i, s, c, l = .5, u = .5, f = .6;
e.rect(0, 0, 8, 6.5, {
fill: "#000000",
opacity: .7,
stroke: "#ffffff",
strokeWidth: .05
});
var m = null !== (n = null === (o = t.controller) || void 0 === o ? void 0 : o.level) && void 0 !== n ? n : 0, p = t.controller ? "".concat(Math.round(t.controller.progress / t.controller.progressTotal * 100), "%") : "N/A";
e.text("".concat(t.name, " | RCL ").concat(m, " (").concat(p, ")"), l, u, {
align: "left",
font: "0.5 monospace",
color: "#ffffff"
}), u += f;
var d = t.energyAvailable, y = t.energyCapacityAvailable, g = y > 0 ? Math.round(d / y * 100) : 0;
if (e.text("Energy: ".concat(d, "/").concat(y, " (").concat(g, "%)"), l, u, {
align: "left",
font: "0.4 monospace",
color: "#ffff00"
}), u += f, t.storage) {
var h = t.storage.store.getUsedCapacity(RESOURCE_ENERGY);
e.text("Storage: ".concat(Math.round(h / 1e3), "k energy"), l, u, {
align: "left",
font: "0.4 monospace",
color: "#00ff00"
}), u += f;
}
r && (e.text("Stage: ".concat(r.colonyLevel), l, u, {
align: "left",
font: "0.4 monospace",
color: "#00ffff"
}), u += f, e.text("Posture: ".concat(null !== (a = r.posture) && void 0 !== a ? a : "eco", " | Danger: ").concat(null !== (i = r.danger) && void 0 !== i ? i : 0), l, u, {
align: "left",
font: "0.4 monospace",
color: null !== (c = [ "#00ff00", "#ffff00", "#ff8800", "#ff0000" ][null !== (s = r.danger) && void 0 !== s ? s : 0]) && void 0 !== c ? c : "#ffffff"
}), u += f);
var v = t.find(FIND_MY_CREEPS).length, R = t.find(FIND_HOSTILE_CREEPS).length;
e.text("Creeps: ".concat(v, " | Hostiles: ").concat(R), l, u, {
align: "left",
font: "0.4 monospace",
color: R > 0 ? "#ff0000" : "#ffffff"
}), u += f;
var E = Game.cpu.getUsed().toFixed(1), T = Game.cpu.bucket;
e.text("CPU: ".concat(E, " | Bucket: ").concat(T), l, u, {
align: "left",
font: "0.4 monospace",
color: T < 3e3 ? "#ff8800" : "#ffffff"
});
}, n.prototype.drawPheromoneBars = function(e, o) {
var n, a, i, c = .5;
if (e.rect(41.5, 0, 8, 5.5, {
fill: "#000000",
opacity: .7,
stroke: "#ffffff",
strokeWidth: .05
}), e.text("Pheromones", 45, c, {
align: "center",
font: "0.5 monospace",
color: "#ffffff"
}), c += .6, o.pheromones) try {
for (var l = t(Object.entries(o.pheromones)), u = l.next(); !u.done; u = l.next()) {
var f = r(u.value, 2), m = f[0], p = f[1], d = null !== (i = s[m]) && void 0 !== i ? i : "#888888", y = 6 * Math.min(1, p / 100);
e.rect(42, c, 6, .4, {
fill: "#333333",
opacity: .8
}), y > 0 && e.rect(42, c, y, .4, {
fill: d,
opacity: this.config.opacity
}), e.text("".concat(m, ": ").concat(Math.round(p)), 41.8, c + .35, {
align: "right",
font: "0.35 monospace",
color: d
}), c += .5;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
u && !u.done && (a = l.return) && a.call(l);
} finally {
if (n) throw n.error;
}
}
}, n.prototype.drawPheromoneHeatmap = function(e, o) {
var a, i, c;
if (o.pheromones) {
var l = null, u = n.HEATMAP_MIN_THRESHOLD;
try {
for (var f = t(Object.entries(o.pheromones)), m = f.next(); !m.done; m = f.next()) {
var p = r(m.value, 2), d = p[0], y = p[1];
y > u && (u = y, l = d);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
m && !m.done && (i = f.return) && i.call(f);
} finally {
if (a) throw a.error;
}
}
if (l && !(u < n.HEATMAP_MIN_THRESHOLD)) {
var g = null !== (c = s[l]) && void 0 !== c ? c : "#888888", h = .15 * Math.min(1, u / 100);
e.rect(40, 10, 8, 5, {
fill: g,
opacity: h
}), e.text("Dominant: ".concat(l), 44, 12.5, {
align: "center",
font: "0.5 monospace",
color: g
}), e.text("Intensity: ".concat(Math.round(u)), 44, 13.5, {
align: "center",
font: "0.4 monospace",
color: "#ffffff"
});
}
}
}, n.prototype.drawCombatInfo = function(e, r) {
var o, n, a, i, s = r.find(FIND_HOSTILE_CREEPS);
try {
for (var c = t(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = this.calculateCreepThreat(u), m = f > 30 ? "#ff0000" : f > 10 ? "#ff8800" : "#ffff00", p = .4 + f / 100, d = .2 + f / 100 * .3;
e.circle(u.pos, {
radius: p,
fill: m,
opacity: d,
stroke: m,
strokeWidth: .1
}), e.text("T:".concat(f), u.pos.x, u.pos.y - .8, {
font: "0.4 monospace",
color: m
}), f > 20 && e.animatedPosition(u.pos.x, u.pos.y, {
color: m,
opacity: .8,
radius: 1,
frames: 8
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
if (s.length > 0) {
var y = r.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
});
try {
for (var g = t(y), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
e.circle(v.pos, {
radius: 5,
fill: "#00ff00",
opacity: .15,
stroke: "#00ff00",
strokeWidth: .05
}), e.circle(v.pos, {
radius: 10,
fill: "#ffff00",
opacity: .08,
stroke: "#ffff00",
strokeWidth: .05
});
}
} catch (e) {
a = {
error: e
};
} finally {
try {
h && !h.done && (i = g.return) && i.call(g);
} finally {
if (a) throw a.error;
}
}
}
}, n.prototype.calculateCreepThreat = function(e) {
var r, o, n = 0;
try {
for (var a = t(e.body), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
if (s.hits) switch (s.type) {
case ATTACK:
n += 5 * (s.boost ? 4 : 1);
break;

case RANGED_ATTACK:
n += 4 * (s.boost ? 4 : 1);
break;

case HEAL:
n += 6 * (s.boost ? 4 : 1);
break;

case TOUGH:
n += 1 * (s.boost ? 4 : 1);
break;

case WORK:
n += 2 * (s.boost ? 4 : 1);
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
return n;
}, n.prototype.drawSpawnQueue = function(e, r) {
var o, n, a, i = r.find(FIND_MY_SPAWNS);
try {
for (var s = t(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
if (l.spawning) {
var u = Game.creeps[l.spawning.name], f = 1 - l.spawning.remainingTime / l.spawning.needTime, m = l.pos.x - 1, p = l.pos.y - 1.5;
e.rect(m, p, 2, .3, {
fill: "#333333",
opacity: .8
}), e.rect(m, p, 2 * f, .3, {
fill: "#00ff00",
opacity: .8
});
var d = null == u ? void 0 : u.memory, y = null !== (a = null == d ? void 0 : d.role) && void 0 !== a ? a : l.spawning.name;
e.speech(y, l.pos.x, l.pos.y, {
background: "#2ccf3b",
textcolor: "#000000",
textsize: .4,
opacity: .9
}), l.spawning.remainingTime > l.spawning.needTime - 5 && e.animatedPosition(l.pos.x, l.pos.y, {
color: "#00ff00",
opacity: .6,
radius: 1.2,
frames: 10
});
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
}, n.prototype.drawResourceFlow = function(e, r) {
var o, n, a, i, s, c, l, u, f = r.storage;
if (f) {
var m = r.find(FIND_SOURCES);
try {
for (var p = t(m), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
this.drawFlowingArrow(e, y.pos, f.pos, "#ffff00", .3);
var g = (y.pos.x + f.pos.x) / 2, h = (y.pos.y + f.pos.y) / 2;
e.resource(RESOURCE_ENERGY, g, h, .2);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
d && !d.done && (n = p.return) && n.call(p);
} finally {
if (o) throw o.error;
}
}
var v = r.find(FIND_MY_SPAWNS);
try {
for (var R = t(v), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
T.store.getFreeCapacity(RESOURCE_ENERGY) > 0 && this.drawFlowingArrow(e, f.pos, T.pos, "#00ff00", .3);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
E && !E.done && (i = R.return) && i.call(R);
} finally {
if (a) throw a.error;
}
}
var S = r.controller;
if (S && this.drawFlowingArrow(e, f.pos, S.pos, "#00ffff", .3), f.store.getUsedCapacity() > 0) {
var C = .8, b = -.8, _ = Object.keys(f.store).filter(function(e) {
return f.store[e] > 1e3;
}).sort(function(e, t) {
return f.store[t] - f.store[e];
}).slice(0, 3);
try {
for (var O = t(_), w = O.next(); !w.done; w = O.next()) {
var x = w.value;
e.resource(x, f.pos.x + C, f.pos.y + b, .3), C += .6;
}
} catch (e) {
s = {
error: e
};
} finally {
try {
w && !w.done && (c = O.return) && c.call(O);
} finally {
if (s) throw s.error;
}
}
}
var U = r.terminal;
if (U && U.store.getUsedCapacity() > 0) {
C = .8, b = -.8, _ = Object.keys(U.store).filter(function(e) {
return U.store[e] > 1e3;
}).sort(function(e, t) {
return U.store[t] - U.store[e];
}).slice(0, 3);
try {
for (var M = t(_), A = M.next(); !A.done; A = M.next()) x = A.value, e.resource(x, U.pos.x + C, U.pos.y + b, .3), 
C += .6;
} catch (e) {
l = {
error: e
};
} finally {
try {
A && !A.done && (u = M.return) && u.call(M);
} finally {
if (l) throw l.error;
}
}
}
}
}, n.prototype.drawFlowingArrow = function(e, t, r, o, n) {
e.line(t, r, {
color: o,
opacity: .5 * n,
width: .1,
lineStyle: "dashed"
});
var a = Game.time % 20 / 20, i = t.x + (r.x - t.x) * a, s = t.y + (r.y - t.y) * a;
e.circle(i, s, {
radius: .15,
fill: o,
opacity: n
});
}, n.prototype.drawArrow = function(e, t, r, o, n) {
e.line(t, r, {
color: o,
opacity: n,
width: .1,
lineStyle: "dashed"
});
}, n.prototype.drawEnhancedStructures = function(e, r) {
var o, n, i, s, c, l, u = a.visualizationManager.getCachedStructures(r.name);
if (u) try {
for (var f = t(u), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = this.getStructureDepthOpacity(p.type);
e.structure(p.x, p.y, p.type, {
opacity: d
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (n = f.return) && n.call(f);
} finally {
if (o) throw o.error;
}
} else {
var y = r.find(FIND_STRUCTURES), g = [];
try {
for (var h = t(y), v = h.next(); !v.done; v = h.next()) {
var R = v.value;
d = this.getStructureDepthOpacity(R.structureType), e.structure(R.pos.x, R.pos.y, R.structureType, {
opacity: d
}), g.push({
x: R.pos.x,
y: R.pos.y,
type: R.structureType
});
}
} catch (e) {
i = {
error: e
};
} finally {
try {
v && !v.done && (s = h.return) && s.call(h);
} finally {
if (i) throw i.error;
}
}
a.visualizationManager.cacheStructures(r.name, g);
}
var E = r.find(FIND_MY_CONSTRUCTION_SITES);
try {
for (var T = t(E), S = T.next(); !S.done; S = T.next()) {
var C = S.value;
e.structure(C.pos.x, C.pos.y, C.structureType, {
opacity: .3
});
}
} catch (e) {
c = {
error: e
};
} finally {
try {
S && !S.done && (l = T.return) && l.call(T);
} finally {
if (c) throw c.error;
}
}
}, n.prototype.getStructureDepthOpacity = function(e) {
switch (e) {
case STRUCTURE_RAMPART:
return .8;

case STRUCTURE_TOWER:
return .9;

case STRUCTURE_SPAWN:
case STRUCTURE_STORAGE:
case STRUCTURE_TERMINAL:
return .85;

case STRUCTURE_ROAD:
return .3;

case STRUCTURE_WALL:
return .9;

default:
return .7;
}
}, n.prototype.drawPerformanceMetrics = function(e) {
var o, n, i = a.visualizationManager.getPerformanceMetrics(), s = .5, c = 7.5, l = .5;
e.rect(0, 7, 10, 5.5, {
fill: "#000000",
opacity: .8,
stroke: "#ffff00",
strokeWidth: .05
}), e.text("Visualization Performance", s, c, {
align: "left",
font: "0.5 monospace",
color: "#ffff00"
}), c += l;
var u = i.percentOfBudget > 10 ? "#ff0000" : "#00ff00";
e.text("Total: ".concat(i.totalCost.toFixed(3), " CPU"), s, c, {
align: "left",
font: "0.4 monospace",
color: u
}), c += l, e.text("(".concat(i.percentOfBudget.toFixed(1), "% of budget)"), s, c, {
align: "left",
font: "0.35 monospace",
color: u
}), c += l, e.text("Layer Costs:", s, c, {
align: "left",
font: "0.4 monospace",
color: "#ffffff"
}), c += l;
try {
for (var f = t(Object.entries(i.layerCosts)), m = f.next(); !m.done; m = f.next()) {
var p = r(m.value, 2), d = p[0], y = p[1];
y > 0 && (e.text("  ".concat(d, ": ").concat(y.toFixed(3)), s, c, {
align: "left",
font: "0.35 monospace",
color: "#aaaaaa"
}), c += .4);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (n = f.return) && n.call(f);
} finally {
if (o) throw o.error;
}
}
}, n.prototype.drawTrafficPaths = function(e, r) {
var o, n, a = r.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
});
try {
for (var i = t(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = c.hits / c.hitsMax, u = "hsl(".concat(120 - 120 * (1 - l), ", 100%, 50%)");
e.circle(c.pos, {
radius: .2,
fill: u,
opacity: .5
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
}, n.prototype.drawBlueprint = function(e, r) {
var o, n;
try {
for (var a = t(r), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
e.structure(s.pos.x, s.pos.y, s.type, {
opacity: .4
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
i && !i.done && (n = a.return) && n.call(a);
} finally {
if (o) throw o.error;
}
}
}, n.prototype.setConfig = function(t) {
this.config = e(e({}, this.config), t);
}, n.prototype.getConfig = function() {
return e({}, this.config);
}, n.prototype.drawCollectionPoint = function(e, t) {
if (t.collectionPoint) {
var r = t.collectionPoint, o = r.x, n = r.y;
e.circle(o, n, {
radius: .5,
fill: "#00ff00",
opacity: .3,
stroke: "#00ff00",
strokeWidth: .1
}), e.text("", o, n + .25, {
font: "0.6 monospace",
color: "#00ff00",
opacity: .8
});
}
}, n.prototype.toggle = function(e) {
"boolean" == typeof this.config[e] && (this.config[e] = !this.config[e]);
}, n.HEATMAP_MIN_THRESHOLD = 10, n;
}();
return ua.RoomVisualizer = c, ua.roomVisualizer = new c, ua;
}();
Object.defineProperty(e, "RoomVisualizer", {
enumerable: !0,
get: function() {
return n.RoomVisualizer;
}
});
var a = function() {
if (aa) return fa;
aa = 1;
var e = fa && fa.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = fa && fa.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(fa, "__esModule", {
value: !0
}), fa.mapVisualizer = fa.MapVisualizer = void 0, (0, ra().createLogger)("MapVisualizer");
var r = {
showRoomStatus: !0,
showConnections: !0,
showThreats: !0,
showExpansion: !1,
showResourceFlow: !1,
showHighways: !1,
opacity: .6
}, o = [ "#00ff00", "#ffff00", "#ff8800", "#ff0000" ], n = {
eco: "#00ff00",
expand: "#00ffff",
defense: "#ffff00",
war: "#ff8800",
siege: "#ff0000",
evacuate: "#ff00ff"
}, a = function() {
function a(t, o) {
void 0 === t && (t = {}), this.config = e(e({}, r), t), this.memoryManager = o;
}
return a.prototype.setMemoryManager = function(e) {
this.memoryManager = e;
}, a.prototype.draw = function() {
var e = Game.map.visual;
this.config.showRoomStatus && this.drawRoomStatus(e), this.config.showConnections && this.drawConnections(e), 
this.config.showThreats && this.drawThreats(e), this.config.showExpansion && this.drawExpansionCandidates(e), 
this.config.showResourceFlow && this.drawResourceFlow(e), this.config.showHighways && this.drawHighways(e);
}, a.prototype.drawRoomStatus = function(e) {
var r, a, i, s, c, l;
try {
for (var u = t(Object.values(Game.rooms)), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (null === (i = m.controller) || void 0 === i ? void 0 : i.my) {
var p = null === (s = this.memoryManager) || void 0 === s ? void 0 : s.getOrInitSwarmState(m.name), d = m.controller.level, y = (null == p ? void 0 : p.danger) ? Math.min(Math.max(p.danger, 0), 3) : 0, g = null !== (c = o[y]) && void 0 !== c ? c : "#ffffff", h = {
radius: 10,
fill: g,
opacity: .5 * this.config.opacity,
stroke: g,
strokeWidth: 1
};
if (e.circle(new RoomPosition(25, 25, m.name), h), e.text("RCL".concat(d), new RoomPosition(25, 25, m.name), {
color: "#ffffff",
fontSize: 8,
align: "center"
}), p && p.posture && "eco" !== p.posture) {
var v = null !== (l = n[p.posture]) && void 0 !== l ? l : "#ffffff";
e.text(p.posture.toUpperCase(), new RoomPosition(25, 30, m.name), {
color: v,
fontSize: 6,
align: "center"
});
}
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
f && !f.done && (a = u.return) && a.call(u);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawConnections = function(e) {
var r, o, n, a, i = function(r) {
var o, i, c, l;
if (!(null === (n = r.controller) || void 0 === n ? void 0 : n.my)) return "continue";
var u = null === (a = s.memoryManager) || void 0 === a ? void 0 : a.getOrInitSwarmState(r.name);
if (!u) return "continue";
if (u.remoteAssignments && u.remoteAssignments.length > 0) try {
for (var f = (o = void 0, t(u.remoteAssignments)), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = {
color: "#00ffff",
opacity: .8 * s.config.opacity,
width: .5
};
e.line(new RoomPosition(25, 25, r.name), new RoomPosition(25, 25, p), d);
var y = {
radius: 5,
fill: "#00ffff",
opacity: .3 * s.config.opacity
};
e.circle(new RoomPosition(25, 25, p), y);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (i = f.return) && i.call(f);
} finally {
if (o) throw o.error;
}
}
if (u && ("war" === u.posture || "siege" === u.posture)) {
var g = Object.values(Game.rooms).filter(function(e) {
return e.find(FIND_HOSTILE_CREEPS).length > 0 && Game.map.getRoomLinearDistance(r.name, e.name) <= 5;
});
try {
for (var h = (c = void 0, t(g)), v = h.next(); !v.done; v = h.next()) {
var R = v.value, E = {
color: "#ff0000",
opacity: s.config.opacity,
width: 1
};
e.line(new RoomPosition(25, 25, r.name), new RoomPosition(25, 25, R.name), E);
}
} catch (e) {
c = {
error: e
};
} finally {
try {
v && !v.done && (l = h.return) && l.call(h);
} finally {
if (c) throw c.error;
}
}
}
}, s = this;
try {
for (var c = t(Object.values(Game.rooms)), l = c.next(); !l.done; l = c.next()) i(l.value);
} catch (e) {
r = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawThreats = function(e) {
var r, o;
try {
for (var n = t(Object.values(Game.rooms)), a = n.next(); !a.done; a = n.next()) {
var i = a.value, s = i.find(FIND_HOSTILE_CREEPS), c = i.find(FIND_HOSTILE_STRUCTURES);
if (s.length > 0 || c.length > 0) {
var l = s.length + 2 * c.length, u = l > 10 ? "#ff0000" : "#ff8800";
e.rect(new RoomPosition(20, 20, i.name), 10, 10, {
fill: u,
opacity: .5 * this.config.opacity,
stroke: u,
strokeWidth: 1
}), e.text("".concat(l), new RoomPosition(25, 25, i.name), {
color: "#ffffff",
fontSize: 8,
align: "center"
});
}
if (i.find(FIND_NUKES).length > 0) {
var f = i.find(FIND_NUKES);
e.circle(new RoomPosition(25, 25, i.name), {
radius: 15,
fill: "#ff00ff",
opacity: .7 * this.config.opacity,
stroke: "#ff00ff",
strokeWidth: 2
}), e.text("".concat(f.length), new RoomPosition(25, 25, i.name), {
color: "#ffffff",
fontSize: 10,
align: "center",
backgroundColor: "#ff00ff",
backgroundPadding: 2
});
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
a && !a.done && (o = n.return) && o.call(n);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawExpansionCandidates = function(e) {
var r, o, n = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), a = function(t) {
if (!t.controller || t.controller.my || t.controller.owner) return "continue";
n.some(function(e) {
return Game.map.getRoomLinearDistance(e.name, t.name) <= 3;
}) && (e.circle(new RoomPosition(25, 25, t.name), {
radius: 8,
fill: "#00ff00",
opacity: .3 * i.config.opacity,
stroke: "#00ff00",
strokeWidth: .5,
lineStyle: "dashed"
}), e.text("EXP", new RoomPosition(25, 25, t.name), {
color: "#00ff00",
fontSize: 6,
align: "center"
}));
}, i = this;
try {
for (var s = t(Object.values(Game.rooms)), c = s.next(); !c.done; c = s.next()) a(c.value);
} catch (e) {
r = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawResourceFlow = function(e) {
var r, o, n = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
try {
for (var a = t(n), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
if (s.terminal) {
var c = Game.market.orders;
for (var l in c) {
var u = c[l];
u.roomName === s.name && u.remainingAmount < u.amount && e.circle(new RoomPosition(25, 25, s.name), {
radius: 12,
fill: "#ffff00",
opacity: .2 * this.config.opacity,
stroke: "#ffff00",
strokeWidth: .5
});
}
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawHighways = function(e) {
var r, o;
try {
for (var n = t(Object.values(Game.rooms)), a = n.next(); !a.done; a = n.next()) {
var i = a.value, s = i.name.match(/[WE](\d+)[NS](\d+)/);
if (s) {
var c = parseInt(s[1], 10), l = parseInt(s[2], 10);
c % 10 != 0 && l % 10 != 0 || (e.rect(new RoomPosition(0, 0, i.name), 50, 50, {
fill: "#444444",
opacity: .2 * this.config.opacity
}), c % 10 == 0 && l % 10 == 0 && e.text("SK", new RoomPosition(25, 25, i.name), {
color: "#ff8800",
fontSize: 12,
align: "center"
}));
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
a && !a.done && (o = n.return) && o.call(n);
} finally {
if (r) throw r.error;
}
}
}, a.prototype.drawRoomOverlay = function(e) {
var t = Game.map.visual;
Game.rooms[e] && (t.rect(new RoomPosition(0, 0, e), 50, 50, {
fill: "transparent",
opacity: 1,
stroke: "#00ffff",
strokeWidth: 2
}), t.text(e, new RoomPosition(25, 5, e), {
color: "#00ffff",
fontSize: 10,
align: "center",
backgroundColor: "#000000",
backgroundPadding: 2
}));
}, a.prototype.setConfig = function(t) {
this.config = e(e({}, this.config), t);
}, a.prototype.getConfig = function() {
return e({}, this.config);
}, a.prototype.toggle = function(e) {
var t = this.config[e];
"boolean" == typeof t && (this.config[e] = !t);
}, a;
}();
return fa.MapVisualizer = a, fa.mapVisualizer = new a, fa;
}();
Object.defineProperty(e, "MapVisualizer", {
enumerable: !0,
get: function() {
return a.MapVisualizer;
}
});
var i = function() {
if (ia) return ma;
ia = 1;
var e = ma && ma.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
return Object.defineProperty(ma, "__esModule", {
value: !0
}), ma.renderBudgetDashboard = function(t) {
var r, o, n, a, i, s, c;
void 0 === t && (t = {});
var l = Game.cpu.getUsed();
if (!t.kernel || !(null === (n = t.stats) || void 0 === n ? void 0 : n.getAdaptiveBudgetInfo)) return Game.cpu.getUsed() - l;
var u = t.room || Object.keys(Game.rooms)[0];
if (!u || !Game.rooms[u]) return Game.cpu.getUsed() - l;
var f = Game.rooms[u].visual, m = null !== (a = t.x) && void 0 !== a ? a : 1, p = null !== (i = t.y) && void 0 !== i ? i : 1, d = t.kernel.getConfig(), y = t.stats.getAdaptiveBudgetInfo(d.adaptiveBudgetConfig || {}), g = t.kernel.getProcesses().reduce(function(e, t) {
return e + t.cpuBudget;
}, 0), h = t.kernel.getTickCpuUsed(), v = g > 0 ? h / g : 0;
f.text(" CPU Budget Dashboard", m, p, {
color: "#FFFFFF",
font: .7,
align: "left"
});
var R = p + 1, E = d.enableAdaptiveBudgets ? "#00FF00" : "#888888", T = d.enableAdaptiveBudgets ? "ENABLED" : "DISABLED";
f.text("Adaptive Budgets: ".concat(T), m, R, {
color: E,
font: .5,
align: "left"
}), R += .7, f.text("Rooms: ".concat(y.roomCount, " | Bucket: ").concat(y.bucket), m, R, {
color: "#CCCCCC",
font: .5,
align: "left"
}), R += .7, f.text("Room Multiplier: ".concat(y.roomMultiplier.toFixed(2), "x | Bucket Multiplier: ").concat(y.bucketMultiplier.toFixed(2), "x"), m, R, {
color: "#AAAAAA",
font: .5,
align: "left"
}), R += 1;
var S = .4, C = function(e, t, r, o) {
f.text(e, m, r, {
color: "#FFFFFF",
font: .5,
align: "left"
}), f.rect(m + 3, r - .2, 8, S, {
fill: "#222222",
opacity: .5
});
var n = 8 * Math.min(t, 1);
f.rect(m + 3, r - .2, n, S, {
fill: o,
opacity: .8
}), f.text("".concat((100 * t).toFixed(1), "%"), m + 3 + 8 + .3, r, {
color: "#FFFFFF",
font: .4,
align: "left"
});
};
C("High Freq:", y.budgets.high, R, "#FF6B6B"), R += .8, C("Medium Freq:", y.budgets.medium, R, "#FFD93D"), 
R += .8, C("Low Freq:", y.budgets.low, R, "#6BCF7F"), R += .8, R += .3, f.text("Overall Utilization:", m, R, {
color: "#FFFFFF",
font: .5,
align: "left"
}), R += .6, f.rect(m, R - .2, 14, S, {
fill: "#222222",
opacity: .5
});
var b = v > .9 ? "#FF0000" : v > .7 ? "#FFD93D" : "#00FF00", _ = 14 * Math.min(v, 1);
if (f.rect(m, R - .2, _, S, {
fill: b,
opacity: .8
}), f.text("".concat((100 * v).toFixed(1), "%"), m + 8 + 6.5, R, {
color: "#FFFFFF",
font: .5,
align: "left"
}), R += .7, f.text("Allocated: ".concat(g.toFixed(2), " | Used: ").concat(h.toFixed(2), " | Available: ").concat(t.kernel.getRemainingCpu().toFixed(2)), m, R, {
color: "#AAAAAA",
font: .4,
align: "left"
}), R += 1, !1 !== t.showProcesses) {
f.text("Process Health:", m, R, {
color: "#FFFFFF",
font: .6,
align: "left"
}), R += .7;
var O = t.kernel.getProcesses(), w = O.filter(function(e) {
return e.stats.healthScore < 80;
}).sort(function(e, t) {
return e.stats.healthScore - t.stats.healthScore;
}).slice(0, null !== (s = t.maxProcesses) && void 0 !== s ? s : 5);
if (0 === w.length) f.text(" All processes healthy", m, R, {
color: "#00FF00",
font: .4,
align: "left"
}), R += .6; else try {
for (var x = e(w), U = x.next(); !U.done; U = x.next()) {
var M = U.value, A = M.stats.healthScore < 30 ? "#FF0000" : M.stats.healthScore < 60 ? "#FFA500" : "#FFD93D", k = "suspended" === M.state ? "" : "", N = null !== (c = t.maxProcessNameLength) && void 0 !== c ? c : 15, P = M.name.length > N ? M.name.substring(0, N - 1) + "" : M.name;
f.text("".concat(k, " ").concat(P, ": ").concat(M.stats.healthScore.toFixed(0), "%"), m, R, {
color: A,
font: .4,
align: "left"
}), R += .6;
}
} catch (e) {
r = {
error: e
};
} finally {
try {
U && !U.done && (o = x.return) && o.call(x);
} finally {
if (r) throw r.error;
}
}
var I = O.filter(function(e) {
return "suspended" === e.state;
}).length;
I > 0 && (R += .3, f.text(" ".concat(I, " process(es) suspended"), m, R, {
color: "#FF6B6B",
font: .4,
align: "left"
}));
}
return Game.cpu.getUsed() - l;
}, ma.renderCompactBudgetStatus = function(e, t, r) {
var o = Game.cpu.getUsed();
if (!t || !(null == r ? void 0 : r.getAdaptiveBudgetInfo)) return 0;
var n = e || Object.keys(Game.rooms)[0];
if (!n || !Game.rooms[n]) return 0;
var a = Game.rooms[n].visual, i = t.getConfig(), s = r.getAdaptiveBudgetInfo(i.adaptiveBudgetConfig || {}), c = t.getProcesses().reduce(function(e, t) {
return e + t.cpuBudget;
}, 0), l = t.getTickCpuUsed(), u = c > 0 ? l / c : 0, f = u > .9 ? "#FF0000" : u > .7 ? "#FFD93D" : "#00FF00";
return a.text("CPU: ".concat((100 * u).toFixed(0), "% | ").concat(s.roomCount, "R | ").concat(s.bucket, "B"), 49, 1, {
color: f,
font: .4,
align: "right"
}), Game.cpu.getUsed() - o;
}, ma;
}();
Object.defineProperty(e, "renderBudgetDashboard", {
enumerable: !0,
get: function() {
return i.renderBudgetDashboard;
}
}), Object.defineProperty(e, "renderCompactBudgetStatus", {
enumerable: !0,
get: function() {
return i.renderCompactBudgetStatus;
}
});
var s = function() {
if (sa) return pa;
sa = 1;
var e = pa && pa.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
};
Object.defineProperty(pa, "__esModule", {
value: !0
}), pa.initializeRoomVisualExtensions = function() {};
var t = "#555555", r = "#AAAAAA", o = "#FFE87B", n = "#F53547", a = "#181818", i = "#8FBB93", s = !1;
return "undefined" == typeof RoomVisual || s || (s = !0, RoomVisual.prototype.structure = function(s, c, l, u) {
void 0 === u && (u = {});
var f = e({
opacity: 1
}, u);
switch (l) {
case STRUCTURE_EXTENSION:
this.circle(s, c, {
radius: .5,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .35,
fill: t,
opacity: f.opacity
});
break;

case STRUCTURE_SPAWN:
this.circle(s, c, {
radius: .65,
fill: a,
stroke: "#CCCCCC",
strokeWidth: .1,
opacity: f.opacity
}), this.circle(s, c, {
radius: .4,
fill: o,
opacity: f.opacity
});
break;

case STRUCTURE_POWER_SPAWN:
this.circle(s, c, {
radius: .65,
fill: a,
stroke: n,
strokeWidth: .1,
opacity: f.opacity
}), this.circle(s, c, {
radius: .4,
fill: o,
opacity: f.opacity
});
break;

case STRUCTURE_TOWER:
this.circle(s, c, {
radius: .6,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .45,
fill: t,
opacity: f.opacity
}), this.rect(s - .2, c - .3, .4, .6, {
fill: r,
opacity: f.opacity
});
break;

case STRUCTURE_STORAGE:
this.poly([ [ -.45, -.55 ], [ 0, -.65 ], [ .45, -.55 ], [ .55, 0 ], [ .45, .55 ], [ 0, .65 ], [ -.45, .55 ], [ -.55, 0 ] ].map(function(e) {
return [ e[0] + s, e[1] + c ];
}), {
stroke: i,
strokeWidth: .05,
fill: a,
opacity: f.opacity
}), this.rect(s - .35, c - .45, .7, .9, {
fill: o,
opacity: .6 * f.opacity
});
break;

case STRUCTURE_TERMINAL:
this.poly([ [ -.45, -.55 ], [ 0, -.65 ], [ .45, -.55 ], [ .55, 0 ], [ .45, .55 ], [ 0, .65 ], [ -.45, .55 ], [ -.55, 0 ] ].map(function(e) {
return [ e[0] + s, e[1] + c ];
}), {
stroke: i,
strokeWidth: .05,
fill: a,
opacity: f.opacity
}), this.circle(s, c, {
radius: .3,
fill: r,
opacity: f.opacity
}), this.rect(s - .15, c - .15, .3, .3, {
fill: t,
opacity: f.opacity
});
break;

case STRUCTURE_LAB:
this.circle(s, c, {
radius: .55,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .4,
fill: t,
opacity: f.opacity
}), this.rect(s - .15, c + .1, .3, .25, {
fill: r,
opacity: f.opacity
});
break;

case STRUCTURE_LINK:
this.circle(s, c, {
radius: .5,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .35,
fill: r,
opacity: f.opacity
});
break;

case STRUCTURE_NUKER:
this.circle(s, c, {
radius: .65,
fill: a,
stroke: "#ff0000",
strokeWidth: .1,
opacity: f.opacity
}), this.circle(s, c, {
radius: .4,
fill: "#ff0000",
opacity: .6 * f.opacity
});
break;

case STRUCTURE_OBSERVER:
this.circle(s, c, {
radius: .6,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .4,
fill: "#00ffff",
opacity: .6 * f.opacity
});
break;

case STRUCTURE_CONTAINER:
this.rect(s - .45, c - .45, .9, .9, {
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.rect(s - .35, c - .35, .7, .7, {
fill: "transparent",
stroke: t,
strokeWidth: .05,
opacity: f.opacity
});
break;

case STRUCTURE_ROAD:
this.circle(s, c, {
radius: .175,
fill: "#666",
opacity: f.opacity
});
break;

case STRUCTURE_RAMPART:
this.rect(s - .45, c - .45, .9, .9, {
fill: "transparent",
stroke: "#00ff00",
strokeWidth: .1,
opacity: f.opacity
});
break;

case STRUCTURE_WALL:
this.rect(s - .45, c - .45, .9, .9, {
fill: a,
stroke: r,
strokeWidth: .05,
opacity: f.opacity
});
break;

case STRUCTURE_EXTRACTOR:
this.circle(s, c, {
radius: .6,
fill: a,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
}), this.circle(s, c, {
radius: .45,
fill: t,
opacity: f.opacity
});
break;

default:
this.circle(s, c, {
radius: .5,
fill: t,
stroke: i,
strokeWidth: .05,
opacity: f.opacity
});
}
}, RoomVisual.prototype.speech = function(e, t, r, o) {
var n, a, i, s, c;
void 0 === o && (o = {});
var l = null !== (n = o.background) && void 0 !== n ? n : "#2ccf3b", u = null !== (a = o.textcolor) && void 0 !== a ? a : "#000000", f = null !== (i = o.textsize) && void 0 !== i ? i : .5, m = null !== (s = o.textfont) && void 0 !== s ? s : "Times New Roman", p = null !== (c = o.opacity) && void 0 !== c ? c : 1, d = f, y = e.length * d * .4 + .4, g = d + .4;
this.rect(t - y / 2, r - 1 - g, y, g, {
fill: l,
opacity: .9 * p
});
var h = [ [ t - .1, r - 1 ], [ t + .1, r - 1 ], [ t, r - .6 ] ];
this.poly(h, {
fill: l,
opacity: .9 * p,
stroke: "transparent"
}), this.text(e, t, r - 1 - g / 2 + .1, {
color: u,
font: "".concat(d, " ").concat(m),
opacity: p
});
}, RoomVisual.prototype.animatedPosition = function(e, t, r) {
var o, n, a, i;
void 0 === r && (r = {});
var s = null !== (o = r.color) && void 0 !== o ? o : "#ff0000", c = null !== (n = r.opacity) && void 0 !== n ? n : 1, l = null !== (a = r.radius) && void 0 !== a ? a : .75, u = null !== (i = r.frames) && void 0 !== i ? i : 6, f = Game.time % u, m = l * (1 - f / u), p = c * (f / u);
this.circle(e, t, {
radius: m,
fill: "transparent",
stroke: s,
strokeWidth: .1,
opacity: p
});
}, RoomVisual.prototype.resource = function(e, t, r, i) {
var s, c;
void 0 === i && (i = .25);
var l = null !== (c = ((s = {})[RESOURCE_ENERGY] = o, s[RESOURCE_POWER] = n, s[RESOURCE_HYDROGEN] = "#FFFFFF", 
s[RESOURCE_OXYGEN] = "#DDDDDD", s[RESOURCE_UTRIUM] = "#48C5E5", s[RESOURCE_LEMERGIUM] = "#24D490", 
s[RESOURCE_KEANIUM] = "#9269EC", s[RESOURCE_ZYNTHIUM] = "#D9B478", s[RESOURCE_CATALYST] = "#F26D6F", 
s[RESOURCE_GHODIUM] = "#FFFFFF", s)[e]) && void 0 !== c ? c : "#CCCCCC";
this.circle(t, r, {
radius: i,
fill: a,
opacity: .9
}), this.circle(t, r, {
radius: .8 * i,
fill: l,
opacity: .8
});
var u = e.length <= 2 ? e : e.substring(0, 2).toUpperCase();
this.text(u, t, r + .03, {
color: a,
font: "".concat(1.2 * i, " monospace"),
align: "center",
opacity: .9
});
}), pa;
}();
Object.defineProperty(e, "initializeRoomVisualExtensions", {
enumerable: !0,
get: function() {
return s.initializeRoomVisualExtensions;
}
});
var c = ra();
Object.defineProperty(e, "createLogger", {
enumerable: !0,
get: function() {
return c.createLogger;
}
});
}(Xn)), Xn), ya = function() {
function e(e) {
void 0 === e && (e = "default"), this.namespace = e;
}
return e.prototype.getStore = function() {
var e = global, t = "_cacheHeap_".concat(this.namespace);
return e[t] && e[t].tick === Game.time || (e[t] ? e[t].tick = Game.time : e[t] = {
tick: Game.time,
entries: new Map
}), e[t];
}, e.prototype.get = function(e) {
return this.getStore().entries.get(e);
}, e.prototype.set = function(e, t) {
this.getStore().entries.set(e, t);
}, e.prototype.delete = function(e) {
return this.getStore().entries.delete(e);
}, e.prototype.has = function(e) {
return this.getStore().entries.has(e);
}, e.prototype.keys = function() {
var e = this.getStore();
return Array.from(e.entries.keys());
}, e.prototype.size = function() {
return this.getStore().entries.size;
}, e.prototype.clear = function() {
this.getStore().entries.clear();
}, e.prototype.cleanup = function() {
var e, t, n = this.getStore(), a = 0;
try {
for (var i = r(n.entries), s = i.next(); !s.done; s = i.next()) {
var c = o(s.value, 2), l = c[0], u = c[1];
void 0 !== u.ttl && -1 !== u.ttl && Game.time - u.cachedAt > u.ttl && (n.entries.delete(l), 
a++);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return a;
}, e;
}(), ga = function() {
function t(e, t) {
void 0 === e && (e = "default"), void 0 === t && (t = 10), this.lastPersistTick = 0, 
this.namespace = e, this.persistInterval = t;
}
return t.prototype.getHeap = function() {
var e = global, t = "_cacheMemoryHeap_".concat(this.namespace);
e[t] && e[t].tick === Game.time || (e[t] ? e[t].tick = Game.time : e[t] = {
tick: Game.time,
entries: new Map,
rehydrated: !1
});
var r = e[t];
return r.rehydrated || (this.rehydrate(r), r.rehydrated = !0), r;
}, t.prototype.getMemory = function() {
return Memory._cacheMemory || (Memory._cacheMemory = {}), Memory._cacheMemory[this.namespace] || (Memory._cacheMemory[this.namespace] = {
version: t.CACHE_VERSION,
lastSync: Game.time,
data: {}
}), Memory._cacheMemory[this.namespace];
}, t.prototype.rehydrate = function(e) {
var t, n, a, i, s = this.getMemory(), c = [];
try {
for (var l = r(Object.entries(s.data)), u = l.next(); !u.done; u = l.next()) {
var f = o(u.value, 2), m = f[0], p = f[1];
void 0 !== p.ttl && -1 !== p.ttl && Game.time - p.cachedAt > p.ttl ? c.push(m) : e.entries.set(m, {
value: p.value,
cachedAt: p.cachedAt,
lastAccessed: Game.time,
ttl: p.ttl,
hits: p.hits,
dirty: !1
});
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (t) throw t.error;
}
}
try {
for (var d = r(c), y = d.next(); !y.done; y = d.next()) m = y.value, delete s.data[m];
} catch (e) {
a = {
error: e
};
} finally {
try {
y && !y.done && (i = d.return) && i.call(d);
} finally {
if (a) throw a.error;
}
}
}, t.prototype.get = function(e) {
var t = this.getHeap().entries.get(e);
if (t) return t.lastAccessed !== Game.time && (t.lastAccessed = Game.time, t.dirty = !0), 
t;
}, t.prototype.set = function(t, r) {
this.getHeap().entries.set(t, e(e({}, r), {
dirty: !0
}));
}, t.prototype.delete = function(e) {
var t = this.getHeap().entries.delete(e);
return delete this.getMemory().data[e], t;
}, t.prototype.has = function(e) {
return this.getHeap().entries.has(e);
}, t.prototype.keys = function() {
var e = this.getHeap();
return Array.from(e.entries.keys());
}, t.prototype.size = function() {
return this.getHeap().entries.size;
}, t.prototype.clear = function() {
this.getHeap().entries.clear(), this.getMemory().data = {};
}, t.prototype.cleanup = function() {
var e, t, n, a, i = this.getHeap(), s = this.getMemory(), c = 0;
try {
for (var l = r(i.entries), u = l.next(); !u.done; u = l.next()) {
var f = o(u.value, 2), m = f[0], p = f[1];
void 0 !== p.ttl && -1 !== p.ttl && Game.time - p.cachedAt > p.ttl && (i.entries.delete(m), 
c++);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
try {
for (var d = r(Object.entries(s.data)), y = d.next(); !y.done; y = d.next()) {
var g = o(y.value, 2), h = (m = g[0], g[1]);
void 0 !== h.ttl && -1 !== h.ttl && Game.time - h.cachedAt > h.ttl && (delete s.data[m], 
c++);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
return c;
}, t.prototype.persist = function() {
var e, t;
if (Game.time - this.lastPersistTick < this.persistInterval) return 0;
var n = this.getHeap(), a = this.getMemory(), i = 0;
try {
for (var s = r(n.entries), c = s.next(); !c.done; c = s.next()) {
var l = o(c.value, 2), u = l[0], f = l[1];
f.dirty && (a.data[u] = {
value: f.value,
cachedAt: f.cachedAt,
ttl: f.ttl,
hits: f.hits
}, f.dirty = !1, i++);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
return a.lastSync = Game.time, this.lastPersistTick = Game.time, i;
}, t.CACHE_VERSION = 1, t;
}(), ha = function() {
function e(e) {
void 0 === e && (e = "heap"), this.stores = new Map, this.stats = new Map, this.defaultStore = e;
}
return e.prototype.getStore = function(e, t) {
var r = null != t ? t : this.defaultStore, o = "".concat(e, ":").concat(r), n = this.stores.get(o);
return n || (n = "memory" === r ? new ga(e) : new ya(e), this.stores.set(o, n)), 
n;
}, e.prototype.getStats = function(e) {
var t = this.stats.get(e);
return t || (t = {
hits: 0,
misses: 0,
evictions: 0
}, this.stats.set(e, t)), t;
}, e.prototype.makeKey = function(e, t) {
return "".concat(e, ":").concat(t);
}, e.prototype.get = function(e, t) {
var r, o = null !== (r = null == t ? void 0 : t.namespace) && void 0 !== r ? r : "default", n = this.getStore(o, null == t ? void 0 : t.store), a = this.getStats(o), i = this.makeKey(o, e), s = n.get(i);
if (s) return void 0 !== s.ttl && -1 !== s.ttl && Game.time - s.cachedAt > s.ttl ? (n.delete(i), 
a.evictions++, a.misses++, (null == t ? void 0 : t.compute) ? (c = t.compute(), 
this.set(e, c, t), c) : void 0) : (a.hits++, s.hits++, s.lastAccessed = Game.time, 
s.value);
if (a.misses++, null == t ? void 0 : t.compute) {
var c = t.compute();
return this.set(e, c, t), c;
}
}, e.prototype.set = function(e, t, r) {
var o, n = null !== (o = null == r ? void 0 : r.namespace) && void 0 !== o ? o : "default", a = this.getStore(n, null == r ? void 0 : r.store), i = this.makeKey(n, e);
if ((null == r ? void 0 : r.maxSize) && a.size() >= r.maxSize) {
for (var s = Math.max(1, Math.floor(.1 * r.maxSize)), c = 0; c < s; c++) this.evictLRU(n, a);
this.getStats(n).evictions += s;
}
var l = {
value: t,
cachedAt: Game.time,
lastAccessed: Game.time,
ttl: null == r ? void 0 : r.ttl,
hits: 0,
dirty: !0
};
a.set(i, l);
}, e.prototype.invalidate = function(e, t) {
void 0 === t && (t = "default");
var r = "".concat(t, ":heap"), o = "".concat(t, ":memory"), n = this.makeKey(t, e), a = !1, i = this.stores.get(r);
i && (a = i.delete(n) || a);
var s = this.stores.get(o);
return s && (a = s.delete(n) || a), a;
}, e.prototype.invalidatePattern = function(e, t) {
var o, n, a, i;
void 0 === t && (t = "default");
var s = "".concat(t, ":heap"), c = "".concat(t, ":memory"), l = 0, u = [ this.stores.get(s), this.stores.get(c) ].filter(Boolean);
try {
for (var f = r(u), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
if (p) {
var d = p.keys();
try {
for (var y = (a = void 0, r(d)), g = y.next(); !g.done; g = y.next()) {
var h = g.value, v = h.indexOf(":");
if (-1 !== v) {
var R = h.substring(v + 1);
e.test(R) && (p.delete(h), l++);
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
g && !g.done && (i = y.return) && i.call(y);
} finally {
if (a) throw a.error;
}
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (n = f.return) && n.call(f);
} finally {
if (o) throw o.error;
}
}
return l;
}, e.prototype.clear = function(e) {
var t, o, n, a;
if (e) {
var i = "".concat(e, ":heap"), s = "".concat(e, ":memory");
null === (n = this.stores.get(i)) || void 0 === n || n.clear(), null === (a = this.stores.get(s)) || void 0 === a || a.clear(), 
this.stats.delete(e);
} else {
try {
for (var c = r(this.stores.values()), l = c.next(); !l.done; l = c.next()) l.value.clear();
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
this.stats.clear();
}
}, e.prototype.getCacheStats = function(e) {
var t, o, n, a, i, s, c, l;
if (e) {
var u = this.getStats(e), f = "".concat(e, ":heap"), m = "".concat(e, ":memory"), p = null !== (s = null === (i = this.stores.get(f)) || void 0 === i ? void 0 : i.size()) && void 0 !== s ? s : 0, d = null !== (l = null === (c = this.stores.get(m)) || void 0 === c ? void 0 : c.size()) && void 0 !== l ? l : 0, y = (g = u.hits + u.misses) > 0 ? u.hits / g : 0;
return {
hits: u.hits,
misses: u.misses,
hitRate: y,
size: p + d,
evictions: u.evictions
};
}
var g, h = 0, v = 0, R = 0, E = 0;
try {
for (var T = r(this.stats.values()), S = T.next(); !S.done; S = T.next()) h += (u = S.value).hits, 
v += u.misses, R += u.evictions;
} catch (e) {
t = {
error: e
};
} finally {
try {
S && !S.done && (o = T.return) && o.call(T);
} finally {
if (t) throw t.error;
}
}
try {
for (var C = r(this.stores.values()), b = C.next(); !b.done; b = C.next()) E += b.value.size();
} catch (e) {
n = {
error: e
};
} finally {
try {
b && !b.done && (a = C.return) && a.call(C);
} finally {
if (n) throw n.error;
}
}
return {
hits: h,
misses: v,
hitRate: y = (g = h + v) > 0 ? h / g : 0,
size: E,
evictions: R
};
}, e.prototype.evictLRU = function(e, t) {
var o, n, a = t.keys();
if (0 !== a.length) {
var i = null, s = 1 / 0;
try {
for (var c = r(a), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = t.get(u);
f && f.lastAccessed < s && (s = f.lastAccessed, i = u);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
i && t.delete(i);
}
}, e.prototype.cleanup = function() {
var e, t, o = 0;
try {
for (var n = r(this.stores.values()), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
i.cleanup && (o += i.cleanup());
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
return o;
}, e.prototype.persist = function() {
var e, t, o = 0;
try {
for (var n = r(this.stores.values()), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
i.persist && (o += i.persist());
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
return o;
}, e;
}(), va = new ha("heap");

!function(e) {
e.L1 = "L1", e.L2 = "L2", e.L3 = "L3";
}(la || (la = {}));

var Ra, Ea = "object", Ta = "path";

function Sa(e, t) {
return "".concat(e.roomName, ":").concat(e.x, ",").concat(e.y, ":").concat(t.roomName, ":").concat(t.x, ",").concat(t.y);
}

function Ca(e, t, r, o) {
void 0 === o && (o = {});
var n = Sa(e, t), a = Room.serializePath(r);
va.set(n, a, {
namespace: Ta,
ttl: o.ttl,
maxSize: 1e3
});
}

var ba = "roomFind", _a = ((Ra = {})[FIND_SOURCES] = 5e3, Ra[FIND_MINERALS] = 5e3, 
Ra[FIND_DEPOSITS] = 100, Ra[FIND_STRUCTURES] = 50, Ra[FIND_MY_STRUCTURES] = 50, 
Ra[FIND_HOSTILE_STRUCTURES] = 20, Ra[FIND_MY_SPAWNS] = 100, Ra[FIND_MY_CONSTRUCTION_SITES] = 20, 
Ra[FIND_CONSTRUCTION_SITES] = 20, Ra[FIND_CREEPS] = 5, Ra[FIND_MY_CREEPS] = 5, Ra[FIND_HOSTILE_CREEPS] = 3, 
Ra[FIND_DROPPED_RESOURCES] = 5, Ra[FIND_TOMBSTONES] = 10, Ra[FIND_RUINS] = 10, Ra[FIND_FLAGS] = 50, 
Ra[FIND_NUKES] = 20, Ra[FIND_POWER_CREEPS] = 10, Ra[FIND_MY_POWER_CREEPS] = 10, 
Ra);

function Oa(e, t, r) {
var o, n, a = function(e, t, r) {
return r ? "".concat(e, ":").concat(t, ":").concat(r) : "".concat(e, ":").concat(t);
}(e.name, t, null == r ? void 0 : r.filterKey), i = va.get(a, {
namespace: ba,
ttl: null !== (n = null !== (o = null == r ? void 0 : r.ttl) && void 0 !== o ? o : _a[t]) && void 0 !== n ? n : 20,
compute: function() {
return (null == r ? void 0 : r.filter) ? e.find(t, {
filter: r.filter
}) : e.find(t);
}
});
return null != i ? i : [];
}

function wa(e) {
return Oa(e, FIND_SOURCES);
}

function xa(e, t) {
return t ? Oa(e, FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === t;
},
filterKey: t
}) : Oa(e, FIND_MY_STRUCTURES);
}

function Ua(e, t) {
return void 0 === t && (t = !0), Oa(e, t ? FIND_MY_CONSTRUCTION_SITES : FIND_CONSTRUCTION_SITES);
}

function Ma(e, t) {
return t ? Oa(e, FIND_DROPPED_RESOURCES, {
filter: function(e) {
return e.resourceType === t;
},
filterKey: t
}) : Oa(e, FIND_DROPPED_RESOURCES);
}

var Aa = "closest";

function ka(e, t) {
return "".concat(e, ":").concat(t);
}

function Na(e, t, r, o) {
if (void 0 === o && (o = 10), 0 === t.length) return Pa(e, r), null;
if (1 === t.length) return t[0];
var n = ka(e.name, r), a = va.get(n, {
namespace: Aa,
ttl: o
});
if (a) {
var i = Game.getObjectById(a);
if (i && t.some(function(e) {
return e.id === i.id;
}) && e.pos.getRangeTo(i.pos) <= 20) return i;
}
var s = e.pos.findClosestByRange(t);
return s ? va.set(n, s.id, {
namespace: Aa,
ttl: o
}) : Pa(e, r), s;
}

function Pa(e, t) {
if (t) {
var r = ka(e.name, t);
va.invalidate(r, Aa);
} else {
var o = new RegExp("^".concat(e.name, ":"));
va.invalidatePattern(o, Aa);
}
}

function Ia(e) {
Pa(e);
}

function Ga(e) {
var t, r = ((t = {})[MOVE] = 50, t[WORK] = 100, t[CARRY] = 50, t[ATTACK] = 80, t[RANGED_ATTACK] = 150, 
t[HEAL] = 250, t[CLAIM] = 600, t[TOUGH] = 10, t);
return e.reduce(function(e, t) {
return e + r[t];
}, 0);
}

function La(e, t) {
return void 0 === t && (t = 0), {
parts: e,
cost: Ga(e),
minCapacity: t || Ga(e)
};
}

var Da, Fa = {
larvaWorker: {
role: "larvaWorker",
family: "economy",
bodies: [ La([ WORK, CARRY ], 150), La([ WORK, CARRY, MOVE ], 200), La([ WORK, WORK, CARRY, CARRY, MOVE, MOVE ], 400), La([ WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE ], 600), La([ WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 800) ],
priority: 100,
maxPerRoom: 3,
remoteRole: !1
},
harvester: {
role: "harvester",
family: "economy",
bodies: [ La([ WORK, WORK, MOVE ], 250), La([ WORK, WORK, WORK, WORK, MOVE, MOVE ], 500), La([ WORK, WORK, WORK, WORK, WORK, MOVE, MOVE, MOVE ], 700), La([ WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE, MOVE ], 800), La([ WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE ], 1e3) ],
priority: 95,
maxPerRoom: 2,
remoteRole: !1
},
hauler: {
role: "hauler",
family: "economy",
bodies: [ La([ CARRY, CARRY, MOVE, MOVE ], 200), La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 400), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 800), La(n(n([], o(Array(16).fill(CARRY)), !1), o(Array(16).fill(MOVE)), !1), 1600) ],
priority: 90,
maxPerRoom: 2,
remoteRole: !0
},
upgrader: {
role: "upgrader",
family: "economy",
bodies: [ La([ WORK, CARRY, MOVE ], 200), La([ WORK, WORK, WORK, CARRY, MOVE, MOVE ], 450), La([ WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 1e3), La([ WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1700) ],
priority: 60,
maxPerRoom: 2,
remoteRole: !1
},
builder: {
role: "builder",
family: "economy",
bodies: [ La([ WORK, CARRY, MOVE, MOVE ], 250), La([ WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 650), La([ WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1400) ],
priority: 70,
maxPerRoom: 2,
remoteRole: !1
},
queenCarrier: {
role: "queenCarrier",
family: "economy",
bodies: [ La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE ], 300), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE ], 450), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 600) ],
priority: 85,
maxPerRoom: 1,
remoteRole: !1
},
mineralHarvester: {
role: "mineralHarvester",
family: "economy",
bodies: [ La([ WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE ], 550), La([ WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE ], 850) ],
priority: 40,
maxPerRoom: 1,
remoteRole: !1
},
labTech: {
role: "labTech",
family: "economy",
bodies: [ La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 400), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 600) ],
priority: 35,
maxPerRoom: 1,
remoteRole: !1
},
factoryWorker: {
role: "factoryWorker",
family: "economy",
bodies: [ La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 400), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 600) ],
priority: 35,
maxPerRoom: 1,
remoteRole: !1
},
remoteHarvester: {
role: "remoteHarvester",
family: "economy",
bodies: [ La([ WORK, WORK, CARRY, MOVE, MOVE, MOVE ], 400), La([ WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 750), La([ WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1050), La([ WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1600) ],
priority: 85,
maxPerRoom: 6,
remoteRole: !0
},
remoteHauler: {
role: "remoteHauler",
family: "economy",
bodies: [ La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 400), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 800), La(n(n([], o(Array(16).fill(CARRY)), !1), o(Array(16).fill(MOVE)), !1), 1600) ],
priority: 80,
maxPerRoom: 6,
remoteRole: !0
},
interRoomCarrier: {
role: "interRoomCarrier",
family: "economy",
bodies: [ La([ CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 400), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 600), La([ CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 800) ],
priority: 90,
maxPerRoom: 4,
remoteRole: !1
},
crossShardCarrier: {
role: "crossShardCarrier",
family: "economy",
bodies: [ La(n(n([], o(Array(4).fill(CARRY)), !1), o(Array(4).fill(MOVE)), !1), 400), La(n(n([], o(Array(8).fill(CARRY)), !1), o(Array(8).fill(MOVE)), !1), 800), La(n(n([], o(Array(12).fill(CARRY)), !1), o(Array(12).fill(MOVE)), !1), 1200), La(n(n([], o(Array(16).fill(CARRY)), !1), o(Array(16).fill(MOVE)), !1), 1600) ],
priority: 85,
maxPerRoom: 6,
remoteRole: !0
},
guard: {
role: "guard",
family: "military",
bodies: [ La([ TOUGH, ATTACK, ATTACK, MOVE, MOVE, MOVE ], 310), La([ TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 620), La([ TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1070), La([ TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1740) ],
priority: 65,
maxPerRoom: 4,
remoteRole: !1
},
remoteGuard: {
role: "remoteGuard",
family: "military",
bodies: [ La([ TOUGH, ATTACK, MOVE, MOVE ], 190), La([ TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE ], 500), La([ TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 880) ],
priority: 65,
maxPerRoom: 2,
remoteRole: !0
},
healer: {
role: "healer",
family: "military",
bodies: [ La([ HEAL, MOVE, MOVE ], 350), La([ TOUGH, HEAL, HEAL, MOVE, MOVE, MOVE ], 620), La([ TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1240), La([ TOUGH, TOUGH, TOUGH, TOUGH, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 2640) ],
priority: 55,
maxPerRoom: 1,
remoteRole: !1
},
soldier: {
role: "soldier",
family: "military",
bodies: [ La([ ATTACK, ATTACK, MOVE, MOVE ], 260), La([ ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE ], 520), La([ TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1340) ],
priority: 50,
maxPerRoom: 1,
remoteRole: !1
},
siegeUnit: {
role: "siegeUnit",
family: "military",
bodies: [ La([ WORK, WORK, MOVE, MOVE ], 300), La([ TOUGH, TOUGH, WORK, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 620), La([ TOUGH, TOUGH, TOUGH, TOUGH, WORK, WORK, WORK, WORK, WORK, WORK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1040) ],
priority: 30,
maxPerRoom: 1,
remoteRole: !1
},
ranger: {
role: "ranger",
family: "military",
bodies: [ La([ TOUGH, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE ], 360), La([ TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE ], 570), La([ TOUGH, TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1040), La([ TOUGH, TOUGH, TOUGH, TOUGH, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1480) ],
priority: 60,
maxPerRoom: 4,
remoteRole: !1
},
harasser: {
role: "harasser",
family: "military",
bodies: [ La([ TOUGH, ATTACK, RANGED_ATTACK, MOVE, MOVE ], 320), La([ TOUGH, TOUGH, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, MOVE, MOVE, MOVE, MOVE ], 640), La([ TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, RANGED_ATTACK, RANGED_ATTACK, RANGED_ATTACK, HEAL, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 1200) ],
priority: 40,
maxPerRoom: 1,
remoteRole: !1
},
scout: {
role: "scout",
family: "utility",
bodies: [ La([ MOVE ], 50) ],
priority: 30,
maxPerRoom: 1,
remoteRole: !0
},
claimer: {
role: "claimer",
family: "utility",
bodies: [ La([ CLAIM, MOVE ], 650), La([ CLAIM, CLAIM, MOVE, MOVE ], 1300) ],
priority: 50,
maxPerRoom: 3,
remoteRole: !0
},
engineer: {
role: "engineer",
family: "utility",
bodies: [ La([ WORK, CARRY, MOVE, MOVE ], 250), La([ WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 500) ],
priority: 55,
maxPerRoom: 2,
remoteRole: !1
},
remoteWorker: {
role: "remoteWorker",
family: "utility",
bodies: [ La([ WORK, WORK, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE ], 500), La([ WORK, WORK, WORK, CARRY, CARRY, CARRY, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 750) ],
priority: 45,
maxPerRoom: 4,
remoteRole: !0
},
powerHarvester: {
role: "powerHarvester",
family: "power",
bodies: [ La([ TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 2300), La([ TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, TOUGH, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, ATTACK, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE, MOVE ], 3e3) ],
priority: 30,
maxPerRoom: 2,
remoteRole: !0
},
powerCarrier: {
role: "powerCarrier",
family: "power",
bodies: [ La(n(n([], o(Array(20).fill(CARRY)), !1), o(Array(20).fill(MOVE)), !1), 2e3), La(n(n([], o(Array(25).fill(CARRY)), !1), o(Array(25).fill(MOVE)), !1), 2500) ],
priority: 25,
maxPerRoom: 2,
remoteRole: !0
}
}, Ba = Object.freeze({
__proto__: null,
ROLE_DEFINITIONS: Fa
});

function ja(e, t) {
return {
id: e,
coreRoom: t,
memberRooms: [ t ],
remoteRooms: [],
forwardBases: [],
role: "economic",
metrics: {
energyIncome: 0,
energyConsumption: 0,
energyBalance: 0,
warIndex: 0,
economyIndex: 50
},
squads: [],
rallyPoints: [],
defenseRequests: [],
resourceRequests: [],
lastUpdate: 0
};
}

!function(e) {
e[e.None = 0] = "None", e[e.Pheromones = 1] = "Pheromones", e[e.Paths = 2] = "Paths", 
e[e.Traffic = 4] = "Traffic", e[e.Defense = 8] = "Defense", e[e.Economy = 16] = "Economy", 
e[e.Construction = 32] = "Construction", e[e.Performance = 64] = "Performance";
}(Da || (Da = {}));

var Ha, Wa, Ya, Ka = Object.freeze({
__proto__: null,
get VisualizationLayer() {
return Da;
},
createDefaultClusterMemory: ja,
createDefaultCreepMemory: function(e, t, r) {
return {
role: e,
family: t,
homeRoom: r,
version: 1
};
},
createDefaultEmpireMemory: function() {
return {
knownRooms: {},
clusters: [],
warTargets: [],
ownedRooms: {},
claimQueue: [],
nukeCandidates: [],
powerBanks: [],
market: {
resources: {},
lastScan: 0,
pendingArbitrage: [],
completedArbitrage: 0,
arbitrageProfit: 0
},
objectives: {
targetPowerLevel: 0,
targetRoomCount: 1,
warMode: !1,
expansionPaused: !1
},
lastUpdate: 0
};
},
createDefaultMarketMemory: function() {
return {
resources: {},
lastScan: 0,
pendingArbitrage: [],
completedArbitrage: 0,
arbitrageProfit: 0
};
},
createDefaultPheromones: function() {
return {
expand: 0,
harvest: 10,
build: 5,
upgrade: 5,
defense: 0,
war: 0,
siege: 0,
logistics: 5,
nukeTarget: 0
};
},
createDefaultSwarmState: function() {
return {
colonyLevel: "seedNest",
posture: "eco",
danger: 0,
pheromones: {
expand: 0,
harvest: 10,
build: 5,
upgrade: 5,
defense: 0,
war: 0,
siege: 0,
logistics: 5,
nukeTarget: 0
},
nextUpdateTick: 0,
eventLog: [],
missingStructures: {
spawn: !0,
storage: !0,
terminal: !0,
labs: !0,
nuker: !0,
factory: !0,
extractor: !0,
powerSpawn: !0,
observer: !0
},
role: "secondaryCore",
remoteAssignments: [],
metrics: {
energyHarvested: 0,
energySpawning: 0,
energyConstruction: 0,
energyRepair: 0,
energyTower: 0,
controllerProgress: 0,
hostileCount: 0,
damageReceived: 0,
constructionSites: 0,
energyAvailable: 0,
energyCapacity: 0,
energyNeed: 0
},
lastUpdate: 0
};
}
}), Va = jr("MemoryMonitor"), za = 2097152, qa = new (function() {
function e() {
this.lastCheckTick = 0, this.lastStatus = "normal";
}
return e.prototype.checkMemoryUsage = function() {
var e = RawMemory.get().length, t = e / za, r = "normal";
t >= .9 ? r = "critical" : t >= .8 && (r = "warning"), r !== this.lastStatus && ("critical" === r ? (Game.notify("CRITICAL: Memory at ".concat((100 * t).toFixed(1), "% (").concat(this.formatBytes(e), "/").concat(this.formatBytes(za), ")")), 
Va.error("Memory usage critical", {
meta: {
used: e,
limit: za,
percentage: t
}
})) : "warning" === r ? Va.warn("Memory usage warning", {
meta: {
used: e,
limit: za,
percentage: t
}
}) : Va.info("Memory usage normal", {
meta: {
used: e,
limit: za,
percentage: t
}
}), this.lastStatus = r);
var o = this.getMemoryBreakdown();
return {
used: e,
limit: za,
percentage: t,
status: r,
breakdown: o
};
}, e.prototype.getMemoryBreakdown = function() {
var e = Memory, t = this.getObjectSize(e.empire), r = this.getObjectSize(Memory.rooms), o = this.getObjectSize(Memory.creeps), n = this.getObjectSize(e.clusters), a = this.getObjectSize(e.ss2PacketQueue), i = RawMemory.get().length, s = t + r + o + n + a;
return {
empire: t,
rooms: r,
creeps: o,
clusters: n,
ss2PacketQueue: a,
other: Math.max(0, i - s),
total: i
};
}, e.prototype.getObjectSize = function(e) {
return null == e ? 0 : JSON.stringify(e).length;
}, e.prototype.formatBytes = function(e) {
return e < 1024 ? "".concat(e, "B") : e < 1048576 ? "".concat((e / 1024).toFixed(1), "KB") : "".concat((e / 1048576).toFixed(2), "MB");
}, e.prototype.logBreakdown = function() {
var e = this.getMemoryBreakdown(), t = this.checkMemoryUsage();
Va.info("Memory Usage", {
meta: {
used: this.formatBytes(t.used),
limit: this.formatBytes(t.limit),
percentage: "".concat((100 * t.percentage).toFixed(1), "%"),
status: t.status.toUpperCase()
}
}), Va.info("Memory Breakdown", {
meta: {
empire: "".concat(this.formatBytes(e.empire), " (").concat((e.empire / e.total * 100).toFixed(1), "%)"),
rooms: "".concat(this.formatBytes(e.rooms), " (").concat((e.rooms / e.total * 100).toFixed(1), "%)"),
creeps: "".concat(this.formatBytes(e.creeps), " (").concat((e.creeps / e.total * 100).toFixed(1), "%)"),
clusters: "".concat(this.formatBytes(e.clusters), " (").concat((e.clusters / e.total * 100).toFixed(1), "%)"),
ss2Queue: "".concat(this.formatBytes(e.ss2PacketQueue), " (").concat((e.ss2PacketQueue / e.total * 100).toFixed(1), "%)"),
other: "".concat(this.formatBytes(e.other), " (").concat((e.other / e.total * 100).toFixed(1), "%)")
}
});
}, e.prototype.getLargestConsumers = function(e) {
void 0 === e && (e = 10);
var t = [];
if (Memory.rooms) for (var r in Memory.rooms) t.push({
type: "room",
name: r,
size: this.getObjectSize(Memory.rooms[r])
});
var o = Memory.clusters;
if (o) for (var n in o) t.push({
type: "cluster",
name: n,
size: this.getObjectSize(o[n])
});
return t.sort(function(e, t) {
return t.size - e.size;
}).slice(0, e);
}, e;
}()), Xa = 1e4, Qa = function() {
function e() {}
return e.prototype.pruneAll = function() {
var e = RawMemory.get().length, t = {
deadCreeps: 0,
eventLogs: 0,
staleIntel: 0,
marketHistory: 0,
bytesSaved: 0
};
t.deadCreeps = this.pruneDeadCreeps(), t.eventLogs = this.pruneEventLogs(20), t.staleIntel = this.pruneStaleIntel(Xa), 
t.marketHistory = this.pruneMarketHistory(5e3);
var r = RawMemory.get().length;
return t.bytesSaved = Math.max(0, e - r), t.bytesSaved > 0 && Hr.info("Memory pruning complete", {
subsystem: "MemoryPruner",
meta: t
}), t;
}, e.prototype.pruneDeadCreeps = function() {
var e = 0;
for (var t in Memory.creeps) t in Game.creeps || (delete Memory.creeps[t], e++);
return e;
}, e.prototype.pruneEventLogs = function(e) {
var t = 0;
if (!Memory.rooms) return 0;
for (var r in Memory.rooms) {
var o = Memory.rooms[r], n = null == o ? void 0 : o.swarm;
if ((null == n ? void 0 : n.eventLog) && n.eventLog.length > e) {
var a = n.eventLog.length - e;
n.eventLog.splice(0, a), t += a;
}
}
return t;
}, e.prototype.pruneStaleIntel = function(e) {
var t, r = Memory.empire;
if (!(null == r ? void 0 : r.knownRooms)) return 0;
var o = 0, n = Game.time - e;
for (var a in r.knownRooms) {
var i = r.knownRooms[a], s = Game.rooms[a];
(null === (t = null == s ? void 0 : s.controller) || void 0 === t ? void 0 : t.my) || i.lastSeen < n && !i.isHighway && !i.hasPortal && (delete r.knownRooms[a], 
o++);
}
return o;
}, e.prototype.pruneMarketHistory = function(e) {
var t = Memory.empire;
if (!(null == t ? void 0 : t.market)) return 0;
var r = t.market.priceHistory;
if (!r) return 0;
var o = 0, n = Game.time - e;
for (var a in r) {
var i = r[a];
if (i) {
var s = i.length;
r[a] = i.filter(function(e) {
return e.time >= n;
}), o += s - r[a].length;
}
}
return o;
}, e.prototype.pruneCompletedConstruction = function() {
var e, t = 0;
if (!Memory.rooms) return 0;
for (var r in Memory.rooms) if (Game.rooms[r]) {
var o = Memory.rooms[r];
if (null === (e = o.construction) || void 0 === e ? void 0 : e.sites) {
var n = o.construction.sites.length;
o.construction.sites = o.construction.sites.filter(function(e) {
return null !== Game.getObjectById(e);
}), t += n - o.construction.sites.length;
}
}
return t;
}, e.prototype.prunePowerBanks = function() {
var e = Memory.empire;
if (!(null == e ? void 0 : e.powerBanks)) return 0;
var t = e.powerBanks.length;
return e.powerBanks = e.powerBanks.filter(function(e) {
return e.decayTick > Game.time;
}), t - e.powerBanks.length;
}, e.prototype.pruneOldNukes = function() {
var e = Memory.empire;
if (!e) return 0;
var t = 0;
if (e.nukesInFlight) for (var r in e.nukesInFlight) e.nukesInFlight[r].impactTick < Game.time && (delete e.nukesInFlight[r], 
t++);
if (e.incomingNukes) {
var o = e.incomingNukes.length;
e.incomingNukes = e.incomingNukes.filter(function(e) {
return e.impactTick >= Game.time;
}), t += o - e.incomingNukes.length;
}
return t;
}, e.prototype.getRecommendations = function() {
var e = [], t = Memory.empire;
if (Memory.rooms) for (var r in Memory.rooms) {
var o = Memory.rooms[r], n = null == o ? void 0 : o.swarm;
(null == n ? void 0 : n.eventLog) && n.eventLog.length > 40 && e.push("Room ".concat(r, " has ").concat(n.eventLog.length, " event log entries (recommended max: ").concat(20, ")"));
}
if (null == t ? void 0 : t.knownRooms) {
var a = 0, i = Game.time - Xa;
for (var r in t.knownRooms) {
var s = t.knownRooms[r];
s.lastSeen < i && !s.isHighway && !s.hasPortal && a++;
}
a > 50 && e.push("".concat(a, " stale intel entries (older than ").concat(Xa, " ticks)"));
}
var c = 0;
for (var l in Memory.creeps) l in Game.creeps || c++;
return c > 10 && e.push("".concat(c, " dead creeps in memory")), e;
}, e;
}(), Za = new Qa, Ja = {
ACTIVE_ROOMS: {
start: 0,
end: 9
},
HISTORICAL_INTEL: {
start: 10,
end: 19
},
MARKET_HISTORY: {
start: 20,
end: 29
},
STANDARDS_DATA: {
start: 30,
end: 39
},
ARCHIVED_EMPIRE: {
start: 40,
end: 49
},
RESERVED: {
start: 50,
end: 89
},
STATS: {
start: 90,
end: 99
}
}, $a = function() {
function e() {
this.activeSegments = new Set, this.segmentCache = new Map;
}
return e.prototype.requestSegment = function(e) {
if (e < 0 || e > 99) throw new Error("Invalid segment ID: ".concat(e, ". Must be 0-99."));
this.activeSegments.add(e);
var t = Array.from(this.activeSegments);
if (t.length > 10) throw Hr.error("Cannot have more than 10 active segments", {
subsystem: "MemorySegmentManager",
meta: {
requested: e,
currentCount: t.length,
activeSegments: t
}
}), this.activeSegments.delete(e), new Error("Segment limit exceeded: Cannot load segment ".concat(e, ". Already have ").concat(t.length - 1, " active segments (limit: 10). Release a segment first."));
RawMemory.setActiveSegments(t);
}, e.prototype.releaseSegment = function(e) {
this.activeSegments.delete(e), this.segmentCache.delete(e), RawMemory.setActiveSegments(Array.from(this.activeSegments));
}, e.prototype.isSegmentLoaded = function(e) {
return void 0 !== RawMemory.segments[e];
}, e.prototype.writeSegment = function(e, t, r, o) {
if (void 0 === o && (o = 1), !this.isSegmentLoaded(e)) return Hr.warn("Attempted to write to unloaded segment", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e,
key: t
}
}), !1;
try {
var n = RawMemory.segments[e], a = n ? JSON.parse(n) : {}, i = {
data: r,
lastUpdate: Game.time,
version: o
};
a[t] = i;
var s = JSON.stringify(a);
return s.length > 102400 ? (Hr.error("Segment data exceeds 100KB limit", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e,
key: t,
size: s.length
}
}), !1) : (RawMemory.segments[e] = s, this.segmentCache.set(e, a), !0);
} catch (r) {
return Hr.error("Failed to write segment data", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e,
key: t,
error: String(r)
}
}), !1;
}
}, e.prototype.readSegment = function(e, t) {
if (!this.isSegmentLoaded(e)) return Hr.warn("Attempted to read from unloaded segment", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e,
key: t
}
}), null;
try {
var r = this.segmentCache.get(e);
if (!r) {
var o = RawMemory.segments[e];
if (!o) return null;
if (null == (r = JSON.parse(o))) return null;
this.segmentCache.set(e, r);
}
var n = r[t];
return n ? n.data : null;
} catch (r) {
return Hr.error("Failed to read segment data", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e,
key: t,
error: String(r)
}
}), null;
}
}, e.prototype.getSegmentMetadata = function(e, t) {
if (!this.isSegmentLoaded(e)) return null;
try {
var r = RawMemory.segments[e];
if (!r) return null;
var o = JSON.parse(r)[t];
return o ? {
lastUpdate: o.lastUpdate,
version: o.version
} : null;
} catch (e) {
return null;
}
}, e.prototype.deleteSegmentKey = function(e, t) {
if (!this.isSegmentLoaded(e)) return !1;
try {
var r = RawMemory.segments[e];
if (!r) return !1;
var o = JSON.parse(r);
return delete o[t], RawMemory.segments[e] = JSON.stringify(o), this.segmentCache.set(e, o), 
!0;
} catch (e) {
return !1;
}
}, e.prototype.clearSegment = function(e) {
this.isSegmentLoaded(e) ? (RawMemory.segments[e] = "", this.segmentCache.delete(e)) : Hr.warn("Attempted to clear unloaded segment", {
subsystem: "MemorySegmentManager",
meta: {
segmentId: e
}
});
}, e.prototype.getSegmentKeys = function(e) {
if (!this.isSegmentLoaded(e)) return [];
try {
var t = RawMemory.segments[e];
if (!t) return [];
var r = JSON.parse(t);
return Object.keys(r);
} catch (e) {
return [];
}
}, e.prototype.getSegmentSize = function(e) {
if (!this.isSegmentLoaded(e)) return 0;
var t = RawMemory.segments[e];
return t ? t.length : 0;
}, e.prototype.getActiveSegments = function() {
return Array.from(this.activeSegments);
}, e.prototype.suggestSegmentForType = function(e) {
for (var t = Ja[e], r = t.start; r <= t.end; r++) if (!this.isSegmentLoaded(r) || this.getSegmentSize(r) < 92160) return r;
return t.start;
}, e.prototype.migrateToSegment = function(e, t, o) {
var n, a, i = e.split("."), s = Memory;
try {
for (var c = r(i), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (!s || "object" != typeof s || !(u in s)) return Hr.warn("Memory path not found for migration", {
subsystem: "MemorySegmentManager",
meta: {
memoryPath: e,
segmentId: t,
key: o
}
}), !1;
s = s[u];
}
} catch (e) {
n = {
error: e
};
} finally {
try {
l && !l.done && (a = c.return) && a.call(c);
} finally {
if (n) throw n.error;
}
}
if (!this.isSegmentLoaded(t)) return this.requestSegment(t), Hr.info("Segment not loaded, will migrate next tick", {
subsystem: "MemorySegmentManager",
meta: {
memoryPath: e,
segmentId: t,
key: o
}
}), !1;
var f = this.writeSegment(t, o, s);
return f && Hr.info("Successfully migrated data to segment", {
subsystem: "MemorySegmentManager",
meta: {
memoryPath: e,
segmentId: t,
key: o,
dataSize: JSON.stringify(s).length
}
}), f;
}, e;
}(), ei = new $a, ti = {
exports: {}
}, ri = (Ha || (Ha = 1, Wa = ti, Ya = function() {
var e = String.fromCharCode, t = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", o = {};
function n(e, t) {
if (!o[e]) {
o[e] = {};
for (var r = 0; r < e.length; r++) o[e][e.charAt(r)] = r;
}
return o[e][t];
}
var a = {
compressToBase64: function(e) {
if (null == e) return "";
var r = a._compress(e, 6, function(e) {
return t.charAt(e);
});
switch (r.length % 4) {
default:
case 0:
return r;

case 1:
return r + "===";

case 2:
return r + "==";

case 3:
return r + "=";
}
},
decompressFromBase64: function(e) {
return null == e ? "" : "" == e ? null : a._decompress(e.length, 32, function(r) {
return n(t, e.charAt(r));
});
},
compressToUTF16: function(t) {
return null == t ? "" : a._compress(t, 15, function(t) {
return e(t + 32);
}) + " ";
},
decompressFromUTF16: function(e) {
return null == e ? "" : "" == e ? null : a._decompress(e.length, 16384, function(t) {
return e.charCodeAt(t) - 32;
});
},
compressToUint8Array: function(e) {
for (var t = a.compress(e), r = new Uint8Array(2 * t.length), o = 0, n = t.length; o < n; o++) {
var i = t.charCodeAt(o);
r[2 * o] = i >>> 8, r[2 * o + 1] = i % 256;
}
return r;
},
decompressFromUint8Array: function(t) {
if (null == t) return a.decompress(t);
for (var r = new Array(t.length / 2), o = 0, n = r.length; o < n; o++) r[o] = 256 * t[2 * o] + t[2 * o + 1];
var i = [];
return r.forEach(function(t) {
i.push(e(t));
}), a.decompress(i.join(""));
},
compressToEncodedURIComponent: function(e) {
return null == e ? "" : a._compress(e, 6, function(e) {
return r.charAt(e);
});
},
decompressFromEncodedURIComponent: function(e) {
return null == e ? "" : "" == e ? null : (e = e.replace(/ /g, "+"), a._decompress(e.length, 32, function(t) {
return n(r, e.charAt(t));
}));
},
compress: function(t) {
return a._compress(t, 16, function(t) {
return e(t);
});
},
_compress: function(e, t, r) {
if (null == e) return "";
var o, n, a, i = {}, s = {}, c = "", l = "", u = "", f = 2, m = 3, p = 2, d = [], y = 0, g = 0;
for (a = 0; a < e.length; a += 1) if (c = e.charAt(a), Object.prototype.hasOwnProperty.call(i, c) || (i[c] = m++, 
s[c] = !0), l = u + c, Object.prototype.hasOwnProperty.call(i, l)) u = l; else {
if (Object.prototype.hasOwnProperty.call(s, u)) {
if (u.charCodeAt(0) < 256) {
for (o = 0; o < p; o++) y <<= 1, g == t - 1 ? (g = 0, d.push(r(y)), y = 0) : g++;
for (n = u.charCodeAt(0), o = 0; o < 8; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
} else {
for (n = 1, o = 0; o < p; o++) y = y << 1 | n, g == t - 1 ? (g = 0, d.push(r(y)), 
y = 0) : g++, n = 0;
for (n = u.charCodeAt(0), o = 0; o < 16; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
}
0 == --f && (f = Math.pow(2, p), p++), delete s[u];
} else for (n = i[u], o = 0; o < p; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
0 == --f && (f = Math.pow(2, p), p++), i[l] = m++, u = String(c);
}
if ("" !== u) {
if (Object.prototype.hasOwnProperty.call(s, u)) {
if (u.charCodeAt(0) < 256) {
for (o = 0; o < p; o++) y <<= 1, g == t - 1 ? (g = 0, d.push(r(y)), y = 0) : g++;
for (n = u.charCodeAt(0), o = 0; o < 8; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
} else {
for (n = 1, o = 0; o < p; o++) y = y << 1 | n, g == t - 1 ? (g = 0, d.push(r(y)), 
y = 0) : g++, n = 0;
for (n = u.charCodeAt(0), o = 0; o < 16; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
}
0 == --f && (f = Math.pow(2, p), p++), delete s[u];
} else for (n = i[u], o = 0; o < p; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, 
d.push(r(y)), y = 0) : g++, n >>= 1;
0 == --f && (f = Math.pow(2, p), p++);
}
for (n = 2, o = 0; o < p; o++) y = y << 1 | 1 & n, g == t - 1 ? (g = 0, d.push(r(y)), 
y = 0) : g++, n >>= 1;
for (;;) {
if (y <<= 1, g == t - 1) {
d.push(r(y));
break;
}
g++;
}
return d.join("");
},
decompress: function(e) {
return null == e ? "" : "" == e ? null : a._decompress(e.length, 32768, function(t) {
return e.charCodeAt(t);
});
},
_decompress: function(t, r, o) {
var n, a, i, s, c, l, u, f = [], m = 4, p = 4, d = 3, y = "", g = [], h = {
val: o(0),
position: r,
index: 1
};
for (n = 0; n < 3; n += 1) f[n] = n;
for (i = 0, c = Math.pow(2, 2), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
switch (i) {
case 0:
for (i = 0, c = Math.pow(2, 8), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
u = e(i);
break;

case 1:
for (i = 0, c = Math.pow(2, 16), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
u = e(i);
break;

case 2:
return "";
}
for (f[3] = u, a = u, g.push(u); ;) {
if (h.index > t) return "";
for (i = 0, c = Math.pow(2, d), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
switch (u = i) {
case 0:
for (i = 0, c = Math.pow(2, 8), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
f[p++] = e(i), u = p - 1, m--;
break;

case 1:
for (i = 0, c = Math.pow(2, 16), l = 1; l != c; ) s = h.val & h.position, h.position >>= 1, 
0 == h.position && (h.position = r, h.val = o(h.index++)), i |= (s > 0 ? 1 : 0) * l, 
l <<= 1;
f[p++] = e(i), u = p - 1, m--;
break;

case 2:
return g.join("");
}
if (0 == m && (m = Math.pow(2, d), d++), f[u]) y = f[u]; else {
if (u !== p) return null;
y = a + a.charAt(0);
}
g.push(y), f[p++] = a + y.charAt(0), a = y, 0 == --m && (m = Math.pow(2, d), d++);
}
}
};
return a;
}(), null != Wa ? Wa.exports = Ya : "undefined" != typeof angular && null != angular && angular.module("LZString", []).factory("LZString", function() {
return Ya;
})), ti.exports), oi = function() {
function e() {}
return e.prototype.compress = function(e, t) {
void 0 === t && (t = 1);
var r = JSON.stringify(e), o = r.length, n = ri.compressToUTF16(r);
return {
compressed: n,
originalSize: o,
compressedSize: n.length,
timestamp: Game.time,
version: t
};
}, e.prototype.decompress = function(e) {
try {
var t = "string" == typeof e ? e : e.compressed, r = ri.decompressFromUTF16(t);
return r ? JSON.parse(r) : (Hr.error("Decompression returned null", {
subsystem: "MemoryCompressor"
}), null);
} catch (e) {
return Hr.error("Failed to decompress data", {
subsystem: "MemoryCompressor",
meta: {
error: String(e)
}
}), null;
}
}, e.prototype.compressIntel = function(e) {
return this.compress(e);
}, e.prototype.decompressIntel = function(e) {
return this.decompress(e);
}, e.prototype.compressPortalMap = function(e) {
return this.compress(e);
}, e.prototype.decompressPortalMap = function(e) {
return this.decompress(e);
}, e.prototype.compressMarketHistory = function(e) {
return this.compress(e);
}, e.prototype.decompressMarketHistory = function(e) {
return this.decompress(e);
}, e.prototype.getCompressionStats = function(e) {
var t = this.compress(e), r = t.originalSize, o = t.compressedSize;
return {
originalSize: r,
compressedSize: o,
bytesSaved: r - o,
ratio: o / r
};
}, e.prototype.shouldCompress = function(e, t, r) {
if (void 0 === t && (t = 1e3), void 0 === r && (r = .9), JSON.stringify(e).length < t) return !1;
var o = this.compress(e);
return o.compressedSize / o.originalSize < r;
}, e.prototype.compressIfBeneficial = function(e, t, r) {
return void 0 === t && (t = 1e3), void 0 === r && (r = .9), this.shouldCompress(e, t, r) ? this.compress(e) : e;
}, e.prototype.isCompressed = function(e) {
return "object" == typeof e && null !== e && "compressed" in e && "originalSize" in e && "compressedSize" in e;
}, e.prototype.getOrDecompress = function(e) {
return this.isCompressed(e) ? this.decompress(e) : e;
}, e.prototype.batchCompress = function(e) {
var t = {};
for (var r in e) t[r] = this.compress(e[r]);
return t;
}, e.prototype.batchDecompress = function(e) {
var t = {};
for (var r in e) t[r] = this.decompress(e[r]);
return t;
}, e.prototype.formatStats = function(e) {
var t = (100 * (1 - e.ratio)).toFixed(1);
return "".concat(this.formatBytes(e.originalSize), "  ").concat(this.formatBytes(e.compressedSize), " (").concat(t, "% saved)");
}, e.prototype.formatBytes = function(e) {
return e < 1024 ? "".concat(e, "B") : e < 1048576 ? "".concat((e / 1024).toFixed(1), "KB") : "".concat((e / 1048576).toFixed(2), "MB");
}, e;
}(), ni = new oi, ai = [ {
version: 4,
description: "Move historical intel to memory segments",
migrate: function(e) {
var t, r, o = e.empire;
if (null == o ? void 0 : o.knownRooms) {
var n = {}, a = {}, i = Game.time - 5e3;
for (var s in o.knownRooms) {
var c = o.knownRooms[s];
c.lastSeen >= i || (null === (r = null === (t = Game.rooms[s]) || void 0 === t ? void 0 : t.controller) || void 0 === r ? void 0 : r.my) || c.isHighway || c.hasPortal ? n[s] = c : a[s] = c;
}
if (Object.keys(a).length > 0) {
var l = ei.suggestSegmentForType("HISTORICAL_INTEL");
if (!ei.isSegmentLoaded(l)) return ei.requestSegment(l), void Hr.info("Segment not loaded, migration will continue next tick", {
subsystem: "MemoryMigrations",
meta: {
segmentId: l
}
});
if (!ei.writeSegment(l, "historicalIntel", a)) return void Hr.error("Failed to write historical intel to segment", {
subsystem: "MemoryMigrations",
meta: {
segmentId: l
}
});
o.knownRooms = n, Hr.info("Migrated historical intel to segments", {
subsystem: "MemoryMigrations",
meta: {
historicalCount: Object.keys(a).length,
activeCount: Object.keys(n).length,
segmentId: l
}
});
}
}
}
}, {
version: 5,
description: "Compress portal map data",
migrate: function(e) {
var t = e.empire;
if (t) {
var r = t, o = r.portals;
if (o && !ni.isCompressed(o)) {
var n = ni.compressPortalMap(o);
r.compressedPortals = n, delete r.portals, Hr.info("Compressed portal map data", {
subsystem: "MemoryMigrations",
meta: {
originalSize: n.originalSize,
compressedSize: n.compressedSize,
ratio: (n.compressedSize / n.originalSize * 100).toFixed(1) + "%"
}
});
}
}
}
}, {
version: 6,
description: "Move market history to segments with compression",
migrate: function(e) {
var t = e.empire;
if (null == t ? void 0 : t.market) {
var r = t.market, o = r.priceHistory;
if (o) {
var n = ni.compressMarketHistory(o), a = ei.suggestSegmentForType("MARKET_HISTORY");
if (!ei.isSegmentLoaded(a)) return ei.requestSegment(a), void Hr.info("Segment not loaded, migration will continue next tick", {
subsystem: "MemoryMigrations",
meta: {
segmentId: a
}
});
ei.writeSegment(a, "priceHistory", n) ? (delete r.priceHistory, Hr.info("Migrated market history to segments", {
subsystem: "MemoryMigrations",
meta: {
originalSize: n.originalSize,
compressedSize: n.compressedSize,
segmentId: a
}
})) : Hr.error("Failed to write market history to segment", {
subsystem: "MemoryMigrations",
meta: {
segmentId: a
}
});
}
}
}
}, {
version: 7,
description: "Ensure all clusters have required array properties",
migrate: function(e) {
var t = e.clusters;
if (t) {
var r = 0;
for (var o in t) {
var n = t[o];
n.squads || (n.squads = [], r++), n.defenseRequests || (n.defenseRequests = [], 
r++), n.resourceRequests || (n.resourceRequests = [], r++), n.rallyPoints || (n.rallyPoints = [], 
r++);
}
r > 0 && Hr.info("Migrated ".concat(r, " cluster array properties"), {
subsystem: "MemoryMigrations",
meta: {
clustersProcessed: Object.keys(t).length
}
});
}
}
} ], ii = function() {
function e() {}
return e.prototype.runMigrations = function() {
var e, t, o, n = Memory, a = null !== (o = n.memoryVersion) && void 0 !== o ? o : 0, i = ai.filter(function(e) {
return e.version > a;
});
if (0 !== i.length) {
Hr.info("Running ".concat(i.length, " memory migration(s)"), {
subsystem: "MigrationRunner",
meta: {
fromVersion: a,
toVersion: i[i.length - 1].version
}
});
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
try {
Hr.info("Running migration v".concat(l.version, ": ").concat(l.description), {
subsystem: "MigrationRunner"
}), l.migrate(Memory), n.memoryVersion = l.version, Hr.info("Migration v".concat(l.version, " complete"), {
subsystem: "MigrationRunner"
});
} catch (e) {
Hr.error("Migration v".concat(l.version, " failed"), {
subsystem: "MigrationRunner",
meta: {
error: String(e)
}
}), Game.notify("Migration v".concat(l.version, " failed: ").concat(String(e)));
break;
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
}
}, e.prototype.getCurrentVersion = function() {
var e;
return null !== (e = Memory.memoryVersion) && void 0 !== e ? e : 0;
}, e.prototype.getLatestVersion = function() {
return 0 === ai.length ? 0 : Math.max.apply(Math, n([], o(ai.map(function(e) {
return e.version;
})), !1));
}, e.prototype.hasPendingMigrations = function() {
return this.getCurrentVersion() < this.getLatestVersion();
}, e.prototype.getPendingMigrations = function() {
var e = this.getCurrentVersion();
return ai.filter(function(t) {
return t.version > e;
});
}, e.prototype.rollbackToVersion = function(e) {
var t = Memory;
Hr.warn("Rolling back memory version to ".concat(e), {
subsystem: "MigrationRunner",
meta: {
fromVersion: this.getCurrentVersion(),
toVersion: e
}
}), t.memoryVersion = e, Game.notify("Memory version rolled back to ".concat(e, ". Data may be inconsistent!"));
}, e;
}(), si = new ii, ci = "empire", li = "clusters", ui = function() {
function e() {
this.lastInitializeTick = null, this.lastCleanupTick = 0, this.lastPruningTick = 0, 
this.lastMonitoringTick = 0;
}
return e.prototype.initialize = function() {
this.lastInitializeTick !== Game.time && (this.lastInitializeTick = Game.time, qr.initialize(), 
si.runMigrations(), this.ensureEmpireMemory(), this.ensureClustersMemory(), Game.time - this.lastCleanupTick >= 10 && (this.cleanDeadCreeps(), 
this.lastCleanupTick = Game.time), Game.time - this.lastPruningTick >= 100 && (Za.pruneAll(), 
this.lastPruningTick = Game.time), Game.time - this.lastMonitoringTick >= 50 && (qa.checkMemoryUsage(), 
this.lastMonitoringTick = Game.time));
}, e.prototype.ensureEmpireMemory = function() {
var e = Memory;
e[ci] || (e[ci] = {
knownRooms: {},
clusters: [],
warTargets: [],
ownedRooms: {},
claimQueue: [],
nukeCandidates: [],
powerBanks: [],
market: {
resources: {},
lastScan: 0,
pendingArbitrage: [],
completedArbitrage: 0,
arbitrageProfit: 0
},
objectives: {
targetPowerLevel: 0,
targetRoomCount: 1,
warMode: !1,
expansionPaused: !1
},
lastUpdate: 0
});
}, e.prototype.ensureClustersMemory = function() {
var e = Memory;
e[li] || (e[li] = {});
}, e.prototype.getEmpire = function() {
var e = "memory:".concat(ci), t = qr.get(e);
if (!t) {
this.ensureEmpireMemory();
var r = Memory;
qr.set(e, r[ci], Yr), t = r[ci];
}
return t;
}, e.prototype.getClusters = function() {
var e = "memory:".concat(li), t = qr.get(e);
if (!t) {
this.ensureClustersMemory();
var r = Memory;
qr.set(e, r[li], Yr), t = r[li];
}
return t;
}, e.prototype.getCluster = function(e, t) {
var r = this.getClusters();
return !r[e] && t && (r[e] = ja(e, t)), r[e];
}, e.prototype.getSwarmState = function(e) {
var t, r = "memory:room:".concat(e, ":swarm"), o = qr.get(r);
if (!o) {
var n = null === (t = Memory.rooms) || void 0 === t ? void 0 : t[e];
if (!n) return;
var a = n.swarm;
a && (qr.set(r, a, Yr), o = a);
}
return o;
}, e.prototype.initSwarmState = function(e) {
var t = "memory:room:".concat(e, ":swarm");
Memory.rooms || (Memory.rooms = {}), Memory.rooms[e] || (Memory.rooms[e] = {});
var r = Memory.rooms[e];
return r.swarm || (r.swarm = {
colonyLevel: "seedNest",
posture: "eco",
danger: 0,
pheromones: {
expand: 0,
harvest: 10,
build: 5,
upgrade: 5,
defense: 0,
war: 0,
siege: 0,
logistics: 5,
nukeTarget: 0
},
nextUpdateTick: 0,
eventLog: [],
missingStructures: {
spawn: !0,
storage: !0,
terminal: !0,
labs: !0,
nuker: !0,
factory: !0,
extractor: !0,
powerSpawn: !0,
observer: !0
},
role: "secondaryCore",
remoteAssignments: [],
metrics: {
energyHarvested: 0,
energySpawning: 0,
energyConstruction: 0,
energyRepair: 0,
energyTower: 0,
controllerProgress: 0,
hostileCount: 0,
damageReceived: 0,
constructionSites: 0,
energyAvailable: 0,
energyCapacity: 0,
energyNeed: 0
},
lastUpdate: 0
}), qr.set(t, r.swarm, Yr), r.swarm;
}, e.prototype.getOrInitSwarmState = function(e) {
var t;
return null !== (t = this.getSwarmState(e)) && void 0 !== t ? t : this.initSwarmState(e);
}, e.prototype.getCreepMemory = function(e) {
var t = Game.creeps[e];
if (t) return t.memory;
}, e.prototype.cleanDeadCreeps = function() {
var e = 0;
for (var t in Memory.creeps) t in Game.creeps || (delete Memory.creeps[t], e++);
return e;
}, e.prototype.recordRoomSeen = function(e) {
var t = this.getEmpire();
t.knownRooms[e] ? t.knownRooms[e].lastSeen = Game.time : t.knownRooms[e] = {
name: e,
lastSeen: Game.time,
sources: 0,
controllerLevel: 0,
threatLevel: 0,
scouted: !1,
terrain: "mixed",
isHighway: !1,
isSK: !1
};
}, e.prototype.addRoomEvent = function(e, t, r) {
var o = this.getSwarmState(e);
if (o) {
var n = {
type: t,
time: Game.time
};
for (void 0 !== r && (n.details = r), o.eventLog.push(n); o.eventLog.length > 20; ) o.eventLog.shift();
}
}, e.prototype.getMemorySize = function() {
return JSON.stringify(Memory).length;
}, e.prototype.isMemoryNearLimit = function() {
return this.getMemorySize() > 1887436.8;
}, e.prototype.persistHeapCache = function() {
qr.persist();
}, e.prototype.getHeapCache = function() {
return qr;
}, e.prototype.isRoomHostile = function(e) {
var t, r, o, n = "memory:room:".concat(e, ":hostile"), a = qr.get(n);
if (void 0 !== a) return !0 === a;
var i = null !== (o = null === (r = null === (t = Memory.rooms) || void 0 === t ? void 0 : t[e]) || void 0 === r ? void 0 : r.hostile) && void 0 !== o && o;
return qr.set(n, !!i || null, 100), i;
}, e.prototype.setRoomHostile = function(e, t) {
Memory.rooms || (Memory.rooms = {}), Memory.rooms[e] || (Memory.rooms[e] = {}), 
Memory.rooms[e].hostile = t;
var r = "memory:room:".concat(e, ":hostile");
qr.set(r, !!t || null, 100);
}, e;
}(), fi = new ui, mi = Object.freeze({
__proto__: null,
MemoryManager: ui,
memoryManager: fi
});

function pi(e) {
var t, o, n, a, i, s, c = {
guards: 0,
rangers: 0,
healers: 0,
urgency: 1,
reasons: []
}, l = null !== (s = null === (i = e.controller) || void 0 === i ? void 0 : i.level) && void 0 !== s ? s : 1;
l >= 3 && (c.guards = 1, c.rangers = 1, c.reasons.push("Baseline defense force for RCL ".concat(l)));
var u = e.find(FIND_HOSTILE_CREEPS);
if (0 === u.length) return c;
var f = 0, m = 0, p = 0, d = 0, y = 0;
try {
for (var g = r(u), h = g.next(); !h.done; h = g.next()) {
var v = h.value.body, R = v.some(function(e) {
return void 0 !== e.boost;
});
R && y++;
try {
for (var E = (n = void 0, r(v)), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
S.type === ATTACK && f++, S.type === RANGED_ATTACK && m++, S.type === HEAL && p++, 
S.type === WORK && d++;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
T && !T.done && (a = E.return) && a.call(E);
} finally {
if (n) throw n.error;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
h && !h.done && (o = g.return) && o.call(g);
} finally {
if (t) throw t.error;
}
}
return f > 0 && (c.guards = Math.max(1, Math.ceil(f / 4)), c.reasons.push("".concat(f, " melee parts detected"))), 
m > 0 && (c.rangers = Math.max(1, Math.ceil(m / 6)), c.reasons.push("".concat(m, " ranged parts detected"))), 
p > 0 && (c.healers = Math.max(1, Math.ceil(p / 8)), c.reasons.push("".concat(p, " heal parts detected"))), 
d > 0 && (c.guards += Math.ceil(d / 5), c.reasons.push("".concat(d, " work parts (dismantlers)"))), 
y > 0 && (c.guards = Math.ceil(1.5 * c.guards), c.rangers = Math.ceil(1.5 * c.rangers), 
c.healers = Math.ceil(1.5 * c.healers), c.urgency = 2, c.reasons.push("".concat(y, " boosted enemies (high threat)"))), 
u.length > 0 && (c.guards = Math.max(c.guards, 2), c.rangers = Math.max(c.rangers, 2)), 
u.length >= 3 && (c.healers = Math.max(c.healers, 1)), u.length >= 5 && (c.urgency = Math.max(c.urgency, 1.5), 
c.reasons.push("".concat(u.length, " hostiles (large attack)"))), e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return (e.structureType === STRUCTURE_SPAWN || e.structureType === STRUCTURE_STORAGE || e.structureType === STRUCTURE_TERMINAL) && e.hits < .8 * e.hitsMax;
}
}).length > 0 && (c.urgency = 3, c.reasons.push("Critical structures under attack!")), 
Hr.info("Defender analysis for ".concat(e.name, ": ").concat(c.guards, " guards, ").concat(c.rangers, " rangers, ").concat(c.healers, " healers (urgency: ").concat(c.urgency, "x) - ").concat(c.reasons.join(", ")), {
subsystem: "Defense"
}), c;
}

function di(e) {
var t = e.find(FIND_MY_CREEPS);
return {
guards: t.filter(function(e) {
return "guard" === e.memory.role;
}).length,
rangers: t.filter(function(e) {
return "ranger" === e.memory.role;
}).length,
healers: t.filter(function(e) {
return "healer" === e.memory.role;
}).length
};
}

function yi(e, t, r) {
var o = pi(e), n = di(e);
if (0 === o.guards && 0 === o.rangers && 0 === o.healers) return 0;
var a = 0;
return ("guard" === r && n.guards < o.guards || "ranger" === r && n.rangers < o.rangers || "healer" === r && n.healers < o.healers) && (a = 100 * o.urgency), 
a;
}

function gi(e, t) {
var r, o;
if (t.danger < 1) return !1;
var n = pi(e), a = di(e), i = n.guards - a.guards + (n.rangers - a.rangers);
if (i <= 0) return !1;
var s = e.find(FIND_MY_SPAWNS);
if (0 === s.length) return !0;
if (0 === s.filter(function(e) {
return !e.spawning;
}).length && i >= 1) return !0;
if (e.energyAvailable < 250 && i >= 1) return !0;
if (n.urgency >= 2 && i >= 2) return !0;
if (t.danger >= 3 && i >= 1) return !0;
var c = null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 1;
return t.danger >= 2 && (i >= 2 || c <= 3);
}

function hi(e, t) {
if (!gi(e, t)) return null;
var r = pi(e), o = di(e), n = {
roomName: e.name,
guardsNeeded: Math.max(0, r.guards - o.guards),
rangersNeeded: Math.max(0, r.rangers - o.rangers),
healersNeeded: Math.max(0, r.healers - o.healers),
urgency: r.urgency,
createdAt: Game.time,
threat: r.reasons.join("; ")
};
return Hr.warn("Defense assistance requested for ".concat(e.name, ": ").concat(n.guardsNeeded, " guards, ").concat(n.rangersNeeded, " rangers, ").concat(n.healersNeeded, " healers - ").concat(n.threat), {
subsystem: "Defense"
}), n;
}

var vi = Object.freeze({
__proto__: null,
analyzeDefenderNeeds: pi,
createDefenseRequest: hi,
getCurrentDefenders: di,
getDefenderPriorityBoost: yi,
needsDefenseAssistance: gi,
needsEmergencyDefenders: function(e, t) {
var r = pi(e), o = di(e), n = r.guards > 0 && 0 === o.guards, a = r.rangers > 0 && 0 === o.rangers, i = r.urgency >= 2;
return (n || a) && i;
}
});

function Ri(e, t, r) {
var o = 0;
if ("guard" !== r && "ranger" !== r && "healer" !== r || (o += yi(e, 0, r)), "upgrader" === r && t.clusterId) {
var n = fi.getCluster(t.clusterId);
(null == n ? void 0 : n.focusRoom) === e.name && (o += 40);
}
return o;
}

function Ei(e, t) {
var r, o = {
harvester: "harvest",
hauler: "logistics",
upgrader: "upgrade",
builder: "build",
guard: "defense",
remoteGuard: "defense",
healer: "defense",
soldier: "war",
siegeUnit: "siege",
ranger: "war",
scout: "expand",
claimer: "expand",
remoteWorker: "expand",
engineer: "build",
remoteHarvester: "harvest",
remoteHauler: "logistics",
interRoomCarrier: "logistics"
}[e];
return o ? .5 + (null !== (r = t[o]) && void 0 !== r ? r : 0) / 100 * 1.5 : 1;
}

var Ti, Si = [ {
carryParts: 4,
capacity: 200,
moveParts: 4,
cost: 400
}, {
carryParts: 8,
capacity: 400,
moveParts: 8,
cost: 800
}, {
carryParts: 16,
capacity: 800,
moveParts: 16,
cost: 1600
}, {
carryParts: 24,
capacity: 1200,
moveParts: 24,
cost: 2400
} ];

function Ci(e, t, o, n) {
var a, i, s, c, l, u, f = (s = t, l = (c = function(e) {
var t = e.match(/^([WE])(\d+)([NS])(\d+)$/);
return t ? {
x: "W" === t[1] ? -parseInt(t[2], 10) : parseInt(t[2], 10),
y: "N" === t[3] ? parseInt(t[4], 10) : -parseInt(t[4], 10)
} : {
x: 0,
y: 0
};
})(e), u = c(s), Math.abs(u.x - l.x) + Math.abs(u.y - l.y)), m = function(e, t) {
void 0 === t && (t = 1.2);
var r = 50 * e * t;
return Math.ceil(2 * r);
}(f), p = 10 * o, d = Si[0];
try {
for (var y = r(Si), g = y.next(); !g.done; g = y.next()) {
var h = g.value;
if (!(h.cost <= n)) break;
d = h;
}
} catch (e) {
a = {
error: e
};
} finally {
try {
g && !g.done && (i = y.return) && i.call(y);
} finally {
if (a) throw a.error;
}
}
var v = p * m, R = Math.max(1, Math.ceil(v / d.capacity * 1.2)), E = Math.min(2 * o, R + 1);
return Hr.debug("Remote hauler calculation: ".concat(e, " -> ").concat(t, " (").concat(o, " sources, ").concat(f, " rooms away) - RT: ").concat(m, " ticks, E/tick: ").concat(p, ", Min: ").concat(R, ", Rec: ").concat(E, ", Cap: ").concat(d.capacity), {
subsystem: "HaulerDimensioning"
}), {
minHaulers: R,
recommendedHaulers: E,
haulerConfig: d,
distance: f,
roundTripTicks: m,
energyPerTick: p
};
}

var bi, _i = ((Ti = {})[MOVE] = 50, Ti[WORK] = 100, Ti[CARRY] = 50, Ti[ATTACK] = 80, 
Ti[RANGED_ATTACK] = 150, Ti[HEAL] = 250, Ti[CLAIM] = 600, Ti[TOUGH] = 10, Ti);

function Oi(e) {
return e.reduce(function(e, t) {
return e + _i[t];
}, 0);
}

!function(e) {
e[e.EMERGENCY = 1e3] = "EMERGENCY", e[e.HIGH = 500] = "HIGH", e[e.NORMAL = 100] = "NORMAL", 
e[e.LOW = 50] = "LOW";
}(bi || (bi = {}));

var wi = function() {
function t() {
this.queues = new Map;
}
return t.prototype.getQueue = function(e) {
return this.queues.has(e) || this.queues.set(e, {
requests: [],
inProgress: new Map,
lastUpdate: Game.time
}), this.queues.get(e);
}, t.prototype.addRequest = function(e) {
var t = this.getQueue(e.roomName);
e.id || (e.id = "".concat(e.role, "_").concat(Game.time, "_").concat(Math.random().toString(36).substring(2, 11))), 
t.requests.push(e), t.requests.sort(function(e, t) {
return t.priority - e.priority;
}), Hr.debug("Added spawn request: ".concat(e.role, " (priority: ").concat(e.priority, ") for room ").concat(e.roomName), {
subsystem: "SpawnQueue"
});
}, t.prototype.getNextRequest = function(e, t) {
var r = this.getQueue(e);
this.cleanupInProgress(r);
for (var o = 0; o < r.requests.length; o++) {
var n = r.requests[o];
if (!this.isRequestInProgress(r, n.id) && n.body.cost <= t) return n;
}
return null;
}, t.prototype.removeRequest = function(e, t) {
var r = this.getQueue(e);
r.requests = r.requests.filter(function(e) {
return e.id !== t;
});
}, t.prototype.markInProgress = function(e, t, r) {
this.getQueue(e).inProgress.set(t, {
spawnId: r,
requestId: t
});
}, t.prototype.isRequestInProgress = function(e, t) {
return e.inProgress.has(t);
}, t.prototype.cleanupInProgress = function(e) {
var t, n, a, i, s = [];
try {
for (var c = r(e.inProgress), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = u[0], m = u[1].spawnId, p = Game.getObjectById(m);
p && p.spawning || s.push(f);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (t) throw t.error;
}
}
try {
for (var d = r(s), y = d.next(); !y.done; y = d.next()) f = y.value, e.inProgress.delete(f);
} catch (e) {
a = {
error: e
};
} finally {
try {
y && !y.done && (i = d.return) && i.call(d);
} finally {
if (a) throw a.error;
}
}
}, t.prototype.getPendingRequests = function(e) {
return n([], o(this.getQueue(e).requests), !1);
}, t.prototype.getQueueSize = function(e) {
return this.getQueue(e).requests.length;
}, t.prototype.clearQueue = function(e) {
this.getQueue(e).requests = [], Hr.debug("Cleared spawn queue for room ".concat(e), {
subsystem: "SpawnQueue"
});
}, t.prototype.getAvailableSpawns = function(e) {
var t = Game.rooms[e];
return t ? t.find(FIND_MY_SPAWNS).filter(function(e) {
return !e.spawning;
}) : [];
}, t.prototype.processQueue = function(e) {
var t, o, n = Game.rooms[e];
if (!n) return 0;
var a = this.getAvailableSpawns(e);
if (0 === a.length) return 0;
this.getQueue(e);
var i = 0;
try {
for (var s = r(a), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = this.getNextRequest(e, n.energyAvailable);
if (!u) break;
var f = this.executeSpawn(l, u);
f === OK ? (i++, this.markInProgress(e, u.id, l.id), this.removeRequest(e, u.id)) : f !== ERR_NOT_ENOUGH_ENERGY && (this.removeRequest(e, u.id), 
Hr.warn("Spawn request failed: ".concat(u.role, " in ").concat(e, " (error: ").concat(f, ")"), {
subsystem: "SpawnQueue"
}));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return i;
}, t.prototype.executeSpawn = function(t, r) {
var o = this.generateCreepName(r.role), n = e({
role: r.role,
family: r.family,
homeRoom: r.roomName,
version: 1
}, r.additionalMemory);
return r.targetRoom && (n.targetRoom = r.targetRoom), r.sourceId && (n.sourceId = r.sourceId), 
r.boostRequirements && (n.boostRequirements = r.boostRequirements), t.spawnCreep(r.body.parts, o, {
memory: n
});
}, t.prototype.generateCreepName = function(e) {
return "".concat(e, "_").concat(Game.time, "_").concat(Math.random().toString(36).substring(2, 11));
}, t.prototype.hasEmergencySpawns = function(e) {
return this.getQueue(e).requests.some(function(e) {
return e.priority >= bi.EMERGENCY;
});
}, t.prototype.countByPriority = function(e, t) {
return this.getQueue(e).requests.filter(function(e) {
return e.priority >= t;
}).length;
}, t.prototype.getQueueStats = function(e) {
var t = this.getQueue(e);
return {
total: t.requests.length,
emergency: t.requests.filter(function(e) {
return e.priority >= bi.EMERGENCY;
}).length,
high: t.requests.filter(function(e) {
return e.priority >= bi.HIGH && e.priority < bi.EMERGENCY;
}).length,
normal: t.requests.filter(function(e) {
return e.priority >= bi.NORMAL && e.priority < bi.HIGH;
}).length,
low: t.requests.filter(function(e) {
return e.priority < bi.NORMAL;
}).length,
inProgress: t.inProgress.size
};
}, t;
}(), xi = new wi;

function Ui(e) {
return {
name: e,
role: "core",
health: {
cpuCategory: "low",
cpuUsage: 0,
bucketLevel: 1e4,
economyIndex: 50,
warIndex: 0,
commodityIndex: 0,
roomCount: 0,
avgRCL: 0,
creepCount: 0,
lastUpdate: 0
},
activeTasks: [],
portals: [],
cpuHistory: [],
cpuLimit: 0
};
}

function Mi(e) {
for (var t = 0, r = 0; r < e.length; r++) t = (t << 5) - t + e.charCodeAt(r), t &= t;
return Math.abs(t);
}

function Ai(e) {
var t, r = {
v: e.version,
s: Object.entries(e.shards).map(function(e) {
var t, r = o(e, 2), n = r[0], a = r[1];
return {
n: n,
r: a.role[0],
h: {
c: a.health.cpuCategory[0],
cu: Math.round(100 * a.health.cpuUsage) / 100,
b: a.health.bucketLevel,
e: Math.round(a.health.economyIndex),
w: Math.round(a.health.warIndex),
m: Math.round(a.health.commodityIndex),
rc: a.health.roomCount,
rl: Math.round(10 * a.health.avgRCL) / 10,
cc: a.health.creepCount,
u: a.health.lastUpdate
},
t: a.activeTasks,
p: a.portals.map(function(e) {
var t;
return {
sr: e.sourceRoom,
sp: "".concat(e.sourcePos.x, ",").concat(e.sourcePos.y),
ts: e.targetShard,
tr: e.targetRoom,
th: e.threatRating,
s: e.isStable ? 1 : 0,
tc: null !== (t = e.traversalCount) && void 0 !== t ? t : 0
};
}),
cl: a.cpuLimit,
ch: (null !== (t = a.cpuHistory) && void 0 !== t ? t : []).slice(-5).map(function(e) {
return {
t: e.tick,
l: e.cpuLimit,
u: Math.round(100 * e.cpuUsed) / 100,
b: e.bucketLevel
};
})
};
}),
g: {
pl: e.globalTargets.targetPowerLevel,
ws: e.globalTargets.mainWarShard,
es: e.globalTargets.primaryEcoShard,
ct: e.globalTargets.colonizationTarget,
en: (null !== (t = e.globalTargets.enemies) && void 0 !== t ? t : []).map(function(e) {
return {
u: e.username,
r: e.rooms,
t: e.threatLevel,
s: e.lastSeen,
a: e.isAlly ? 1 : 0
};
})
},
k: e.tasks.map(function(e) {
return {
i: e.id,
y: e.type[0],
ss: e.sourceShard,
ts: e.targetShard,
tr: e.targetRoom,
rt: e.resourceType,
ra: e.resourceAmount,
p: e.priority,
st: e.status[0],
pr: e.progress
};
}),
ls: e.lastSync
}, n = Mi(JSON.stringify(r));
return JSON.stringify({
d: r,
c: n
});
}

function ki(e) {
var t, n, a, i, s, c, l;
try {
var u = JSON.parse(e), f = Mi(JSON.stringify(u.d));
if (u.c !== f) return Hr.warn("InterShardMemory checksum mismatch", {
subsystem: "InterShard",
meta: {
expected: f,
actual: u.c
}
}), null;
var m = u.d, p = {
c: "core",
f: "frontier",
r: "resource",
b: "backup",
w: "war"
}, d = {
l: "low",
m: "medium",
h: "high",
c: "critical"
}, y = {
c: "colonize",
r: "reinforce",
t: "transfer",
e: "evacuate"
}, g = {
p: "pending",
a: "active",
c: "complete",
f: "failed"
}, h = {}, v = m.s;
try {
for (var R = r(v), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
h[T.n] = {
name: T.n,
role: null !== (a = p[T.r]) && void 0 !== a ? a : "core",
health: {
cpuCategory: null !== (i = d[T.h.c]) && void 0 !== i ? i : "low",
cpuUsage: null !== (s = T.h.cu) && void 0 !== s ? s : 0,
bucketLevel: null !== (c = T.h.b) && void 0 !== c ? c : 1e4,
economyIndex: T.h.e,
warIndex: T.h.w,
commodityIndex: T.h.m,
roomCount: T.h.rc,
avgRCL: T.h.rl,
creepCount: T.h.cc,
lastUpdate: T.h.u
},
activeTasks: T.t,
portals: T.p.map(function(e) {
var t, r = o(e.sp.split(","), 2), n = r[0], a = r[1];
return {
sourceRoom: e.sr,
sourcePos: {
x: parseInt(null != n ? n : "0", 10),
y: parseInt(null != a ? a : "0", 10)
},
targetShard: e.ts,
targetRoom: e.tr,
threatRating: e.th,
lastScouted: 0,
isStable: 1 === e.s,
traversalCount: null !== (t = e.tc) && void 0 !== t ? t : 0
};
}),
cpuLimit: T.cl,
cpuHistory: (null !== (l = T.ch) && void 0 !== l ? l : []).map(function(e) {
return {
tick: e.t,
cpuLimit: e.l,
cpuUsed: e.u,
bucketLevel: e.b
};
})
};
}
} catch (e) {
t = {
error: e
};
} finally {
try {
E && !E.done && (n = R.return) && n.call(R);
} finally {
if (t) throw t.error;
}
}
var S = m.g, C = m.k, b = {
targetPowerLevel: S.pl
};
return S.ws && (b.mainWarShard = S.ws), S.es && (b.primaryEcoShard = S.es), S.ct && (b.colonizationTarget = S.ct), 
S.en && (b.enemies = S.en.map(function(e) {
return {
username: e.u,
rooms: e.r,
threatLevel: e.t,
lastSeen: e.s,
isAlly: 1 === e.a
};
})), {
version: m.v,
shards: h,
globalTargets: b,
tasks: C.map(function(e) {
var t, r, o = {
id: e.i,
type: null !== (t = y[e.y]) && void 0 !== t ? t : "colonize",
sourceShard: e.ss,
targetShard: e.ts,
priority: e.p,
status: null !== (r = g[e.st]) && void 0 !== r ? r : "pending",
createdAt: 0
};
return e.tr && (o.targetRoom = e.tr), e.rt && (o.resourceType = e.rt), void 0 !== e.ra && (o.resourceAmount = e.ra), 
void 0 !== e.pr && (o.progress = e.pr), o;
}),
lastSync: m.ls,
checksum: u.c
};
} catch (e) {
return Hr.error("Failed to deserialize InterShardMemory: ".concat(String(e)), {
subsystem: "InterShard"
}), null;
}
}

var Ni = 102400, Pi = [], Ii = new Set;

function Gi(e) {
return function(t, r, o) {
Pi.push({
options: e,
methodName: String(r),
target: t
});
};
}

function Li(t, r, o) {
return Gi(e({
id: t,
name: r,
priority: Ao.MEDIUM,
frequency: "medium",
minBucket: 0,
cpuBudget: .15,
interval: 5
}, o));
}

function Di(t, r, o) {
return Gi(e({
id: t,
name: r,
priority: Ao.LOW,
frequency: "low",
minBucket: 0,
cpuBudget: .1,
interval: 20
}, o));
}

function Fi(t, r, o) {
return Gi(e({
id: t,
name: r,
priority: Ao.IDLE,
frequency: "low",
minBucket: 0,
cpuBudget: .05,
interval: 100
}, o));
}

function Bi() {
return function(e) {
return Ii.add(e), e;
};
}

function ji(e) {
var t, o, n, a, i = Object.getPrototypeOf(e);
try {
for (var s = r(Pi), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
if (l.target === i || Object.getPrototypeOf(l.target) === i || l.target === Object.getPrototypeOf(i)) {
var u = e[l.methodName];
if ("function" == typeof u) {
var f = u.bind(e);
Ko.registerProcess({
id: l.options.id,
name: l.options.name,
priority: null !== (n = l.options.priority) && void 0 !== n ? n : Ao.MEDIUM,
frequency: null !== (a = l.options.frequency) && void 0 !== a ? a : "medium",
minBucket: l.options.minBucket,
cpuBudget: l.options.cpuBudget,
interval: l.options.interval,
execute: f
}), Hr.debug('Registered decorated process "'.concat(l.options.name, '" (').concat(l.options.id, ")"), {
subsystem: "ProcessDecorators"
});
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
}

function Hi() {
for (var e, t, o = [], n = 0; n < arguments.length; n++) o[n] = arguments[n];
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) ji(i.value);
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
Hr.info("Registered decorated processes from ".concat(o.length, " instance(s)"), {
subsystem: "ProcessDecorators"
});
}

var Wi, Yi = Object.freeze({
__proto__: null,
CriticalProcess: function(t, r, o) {
return Gi(e({
id: t,
name: r,
priority: Ao.CRITICAL,
frequency: "high",
minBucket: 0,
cpuBudget: .3,
interval: 1
}, o));
},
HighFrequencyProcess: function(t, r, o) {
return Gi(e({
id: t,
name: r,
priority: Ao.HIGH,
frequency: "high",
minBucket: 0,
cpuBudget: .3,
interval: 1
}, o));
},
IdleProcess: Fi,
LowFrequencyProcess: Di,
MediumFrequencyProcess: Li,
Process: Gi,
ProcessClass: Bi,
clearProcessMetadata: function() {
Pi.length = 0;
},
getProcessMetadata: function() {
return n([], o(Pi), !1);
},
getRegisteredClasses: function() {
return new Set(Ii);
},
registerAllDecoratedProcesses: Hi,
registerDecoratedProcesses: ji
}), Ki = {
updateInterval: 100,
minBucket: 0,
maxCpuBudget: .02,
defaultCpuLimit: 20
}, Vi = {
core: 1.5,
frontier: .8,
resource: 1,
backup: .5,
war: 1.2
}, zi = function() {
function n(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.config = e(e({}, Ki), t), this.interShardMemory = {
version: 1,
shards: {},
globalTargets: {
targetPowerLevel: 0
},
tasks: [],
lastSync: 0,
checksum: 0
};
}
return n.prototype.initialize = function() {
var e, t;
try {
var r = InterShardMemory.getLocal();
if (r) {
var o = ki(r);
o && (this.interShardMemory = o, Hr.debug("Loaded InterShardMemory", {
subsystem: "Shard"
}));
}
} catch (e) {
var n = e instanceof Error ? e.message : String(e);
Hr.error("Failed to load InterShardMemory: ".concat(n), {
subsystem: "Shard"
});
}
var a = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0";
this.interShardMemory.shards[a] || (this.interShardMemory.shards[a] = Ui(a));
}, n.prototype.run = function() {
this.lastRun = Game.time, this.updateCurrentShardHealth(), this.processInterShardTasks(), 
this.scanForPortals(), this.autoAssignShardRole(), Object.keys(this.interShardMemory.shards).length > 1 && this.distributeCpuLimits(), 
this.syncInterShardMemory(), Game.time % 500 == 0 && this.logShardStatus();
}, n.prototype.calculateCommodityIndex = function(e) {
var t, o, n, a, i, s = 0, c = 0;
try {
for (var l = r(e), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = f.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_FACTORY;
}
})[0];
if (m) {
c++, s += 5 * (null !== (i = m.level) && void 0 !== i ? i : 0), m.store.getUsedCapacity() > 0 && (s += 10);
var p = f.storage;
if (p) {
var d = [ RESOURCE_COMPOSITE, RESOURCE_CRYSTAL, RESOURCE_LIQUID, RESOURCE_GHODIUM_MELT, RESOURCE_OXIDANT, RESOURCE_REDUCTANT, RESOURCE_PURIFIER ];
try {
for (var y = (n = void 0, r(d)), g = y.next(); !g.done; g = y.next()) {
var h = g.value, v = p.store.getUsedCapacity(h);
v > 0 && (s += Math.min(10, v / 1e3));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
g && !g.done && (a = y.return) && a.call(y);
} finally {
if (n) throw n.error;
}
}
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
if (0 === c) return 0;
var R = 105 * c;
return s = Math.min(100, s / R * 100), Math.round(s);
}, n.prototype.updateCurrentShardHealth = function() {
var e, t, o, n, a, i, s, c = null !== (i = null === (a = Game.shard) || void 0 === a ? void 0 : a.name) && void 0 !== i ? i : "shard0", l = this.interShardMemory.shards[c];
if (l) {
var u = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), f = Game.cpu.getUsed() / Game.cpu.limit, m = f < .5 ? "low" : f < .75 ? "medium" : f < .9 ? "high" : "critical", p = u.length > 0 ? u.reduce(function(e, t) {
var r, o;
return e + (null !== (o = null === (r = t.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0);
}, 0) / u.length : 0, d = 0;
try {
for (var y = r(u), g = y.next(); !g.done; g = y.next()) {
var h = g.value.storage;
if (h) {
var v = h.store.getUsedCapacity(RESOURCE_ENERGY);
d += Math.min(100, v / 5e3);
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
g && !g.done && (t = y.return) && t.call(y);
} finally {
if (e) throw e.error;
}
}
d = u.length > 0 ? d / u.length : 0;
var R = 0;
try {
for (var E = r(u), T = E.next(); !T.done; T = E.next()) {
var S = T.value.find(FIND_HOSTILE_CREEPS).length;
R += Math.min(100, 10 * S);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
T && !T.done && (n = E.return) && n.call(E);
} finally {
if (o) throw o.error;
}
}
R = u.length > 0 ? R / u.length : 0, l.health = {
cpuCategory: m,
cpuUsage: Math.round(100 * f) / 100,
bucketLevel: Game.cpu.bucket,
economyIndex: Math.round(d),
warIndex: Math.round(R),
commodityIndex: this.calculateCommodityIndex(u),
roomCount: u.length,
avgRCL: Math.round(10 * p) / 10,
creepCount: Object.keys(Game.creeps).length,
lastUpdate: Game.time
};
var C = null !== (s = l.cpuHistory) && void 0 !== s ? s : [];
C.push({
tick: Game.time,
cpuLimit: Game.cpu.limit,
cpuUsed: Game.cpu.getUsed(),
bucketLevel: Game.cpu.bucket
}), l.cpuHistory = C.slice(-10), Game.cpu.shardLimits && (l.cpuLimit = Game.cpu.shardLimits[c]);
}
}, n.prototype.processInterShardTasks = function() {
var e, t, o, n, a = null !== (n = null === (o = Game.shard) || void 0 === o ? void 0 : o.name) && void 0 !== n ? n : "shard0", i = this.interShardMemory.tasks.filter(function(e) {
return e.targetShard === a && "pending" === e.status;
});
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
switch (l.type) {
case "colonize":
this.handleColonizeTask(l);
break;

case "reinforce":
this.handleReinforceTask(l);
break;

case "transfer":
this.handleTransferTask(l);
break;

case "evacuate":
this.handleEvacuateTask(l);
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
this.interShardMemory.tasks = this.interShardMemory.tasks.filter(function(e) {
return "pending" === e.status || "active" === e.status || Game.time - e.createdAt < 5e3;
});
}, n.prototype.handleColonizeTask = function(e) {
var t;
e.status = "active";
var r = null !== (t = e.targetRoom) && void 0 !== t ? t : "unknown";
Hr.info("Processing colonize task: ".concat(r, " from ").concat(e.sourceShard), {
subsystem: "Shard"
});
}, n.prototype.handleReinforceTask = function(e) {
var t;
e.status = "active";
var r = null !== (t = e.targetRoom) && void 0 !== t ? t : "unknown";
Hr.info("Processing reinforce task: ".concat(r, " from ").concat(e.sourceShard), {
subsystem: "Shard"
});
}, n.prototype.handleTransferTask = function(e) {
e.status = "active", Hr.info("Processing transfer task from ".concat(e.sourceShard), {
subsystem: "Shard"
});
}, n.prototype.handleEvacuateTask = function(e) {
var t;
e.status = "active";
var r = null !== (t = e.targetRoom) && void 0 !== t ? t : "unknown";
Hr.info("Processing evacuate task: ".concat(r, " to ").concat(e.targetShard), {
subsystem: "Shard"
});
}, n.prototype.scanForPortals = function() {
var e, t, o = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0", n = this.interShardMemory.shards[o];
if (n) {
var a = function(e) {
var t, o, a = Game.rooms[e].find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_PORTAL;
}
}), i = function(t) {
var r = t.destination;
if (!r) return "continue";
if ("shard" in r) {
var o = r.shard, a = r.room, i = n.portals.find(function(t) {
return t.sourceRoom === e && t.targetShard === o;
});
if (i) i.lastScouted = Game.time, i.isStable = void 0 === t.ticksToDecay, void 0 !== t.ticksToDecay && (i.decayTick = Game.time + t.ticksToDecay); else {
var s = {
sourceRoom: e,
sourcePos: {
x: t.pos.x,
y: t.pos.y
},
targetShard: o,
targetRoom: a,
threatRating: 0,
lastScouted: Game.time,
isStable: void 0 === t.ticksToDecay,
traversalCount: 0
};
void 0 !== t.ticksToDecay && (s.decayTick = Game.time + t.ticksToDecay), n.portals.push(s), 
Hr.info("Discovered portal in ".concat(e, " to ").concat(o, "/").concat(a), {
subsystem: "Shard"
});
}
}
};
try {
for (var s = (t = void 0, r(a)), c = s.next(); !c.done; c = s.next()) i(c.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
};
for (var i in Game.rooms) a(i);
n.portals = n.portals.filter(function(e) {
return !e.decayTick || e.decayTick > Game.time;
});
}
}, n.prototype.autoAssignShardRole = function() {
var e, t, r = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0", o = this.interShardMemory.shards[r];
if (o) {
var n = o.health, a = Object.values(this.interShardMemory.shards), i = o.role;
n.warIndex > 50 ? i = "war" : n.roomCount < 3 && n.avgRCL < 4 ? i = "frontier" : n.economyIndex > 70 && n.roomCount >= 3 && n.avgRCL >= 6 ? i = "resource" : a.length > 1 && n.roomCount < 2 && n.avgRCL < 3 ? i = "backup" : n.roomCount >= 2 && n.avgRCL >= 4 && (i = "core"), 
"frontier" === o.role && n.roomCount >= 3 && n.avgRCL >= 5 && (i = "core", Hr.info("Transitioning from frontier to core shard", {
subsystem: "Shard"
})), "war" === o.role && n.warIndex < 20 && (i = n.economyIndex > 70 && n.roomCount >= 3 ? "resource" : n.roomCount >= 2 ? "core" : "frontier", 
Hr.info("War ended, transitioning to ".concat(i), {
subsystem: "Shard"
})), i !== o.role && (o.role = i, Hr.info("Auto-assigned shard role: ".concat(i), {
subsystem: "Shard"
}));
}
}, n.prototype.calculateCpuEfficiency = function(e) {
var t, o;
if (!e.cpuHistory || 0 === e.cpuHistory.length) return 1;
var n = 0;
try {
for (var a = r(e.cpuHistory), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
s.cpuLimit > 0 && (n += s.cpuUsed / s.cpuLimit);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
return n / e.cpuHistory.length;
}, n.prototype.calculateShardWeight = function(e, t, r) {
var o = Vi[e.role], n = t === r ? Game.cpu.bucket : e.health.bucketLevel;
n < 2e3 ? o *= .8 : n < 5e3 ? o *= .9 : n > 9e3 && (o *= 1.1);
var a = this.calculateCpuEfficiency(e);
return a > .95 ? o *= 1.15 : a < .6 && (o *= .85), "war" === e.role && e.health.warIndex > 50 && (o *= 1.2), 
o;
}, n.prototype.distributeCpuLimits = function() {
var e, t, o, n, a, i;
try {
var s = this.interShardMemory.shards, c = Object.keys(s), l = Game.cpu.shardLimits ? Object.values(Game.cpu.shardLimits).reduce(function(e, t) {
return e + t;
}, 0) : this.config.defaultCpuLimit * c.length, u = null !== (i = null === (a = Game.shard) || void 0 === a ? void 0 : a.name) && void 0 !== i ? i : "shard0", f = {}, m = 0;
try {
for (var p = r(c), d = p.next(); !d.done; d = p.next()) {
var y = s[E = d.value];
if (y) {
var g = this.calculateShardWeight(y, E, u);
f[E] = g, m += g;
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
d && !d.done && (t = p.return) && t.call(p);
} finally {
if (e) throw e.error;
}
}
var h = {};
try {
for (var v = r(c), R = v.next(); !R.done; R = v.next()) {
var E;
f[E = R.value] && (h[E] = Math.max(5, Math.round(f[E] / m * l)));
}
} catch (e) {
o = {
error: e
};
} finally {
try {
R && !R.done && (n = v.return) && n.call(v);
} finally {
if (o) throw o.error;
}
}
if (Game.cpu.shardLimits) {
var T = Game.cpu.shardLimits, S = c.some(function(e) {
var t, r;
return Math.abs((null !== (t = T[e]) && void 0 !== t ? t : 0) - (null !== (r = h[e]) && void 0 !== r ? r : 0)) > 1;
});
S && Game.cpu.setShardLimits(h) === OK && Hr.info("Updated shard CPU limits: ".concat(JSON.stringify(h)), {
subsystem: "Shard"
});
}
} catch (e) {
var C = e instanceof Error ? e.message : String(e);
Hr.debug("Could not set shard limits: ".concat(C), {
subsystem: "Shard"
});
}
}, n.prototype.syncInterShardMemory = function() {
try {
this.interShardMemory.lastSync = Game.time;
var e = this.validateInterShardMemory();
e.valid || (Hr.warn("InterShardMemory validation failed: ".concat(e.errors.join(", ")), {
subsystem: "Shard"
}), this.repairInterShardMemory());
var t = Ai(this.interShardMemory);
if (t.length > Ni) {
Hr.warn("InterShardMemory size exceeds limit: ".concat(t.length, "/").concat(Ni), {
subsystem: "Shard"
}), this.trimInterShardMemory();
var r = Ai(this.interShardMemory);
return r.length > Ni ? (Hr.error("InterShardMemory still too large after trim: ".concat(r.length, "/").concat(Ni), {
subsystem: "Shard"
}), void this.emergencyTrim()) : void InterShardMemory.setLocal(r);
}
InterShardMemory.setLocal(t), Game.time % 50 == 0 && this.verifySyncIntegrity();
} catch (e) {
var o = e instanceof Error ? e.message : String(e);
Hr.error("Failed to sync InterShardMemory: ".concat(o), {
subsystem: "Shard"
}), this.attemptSyncRecovery();
}
}, n.prototype.validateInterShardMemory = function() {
var e, t, n = [];
if ("number" != typeof this.interShardMemory.version && n.push("Invalid version"), 
"object" != typeof this.interShardMemory.shards) n.push("Invalid shards object"); else try {
for (var a = r(Object.entries(this.interShardMemory.shards)), i = a.next(); !i.done; i = a.next()) {
var s = o(i.value, 2), c = s[0], l = s[1];
l.health && "number" == typeof l.health.lastUpdate || n.push("Shard ".concat(c, " has invalid health data")), 
Array.isArray(l.portals) || n.push("Shard ".concat(c, " has invalid portals array")), 
Array.isArray(l.activeTasks) || n.push("Shard ".concat(c, " has invalid activeTasks array"));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return Array.isArray(this.interShardMemory.tasks) || n.push("Invalid tasks array"), 
"number" != typeof this.interShardMemory.lastSync && n.push("Invalid lastSync"), 
{
valid: 0 === n.length,
errors: n
};
}, n.prototype.repairInterShardMemory = function() {
var e, t;
"number" != typeof this.interShardMemory.version && (this.interShardMemory.version = 1), 
"object" != typeof this.interShardMemory.shards && (this.interShardMemory.shards = {});
try {
for (var n = r(Object.entries(this.interShardMemory.shards)), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2), s = i[0], c = i[1];
c.health && "number" == typeof c.health.lastUpdate || (this.interShardMemory.shards[s] = Ui(s)), 
Array.isArray(c.portals) || (c.portals = []), Array.isArray(c.activeTasks) || (c.activeTasks = []);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
Array.isArray(this.interShardMemory.tasks) || (this.interShardMemory.tasks = []), 
this.interShardMemory.globalTargets || (this.interShardMemory.globalTargets = {
targetPowerLevel: 0
}), "number" != typeof this.interShardMemory.lastSync && (this.interShardMemory.lastSync = Game.time), 
Hr.info("Repaired InterShardMemory structure", {
subsystem: "Shard"
});
}, n.prototype.verifySyncIntegrity = function() {
var e, t;
try {
var r = InterShardMemory.getLocal();
if (!r) return void Hr.warn("InterShardMemory verification failed: no data present", {
subsystem: "Shard"
});
var o = ki(r);
if (!o) return void Hr.warn("InterShardMemory verification failed: deserialization failed", {
subsystem: "Shard"
});
var n = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0";
o.shards[n] || Hr.warn("InterShardMemory verification failed: current shard ".concat(n, " not found"), {
subsystem: "Shard"
});
} catch (e) {
var a = e instanceof Error ? e.message : String(e);
Hr.warn("InterShardMemory verification failed: ".concat(a), {
subsystem: "Shard"
});
}
}, n.prototype.attemptSyncRecovery = function() {
var e, t;
try {
Hr.info("Attempting InterShardMemory recovery", {
subsystem: "Shard"
});
var r = InterShardMemory.getLocal();
if (r) {
var o = ki(r);
if (o) return this.interShardMemory = o, void Hr.info("Recovered InterShardMemory from storage", {
subsystem: "Shard"
});
}
var n = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0";
this.interShardMemory = {
version: 1,
shards: {},
globalTargets: {
targetPowerLevel: 0
},
tasks: [],
lastSync: 0,
checksum: 0
}, this.interShardMemory.shards[n] = Ui(n), Hr.info("Recreated InterShardMemory with current shard only", {
subsystem: "Shard"
});
} catch (e) {
var a = e instanceof Error ? e.message : String(e);
Hr.error("InterShardMemory recovery failed: ".concat(a), {
subsystem: "Shard"
});
}
}, n.prototype.emergencyTrim = function() {
var e, t, r, o = null !== (r = null === (t = Game.shard) || void 0 === t ? void 0 : t.name) && void 0 !== r ? r : "shard0", n = this.interShardMemory.shards[o];
n && (this.interShardMemory.shards = ((e = {})[o] = n, e), this.interShardMemory.tasks = this.interShardMemory.tasks.filter(function(e) {
return e.sourceShard === o || e.targetShard === o;
}), n.portals = n.portals.sort(function(e, t) {
return t.lastScouted - e.lastScouted;
}).slice(0, 10), Hr.warn("Emergency trim applied to InterShardMemory", {
subsystem: "Shard"
}));
}, n.prototype.trimInterShardMemory = function() {
for (var e in this.interShardMemory.tasks = this.interShardMemory.tasks.filter(function(e) {
return "pending" === e.status || "active" === e.status || Game.time - e.createdAt < 1e3;
}), this.interShardMemory.shards) {
var t = this.interShardMemory.shards[e];
t && (t.portals = t.portals.filter(function(e) {
return Game.time - e.lastScouted < 1e4;
}));
}
}, n.prototype.logShardStatus = function() {
var e, t, r = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0", o = this.interShardMemory.shards[r];
if (o) {
var n = o.health;
Hr.info("Shard ".concat(r, " (").concat(o.role, "): ") + "".concat(n.roomCount, " rooms, RCL ").concat(n.avgRCL, ", ") + "CPU: ".concat(n.cpuCategory, ", Eco: ").concat(n.economyIndex, "%, War: ").concat(n.warIndex, "%"), {
subsystem: "Shard"
});
}
}, n.prototype.createTask = function(e, t, r, o) {
var n, a;
void 0 === o && (o = 50);
var i = null !== (a = null === (n = Game.shard) || void 0 === n ? void 0 : n.name) && void 0 !== a ? a : "shard0", s = {
id: "".concat(Game.time, "-").concat(Math.random().toString(36).substring(2, 11)),
type: e,
sourceShard: i,
targetShard: t,
priority: o,
status: "pending",
createdAt: Game.time
};
r && (s.targetRoom = r), this.interShardMemory.tasks.push(s), Hr.info("Created inter-shard task: ".concat(e, " to ").concat(t), {
subsystem: "Shard"
});
}, n.prototype.getCurrentShardState = function() {
var e, t, r = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0";
return this.interShardMemory.shards[r];
}, n.prototype.getAllShards = function() {
return Object.values(this.interShardMemory.shards);
}, n.prototype.getPortalsToShard = function(e) {
var t, r, o = null !== (r = null === (t = Game.shard) || void 0 === t ? void 0 : t.name) && void 0 !== r ? r : "shard0", n = this.interShardMemory.shards[o];
return n ? n.portals.filter(function(t) {
return t.targetShard === e;
}) : [];
}, n.prototype.setShardRole = function(e) {
var t, r, o = null !== (r = null === (t = Game.shard) || void 0 === t ? void 0 : t.name) && void 0 !== r ? r : "shard0", n = this.interShardMemory.shards[o];
n && (n.role = e, Hr.info("Set shard role to: ".concat(e), {
subsystem: "Shard"
}));
}, n.prototype.createResourceTransferTask = function(e, t, r, o, n) {
var a, i;
void 0 === n && (n = 50);
var s = null !== (i = null === (a = Game.shard) || void 0 === a ? void 0 : a.name) && void 0 !== i ? i : "shard0", c = {
id: "".concat(Game.time, "-transfer-").concat(Math.random().toString(36).substring(2, 11)),
type: "transfer",
sourceShard: s,
targetShard: e,
targetRoom: t,
resourceType: r,
resourceAmount: o,
priority: n,
status: "pending",
createdAt: Game.time,
progress: 0
};
this.interShardMemory.tasks.push(c), Hr.info("Created resource transfer task: ".concat(o, " ").concat(r, " to ").concat(e, "/").concat(t), {
subsystem: "Shard"
});
}, n.prototype.getOptimalPortalRoute = function(e, t) {
var r, o, n, a, i = null !== (o = null === (r = Game.shard) || void 0 === r ? void 0 : r.name) && void 0 !== o ? o : "shard0", s = this.interShardMemory.shards[i];
if (!s) return null;
var c = s.portals.filter(function(t) {
return t.targetShard === e;
});
if (0 === c.length) return null;
var l = c.map(function(e) {
var r, o = 100;
e.isStable && (o += 50), o -= 15 * e.threatRating, o += Math.min(2 * (null !== (r = e.traversalCount) && void 0 !== r ? r : 0), 20), 
t && (o -= 2 * Game.map.getRoomLinearDistance(t, e.sourceRoom));
var n = Game.time - e.lastScouted;
return n < 1e3 ? o += 10 : n > 5e3 && (o -= 10), {
portal: e,
score: o
};
});
return l.sort(function(e, t) {
return t.score - e.score;
}), null !== (a = null === (n = l[0]) || void 0 === n ? void 0 : n.portal) && void 0 !== a ? a : null;
}, n.prototype.recordPortalTraversal = function(e, t, r) {
var o, n, a, i = null !== (n = null === (o = Game.shard) || void 0 === o ? void 0 : o.name) && void 0 !== n ? n : "shard0", s = this.interShardMemory.shards[i];
if (s) {
var c = s.portals.find(function(r) {
return r.sourceRoom === e && r.targetShard === t;
});
c && (r ? (c.traversalCount = (null !== (a = c.traversalCount) && void 0 !== a ? a : 0) + 1, 
c.threatRating = Math.max(0, c.threatRating - .1)) : c.threatRating = Math.min(3, c.threatRating + .5));
}
}, n.prototype.updateTaskProgress = function(e, t, r) {
var o = this.interShardMemory.tasks.find(function(t) {
return t.id === e;
});
o && (o.progress = Math.min(100, Math.max(0, t)), o.updatedAt = Game.time, r && (o.status = r));
}, n.prototype.getActiveTransferTasks = function() {
var e, t, r = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0";
return this.interShardMemory.tasks.filter(function(e) {
return !("transfer" !== e.type || e.sourceShard !== r && e.targetShard !== r || "pending" !== e.status && "active" !== e.status);
});
}, n.prototype.cancelTask = function(e) {
var t = this.interShardMemory.tasks.find(function(t) {
return t.id === e;
});
t && (t.status = "failed", t.updatedAt = Game.time, Hr.info("Cancelled task ".concat(e), {
subsystem: "Shard"
}));
}, n.prototype.getSyncStatus = function() {
var e, t, o = Ai(this.interShardMemory).length, n = o / Ni * 100, a = Game.time - this.interShardMemory.lastSync, i = o < 92160 && a < 500, s = 0;
try {
for (var c = r(Object.values(this.interShardMemory.shards)), l = c.next(); !l.done; l = c.next()) s += l.value.portals.length;
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return {
lastSync: this.interShardMemory.lastSync,
ticksSinceSync: a,
memorySize: o,
sizePercent: Math.round(100 * n) / 100,
shardsTracked: Object.keys(this.interShardMemory.shards).length,
activeTasks: this.interShardMemory.tasks.filter(function(e) {
return "pending" === e.status || "active" === e.status;
}).length,
totalPortals: s,
isHealthy: i
};
}, n.prototype.forceSync = function() {
Hr.info("Forcing InterShardMemory sync with validation", {
subsystem: "Shard"
}), this.syncInterShardMemory();
}, n.prototype.getMemoryStats = function() {
var t, o, n = Ai(this.interShardMemory).length, a = Ai(e(e({}, this.interShardMemory), {
tasks: [],
globalTargets: {
targetPowerLevel: 0
}
})).length, i = JSON.stringify(this.interShardMemory.tasks).length, s = 0;
try {
for (var c = r(Object.values(this.interShardMemory.shards)), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
s += JSON.stringify(u.portals).length;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
return {
size: n,
limit: Ni,
percent: Math.round(n / Ni * 1e4) / 100,
breakdown: {
shards: a,
tasks: i,
portals: s,
other: n - a - i
}
};
}, t([ Di("empire:shard", "Shard Manager", {
priority: Ao.LOW,
interval: 100,
minBucket: 0,
cpuBudget: .02
}) ], n.prototype, "run", null), t([ Bi() ], n);
}(), qi = new zi, Xi = function() {
function e() {
Memory.crossShardTransfers || (Memory.crossShardTransfers = {
requests: {},
lastUpdate: Game.time
}), this.memory = Memory.crossShardTransfers;
}
return e.prototype.run = function() {
var e, t, o, n;
this.cleanupOldRequests();
var a = qi.getActiveTransferTasks();
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if ("transfer" === c.type && c.resourceType && c.resourceAmount && !this.memory.requests[c.id]) {
var l = null !== (n = null === (o = Game.shard) || void 0 === o ? void 0 : o.name) && void 0 !== n ? n : "shard0";
c.sourceShard === l && this.createTransferRequest(c);
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
for (var u in this.memory.requests) {
var f = this.memory.requests[u];
f && this.processTransferRequest(f);
}
this.memory.lastUpdate = Game.time;
}, e.prototype.createTransferRequest = function(e) {
if (e.resourceType && e.resourceAmount && e.targetRoom) {
var t = qi.getOptimalPortalRoute(e.targetShard);
if (t) {
var r = this.findSourceRoom(e.resourceType, e.resourceAmount);
if (r) {
var o = {
taskId: e.id,
resourceType: e.resourceType,
amount: e.resourceAmount,
sourceRoom: r,
targetShard: e.targetShard,
targetRoom: e.targetRoom,
portalRoom: t.sourceRoom,
priority: e.priority,
status: "queued",
assignedCreeps: [],
transferred: 0
};
this.memory.requests[e.id] = o, Hr.info("Created transfer request: ".concat(e.resourceAmount, " ").concat(e.resourceType, " from ").concat(r, " to ").concat(e.targetShard, "/").concat(e.targetRoom), {
subsystem: "CrossShardTransfer"
});
} else Hr.warn("No room with sufficient ".concat(e.resourceType, " for transfer"), {
subsystem: "CrossShardTransfer"
});
} else Hr.warn("No portal found to ".concat(e.targetShard, ", cannot create transfer request"), {
subsystem: "CrossShardTransfer"
});
}
}, e.prototype.findSourceRoom = function(e, t) {
var o, n, a = Object.values(Game.rooms).filter(function(e) {
var t;
return (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.terminal && e.storage;
});
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = c.terminal, u = c.storage;
if (l && l.store.getUsedCapacity(e) >= t) return c.name;
if (u && u.store.getUsedCapacity(e) >= t) return c.name;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return null;
}, e.prototype.processTransferRequest = function(e) {
switch (e.status) {
case "queued":
this.handleQueuedRequest(e);
break;

case "gathering":
this.handleGatheringRequest(e);
break;

case "moving":
this.handleMovingRequest(e);
break;

case "transferring":
this.handleTransferringRequest(e);
}
var t = Math.round(e.transferred / e.amount * 100);
qi.updateTaskProgress(e.taskId, t);
}, e.prototype.handleQueuedRequest = function(e) {
var t, r = e.amount - e.transferred, o = e.assignedCreeps.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return void 0 !== e;
}).reduce(function(e, t) {
return e + t.carryCapacity;
}, 0);
if (o >= r) return e.status = "gathering", void Hr.info("Transfer request ".concat(e.taskId, " moving to gathering phase"), {
subsystem: "CrossShardTransfer"
});
var n = Game.rooms[e.sourceRoom];
if (n && (null === (t = n.controller) || void 0 === t ? void 0 : t.my)) {
var a, i = r - o, s = n.energyCapacityAvailable;
try {
a = function(e) {
switch (e.role) {
case "harvester":
case "staticMiner":
case "mineralHarvester":
case "remoteHarvester":
return function(e) {
var t = e.maxEnergy, r = Math.min(10, Math.floor(t / 100));
r = Math.max(2, r);
for (var o = Math.max(1, Math.ceil((r + 1) / 2)), n = 100 * r + 50 + 50 * o; n > t && r > 2; ) n = 100 * --r + 50 + 50 * (o = Math.max(1, Math.ceil((r + 1) / 2)));
if (n > t) for (;o > 1 && n > t; ) n = 100 * r + 50 + 50 * --o;
for (var a = [], i = 0; i < r; i++) a.push(WORK);
for (i = 0; i < 1; i++) a.push(CARRY);
for (i = 0; i < o; i++) a.push(MOVE);
var s = Oi(a);
return {
parts: a,
cost: s,
minCapacity: s
};
}(e);

case "hauler":
case "carrier":
case "queenCarrier":
case "remoteHauler":
case "interRoomCarrier":
case "crossShardCarrier":
return function(e) {
var t = e.maxEnergy, r = e.distance, o = void 0 === r ? 10 : r, n = e.hasRoads, a = void 0 !== n && n, i = e.energyPerTick, s = a ? 2 : 1, c = (void 0 === i ? 10 : i) * (2 * o), l = Math.ceil(c / 50), u = Math.ceil(l / s), f = 50 * l + 50 * u;
if (f > t) {
var m = t / f;
f = 50 * (l = Math.max(2, Math.floor(l * m))) + 50 * (u = Math.ceil(l / s));
}
l = Math.max(2, Math.min(25, l)), u = Math.max(1, Math.min(25, u));
for (var p = [], d = 0; d < l; d++) p.push(CARRY);
for (d = 0; d < u; d++) p.push(MOVE);
return {
parts: p,
cost: Oi(p),
minCapacity: Oi(p)
};
}(e);

case "upgrader":
return function(e) {
for (var t = e.maxEnergy, r = Math.floor(t / 450), o = Math.max(1, Math.min(15, 3 * r)), n = Math.max(1, Math.ceil(o / 3)), a = Math.max(1, Math.ceil((o + n) / 2)), i = [], s = 0; s < o; s++) i.push(WORK);
for (s = 0; s < n; s++) i.push(CARRY);
for (s = 0; s < a; s++) i.push(MOVE);
return {
parts: i,
cost: Oi(i),
minCapacity: Oi(i)
};
}(e);

case "builder":
case "engineer":
case "remoteWorker":
default:
return function(e) {
for (var t = e.maxEnergy, r = Math.floor(t / 200), o = Math.max(1, Math.min(16, r)), n = o, a = o, i = [], s = 0; s < o; s++) i.push(WORK);
for (s = 0; s < n; s++) i.push(CARRY);
for (s = 0; s < a; s++) i.push(MOVE);
return {
parts: i,
cost: Oi(i),
minCapacity: Oi(i)
};
}(e);

case "guard":
case "soldier":
return function(e) {
var t, r, o, n = e.maxEnergy, a = e.willBoost;
if (void 0 !== a && a) {
var i = 580, s = Math.max(1, Math.floor(n / i));
t = Math.min(10, s), r = Math.min(20, 4 * s), o = Math.min(30, 5 * s);
} else i = 580, s = Math.max(1, Math.floor(n / i)), t = Math.max(1, s), r = Math.max(1, 4 * s), 
o = Math.max(1, 5 * s);
for (var c = [], l = 0; l < t; l++) c.push(TOUGH);
for (l = 0; l < r; l++) c.push(ATTACK);
for (l = 0; l < o; l++) c.push(MOVE);
return {
parts: c,
cost: Oi(c),
minCapacity: Oi(c)
};
}(e);

case "ranger":
return function(e) {
var t, r, o, n = e.maxEnergy, a = e.willBoost;
if (void 0 !== a && a) {
var i = 210, s = Math.floor(n / i);
t = Math.min(5, Math.floor(.1 * s)), r = Math.min(25, Math.floor(.6 * s)), o = Math.min(20, Math.ceil(.3 * s));
} else i = 210, s = Math.floor(n / i), t = Math.max(1, Math.min(5, Math.floor(.1 * s))), 
r = Math.max(1, Math.min(20, Math.floor(.5 * s))), o = Math.max(1, Math.min(20, Math.ceil(.4 * s)));
for (var c = [], l = 0; l < t; l++) c.push(TOUGH);
for (l = 0; l < r; l++) c.push(RANGED_ATTACK);
for (l = 0; l < o; l++) c.push(MOVE);
return {
parts: c,
cost: Oi(c),
minCapacity: Oi(c)
};
}(e);

case "healer":
return function(e) {
for (var t = e.maxEnergy, r = Math.floor(t / 300), o = Math.max(1, Math.min(25, r)), n = o, a = [], i = 0; i < o; i++) a.push(HEAL);
for (i = 0; i < n; i++) a.push(MOVE);
return {
parts: a,
cost: Oi(a),
minCapacity: Oi(a)
};
}(e);
}
}({
maxEnergy: s,
role: "crossShardCarrier"
});
} catch (e) {
return void Hr.error("Failed to optimize body for crossShardCarrier: ".concat(String(e)), {
subsystem: "CrossShardTransfer"
});
}
var c = 50 * a.parts.filter(function(e) {
return e === CARRY;
}).length, l = Math.ceil(i / c), u = Math.min(l, 3), f = bi.NORMAL;
f = e.priority >= 80 ? bi.HIGH : e.priority >= 50 ? bi.NORMAL : bi.LOW;
for (var m = 0; m < u; m++) {
var p = {
transferRequestId: e.taskId,
portalRoom: e.portalRoom,
targetShard: e.targetShard,
workflowState: "gathering"
}, d = {
id: "crossShardCarrier_".concat(e.taskId, "_").concat(m, "_").concat(Game.time),
roomName: e.sourceRoom,
role: "crossShardCarrier",
family: "economy",
body: a,
priority: f,
createdAt: Game.time,
targetRoom: e.targetRoom,
additionalMemory: p
};
xi.addRequest(d), Hr.info("Requested spawn of crossShardCarrier for transfer ".concat(e.taskId, " (").concat(m + 1, "/").concat(u, ")"), {
subsystem: "CrossShardTransfer"
});
}
Hr.debug("Transfer request ".concat(e.taskId, " needs ").concat(i, " carry capacity, requested ").concat(u, " carriers"), {
subsystem: "CrossShardTransfer"
});
} else Hr.warn("Source room ".concat(e.sourceRoom, " not available for spawning carriers"), {
subsystem: "CrossShardTransfer"
});
}, e.prototype.handleGatheringRequest = function(e) {
var t = e.assignedCreeps.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return void 0 !== e;
});
0 !== t.length ? t.every(function(t) {
return t.store.getUsedCapacity(e.resourceType) > 0;
}) && (e.status = "moving", Hr.info("Transfer request ".concat(e.taskId, " moving to portal"), {
subsystem: "CrossShardTransfer"
})) : e.status = "queued";
}, e.prototype.handleMovingRequest = function(e) {
var t = e.assignedCreeps.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return void 0 !== e;
});
if (0 === t.length) return e.status = "failed", void qi.updateTaskProgress(e.taskId, e.transferred, "failed");
t.filter(function(t) {
return t.room.name === e.portalRoom;
}).length > 0 && (e.status = "transferring", Hr.info("Transfer request ".concat(e.taskId, " reached portal, transferring"), {
subsystem: "CrossShardTransfer"
}));
}, e.prototype.handleTransferringRequest = function(e) {
0 === e.assignedCreeps.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return void 0 !== e;
}).length && (e.status = "complete", e.transferred = e.amount, qi.updateTaskProgress(e.taskId, 100, "complete"), 
qi.recordPortalTraversal(e.portalRoom, e.targetShard, !0), Hr.info("Transfer request ".concat(e.taskId, " completed"), {
subsystem: "CrossShardTransfer"
}));
}, e.prototype.cleanupOldRequests = function() {
for (var e in this.memory.requests) {
var t = this.memory.requests[e];
t && ("complete" === t.status || "failed" === t.status) && Game.time - this.memory.lastUpdate > 5e3 && delete this.memory.requests[e];
}
}, e.prototype.getCreepRequest = function(e) {
for (var t in this.memory.requests) {
var r = this.memory.requests[t];
if (r && r.assignedCreeps.includes(e)) return r;
}
return null;
}, e.prototype.assignCreep = function(e, t) {
var r = this.memory.requests[e];
r && !r.assignedCreeps.includes(t) && (r.assignedCreeps.push(t), Hr.info("Assigned creep ".concat(t, " to transfer request ").concat(e), {
subsystem: "CrossShardTransfer"
}));
}, e.prototype.getActiveRequests = function() {
return Object.values(this.memory.requests).filter(function(e) {
return "complete" !== e.status && "failed" !== e.status;
});
}, e.prototype.getPrioritizedRequests = function() {
return this.getActiveRequests().filter(function(e) {
return "queued" === e.status;
}).sort(function(e, t) {
return t.priority - e.priority;
});
}, e;
}(), Qi = new Xi, Zi = new Map, Ji = -1, $i = null;

function es(e, t) {
var r, o;
void 0 === t && (t = !1), Ji === Game.time && $i === Game.creeps || (Zi.clear(), 
Ji = Game.time, $i = Game.creeps);
var n = t ? "".concat(e, "_active") : e, a = Zi.get(n);
if (a && a instanceof Map) return a;
var i = new Map;
for (var s in Game.creeps) {
var c = Game.creeps[s], l = c.memory;
if (l.homeRoom === e) {
if (t && c.spawning) continue;
var u = null !== (r = l.role) && void 0 !== r ? r : "unknown";
i.set(u, (null !== (o = i.get(u)) && void 0 !== o ? o : 0) + 1);
}
}
return Zi.set(n, i), i;
}

function ts(e, t, o) {
var n, a, i = 0;
try {
for (var s = r(Object.values(Game.creeps)), c = s.next(); !c.done; c = s.next()) {
var l = c.value.memory;
l.homeRoom === e && l.role === t && l.targetRoom === o && i++;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
c && !c.done && (a = s.return) && a.call(s);
} finally {
if (n) throw n.error;
}
}
return i;
}

function rs(e, t, o) {
var n, a, i, s, c, l = null !== (i = o.remoteAssignments) && void 0 !== i ? i : [];
if (0 === l.length) return null;
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value, p = ts(e, t, m), d = Game.rooms[m];
if (p < ("remoteHarvester" === t ? d ? wa(d).length : 2 : "remoteHauler" === t && d ? Ci(e, m, wa(d).length, null !== (c = null === (s = Game.rooms[e]) || void 0 === s ? void 0 : s.energyCapacityAvailable) && void 0 !== c ? c : 800).recommendedHaulers : 2)) return m;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
f && !f.done && (a = u.return) && a.call(u);
} finally {
if (n) throw n.error;
}
}
return null;
}

function os(e, t, o, n) {
var a, i, s;
if ("remoteHarvester" === e || "remoteHauler" === e) {
var c = rs(n, e, o);
return !!c && (t.targetRoom = c, !0);
}
if ("remoteWorker" === e) {
var l = null !== (s = o.remoteAssignments) && void 0 !== s ? s : [];
if (l.length > 0) {
var u = 1 / 0, f = [];
try {
for (var m = r(l), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = ts(n, e, d);
y < u ? (u = y, f = [ d ]) : y === u && f.push(d);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
p && !p.done && (i = m.return) && i.call(m);
} finally {
if (a) throw a.error;
}
}
var g = f.length > 1 ? f[Game.time % f.length] : f[0];
return t.targetRoom = g, !0;
}
return !1;
}
return !0;
}

function ns(e, t, o, n) {
var a, i, s, c, l;
void 0 === n && (n = !1);
var u = Fa[t];
if (!u) return !1;
if ("larvaWorker" === t && !n) return !1;
if ("remoteHarvester" === t || "remoteHauler" === t) return null !== rs(e, t, o);
if ("remoteWorker" === t) {
if (0 === (m = null !== (s = o.remoteAssignments) && void 0 !== s ? s : []).length) return !1;
var f = function(e, t) {
Ji === Game.time && $i === Game.creeps || (Zi.clear(), Ji = Game.time, $i = Game.creeps);
var r = "".concat(e, ":").concat(t), o = Zi.get(r);
if ("number" == typeof o) return o;
var n = 0;
for (var a in Game.creeps) {
var i = Game.creeps[a].memory;
i.homeRoom === e && i.role === t && n++;
}
return Zi.set(r, n), n;
}(e, "remoteWorker");
return f < u.maxPerRoom;
}
if ("remoteGuard" === t) {
var m;
if (0 === (m = null !== (c = o.remoteAssignments) && void 0 !== c ? c : []).length) return !1;
try {
for (var p = r(m), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = Game.rooms[y];
if (g) {
var h = Oa(g, FIND_HOSTILE_CREEPS).filter(function(e) {
return e.body.some(function(e) {
return e.type === ATTACK || e.type === RANGED_ATTACK || e.type === WORK;
});
});
if (h.length > 0 && ts(e, t, y) < Math.min(u.maxPerRoom, Math.ceil(h.length / 2))) return !0;
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
return !1;
}
var v = null !== (l = es(e).get(t)) && void 0 !== l ? l : 0, R = u.maxPerRoom;
if ("upgrader" === t && o.clusterId && (null == (x = fi.getCluster(o.clusterId)) ? void 0 : x.focusRoom) === e) {
var E = Game.rooms[e];
(null == E ? void 0 : E.controller) && (R = E.controller.level <= 3 ? 2 : E.controller.level <= 6 ? 4 : 6);
}
if (v >= R) return !1;
var T = Game.rooms[e];
if (!T) return !1;
if ("scout" === t) return !(o.danger >= 1) && "defensive" !== o.posture && "war" !== o.posture && "siege" !== o.posture && (0 === v || "expand" === o.posture && v < u.maxPerRoom);
if ("claimer" === t) {
var S = fi.getEmpire(), C = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), b = C.length < Game.gcl.level, _ = S.claimQueue.some(function(e) {
return !e.claimed;
}), O = function(e, t) {
var o, n, a, i, s, c, l = null !== (a = t.remoteAssignments) && void 0 !== a ? a : [];
if (0 === l.length) return !1;
var u, f = (u = Object.values(Game.spawns)).length > 0 ? u[0].owner.username : "", m = function(e) {
var t = Game.rooms[e];
if (null == t ? void 0 : t.controller) {
var r = t.controller;
if (r.owner) return "continue";
var o = (null === (i = r.reservation) || void 0 === i ? void 0 : i.username) === f, n = null !== (c = null === (s = r.reservation) || void 0 === s ? void 0 : s.ticksToEnd) && void 0 !== c ? c : 0;
if ((!o || n < 3e3) && !Object.values(Game.creeps).some(function(t) {
var r = t.memory;
return "claimer" === r.role && r.targetRoom === e && "reserve" === r.task;
})) return {
value: !0
};
} else if (!Object.values(Game.creeps).some(function(t) {
var r = t.memory;
return "claimer" === r.role && r.targetRoom === e && "reserve" === r.task;
})) return {
value: !0
};
};
try {
for (var p = r(l), d = p.next(); !d.done; d = p.next()) {
var y = m(d.value);
if ("object" == typeof y) return y.value;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
d && !d.done && (n = p.return) && n.call(p);
} finally {
if (o) throw o.error;
}
}
return !1;
}(0, o);
return !(!b || !_) || !!O;
}
if ("mineralHarvester" === t) {
var w = T.find(FIND_MINERALS)[0];
if (!w) return !1;
if (!w.pos.lookFor(LOOK_STRUCTURES).find(function(e) {
return e.structureType === STRUCTURE_EXTRACTOR;
})) return !1;
if (0 === w.mineralAmount) return !1;
}
if ("labTech" === t && T.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
}).length < 3) return !1;
if ("factoryWorker" === t && 0 === T.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_FACTORY;
}
}).length) return !1;
if ("queenCarrier" === t && !T.storage) return !1;
if ("builder" === t && 0 === T.find(FIND_MY_CONSTRUCTION_SITES).length && v > 0) return !1;
if ("interRoomCarrier" === t) {
if (!o.clusterId) return !1;
var x;
if (!(x = fi.getCluster(o.clusterId)) || !x.resourceRequests || 0 === x.resourceRequests.length) return !1;
if (!(M = x.resourceRequests.some(function(e) {
if (e.fromRoom !== T.name) return !1;
var t = e.assignedCreeps.filter(function(e) {
return Game.creeps[e];
}).length;
return e.amount - e.delivered > 500 && t < 2;
}))) return !1;
}
if ("crossShardCarrier" === t) {
var U = Qi.getActiveRequests();
if (0 === U.length) return !1;
var M = U.some(function(e) {
var t, o;
if (e.sourceRoom !== T.name) return !1;
var n = e.assignedCreeps || [], a = e.amount - e.transferred, i = 0, s = 0;
try {
for (var c = r(n), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = Game.creeps[u];
f && (i += f.carryCapacity, s++);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
return i < a && s < 3;
});
if (!M) return !1;
}
return !0;
}

function as(e) {
var t, r;
return (null !== (t = e.get("harvester")) && void 0 !== t ? t : 0) + (null !== (r = e.get("larvaWorker")) && void 0 !== r ? r : 0);
}

function is(e) {
var t = wa(e);
return [ {
role: "larvaWorker",
minCount: 1
}, {
role: "harvester",
minCount: 1
}, {
role: "hauler",
minCount: 1
}, {
role: "harvester",
minCount: Math.max(t.length, 1)
}, {
role: "queenCarrier",
minCount: 1,
condition: function(e) {
return Boolean(e.storage);
}
}, {
role: "upgrader",
minCount: 1
} ];
}

function ss(e, t) {
var o, n, a, i, s = es(e, !0);
if (0 === as(s)) return !0;
if (0 === function(e) {
var t, r;
return (null !== (t = e.get("hauler")) && void 0 !== t ? t : 0) + (null !== (r = e.get("larvaWorker")) && void 0 !== r ? r : 0);
}(s) && (null !== (a = s.get("harvester")) && void 0 !== a ? a : 0) > 0) return !0;
var c = es(e, !1), l = is(t);
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if ((!m.condition || m.condition(t)) && (null !== (i = c.get(m.role)) && void 0 !== i ? i : 0) < m.minCount) return !0;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
return !1;
}

function cs(e, t) {
var o, n, a = null;
try {
for (var i = r(e.bodies), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
c.cost <= t && (!a || c.cost > a.cost) && (a = c);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}

function ls(e) {
return "".concat(e, "_").concat(Game.time, "_").concat(Math.floor(1e3 * Math.random()));
}

function us(e, t) {
var n, a, i, s, c, l, u = xa(e, STRUCTURE_SPAWN).find(function(e) {
return !e.spawning;
});
if (u) {
var f = e.energyCapacityAvailable, m = e.energyAvailable, p = 0 === as(es(e.name, !0)), d = p ? m : f;
if (p && m < 150 && (Hr.warn("WORKFORCE COLLAPSE: ".concat(m, " energy available, need 150 to spawn minimal larvaWorker. ") + "Room will recover once energy reaches 150.", {
subsystem: "spawn",
room: e.name
}), Ko.emit("spawn.emergency", {
roomName: e.name,
energyAvailable: m,
message: "Critical workforce collapse - waiting for energy to spawn minimal creep",
source: "SpawnManager"
})), ss(e.name, e) && Game.time % 10 == 0) {
var y = es(e.name, !0), g = es(e.name, !1), h = null !== (i = y.get("larvaWorker")) && void 0 !== i ? i : 0, v = null !== (s = y.get("harvester")) && void 0 !== s ? s : 0;
Hr.info("BOOTSTRAP MODE: ".concat(as(y), " active energy producers ") + "(".concat(h, " larva, ").concat(v, " harvest), ").concat(as(g), " total. ") + "Energy: ".concat(m, "/").concat(f), {
subsystem: "spawn",
room: e.name
});
}
if (ss(e.name, e)) {
var R = function(e, t, o) {
var n, a, i;
if (0 === as(es(e, !0))) return Hr.info("Bootstrap: Spawning larvaWorker (emergency - no active energy producers)", {
subsystem: "spawn",
room: e
}), "larvaWorker";
var s = es(e, !1), c = is(t);
Hr.info("Bootstrap: Checking ".concat(c.length, " roles in order"), {
subsystem: "spawn",
room: e,
meta: {
totalCreeps: s.size,
creepCounts: Array.from(s.entries())
}
});
try {
for (var l = r(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if (!f.condition || f.condition(t)) {
var m = null !== (i = s.get(f.role)) && void 0 !== i ? i : 0;
if (m < f.minCount) {
var p = ns(e, f.role, o, !0);
if (Hr.info("Bootstrap: Role ".concat(f.role, " needs spawning (current: ").concat(m, ", min: ").concat(f.minCount, ", needsRole: ").concat(p, ")"), {
subsystem: "spawn",
room: e
}), p) return f.role;
Hr.warn("Bootstrap: Role ".concat(f.role, " blocked by needsRole check (current: ").concat(m, "/").concat(f.minCount, ")"), {
subsystem: "spawn",
room: e
});
}
} else Hr.info("Bootstrap: Skipping ".concat(f.role, " (condition not met)"), {
subsystem: "spawn",
room: e
});
}
} catch (e) {
n = {
error: e
};
} finally {
try {
u && !u.done && (a = l.return) && a.call(l);
} finally {
if (n) throw n.error;
}
}
return Hr.info("Bootstrap: No role needs spawning", {
subsystem: "spawn",
room: e
}), null;
}(e.name, e, t);
if (!R) return;
if (!(w = Fa[R])) return;
var E = cs(w, d);
if (E && m >= E.cost) ; else if (!(E = cs(w, m))) return void Hr.info("Bootstrap: No affordable body for ".concat(R, " (available: ").concat(m, ", min needed: ").concat(null !== (l = null === (c = w.bodies[0]) || void 0 === c ? void 0 : c.cost) && void 0 !== l ? l : "unknown", ")"), {
subsystem: "spawn",
room: e.name
});
var T = ls(R);
if (!os(R, x = {
role: w.role,
family: w.family,
homeRoom: e.name,
version: 1
}, t, e.name)) return;
var S = void 0;
try {
S = u.spawnCreep(E.parts, T, {
memory: x
});
} catch (t) {
return void Hr.error("EXCEPTION during spawn attempt for ".concat(R, ": ").concat(t), {
subsystem: "spawn",
room: e.name,
meta: {
error: String(t),
role: R,
bodyCost: E.cost,
bodyParts: E.parts.length
}
});
}
if (S === OK) Hr.info("BOOTSTRAP SPAWN: ".concat(R, " (").concat(T, ") with ").concat(E.parts.length, " parts, cost ").concat(E.cost, ". Recovery in progress."), {
subsystem: "spawn",
room: e.name
}), Ko.emit("spawn.completed", {
roomName: e.name,
creepName: T,
role: R,
cost: E.cost,
source: "SpawnManager"
}); else {
var C = S === ERR_NOT_ENOUGH_ENERGY ? "ERR_NOT_ENOUGH_ENERGY" : S === ERR_NAME_EXISTS ? "ERR_NAME_EXISTS" : S === ERR_BUSY ? "ERR_BUSY" : S === ERR_NOT_OWNER ? "ERR_NOT_OWNER" : S === ERR_INVALID_ARGS ? "ERR_INVALID_ARGS" : S === ERR_RCL_NOT_ENOUGH ? "ERR_RCL_NOT_ENOUGH" : "UNKNOWN(".concat(S, ")");
Hr.warn("BOOTSTRAP SPAWN FAILED: ".concat(R, " (").concat(T, ") - ").concat(C, ". Body: ").concat(E.parts.length, " parts, cost: ").concat(E.cost, ", available: ").concat(m), {
subsystem: "spawn",
room: e.name,
meta: {
errorCode: S,
errorName: C,
role: R,
bodyCost: E.cost,
energyAvailable: m,
energyCapacity: f
}
});
}
} else {
var b = function(e, t) {
var n, a, i, s, c = es(e.name), l = function(e) {
switch (e) {
case "eco":
return {
harvester: 1.5,
hauler: 1.2,
upgrader: 1.3,
builder: 1,
queenCarrier: 1,
guard: .3,
remoteGuard: .8,
healer: .1,
scout: 1,
claimer: .8,
engineer: .8,
remoteHarvester: 1.2,
remoteHauler: 1.2,
interRoomCarrier: 1
};

case "expand":
return {
harvester: 1.2,
hauler: 1,
upgrader: .8,
builder: 1,
queenCarrier: .8,
guard: .3,
remoteGuard: 1,
scout: 1.5,
claimer: 1.5,
remoteWorker: 1.5,
engineer: .5,
remoteHarvester: 1.5,
remoteHauler: 1.5,
interRoomCarrier: 1.2
};

case "defensive":
return {
harvester: 1,
hauler: 1,
upgrader: .5,
builder: .5,
queenCarrier: 1,
guard: 2,
remoteGuard: 1.8,
healer: 1.5,
ranger: 1,
scout: 0,
engineer: 1.2,
remoteHarvester: .5,
remoteHauler: .5,
interRoomCarrier: 1.5
};

case "war":
return {
harvester: .8,
hauler: .8,
upgrader: .3,
builder: .3,
queenCarrier: 1,
guard: 2.5,
healer: 2,
soldier: 2,
ranger: 1.5,
scout: 0,
engineer: .5,
remoteHarvester: .3,
remoteHauler: .3,
interRoomCarrier: .5
};

case "siege":
return {
harvester: .5,
hauler: .5,
upgrader: .1,
builder: .1,
queenCarrier: 1,
guard: 3,
healer: 2.5,
soldier: 2.5,
siegeUnit: 2,
ranger: 1,
scout: 0,
engineer: .2,
remoteHarvester: .1,
remoteHauler: .1
};

case "evacuate":
return {
hauler: 2,
queenCarrier: 1.5
};

case "nukePrep":
return {
harvester: 1,
hauler: 1,
upgrader: .5,
builder: .5,
queenCarrier: 1,
guard: 1.5,
scout: .5,
engineer: 2,
remoteHarvester: .5,
remoteHauler: .5
};

default:
return {
harvester: 1,
hauler: 1,
upgrader: 1,
builder: 1,
queenCarrier: 1,
scout: 1,
remoteHarvester: 1,
remoteHauler: 1
};
}
}(t.posture), u = [];
try {
for (var f = r(Object.entries(Fa)), m = f.next(); !m.done; m = f.next()) {
var p = o(m.value, 2), d = p[0], y = p[1];
if (ns(e.name, d, t)) {
var g = y.priority, h = null !== (i = l[d]) && void 0 !== i ? i : .5, v = Ei(d, t.pheromones), R = Ri(e, t, d), E = null !== (s = c.get(d)) && void 0 !== s ? s : 0, T = (g + R) * h * v * (y.maxPerRoom > 0 ? Math.max(.1, 1 - E / y.maxPerRoom) : .1);
u.push({
role: d,
score: T
});
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (n) throw n.error;
}
}
return u.sort(function(e, t) {
return t.score - e.score;
}), u.map(function(e) {
return e.role;
});
}(e, t);
try {
for (var _ = r(b), O = _.next(); !O.done; O = _.next()) {
var w;
if (R = O.value, w = Fa[R]) {
var x, U = cs(w, d);
if (U && !(m < U.cost) && (T = ls(R), os(R, x = {
role: w.role,
family: w.family,
homeRoom: e.name,
version: 1
}, t, e.name))) {
if ("interRoomCarrier" === R && t.clusterId) {
var M = fi.getCluster(t.clusterId);
if (M) {
var A = M.resourceRequests.find(function(t) {
if (t.fromRoom !== e.name) return !1;
var r = t.assignedCreeps.filter(function(e) {
return Game.creeps[e];
}).length;
return t.amount - t.delivered > 500 && r < 2;
});
A && (x.transferRequest = {
fromRoom: A.fromRoom,
toRoom: A.toRoom,
resourceType: A.resourceType,
amount: A.amount
}, A.assignedCreeps.push(T));
}
}
if ((S = u.spawnCreep(U.parts, T, {
memory: x
})) === OK) return void Ko.emit("spawn.completed", {
roomName: e.name,
creepName: T,
role: R,
cost: U.cost,
source: "SpawnManager"
});
if (S !== ERR_NOT_ENOUGH_ENERGY) return C = S === ERR_NAME_EXISTS ? "ERR_NAME_EXISTS" : S === ERR_BUSY ? "ERR_BUSY" : S === ERR_NOT_OWNER ? "ERR_NOT_OWNER" : S === ERR_INVALID_ARGS ? "ERR_INVALID_ARGS" : S === ERR_RCL_NOT_ENOUGH ? "ERR_RCL_NOT_ENOUGH" : "UNKNOWN(".concat(S, ")"), 
void Hr.warn("Spawn failed for ".concat(R, ": ").concat(C, ". Body: ").concat(U.parts.length, " parts, cost: ").concat(U.cost), {
subsystem: "spawn",
room: e.name,
meta: {
errorCode: S,
errorName: C,
role: R,
bodyCost: U.cost
}
});
}
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
O && !O.done && (a = _.return) && a.call(_);
} finally {
if (n) throw n.error;
}
}
b.length > 0 && Game.time % 20 == 0 ? Hr.info("Waiting for energy: ".concat(b.length, " roles need spawning, waiting for optimal bodies. ") + "Energy: ".concat(m, "/").concat(f), {
subsystem: "spawn",
room: e.name,
meta: {
topRoles: b.slice(0, 3).join(", "),
energyAvailable: m,
energyCapacity: f
}
}) : 0 === b.length && Game.time % 100 == 0 && Hr.info("No spawns needed: All roles fully staffed. Energy: ".concat(m, "/").concat(f), {
subsystem: "spawn",
room: e.name,
meta: {
energyAvailable: m,
energyCapacity: f,
activeCreeps: es(e.name, !0).size
}
});
}
}
}

var fs = jr("CreepContext"), ms = ((Wi = {})[STRUCTURE_SPAWN] = 100, Wi[STRUCTURE_EXTENSION] = 90, 
Wi[STRUCTURE_TOWER] = 80, Wi[STRUCTURE_RAMPART] = 75, Wi[STRUCTURE_WALL] = 70, Wi[STRUCTURE_STORAGE] = 70, 
Wi[STRUCTURE_CONTAINER] = 60, Wi[STRUCTURE_ROAD] = 30, Wi), ps = new Map;

function ds(e) {
e._allStructuresLoaded || (e.allStructures = e.room.find(FIND_STRUCTURES), e._allStructuresLoaded = !0);
}

function ys(e) {
return void 0 === e._prioritizedSites && (e._prioritizedSites = e.room.find(FIND_MY_CONSTRUCTION_SITES).sort(function(e, t) {
var r, o, n = null !== (r = ms[e.structureType]) && void 0 !== r ? r : 50;
return (null !== (o = ms[t.structureType]) && void 0 !== o ? o : 50) - n;
})), e._prioritizedSites;
}

function gs(e) {
return void 0 === e._repairTargets && (ds(e), e._repairTargets = e.allStructures.filter(function(e) {
return e.hits < .75 * e.hitsMax && e.structureType !== STRUCTURE_WALL;
})), e._repairTargets;
}

function hs(e) {
var t, o, n = e.room, a = e.memory, i = function(e) {
var t = ps.get(e.name);
if (t && t.tick === Game.time) return t;
var r = {
tick: Game.time,
room: e,
hostiles: qn.safeFind(e, FIND_HOSTILE_CREEPS),
myStructures: e.find(FIND_MY_STRUCTURES),
allStructures: []
};
return ps.set(e.name, r), r;
}(n);
void 0 === a.working && (a.working = e.store.getUsedCapacity() > 0, fs.debug("".concat(e.name, " initialized working=").concat(a.working, " from carry state"), {
creep: e.name
}));
var s = null !== (t = a.homeRoom) && void 0 !== t ? t : n.name;
return {
creep: e,
room: n,
memory: a,
get swarmState() {
return function(e) {
var t, r = null === (t = Memory.rooms) || void 0 === t ? void 0 : t[e];
return null == r ? void 0 : r.swarm;
}(n.name);
},
get squadMemory() {
return function(e) {
if (e) {
var t = Memory.squads;
return null == t ? void 0 : t[e];
}
}(a.squadId);
},
homeRoom: s,
isInHomeRoom: n.name === s,
isFull: 0 === e.store.getFreeCapacity(),
isEmpty: 0 === e.store.getUsedCapacity(),
isWorking: null !== (o = a.working) && void 0 !== o && o,
get assignedSource() {
return function(e) {
return e.sourceId ? Game.getObjectById(e.sourceId) : null;
}(a);
},
get assignedMineral() {
var e, t = function(e) {
return void 0 === e._minerals && (e._minerals = e.room.find(FIND_MINERALS)), e._minerals;
}(i);
return null !== (e = t[0]) && void 0 !== e ? e : null;
},
get energyAvailable() {
return function(e) {
return void 0 === e._activeSources && (e._activeSources = e.room.find(FIND_SOURCES_ACTIVE)), 
e._activeSources;
}(i).length > 0;
},
get nearbyEnemies() {
return i.hostiles.length > 0 && function(e, t) {
var o, n;
try {
for (var a = r(t), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = Math.abs(e.x - s.pos.x), l = Math.abs(e.y - s.pos.y);
if (Math.max(c, l) <= 10) return !0;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
i && !i.done && (n = a.return) && n.call(a);
} finally {
if (o) throw o.error;
}
}
return !1;
}(e.pos, i.hostiles);
},
get constructionSiteCount() {
return ys(i).length;
},
get damagedStructureCount() {
return gs(i).length;
},
get droppedResources() {
return function(e) {
return void 0 === e._droppedResources && (e._droppedResources = e.room.find(FIND_DROPPED_RESOURCES, {
filter: function(e) {
return e.resourceType === RESOURCE_ENERGY && e.amount > 50 || e.resourceType !== RESOURCE_ENERGY && e.amount > 0;
}
})), e._droppedResources;
}(i);
},
get containers() {
return function(e) {
return void 0 === e._containers && (ds(e), e._containers = e.allStructures.filter(function(e) {
return e.structureType === STRUCTURE_CONTAINER;
})), e._containers;
}(i);
},
get depositContainers() {
return function(e) {
return void 0 === e._depositContainers && (ds(e), e._depositContainers = e.allStructures.filter(function(e) {
return e.structureType === STRUCTURE_CONTAINER;
})), e._depositContainers;
}(i);
},
get spawnStructures() {
return function(e) {
return void 0 === e._spawnStructures && (e._spawnStructures = e.myStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN || e.structureType === STRUCTURE_EXTENSION;
})), e._spawnStructures;
}(i);
},
get towers() {
return function(e) {
return void 0 === e._towers && (e._towers = e.myStructures.filter(function(e) {
return e.structureType === STRUCTURE_TOWER;
})), e._towers;
}(i);
},
storage: n.storage,
terminal: n.terminal,
hostiles: i.hostiles,
get damagedAllies() {
return function(e) {
return void 0 === e._damagedAllies && (e._damagedAllies = e.room.find(FIND_MY_CREEPS, {
filter: function(e) {
return e.hits < e.hitsMax;
}
})), e._damagedAllies;
}(i);
},
get prioritizedSites() {
return ys(i);
},
get repairTargets() {
return gs(i);
},
get labs() {
return function(e) {
return void 0 === e._labs && (e._labs = e.myStructures.filter(function(e) {
return e.structureType === STRUCTURE_LAB;
})), e._labs;
}(i);
},
get factory() {
return function(e) {
return e._factoryChecked || (e._factory = e.myStructures.find(function(e) {
return e.structureType === STRUCTURE_FACTORY;
}), e._factoryChecked = !0), e._factory;
}(i);
},
get tombstones() {
return function(e) {
return void 0 === e._tombstones && (e._tombstones = e.room.find(FIND_TOMBSTONES)), 
e._tombstones;
}(i);
},
get mineralContainers() {
return function(e) {
return void 0 === e._mineralContainers && (e._mineralContainers = e.room.find(FIND_STRUCTURES, {
filter: function(e) {
if (e.structureType !== STRUCTURE_CONTAINER) return !1;
var t = e;
return Object.keys(t.store).some(function(e) {
return e !== RESOURCE_ENERGY && t.store.getUsedCapacity(e) > 0;
});
}
})), e._mineralContainers;
}(i);
}
};
}

var vs, Rs = {}, Es = function() {
if (vs) return Rs;
vs = 1, Object.defineProperty(Rs, "__esModule", {
value: !0
});
var e = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : void 0 !== f ? f : "undefined" != typeof self ? self : {}, t = function(e) {
return e && e.Math === Math && e;
}, r = t("object" == typeof globalThis && globalThis) || t("object" == typeof window && window) || t("object" == typeof self && self) || t("object" == typeof e && e) || t("object" == typeof e && e) || function() {
return this;
}() || Function("return this")(), o = {}, n = function(e) {
try {
return !!e();
} catch (e) {
return !0;
}
}, a = !n(function() {
return 7 !== Object.defineProperty({}, 1, {
get: function() {
return 7;
}
})[1];
}), i = !n(function() {
var e = function() {}.bind();
return "function" != typeof e || e.hasOwnProperty("prototype");
}), s = i, c = Function.prototype.call, l = s ? c.bind(c) : function() {
return c.apply(c, arguments);
}, u = {}, m = {}.propertyIsEnumerable, p = Object.getOwnPropertyDescriptor, d = p && !m.call({
1: 2
}, 1);
u.f = d ? function(e) {
var t = p(this, e);
return !!t && t.enumerable;
} : m;
var y, g, h = function(e, t) {
return {
enumerable: !(1 & e),
configurable: !(2 & e),
writable: !(4 & e),
value: t
};
}, v = i, R = Function.prototype, E = R.call, T = v && R.bind.bind(E, E), S = v ? T : function(e) {
return function() {
return E.apply(e, arguments);
};
}, C = S, b = C({}.toString), _ = C("".slice), O = function(e) {
return _(b(e), 8, -1);
}, w = n, x = O, U = Object, M = S("".split), A = w(function() {
return !U("z").propertyIsEnumerable(0);
}) ? function(e) {
return "String" === x(e) ? M(e, "") : U(e);
} : U, k = function(e) {
return null == e;
}, N = k, P = TypeError, I = function(e) {
if (N(e)) throw new P("Can't call method on " + e);
return e;
}, G = A, L = I, D = function(e) {
return G(L(e));
}, F = "object" == typeof document && document.all, B = void 0 === F && void 0 !== F ? function(e) {
return "function" == typeof e || e === F;
} : function(e) {
return "function" == typeof e;
}, j = B, H = function(e) {
return "object" == typeof e ? null !== e : j(e);
}, W = r, Y = B, K = function(e, t) {
return arguments.length < 2 ? (r = W[e], Y(r) ? r : void 0) : W[e] && W[e][t];
var r;
}, V = S({}.isPrototypeOf), z = r.navigator, q = z && z.userAgent, X = r, Q = q ? String(q) : "", Z = X.process, J = X.Deno, $ = Z && Z.versions || J && J.version, ee = $ && $.v8;
ee && (g = (y = ee.split("."))[0] > 0 && y[0] < 4 ? 1 : +(y[0] + y[1])), !g && Q && (!(y = Q.match(/Edge\/(\d+)/)) || y[1] >= 74) && (y = Q.match(/Chrome\/(\d+)/)) && (g = +y[1]);
var te = g, re = n, oe = r.String, ne = !!Object.getOwnPropertySymbols && !re(function() {
var e = Symbol("symbol detection");
return !oe(e) || !(Object(e) instanceof Symbol) || !Symbol.sham && te && te < 41;
}), ae = ne && !Symbol.sham && "symbol" == typeof Symbol.iterator, ie = K, se = B, ce = V, le = Object, ue = ae ? function(e) {
return "symbol" == typeof e;
} : function(e) {
var t = ie("Symbol");
return se(t) && ce(t.prototype, le(e));
}, fe = String, me = B, pe = TypeError, de = function(e) {
if (me(e)) return e;
throw new pe(function(e) {
try {
return fe(e);
} catch (e) {
return "Object";
}
}(e) + " is not a function");
}, ye = de, ge = k, he = l, ve = B, Re = H, Ee = TypeError, Te = {
exports: {}
}, Se = r, Ce = Object.defineProperty, be = function(e, t) {
try {
Ce(Se, e, {
value: t,
configurable: !0,
writable: !0
});
} catch (r) {
Se[e] = t;
}
return t;
}, _e = r, Oe = be, we = "__core-js_shared__", xe = Te.exports = _e[we] || Oe(we, {});
(xe.versions || (xe.versions = [])).push({
version: "3.42.0",
mode: "global",
copyright: " 2014-2025 Denis Pushkarev (zloirock.ru)",
license: "https://github.com/zloirock/core-js/blob/v3.42.0/LICENSE",
source: "https://github.com/zloirock/core-js"
});
var Ue = Te.exports, Me = Ue, Ae = function(e, t) {
return Me[e] || (Me[e] = t || {});
}, ke = I, Ne = Object, Pe = function(e) {
return Ne(ke(e));
}, Ie = Pe, Ge = S({}.hasOwnProperty), Le = Object.hasOwn || function(e, t) {
return Ge(Ie(e), t);
}, De = S, Fe = 0, Be = Math.random(), je = De(1..toString), He = function(e) {
return "Symbol(" + (void 0 === e ? "" : e) + ")_" + je(++Fe + Be, 36);
}, We = Ae, Ye = Le, Ke = He, Ve = ne, ze = ae, qe = r.Symbol, Xe = We("wks"), Qe = ze ? qe.for || qe : qe && qe.withoutSetter || Ke, Ze = function(e) {
return Ye(Xe, e) || (Xe[e] = Ve && Ye(qe, e) ? qe[e] : Qe("Symbol." + e)), Xe[e];
}, Je = l, $e = H, et = ue, tt = TypeError, rt = Ze("toPrimitive"), ot = ue, nt = function(e) {
var t = function(e, t) {
if (!$e(e) || et(e)) return e;
var r, o, n = (o = e[rt], ge(o) ? void 0 : ye(o));
if (n) {
if (void 0 === t && (t = "default"), r = Je(n, e, t), !$e(r) || et(r)) return r;
throw new tt("Can't convert object to primitive value");
}
return void 0 === t && (t = "number"), function(e, t) {
var r, o;
if ("string" === t && ve(r = e.toString) && !Re(o = he(r, e))) return o;
if (ve(r = e.valueOf) && !Re(o = he(r, e))) return o;
if ("string" !== t && ve(r = e.toString) && !Re(o = he(r, e))) return o;
throw new Ee("Can't convert object to primitive value");
}(e, t);
}(e, "string");
return ot(t) ? t : t + "";
}, at = H, it = r.document, st = at(it) && at(it.createElement), ct = function(e) {
return st ? it.createElement(e) : {};
}, lt = ct, ut = !a && !n(function() {
return 7 !== Object.defineProperty(lt("div"), "a", {
get: function() {
return 7;
}
}).a;
}), ft = a, mt = l, pt = u, dt = h, yt = D, gt = nt, ht = Le, vt = ut, Rt = Object.getOwnPropertyDescriptor;
o.f = ft ? Rt : function(e, t) {
if (e = yt(e), t = gt(t), vt) try {
return Rt(e, t);
} catch (e) {}
if (ht(e, t)) return dt(!mt(pt.f, e, t), e[t]);
};
var Et = {}, Tt = a && n(function() {
return 42 !== Object.defineProperty(function() {}, "prototype", {
value: 42,
writable: !1
}).prototype;
}), St = H, Ct = String, bt = TypeError, _t = function(e) {
if (St(e)) return e;
throw new bt(Ct(e) + " is not an object");
}, Ot = a, wt = ut, xt = Tt, Ut = _t, Mt = nt, At = TypeError, kt = Object.defineProperty, Nt = Object.getOwnPropertyDescriptor, Pt = "enumerable", It = "configurable", Gt = "writable";
Et.f = Ot ? xt ? function(e, t, r) {
if (Ut(e), t = Mt(t), Ut(r), "function" == typeof e && "prototype" === t && "value" in r && Gt in r && !r[Gt]) {
var o = Nt(e, t);
o && o[Gt] && (e[t] = r.value, r = {
configurable: It in r ? r[It] : o[It],
enumerable: Pt in r ? r[Pt] : o[Pt],
writable: !1
});
}
return kt(e, t, r);
} : kt : function(e, t, r) {
if (Ut(e), t = Mt(t), Ut(r), wt) try {
return kt(e, t, r);
} catch (e) {}
if ("get" in r || "set" in r) throw new At("Accessors not supported");
return "value" in r && (e[t] = r.value), e;
};
var Lt = Et, Dt = h, Ft = a ? function(e, t, r) {
return Lt.f(e, t, Dt(1, r));
} : function(e, t, r) {
return e[t] = r, e;
}, Bt = {
exports: {}
}, jt = a, Ht = Le, Wt = Function.prototype, Yt = jt && Object.getOwnPropertyDescriptor, Kt = {
CONFIGURABLE: Ht(Wt, "name") && (!jt || jt && Yt(Wt, "name").configurable)
}, Vt = B, zt = Ue, qt = S(Function.toString);
Vt(zt.inspectSource) || (zt.inspectSource = function(e) {
return qt(e);
});
var Xt, Qt, Zt, Jt = zt.inspectSource, $t = B, er = r.WeakMap, tr = $t(er) && /native code/.test(String(er)), rr = He, or = Ae("keys"), nr = function(e) {
return or[e] || (or[e] = rr(e));
}, ar = {}, ir = tr, sr = r, cr = Ft, lr = Le, ur = Ue, fr = nr, mr = ar, pr = "Object already initialized", dr = sr.TypeError, yr = sr.WeakMap;
if (ir || ur.state) {
var gr = ur.state || (ur.state = new yr);
gr.get = gr.get, gr.has = gr.has, gr.set = gr.set, Xt = function(e, t) {
if (gr.has(e)) throw new dr(pr);
return t.facade = e, gr.set(e, t), t;
}, Qt = function(e) {
return gr.get(e) || {};
}, Zt = function(e) {
return gr.has(e);
};
} else {
var hr = fr("state");
mr[hr] = !0, Xt = function(e, t) {
if (lr(e, hr)) throw new dr(pr);
return t.facade = e, cr(e, hr, t), t;
}, Qt = function(e) {
return lr(e, hr) ? e[hr] : {};
}, Zt = function(e) {
return lr(e, hr);
};
}
var vr = {
get: Qt,
enforce: function(e) {
return Zt(e) ? Qt(e) : Xt(e, {});
}
}, Rr = S, Er = n, Tr = B, Sr = Le, Cr = a, br = Kt.CONFIGURABLE, _r = Jt, Or = vr.enforce, wr = vr.get, xr = String, Ur = Object.defineProperty, Mr = Rr("".slice), Ar = Rr("".replace), kr = Rr([].join), Nr = Cr && !Er(function() {
return 8 !== Ur(function() {}, "length", {
value: 8
}).length;
}), Pr = String(String).split("String"), Ir = Bt.exports = function(e, t, r) {
"Symbol(" === Mr(xr(t), 0, 7) && (t = "[" + Ar(xr(t), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), 
r && r.getter && (t = "get " + t), r && r.setter && (t = "set " + t), (!Sr(e, "name") || br && e.name !== t) && (Cr ? Ur(e, "name", {
value: t,
configurable: !0
}) : e.name = t), Nr && r && Sr(r, "arity") && e.length !== r.arity && Ur(e, "length", {
value: r.arity
});
try {
r && Sr(r, "constructor") && r.constructor ? Cr && Ur(e, "prototype", {
writable: !1
}) : e.prototype && (e.prototype = void 0);
} catch (e) {}
var o = Or(e);
return Sr(o, "source") || (o.source = kr(Pr, "string" == typeof t ? t : "")), e;
};
Function.prototype.toString = Ir(function() {
return Tr(this) && wr(this).source || _r(this);
}, "toString");
var Gr = Bt.exports, Lr = B, Dr = Et, Fr = Gr, Br = be, jr = {}, Hr = Math.ceil, Wr = Math.floor, Yr = Math.trunc || function(e) {
var t = +e;
return (t > 0 ? Wr : Hr)(t);
}, Kr = function(e) {
var t = +e;
return t != t || 0 === t ? 0 : Yr(t);
}, Vr = Kr, zr = Math.max, qr = Math.min, Xr = Kr, Qr = Math.min, Zr = function(e) {
return t = e.length, (r = Xr(t)) > 0 ? Qr(r, 9007199254740991) : 0;
var t, r;
}, Jr = D, $r = Zr, eo = {
indexOf: function(e, t, r) {
var o = Jr(e), n = $r(o);
if (0 === n) return -1;
for (var a = function(e, t) {
var r = Vr(e);
return r < 0 ? zr(r + t, 0) : qr(r, t);
}(r, n); n > a; a++) if (a in o && o[a] === t) return a || 0;
return -1;
}
}, to = Le, ro = D, oo = eo.indexOf, no = ar, ao = S([].push), io = function(e, t) {
var r, o = ro(e), n = 0, a = [];
for (r in o) !to(no, r) && to(o, r) && ao(a, r);
for (;t.length > n; ) to(o, r = t[n++]) && (~oo(a, r) || ao(a, r));
return a;
}, so = [ "constructor", "hasOwnProperty", "isPrototypeOf", "propertyIsEnumerable", "toLocaleString", "toString", "valueOf" ], co = io, lo = so.concat("length", "prototype");
jr.f = Object.getOwnPropertyNames || function(e) {
return co(e, lo);
};
var uo = {};
uo.f = Object.getOwnPropertySymbols;
var fo = K, mo = jr, po = uo, yo = _t, go = S([].concat), ho = fo("Reflect", "ownKeys") || function(e) {
var t = mo.f(yo(e)), r = po.f;
return r ? go(t, r(e)) : t;
}, vo = Le, Ro = ho, Eo = o, To = Et, So = n, Co = B, bo = /#|\.prototype\./, _o = function(e, t) {
var r = wo[Oo(e)];
return r === Uo || r !== xo && (Co(t) ? So(t) : !!t);
}, Oo = _o.normalize = function(e) {
return String(e).replace(bo, ".").toLowerCase();
}, wo = _o.data = {}, xo = _o.NATIVE = "N", Uo = _o.POLYFILL = "P", Mo = _o, Ao = r, ko = o.f, No = Ft, Po = function(e, t, r, o) {
o || (o = {});
var n = o.enumerable, a = void 0 !== o.name ? o.name : t;
if (Lr(r) && Fr(r, a, o), o.global) n ? e[t] = r : Br(t, r); else {
try {
o.unsafe ? e[t] && (n = !0) : delete e[t];
} catch (e) {}
n ? e[t] = r : Dr.f(e, t, {
value: r,
enumerable: !1,
configurable: !o.nonConfigurable,
writable: !o.nonWritable
});
}
return e;
}, Io = be, Go = function(e, t, r) {
for (var o = Ro(t), n = To.f, a = Eo.f, i = 0; i < o.length; i++) {
var s = o[i];
vo(e, s) || r && vo(r, s) || n(e, s, a(t, s));
}
}, Lo = Mo, Do = function(e, t) {
var r, o, n, a, i, s = e.target, c = e.global, l = e.stat;
if (r = c ? Ao : l ? Ao[s] || Io(s, {}) : Ao[s] && Ao[s].prototype) for (o in t) {
if (a = t[o], n = e.dontCallGetSet ? (i = ko(r, o)) && i.value : r[o], !Lo(c ? o : s + (l ? "." : "#") + o, e.forced) && void 0 !== n) {
if (typeof a == typeof n) continue;
Go(a, n);
}
(e.sham || n && n.sham) && No(a, "sham", !0), Po(r, o, a, e);
}
}, Fo = O, Bo = Array.isArray || function(e) {
return "Array" === Fo(e);
}, jo = TypeError, Ho = O, Wo = S, Yo = function(e) {
if ("Function" === Ho(e)) return Wo(e);
}, Ko = de, Vo = i, zo = Yo(Yo.bind), qo = Bo, Xo = Zr, Qo = function(e) {
if (e > 9007199254740991) throw jo("Maximum allowed index exceeded");
return e;
}, Zo = function(e, t, r, o, n, a, i, s) {
for (var c, l, u = n, f = 0, m = !!i && function(e, t) {
return Ko(e), void 0 === t ? e : Vo ? zo(e, t) : function() {
return e.apply(t, arguments);
};
}(i, s); f < o; ) f in r && (c = m ? m(r[f], f, t) : r[f], a > 0 && qo(c) ? (l = Xo(c), 
u = Zo(e, t, c, l, u, a - 1) - 1) : (Qo(u + 1), e[u] = c), u++), f++;
return u;
}, Jo = Zo, $o = {};
$o[Ze("toStringTag")] = "z";
var en = "[object z]" === String($o), tn = B, rn = O, on = Ze("toStringTag"), nn = Object, an = "Arguments" === rn(function() {
return arguments;
}()), sn = S, cn = n, ln = B, un = en ? rn : function(e) {
var t, r, o;
return void 0 === e ? "Undefined" : null === e ? "Null" : "string" == typeof (r = function(e, t) {
try {
return e[t];
} catch (e) {}
}(t = nn(e), on)) ? r : an ? rn(t) : "Object" === (o = rn(t)) && tn(t.callee) ? "Arguments" : o;
}, fn = Jt, mn = function() {}, pn = K("Reflect", "construct"), dn = /^\s*(?:class|function)\b/, yn = sn(dn.exec), gn = !dn.test(mn), hn = function(e) {
if (!ln(e)) return !1;
try {
return pn(mn, [], e), !0;
} catch (e) {
return !1;
}
}, vn = function(e) {
if (!ln(e)) return !1;
switch (un(e)) {
case "AsyncFunction":
case "GeneratorFunction":
case "AsyncGeneratorFunction":
return !1;
}
try {
return gn || !!yn(dn, fn(e));
} catch (e) {
return !0;
}
};
vn.sham = !0;
var Rn = !pn || cn(function() {
var e;
return hn(hn.call) || !hn(Object) || !hn(function() {
e = !0;
}) || e;
}) ? vn : hn, En = Bo, Tn = Rn, Sn = H, Cn = Ze("species"), bn = Array, _n = function(e, t) {
return new (function(e) {
var t;
return En(e) && (t = e.constructor, (Tn(t) && (t === bn || En(t.prototype)) || Sn(t) && null === (t = t[Cn])) && (t = void 0)), 
void 0 === t ? bn : t;
}(e))(0 === t ? 0 : t);
}, On = Jo, wn = de, xn = Pe, Un = Zr, Mn = _n;
Do({
target: "Array",
proto: !0
}, {
flatMap: function(e) {
var t, r = xn(this), o = Un(r);
return wn(e), (t = Mn(r, 0)).length = On(t, r, r, o, 0, 1, e, arguments.length > 1 ? arguments[1] : void 0), 
t;
}
});
var An = {}, kn = io, Nn = so, Pn = Object.keys || function(e) {
return kn(e, Nn);
}, In = a, Gn = Tt, Ln = Et, Dn = _t, Fn = D, Bn = Pn;
An.f = In && !Gn ? Object.defineProperties : function(e, t) {
Dn(e);
for (var r, o = Fn(t), n = Bn(t), a = n.length, i = 0; a > i; ) Ln.f(e, r = n[i++], o[r]);
return e;
};
var jn, Hn = K("document", "documentElement"), Wn = _t, Yn = An, Kn = so, Vn = ar, zn = Hn, qn = ct, Xn = "prototype", Qn = "script", Zn = nr("IE_PROTO"), Jn = function() {}, $n = function(e) {
return "<" + Qn + ">" + e + "</" + Qn + ">";
}, ea = function(e) {
e.write($n("")), e.close();
var t = e.parentWindow.Object;
return e = null, t;
}, ta = function() {
try {
jn = new ActiveXObject("htmlfile");
} catch (e) {}
var e, t, r;
ta = "undefined" != typeof document ? document.domain && jn ? ea(jn) : (t = qn("iframe"), 
r = "java" + Qn + ":", t.style.display = "none", zn.appendChild(t), t.src = String(r), 
(e = t.contentWindow.document).open(), e.write($n("document.F=Object")), e.close(), 
e.F) : ea(jn);
for (var o = Kn.length; o--; ) delete ta[Xn][Kn[o]];
return ta();
};
Vn[Zn] = !0;
var ra = Ze, oa = Object.create || function(e, t) {
var r;
return null !== e ? (Jn[Xn] = Wn(e), r = new Jn, Jn[Xn] = null, r[Zn] = e) : r = ta(), 
void 0 === t ? r : Yn.f(r, t);
}, na = Et.f, aa = ra("unscopables"), ia = Array.prototype;
void 0 === ia[aa] && na(ia, aa, {
configurable: !0,
value: oa(null)
});
var sa = function(e) {
ia[aa][e] = !0;
};
sa("flatMap");
var ca = r, la = S, ua = function(e, t) {
return la(ca[e].prototype[t]);
};
ua("Array", "flatMap");
var fa = Jo, ma = Pe, pa = Zr, da = Kr, ya = _n;
Do({
target: "Array",
proto: !0
}, {
flat: function() {
var e = arguments.length ? arguments[0] : void 0, t = ma(this), r = pa(t), o = ya(t, 0);
return o.length = fa(o, t, t, r, 0, void 0 === e ? 1 : da(e)), o;
}
}), sa("flat"), ua("Array", "flat");
const ga = {
DEFAULT_MOVE_OPTS: {
avoidCreeps: !1,
avoidObstacleStructures: !0,
avoidSourceKeepers: !0,
keepTargetInRoom: !0,
repathIfStuck: 3,
roadCost: 1,
plainCost: 2,
swampCost: 10,
priority: 1,
defaultRoomCost: 2,
highwayRoomCost: 1,
sourceKeeperRoomCost: 2,
maxRooms: 64,
maxOps: 1e5,
maxOpsPerRoom: 2e3
},
DEFAULT_VISUALIZE_OPTS: {
fill: "transparent",
stroke: "#fff",
lineStyle: "dashed",
strokeWidth: .15,
opacity: .1
},
MEMORY_CACHE_PATH: "_cg",
MEMORY_CACHE_EXPIRATION_PATH: "_cge",
MEMORY_PORTAL_PATH: "_cgp"
}, ha = new Map, va = new Map, Ra = {
set(e, t, r) {
ha.set(e, t), void 0 !== r && va.set(e, r);
},
get: e => ha.get(e),
expires: e => va.get(e),
delete(e) {
ha.delete(e);
},
with: () => Ra,
clean() {
for (const [e, t] of va) Game.time >= t && (Ra.delete(e), va.delete(e));
}
}, Ea = (() => {
const e = 15, t = [ 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216, 33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648, 4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472, 274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104, 8796093022208, 17592186044416, 35184372088832, 70368744177664, 0x800000000000, 281474976710656, 562949953421312, 0x4000000000000, 0x8000000000000, 4503599627370496, 9007199254740992 ], r = t[15];
class o extends RangeError {
constructor(e) {
super("[utf15][RangeError]: " + e);
}
}
class n extends TypeError {
constructor(e) {
super("[utf15][TypeError]: " + e);
}
}
const a = (e, t, ...r) => {
if (!e) throw new t(r.reduce((e, t) => e + t + " ", ""));
}, i = e => (a((e = +e) >= 0 && e < r, o, "x out of bounds:", e), e + 48), s = e => (a((e = +e) >= 0 && e <= 65535, o, "x out of bounds:", e), 
e - 48);
function c(r, o) {
const s = Array.isArray(this.depth), c = s ? 0 : this.depth, l = s ? this.depth : [];
a(c || l.length === o.length, n, "Wrong depths array length:", l, o), s || (r += String.fromCodePoint(i(o.length)));
let u = 0, f = 0;
for (let n = 0, a = o.length; n < a; ++n) {
const a = o[n], s = c || l[n];
for (let o = 0; o < s; ) {
const n = e - u, c = s - o, l = Math.min(n, c);
let m = Math.floor(a / t[o]);
m %= t[l], m *= t[u], f += m, o += l, u += l, u === e && (r += String.fromCodePoint(i(f)), 
u = f = 0);
}
}
return 0 !== u && (r += String.fromCodePoint(i(f))), r;
}
function l(r, o) {
a(!this.meta || o.depth > 0 || 0 === o.depth && Array.isArray(this.depth), n, "Array decoding error (check inputs and codec config)"), 
o.depth = o.depth || this.depth;
const i = Array.isArray(o.depth);
let c = 0, l = 0;
const u = i ? o.depth.length : s(r.codePointAt(c++)), f = i ? 0 : o.depth, m = i ? o.depth : [], p = new Array(u);
let d = 0, y = s(r.codePointAt(c++));
for (;l < u; ) {
const o = f || m[l];
let n = 0, a = 0;
for (;a < o; ) {
const i = e - d, f = o - a, m = Math.min(i, f);
let p = Math.floor(y / t[d]);
if (p %= t[m], p *= t[a], n += p, a += m, d += m, d === e) {
if (l + 1 === u && a === o) break;
y = s(r.codePointAt(c++)), d = 0;
}
}
a > 0 && (p[l++] = n);
}
return [ p, c ];
}
return {
Codec: class {
constructor(e) {
e = e || {}, this.meta = +!!e.meta, this.array = +!!e.array, this.depth = e.depth || 53, 
(e => {
let t = !1;
if (t = t || isNaN(e.meta) || 0 !== e.meta && 1 !== e.meta, t = t || isNaN(e.array) || 0 !== e.array && 1 !== e.array, 
t || (() => {
const r = Array.isArray(e.depth);
if (t = t || r && !e.array, t) return;
const o = e => isNaN(e) || e <= 0 || e > 53;
r ? e.depth.forEach((r, n) => {
e.depth[n] = +e.depth[n], t = t || o(r);
}) : (e.depth = +e.depth, t = t || o(e.depth));
})(), t) {
let t = "[JSON.stringify() ERROR]";
try {
t = JSON.stringify(e);
} finally {}
a(0, n, "Codec config is invalid:", t);
}
})(this);
}
encode(o) {
a((+Array.isArray(o) | +!!o.BYTES_PER_ELEMENT) ^ !this.array, n, "Incompatible codec (array <=> single value), arg =", o);
let s = "";
if (this.meta && (s = ((e, t) => {
const r = Array.isArray(t.depth) ? 0 : t.depth;
return e + String.fromCodePoint(i(t.array), i(r));
})(s, this)), this.array) s = c.call(this, s, o); else {
let n = +o % t[this.depth];
const a = Math.ceil(this.depth / e);
for (let e = 0; e < a; ++e) {
const e = i(n % r);
s += String.fromCodePoint(e), n = Math.floor(n / r);
}
}
return s;
}
decode(r, o) {
let i = null, c = 0;
if (this.meta ? [r, c] = ((e, t, r) => (r = r || 0, t.array = s(e.codePointAt(r)), 
t.depth = s(e.codePointAt(r + 1)), [ e.slice(r + 2), 2 ]))(r, i = {}) : i = this, 
a(i.array ^ !this.array, n, "Incompatible codec (array <=> single value), str =", r), 
this.array) {
const e = l.call(this, r, i);
return o && (o.length = c + e[1]), e[0];
}
let u = 0, f = 0;
const m = Math.ceil(i.depth / e);
for (let o = 0; o < m; ++o) u += s(r.codePointAt(o)) * t[f], f += e;
return o && (o.length = c + m), u;
}
},
MAX_DEPTH: 53
};
})();
var Ta = Ea;
const Sa = new Ta.Codec({
array: !1
}), Ca = {
key: "ns",
serialize(e) {
if (void 0 !== e) return Sa.encode(e);
},
deserialize(e) {
if (void 0 !== e) return Sa.decode(e);
}
}, ba = (e, t) => `cg_${e.key}_${t}`, _a = (e, t) => Object.assign(Object.assign({}, e), {
get(r) {
var o;
const n = e.get(r);
if (n) try {
const e = null !== (o = Ra.get(ba(t, n))) && void 0 !== o ? o : t.deserialize(n);
return void 0 !== e && Ra.set(ba(t, n), e, Game.time + CREEP_LIFE_TIME), e;
} catch (o) {
return e.delete(r), void Ra.delete(ba(t, n));
}
},
set(r, o, n) {
const a = e.get(r);
a && Ra.delete(ba(t, a));
const i = t.serialize(o);
i ? (e.set(r, i, n), Ra.set(ba(t, i), o, Game.time + CREEP_LIFE_TIME)) : e.delete(r);
},
delete(r) {
const o = e.get(r);
o && Ra.delete(ba(t, o)), e.delete(r);
},
with: t => _a(e, t)
});
function Oa() {
var e, t;
return null !== (e = Memory[t = ga.MEMORY_CACHE_PATH]) && void 0 !== e || (Memory[t] = {}), 
Memory[ga.MEMORY_CACHE_PATH];
}
function wa() {
var e, t;
return null !== (e = Memory[t = ga.MEMORY_CACHE_EXPIRATION_PATH]) && void 0 !== e || (Memory[t] = {}), 
Memory[ga.MEMORY_CACHE_EXPIRATION_PATH];
}
const xa = {
set(e, t, r) {
if (Oa()[e] = t, void 0 !== r) {
const t = Ca.serialize(r);
t && (wa()[e] = t);
}
},
get: e => Oa()[e],
expires: e => Ca.deserialize(wa()[e]),
delete(e) {
delete Oa()[e];
},
with: e => _a(xa, e),
clean() {
const e = wa();
for (const t in e) {
const r = Ca.deserialize(e[t]);
void 0 !== r && Game.time >= r && (xa.delete(t), delete e[t]);
}
}
}, Ua = (e, t, r = 1 / 0) => {
let o = new Map, n = Game.time;
return (...a) => {
Game.time >= n + r && (n = Game.time, o = new Map);
const i = e(...a);
return o.has(i) || o.set(i, t(...a)), o.get(i);
};
}, Ma = (e, t) => Ua(e, t, 1), Aa = Ua(e => e, e => {
for (let t = 2; t < e.length; t++) if ("N" === e[t] || "S" === e[t]) {
const r = e[0], o = e[t];
let n = parseInt(e.slice(1, t)), a = parseInt(e.slice(t + 1));
return "W" === r && (n = -n - 1), "N" === o && (a = -a - 1), n += 128, a += 128, 
n << 8 | a;
}
throw new Error(`Invalid room name ${e}`);
}), ka = (e, t, r) => {
const o = Object.create(RoomPosition.prototype);
return o.__packedPos = Aa(r) << 16 | e << 8 | t, o;
}, Na = (e, t, r) => {
const o = Object.create(RoomPosition.prototype);
return o.__packedPos = 4294901760 & e.__packedPos | t << 8 | r, o;
}, Pa = (e, t, r) => {
const o = e.__packedPos >> 8 & 255, n = 255 & e.__packedPos, a = Object.create(RoomPosition.prototype);
return a.__packedPos = 4294901760 & e.__packedPos | o + t << 8 | n + r, a;
}, Ia = new Ta.Codec({
array: !1,
depth: 28
}), Ga = new Ta.Codec({
array: !0,
depth: 12
}), La = new Ta.Codec({
depth: 3,
array: !0
}), Da = new Ta.Codec({
array: !0,
depth: 16
}), Fa = [ "WN", "EN", "WS", "ES" ], Ba = e => {
const t = (65280 & e.__packedPos) >> 8, r = 255 & e.__packedPos, o = e.__packedPos >>> 4 & 4294963200 | t << 6 | r;
return Ia.encode(o);
}, ja = function(e) {
const t = Ia.decode(e), r = t << 4 & 4294901760 | (4032 & t) >> 6 << 8 | 63 & t, o = Object.create(RoomPosition.prototype);
if (o.__packedPos = r, o.x > 49 || o.y > 49) throw new Error("Invalid room position");
return o;
}, Ha = e => Ya([ e ]), Wa = e => Ka(e)[0], Ya = e => Ga.encode(e.map(e => e.x << 6 | e.y)), Ka = e => Ga.decode(e).map(e => {
const t = {
x: (4032 & e) >> 6,
y: 63 & e
};
if (t.x > 49 || t.y > 49) throw new Error("Invalid packed coord");
return t;
}), Va = e => e.map(e => Ba(e)).join(""), za = e => {
var t;
return null === (t = e.match(/.{1,2}/g)) || void 0 === t ? void 0 : t.map(e => ja(e));
}, qa = e => {
let t = e.match(/^([WE])([0-9]+)([NS])([0-9]+)$/);
if (!t) throw new Error("Invalid room name");
let [, r, o, n, a] = t;
return {
wx: "W" == r ? ~Number(o) : Number(o),
wy: "N" == n ? ~Number(a) : Number(a)
};
}, Xa = (e, t) => `${e < 0 ? "W" : "E"}${e = e < 0 ? ~e : e}${t < 0 ? "N" : "S"}${t = t < 0 ? ~t : t}`, Qa = e => {
let {x: t, y: r, roomName: o} = e;
if (t < 0 || t >= 50) throw new RangeError("x value " + t + " not in range");
if (r < 0 || r >= 50) throw new RangeError("y value " + r + " not in range");
if ("sim" == o) throw new RangeError("Sim room does not have world position");
let {wx: n, wy: a} = qa(o);
return {
x: 50 * Number(n) + t,
y: 50 * Number(a) + r
};
}, Za = e => {
let [t, r] = [ Math.floor(e.x / 50), e.x % 50 ], [o, n] = [ Math.floor(e.y / 50), e.y % 50 ];
t < 0 && r < 0 && (r = 49 - ~r), o < 0 && n < 0 && (n = 49 - ~n);
let a = Xa(t, o);
return ka(r, n, a);
}, Ja = (e, t) => {
if (e.roomName === t.roomName) return e.getRangeTo(t);
let r = Qa(e), o = Qa(t);
return Math.max(Math.abs(r.x - o.x), Math.abs(r.y - o.y));
};
function $a(e, t) {
const r = [ {
x: 0,
y: -1
}, {
x: 1,
y: -1
}, {
x: 1,
y: 0
}, {
x: 1,
y: 1
}, {
x: 0,
y: 1
}, {
x: -1,
y: 1
}, {
x: -1,
y: 0
}, {
x: -1,
y: -1
} ][t - 1];
let o = e.x + r.x, n = e.y + r.y, a = e.roomName;
if (o < 0) {
const {wx: t, wy: r} = qa(e.roomName);
a = Xa(t - 1, r), o = 49;
} else if (o > 49) {
const {wx: t, wy: r} = qa(e.roomName);
a = Xa(t + 1, r), o = 0;
} else if (n < 0) {
const {wx: t, wy: r} = qa(e.roomName);
a = Xa(t, r - 1), n = 49;
} else if (n > 49) {
const {wx: t, wy: r} = qa(e.roomName);
a = Xa(t, r + 1), n = 0;
}
return a === e.roomName ? Na(e, o, n) : ka(o, n, a);
}
const ei = e => Da.encode(e.map(e => {
const [t, r, o, n, a] = e.split(/([A-Z])([0-9]+)([A-Z])([0-9]+)/);
return Fa.indexOf(r + n) << 14 | parseInt(o) << 7 | parseInt(a);
})), ti = e => Da.decode(e).map(e => {
const t = e >> 14, r = e >> 7 & 127, o = 127 & e, [n, a] = Fa[t].split("");
return `${n}${r}${a}${o}`;
}), ri = e => ei([ e ]), oi = e => ti(e)[0], ni = new Ta.Codec({
array: !1,
depth: 15
}), ai = {
key: "mts",
serialize(e) {
if (void 0 !== e) return `${Ba(e.pos)}${ni.encode(e.range)}`;
},
deserialize(e) {
if (void 0 !== e) return {
pos: ja(e.slice(0, 2)),
range: ni.decode(e.slice(2))
};
}
}, ii = {
key: "mtls",
serialize(e) {
if (void 0 !== e) return e.map(e => ai.serialize(e)).join("");
},
deserialize(e) {
if (void 0 === e) return;
const t = [];
for (let r = 0; r < e.length; r += 3) {
const o = ai.deserialize(e.slice(r, r + 3));
o && t.push(o);
}
return t;
}
}, si = {
key: "ps",
serialize(e) {
if (void 0 !== e) return Ba(e);
},
deserialize(e) {
if (void 0 !== e) return ja(e);
}
}, ci = {
key: "pls",
serialize(e) {
if (void 0 !== e) return Va(e);
},
deserialize(e) {
if (void 0 !== e) return za(e);
}
}, li = {
key: "cs",
serialize(e) {
if (void 0 !== e) return Ha(e);
},
deserialize(e) {
if (void 0 !== e) return Wa(e);
}
}, ui = {
key: "cls",
serialize(e) {
if (void 0 !== e) return Ya(e);
},
deserialize(e) {
if (void 0 !== e) return Ka(e);
}
};
function fi() {
xa.clean(), Ra.clean();
}
const mi = {
HeapCache: Ra,
MemoryCache: xa
};
class pi extends Set {
constructor() {
super(...arguments), this.map = new Map;
}
add(e) {
return this.map.set(e.__packedPos, e), this;
}
delete(e) {
return this.map.delete(e.__packedPos);
}
has(e) {
return this.map.has(e.__packedPos);
}
clear() {
this.map.clear();
}
* entries() {
for (const e of this.map.values()) yield [ e, e ];
}
values() {
return this.map.values();
}
keys() {
return this.map.values();
}
[Symbol.iterator]() {
return this.map.values();
}
get size() {
return this.map.size;
}
}
const di = e => 0 === e.x || 0 === e.y || 49 === e.x || 49 === e.y, yi = Ua((e, t = !0, r = !1) => {
let o = `${t}${r}`;
return Array.isArray(e) ? e.length && "pos" in e[0] ? o += e.map(e => `${e.pos.__packedPos}_${e.range}`).join(",") : o += e.map(e => e.__packedPos).join(",") : o += "pos" in e ? "range" in e ? `${e.pos.__packedPos}_${e.range}` : `${e.pos.__packedPos}_1` : `${e.__packedPos}_1`, 
o;
}, (e, t = !0, r = !1) => {
let o = [];
if (Array.isArray(e) ? e.length && "pos" in e[0] ? o.push(...e) : o.push(...e.map(e => ({
pos: e,
range: 0
}))) : "pos" in e ? "range" in e ? o.push(e) : o.push({
pos: e.pos,
range: 1
}) : o.push({
pos: e,
range: 1
}), t && (o = o.flatMap(gi)), r) {
const e = new pi;
for (const {pos: r, range: n} of o) Ei(r, n + 1).filter(e => !!Si(e, !0, !1) && (!t || e.roomName === r.roomName && !di(e))).forEach(t => e.add(t));
for (const t of e) o.some(e => e.pos.inRangeTo(t, e.range)) && e.delete(t);
o = [ ...e ].map(e => ({
pos: e,
range: 0
}));
}
return o;
});
function gi({pos: e, range: t}) {
if (0 === t || e.x > t && 49 - e.x > t && e.y > t && 49 - e.y > t) return [ {
pos: e,
range: t
} ];
const r = Math.max(1, e.x - t), o = Math.min(48, e.x + t), n = Math.max(1, e.y - t), a = Math.min(48, e.y + t), i = o - r + 1, s = a - n + 1, c = Math.floor((Math.min(i, s) - 1) / 2), l = Math.floor(i / (c + 1)), u = Math.floor(s / (c + 1)), f = new Set(Array(l).fill(0).map((e, t) => Math.min(o - c, r + c + t * (2 * c + 1)))), m = new Set(Array(u).fill(0).map((e, t) => Math.min(a - c, n + c + t * (2 * c + 1)))), p = [];
for (const t of f) for (const r of m) p.push({
pos: Na(e, t, r),
range: c
});
return p;
}
const hi = (e = 1) => {
let t = new Array(2 * e + 1).fill(0).map((t, r) => r - e);
return t.flatMap(e => t.map(t => ({
x: e,
y: t
}))).filter(e => !(0 === e.x && 0 === e.y));
}, vi = e => Ri(e, 1), Ri = (e, t, r = !1) => {
if (0 === t) return [ e ];
let o = [];
return o = hi(t).map(t => e.x + t.x < 0 || e.x + t.x > 49 || e.y + t.y < 0 || e.y + t.y > 49 ? null : Pa(e, t.x, t.y)).filter(e => null !== e), 
r && o.push(e), o;
}, Ei = (e, t) => {
const r = Qa(e);
let o = [];
for (let e = r.x - t; e <= r.x + t; e++) o.push(Za({
x: e,
y: r.y - t
})), o.push(Za({
x: e,
y: r.y + t
}));
for (let e = r.y - t + 1; e <= r.y + t - 1; e++) o.push(Za({
x: r.x - t,
y: e
})), o.push(Za({
x: r.x + t,
y: e
}));
return o;
}, Ti = (e, t = !1) => vi(e).filter(e => Si(e, t)), Si = (e, t = !1, r = !1) => {
let o;
try {
o = Game.map.getRoomTerrain(e.roomName);
} catch (e) {
return !1;
}
return !(o.get(e.x, e.y) === TERRAIN_MASK_WALL || Game.rooms[e.roomName] && e.look().some(e => !(t || e.type !== LOOK_CREEPS && e.type !== LOOK_POWER_CREEPS) || !(r || !e.constructionSite || !e.constructionSite.my || !OBSTACLE_OBJECT_TYPES.includes(e.constructionSite.structureType)) || !(r || !e.structure || !(OBSTACLE_OBJECT_TYPES.includes(e.structure.structureType) || e.structure instanceof StructureRampart && !e.structure.my))));
}, Ci = e => {
let t = e.match(/^[WE]([0-9]+)[NS]([0-9]+)$/);
if (!t) throw new Error("Invalid room name");
return Number(t[1]) % 10 == 0 || Number(t[2]) % 10 == 0;
}, bi = e => {
let t = e.match(/^[WE]([0-9]+)[NS]([0-9]+)$/);
if (!t) throw new Error("Invalid room name");
let r = Number(t[1]) % 10, o = Number(t[2]) % 10;
return !(5 === r && 5 === o) && r >= 4 && r <= 6 && o >= 4 && o <= 6;
}, _i = (e, t, r) => r ? e.slice(0, t) : e.slice(t + 1), Oi = e => "_ck" + e;
function wi(e) {
bi(e) && !xa.get(Oi(e)) && xa.with(ci).set(Oi(e), [ ...Game.rooms[e].find(FIND_SOURCES), ...Game.rooms[e].find(FIND_MINERALS) ].map(e => e.pos));
}
class xi extends Map {
get(e) {
return super.get(e.x << 6 | e.y);
}
set(e, t) {
return super.set(e.x << 6 | e.y, t), this;
}
delete(e) {
return super.delete(e.x << 6 | e.y);
}
has(e) {
return super.has(e.x << 6 | e.y);
}
* entries() {
for (const [e, t] of super.entries()) {
const r = {
x: e >> 6,
y: 63 & e
};
yield [ r, t ];
}
}
values() {
return super.values();
}
* keys() {
for (const e of super.keys()) {
const t = {
x: e >> 6,
y: 63 & e
};
yield t;
}
}
[Symbol.iterator]() {
return this.entries();
}
}
class Ui extends xi {
constructor() {
super(...arguments), this.reversed = new xi;
}
set(e, t) {
return this.reversed.set(t, e), super.set(e, t);
}
delete(e) {
const t = this.get(e);
return t && this.reversed.delete(t), super.delete(e);
}
clear() {
this.reversed.clear(), super.clear();
}
}
var Mi, Ai, ki, Ni;
const Pi = new Ta.Codec({
array: !1,
depth: 30
}), Ii = new Map;
null !== (Mi = Memory[Ni = ga.MEMORY_PORTAL_PATH]) && void 0 !== Mi || (Memory[Ni] = []);
for (const e of Memory[ga.MEMORY_PORTAL_PATH]) {
const t = Di(e), r = null !== (Ai = Ii.get(t.room1)) && void 0 !== Ai ? Ai : new Map;
r.set(t.room2, t), Ii.set(t.room1, r);
const o = null !== (ki = Ii.get(t.room2)) && void 0 !== ki ? ki : new Map;
o.set(t.room1, t), Ii.set(t.room2, o);
}
function Gi(e) {
var t, r, o, n, a;
if (!Ci(e) && !(e => {
let t = e.match(/^[WE]([0-9]+)[NS]([0-9]+)$/);
if (!t) throw new Error("Invalid room name");
return Number(t[1]) % 10 == 5 && Number(t[2]) % 10 == 5;
})(e)) return;
const i = new Set;
for (const o of function(e) {
var t;
if (!Game.rooms[e]) return [];
const r = new Map;
for (const o of Game.rooms[e].find(FIND_STRUCTURES, {
filter: {
structureType: STRUCTURE_PORTAL
}
})) {
if (!(o.destination instanceof RoomPosition)) continue;
const n = null !== (t = r.get(o.destination.roomName)) && void 0 !== t ? t : {
room1: e,
room2: o.destination.roomName,
portalMap: new Ui
};
r.set(o.destination.roomName, n), n.portalMap.set(o.pos, o.destination), o.ticksToDecay ? n.expires = Game.time + o.ticksToDecay : delete n.expires;
}
return [ ...r.values() ];
}(e)) (null !== (t = Ii.get(o.room1)) && void 0 !== t ? t : new Map).set(o.room2, o), 
(null !== (r = Ii.get(o.room2)) && void 0 !== r ? r : new Map).set(o.room1, o), 
i.add(o.room2);
const s = Ii.get(e);
for (const t of null !== (o = null == s ? void 0 : s.keys()) && void 0 !== o ? o : []) i.has(t) || (null === (n = Ii.get(e)) || void 0 === n || n.delete(t), 
null === (a = Ii.get(t)) || void 0 === a || a.delete(e));
}
function Li(e) {
var t;
let r = "";
return r += ri(e.room1), r += ri(e.room2), r += Pi.encode(null !== (t = e.expires) && void 0 !== t ? t : 0), 
r += Ya([ ...e.portalMap.entries() ].flat()), r;
}
function Di(e) {
const t = oi(e.slice(0, 3)), r = oi(e.slice(3, 6)), o = Pi.decode(e.slice(6, 8)), n = new Ui, a = Ka(e.slice(8));
for (let e = 0; e < a.length; e += 2) n.set(a[e], a[e + 1]);
return {
room1: t,
room2: r,
expires: 0 !== o ? o : void 0,
portalMap: n
};
}
function Fi(e) {
var t;
const r = new Set(Object.values(null !== (t = Game.map.describeExits(e)) && void 0 !== t ? t : {})), o = Ii.get(e);
if (!o) return [ ...r ];
for (const e of o.values()) r.add(e.room2);
return [ ...r ];
}
const Bi = new Ta.Codec({
array: !1,
depth: 15
}), ji = (e, t) => {
var r;
if (!e || !e.length) throw new Error("Empty id");
let o = e;
o.length % 3 != 0 && (o = o.padStart(3 * Math.ceil(o.length / 3), "0"));
let n = "";
for (let e = 0; e < o.length; e += 3) n += Bi.encode(parseInt(o.slice(e, e + 3), 16));
return null !== (r = n + t) && void 0 !== r ? r : "";
}, Hi = (e, t) => ji(e.id, t);
var Wi = Object.freeze({
__proto__: null,
creepKey: Hi,
objectIdKey: ji,
roomKey: (e, t) => ri(e) + (null != t ? t : "")
});
const Yi = (e, t) => r => {
var o;
if (t && !t.includes(r)) return !1;
let n = null === (o = e.roomCallback) || void 0 === o ? void 0 : o.call(e, r);
return !1 === n ? n : ((e, t, r) => {
var o, n, a, i, s, c, l;
if (r.avoidCreeps && (null === (o = Game.rooms[t]) || void 0 === o || o.find(FIND_CREEPS).forEach(t => e.set(t.pos.x, t.pos.y, 255)), 
null === (n = Game.rooms[t]) || void 0 === n || n.find(FIND_POWER_CREEPS).forEach(t => e.set(t.pos.x, t.pos.y, 255))), 
r.avoidSourceKeepers && function(e, t) {
var r;
const o = null !== (r = xa.with(ci).get(Oi(e))) && void 0 !== r ? r : [];
for (const e of o) Ri(e, 5, !0).forEach(e => t.set(e.x, e.y, 255));
}(t, e), (r.avoidObstacleStructures || r.roadCost) && (r.avoidObstacleStructures && (null === (a = Game.rooms[t]) || void 0 === a || a.find(FIND_MY_CONSTRUCTION_SITES).forEach(t => {
OBSTACLE_OBJECT_TYPES.includes(t.structureType) && e.set(t.pos.x, t.pos.y, 255);
})), null === (i = Game.rooms[t]) || void 0 === i || i.find(FIND_STRUCTURES).forEach(t => {
r.avoidObstacleStructures && (OBSTACLE_OBJECT_TYPES.includes(t.structureType) || t.structureType === STRUCTURE_RAMPART && !t.my && !t.isPublic) && e.set(t.pos.x, t.pos.y, 255), 
r.roadCost && t instanceof StructureRoad && 0 === e.get(t.pos.x, t.pos.y) && e.set(t.pos.x, t.pos.y, r.roadCost);
})), r.avoidTargets) {
const o = Game.map.getRoomTerrain(t);
for (const n of r.avoidTargets(t)) for (const t of Ri(n.pos, n.range, !0)) if (o.get(t.x, t.y) !== TERRAIN_MASK_WALL) {
const o = 254 - t.getRangeTo(n.pos) * (null !== (s = r.avoidTargetGradient) && void 0 !== s ? s : 0);
e.set(t.x, t.y, Math.max(e.get(t.x, t.y), o));
}
}
return r.ignorePortals || [ ...null !== (l = null === (c = Ii.get(t)) || void 0 === c ? void 0 : c.values()) && void 0 !== l ? l : [] ].flatMap(e => t === e.room1 ? [ ...e.portalMap.keys() ] : [ ...e.portalMap.reversed.keys() ]).forEach(t => e.set(t.x, t.y, 255)), 
e;
})(n instanceof PathFinder.CostMatrix ? n.clone() : new PathFinder.CostMatrix, r, e);
};
function Ki(e, t) {
const r = Game.map.getRoomTerrain(e);
let o = !1;
for (let e = 0; e < 25; e++) {
const {x: n, y: a} = Vi(t, e);
if (r.get(n, a) !== TERRAIN_MASK_WALL) {
o = !0;
break;
}
}
let n = !1;
for (let e = 25; e < 49; e++) {
const {x: o, y: a} = Vi(t, e);
if (r.get(o, a) !== TERRAIN_MASK_WALL) {
n = !0;
break;
}
}
return [ o, n ];
}
function Vi(e, t) {
return e === FIND_EXIT_TOP ? {
x: t,
y: 0
} : e === FIND_EXIT_BOTTOM ? {
x: t,
y: 49
} : e === FIND_EXIT_LEFT ? {
x: 0,
y: t
} : {
x: 49,
y: t
};
}
class zi {
constructor() {
this.queue = [];
}
put(e, t) {
let r = this.queue.findIndex(([e]) => e > t);
-1 === r && (r = this.queue.length), this.queue.splice(r, 0, [ t, e ]);
}
take() {
var e;
return null === (e = this.queue.shift()) || void 0 === e ? void 0 : e[1];
}
* [Symbol.iterator]() {
for (const [e, t] of this.queue) yield t;
}
}
const qi = Ma((e, t) => e + t, (e, t) => {
const {wx: r, wy: o} = qa(e), {wx: n, wy: a} = qa(t);
return Math.abs(r - n) + Math.abs(o - a);
}), Xi = Ma(e => e, e => {
let t = 1 / 0;
for (const r of Ii.keys()) t = Math.min(t, qi(e, r));
return t;
});
function Qi(e, t) {
return Math.min(qi(e, t), Xi(e) + Xi(t));
}
function Zi(e, t, r) {
var o, n, a, i, s, c, l, u;
let f = Object.assign(Object.assign({}, ga.DEFAULT_MOVE_OPTS), r);
(null == r ? void 0 : r.creepMovementInfo) && (f = Object.assign(Object.assign({}, f), function(e) {
const t = {
roadCost: ga.DEFAULT_MOVE_OPTS.roadCost || 1,
plainCost: ga.DEFAULT_MOVE_OPTS.plainCost || 2,
swampCost: ga.DEFAULT_MOVE_OPTS.swampCost || 10
};
let r = e.usedCapacity, o = 0, n = 0, a = 0;
for (let t = e.body.length - 1; t >= 0; t--) {
const i = e.body[t];
if (i.type !== MOVE && i.type !== CARRY) a++; else {
if (i.hits <= 0) continue;
if (i.type === MOVE) {
let e = 1;
i.boost && (e = BOOSTS[MOVE][i.boost].fatigue), o += 1 * e;
} else if (r > 0 && i.type === CARRY) {
let e = 1;
i.boost && (e = BOOSTS[CARRY][i.boost].capacity), r -= CARRY_CAPACITY * e, n++;
}
}
}
if (o > 0) {
const e = n + a, r = 2 * o, i = Math.max(e / r, .1), s = Math.ceil(i), c = Math.ceil(2 * i), l = Math.ceil(10 * i), u = (...e) => [ ...e ].reduce((e, t) => {
return r = e, (o = t) ? u(o, r % o) : r;
var r, o;
}), f = u(s, c, l);
t.roadCost = s / f, t.plainCost = c / f, t.swampCost = l / f;
}
return t;
}(r.creepMovementInfo)));
const m = t.reduce((e, {pos: t}) => e.includes(t.roomName) ? e : [ t.roomName, ...e ], []);
let p = function(e, t, r) {
const o = Object.assign(Object.assign({}, ga.DEFAULT_MOVE_OPTS), r), n = Ua((e, t) => e + t, (e, t) => {
var r;
const n = null === (r = o.routeCallback) || void 0 === r ? void 0 : r.call(o, e, t);
return void 0 !== n ? n : Ci(e) ? o.highwayRoomCost : bi(e) ? o.sourceKeeperRoomCost : o.defaultRoomCost;
}), a = function(e, t, r, o) {
var n, a;
if (t.includes(e)) return [];
const i = null !== (n = null == r ? void 0 : r.routeCallback) && void 0 !== n ? n : () => 1, s = new zi;
s.put(e, 0);
const c = new Map, l = new Map;
c.set(e, e), l.set(e, 0);
let u = s.take();
for (;u && !t.includes(u); ) {
for (const e of Fi(u)) {
const r = l.get(u) + i(u, e);
if (r !== 1 / 0 && (!l.has(e) || r < l.get(e))) {
l.set(e, r);
const o = r + Math.min(...t.map(t => Qi(e, t)));
s.put(e, o), c.set(e, u);
}
}
u = s.take();
}
if (u && t.includes(u)) {
const t = [];
let r = [ {
room: u
} ];
for (;u !== e; ) {
const e = c.get(u), n = null === (a = Ii.get(e)) || void 0 === a ? void 0 : a.get(u);
if (n && !o) t.unshift(r), r = [ {
room: e,
portalSet: n
} ]; else {
const t = Game.map.findExit(e, u);
r.unshift({
room: e,
exit: t === ERR_NO_PATH ? void 0 : t
});
}
u = e;
}
return t.unshift(r), t;
}
return ERR_NO_PATH;
}(e, t, {
routeCallback: n
}, o.avoidPortals);
if (a !== ERR_NO_PATH) return a.map(e => {
var t;
const r = function(e, t, r) {
var o;
let n = new Set(e.map(({room: e}) => e));
const a = r.maxRooms;
for (let i = 0; i < e.length - 1 && !(n.size >= a) && e[i].exit; i++) {
if (e[i].exit !== e[i + 1].exit) {
const r = Game.map.describeExits(e[i].room)[e[i + 1].exit];
r && Game.map.findExit(r, e[i + 1].room) > 0 && t(r, e[i].room) !== 1 / 0 && n.add(r);
}
if (!(e[i].exit !== e[i + 1].exit && e[i + 1].exit || (null === (o = e[i + 2]) || void 0 === o ? void 0 : o.exit) && e[i].exit !== e[i + 2].exit)) {
if (n.size >= r.maxRooms - 1) continue;
const o = Ki(e[i].room, e[i].exit);
if (o.every(e => e)) continue;
let a;
if (o[0] || e[i].exit !== FIND_EXIT_TOP && e[i].exit !== FIND_EXIT_BOTTOM ? o[1] || e[i].exit !== FIND_EXIT_TOP && e[i].exit !== FIND_EXIT_BOTTOM ? o[0] || e[i].exit !== FIND_EXIT_LEFT && e[i].exit !== FIND_EXIT_RIGHT ? o[1] || e[i].exit !== FIND_EXIT_LEFT && e[i].exit !== FIND_EXIT_RIGHT || (a = FIND_EXIT_BOTTOM) : a = FIND_EXIT_TOP : a = FIND_EXIT_RIGHT : a = FIND_EXIT_LEFT, 
!a) throw new Error("Invalid exit tile state: " + e[i].exit + JSON.stringify(o));
const s = Game.map.describeExits(e[i].room)[a], c = Game.map.describeExits(e[i + 1].room)[a];
s && c && Game.map.findExit(s, c) > 0 && t(s, e[i].room) !== 1 / 0 && t(c, e[i + 1].room) !== 1 / 0 && (n.add(s), 
n.add(c));
}
}
const i = [ ...n ];
for (;n.size < a; ) {
const e = i.shift();
if (!e) break;
const r = Game.map.describeExits(e);
if (r) for (const o of Object.values(r)) n.has(o) || t(o, e) !== 1 / 0 && (n.add(o), 
i.push(o));
}
return [ ...n ];
}(e, n, o);
return {
rooms: r,
portalSet: null === (t = e[e.length - 1]) || void 0 === t ? void 0 : t.portalSet
};
});
}(e.roomName, m, f);
if ((null == p ? void 0 : p.length) && 1 !== p.length) {
let r = e;
const o = [];
for (const e of p) if (e.portalSet) {
const t = e.rooms.includes(e.portalSet.room1) ? e.portalSet.room1 : e.portalSet.room2, n = (t === e.portalSet.room1 ? [ ...e.portalSet.portalMap.keys() ] : [ ...e.portalSet.portalMap.values() ]).map(e => ({
pos: new RoomPosition(e.x, e.y, t),
range: 1
})), a = PathFinder.search(r, n, Object.assign(Object.assign({}, f), {
maxOps: Math.min(null !== (l = f.maxOps) && void 0 !== l ? l : 1e5, (null !== (u = f.maxOpsPerRoom) && void 0 !== u ? u : 2e3) * e.rooms.length),
roomCallback: Yi(f, e.rooms)
}));
if (!a.path.length || a.incomplete) return;
const i = n.find(e => e.pos.isNearTo(a.path[a.path.length - 1])).pos;
if (o.push(...a.path, i), e.portalSet.room1 === t) {
const t = e.portalSet.portalMap.get(i);
if (!t) throw new Error(`Portal ${i} not found in portalSet ${JSON.stringify(e.portalSet)}`);
r = new RoomPosition(t.x, t.y, e.portalSet.room2);
} else {
const t = e.portalSet.portalMap.reversed.get(i);
if (!t) throw new Error(`Portal ${i} not found in portalSet ${JSON.stringify(e.portalSet)}`);
r = new RoomPosition(t.x, t.y, e.portalSet.room1);
}
} else {
const n = PathFinder.search(r, t, Object.assign(Object.assign({}, f), {
maxOps: Math.min(null !== (s = f.maxOps) && void 0 !== s ? s : 1e5, (null !== (c = f.maxOpsPerRoom) && void 0 !== c ? c : 2e3) * e.rooms.length),
roomCallback: Yi(f, e.rooms)
}));
if (!n.path.length || n.incomplete) return;
o.push(...n.path);
}
return o;
}
{
const r = null === (o = null == p ? void 0 : p[0]) || void 0 === o ? void 0 : o.rooms, s = PathFinder.search(e, t, Object.assign(Object.assign({}, f), {
maxOps: Math.min(null !== (n = f.maxOps) && void 0 !== n ? n : 1e5, (null !== (a = f.maxOpsPerRoom) && void 0 !== a ? a : 2e3) * (null !== (i = null == r ? void 0 : r.length) && void 0 !== i ? i : 1)),
roomCallback: Yi(f, r)
}));
if (!s.path.length || s.incomplete) return;
return s.path;
}
}
let Ji = new Map, $i = 0;
function es(e) {
var t;
return Game.time !== $i && ($i = Game.time, Ji = new Map), Ji.set(e, null !== (t = Ji.get(e)) && void 0 !== t ? t : {
creep: new Map,
priority: new Map,
targets: new Map,
pullers: new Set,
pullees: new Set,
prefersToStay: new Set,
blockedSquares: new Set
}), Ji.get(e);
}
function ts(e, t = !1) {
var r, o, n, a;
"fatigue" in e.creep && e.creep.fatigue && !t && (e.targets = [ e.creep.pos ]), 
null !== (r = e.targetCount) && void 0 !== r || (e.targetCount = e.targets.length);
const i = es(e.creep.pos.roomName);
!function(e) {
var t, r, o, n;
if (!e) return;
null !== (t = e.targetCount) && void 0 !== t || (e.targetCount = e.targets.length);
const a = es(e.creep.pos.roomName);
a.creep.delete(e.creep.id), null === (o = null === (r = a.priority.get(e.priority)) || void 0 === r ? void 0 : r.get(e.targets.length)) || void 0 === o || o.delete(e.creep.id);
for (const t of e.targets) {
const r = Ba(t);
null === (n = a.targets.get(r)) || void 0 === n || n.delete(e.creep.id);
}
}(i.creep.get(e.creep.id)), i.creep.set(e.creep.id, e);
const s = null !== (o = i.priority.get(e.priority)) && void 0 !== o ? o : new Map;
i.priority.set(e.priority, s);
const c = null !== (n = s.get(e.targets.length)) && void 0 !== n ? n : new Map;
s.set(e.targets.length, c), c.set(e.creep.id, e);
for (const t of e.targets) {
const r = Ba(t), o = null !== (a = i.targets.get(r)) && void 0 !== a ? a : new Map;
i.targets.set(r, o), o.set(e.creep.id, e);
}
e.targets.length && e.targets[0].isEqualTo(e.creep.pos) && i.prefersToStay.add(Ba(e.creep.pos));
}
function rs(e, t, r) {
var o, n, a;
const i = es(e.creep.pos.roomName), s = null !== (o = i.priority.get(e.priority)) && void 0 !== o ? o : new Map;
null === (n = s.get(t)) || void 0 === n || n.delete(e.creep.id), i.priority.set(e.priority, s);
const c = null !== (a = s.get(r)) && void 0 !== a ? a : new Map;
s.set(r, c), c.set(e.creep.id, e);
}
const os = e => {
const t = Game.cpu.getUsed();
return e(), Math.max(0, Game.cpu.getUsed() - t);
}, ns = "_crr";
function as() {
const e = xa.with(Ca).get(ns);
return Boolean(e && Game.time - 2 <= e);
}
let is = [];
function ss(e, t) {
var r, o, n, a, i, s, c, l;
const u = Game.cpu.getUsed();
let f = 0;
const m = es(e), p = m.blockedSquares;
if (null == t ? void 0 : t.visualize) for (const {creep: e, targets: t, priority: r} of m.creep.values()) t.forEach(t => {
t.isEqualTo(e.pos) ? Game.rooms[e.pos.roomName].visual.circle(e.pos, {
radius: .5,
stroke: "orange",
fill: "transparent"
}) : Game.rooms[e.pos.roomName].visual.line(e.pos, t, {
color: "orange"
});
});
for (const r of Game.rooms[e].find(FIND_MY_CREEPS).concat(Game.rooms[e].find(FIND_MY_POWER_CREEPS))) m.creep.has(r.id) || m.pullees.has(r.id) || m.pullers.has(r.id) || (ts({
creep: r,
priority: 0,
targets: [ r.pos, ...Ti(r.pos, !0) ]
}), (null == t ? void 0 : t.visualize) && Game.rooms[r.pos.roomName].visual.circle(r.pos, {
radius: 1,
stroke: "red",
fill: "transparent "
}));
for (const e of m.pullers) {
const t = Game.getObjectById(e);
if (!t) continue;
const a = Ba(t.pos);
p.add(a);
for (const t of null !== (o = null === (r = m.targets.get(a)) || void 0 === r ? void 0 : r.values()) && void 0 !== o ? o : []) {
if (t.creep.id === e) continue;
null !== (n = t.targetCount) && void 0 !== n || (t.targetCount = t.targets.length);
const r = t.targetCount;
t.targetCount -= 1, rs(t, r, t.targetCount);
}
}
const d = [ ...m.priority.entries() ].sort((e, t) => t[0] - e[0]);
for (const [e, r] of d) for (;r.size; ) {
const e = Math.min(...r.keys()), o = r.get(e);
if (!o) break;
o.size || r.delete(e);
const n = [ ...o.values() ];
for (;n.length; ) {
const e = n.shift();
if (!e) break;
if (e.resolved) {
o.delete(e.creep.id);
continue;
}
let r;
(null == t ? void 0 : t.visualize) && e.targets.forEach(t => {
t.isEqualTo(e.creep.pos) ? Game.rooms[e.creep.pos.roomName].visual.circle(e.creep.pos, {
radius: .5,
stroke: "yellow",
strokeWidth: .2,
fill: "transparent",
opacity: .2
}) : Game.rooms[e.creep.pos.roomName].visual.line(e.creep.pos, t, {
color: "yellow",
width: .2
});
});
for (const t of e.targets) {
const o = Ba(t);
if (!p.has(o) || e.creep.pos.isEqualTo(t) && m.pullers.has(e.creep.id)) {
if (e.creep.pos.isEqualTo(t) || !m.prefersToStay.has(o)) {
r = t;
break;
}
null != r || (r = t);
}
}
if (o.delete(e.creep.id), !r) {
(null == t ? void 0 : t.visualize) && Game.rooms[e.creep.pos.roomName].visual.line(e.creep.pos.x - .5, e.creep.pos.y - .5, e.creep.pos.x + .5, e.creep.pos.y + .5, {
color: "red"
}).line(e.creep.pos.x - .5, e.creep.pos.y + .5, e.creep.pos.x + .5, e.creep.pos.y - .5, {
color: "red"
});
continue;
}
f += os(() => e.creep.move(e.creep.pos.getDirectionTo(r))), e.resolved = !0, (null == t ? void 0 : t.visualize) && Game.rooms[e.creep.pos.roomName].visual.line(e.creep.pos, r, {
color: "green",
width: .5
});
const u = Ba(r);
p.add(u);
for (const e of null !== (i = null === (a = m.targets.get(u)) || void 0 === a ? void 0 : a.values()) && void 0 !== i ? i : []) {
if (e.resolved) continue;
null !== (s = e.targetCount) && void 0 !== s || (e.targetCount = e.targets.length);
const t = e.targetCount;
e.targetCount -= 1, rs(e, t, e.targetCount);
}
if (!r.isEqualTo(e.creep.pos) && !m.pullers.has(e.creep.id)) {
const o = Ba(e.creep.pos), a = [ ...null !== (l = null === (c = m.targets.get(o)) || void 0 === c ? void 0 : c.values()) && void 0 !== l ? l : [] ].filter(t => t !== e && t.targets.length < 2), i = a.find(e => !e.resolved && (null == r ? void 0 : r.isEqualTo(e.creep.pos)) && !m.pullers.has(e.creep.id));
i && ((null == t ? void 0 : t.visualize) && Game.rooms[i.creep.pos.roomName].visual.circle(i.creep.pos, {
radius: .2,
fill: "green"
}), a.filter(e => e.resolved).forEach(e => {
(null == t ? void 0 : t.visualize) && Game.rooms[e.creep.pos.roomName].visual.circle(e.creep.pos, {
radius: .2,
fill: "red"
});
}), p.delete(o), n.unshift(i));
}
}
}
const y = Math.max(0, Game.cpu.getUsed() - u);
is.push(f / y), is.length > 1500 && (is = is.slice(-1500));
}
function cs(e, t, r = 1) {
return e.pos ? as() ? (ts({
creep: e,
targets: t,
priority: r
}), OK) : t[0].isEqualTo(e.pos) ? OK : e.move(e.pos.getDirectionTo(t[0])) : ERR_INVALID_ARGS;
}
const ls = e => `_poi_${e}`, us = "_cpi";
function fs(e, t, r, o) {
var n;
const a = Object.assign(Object.assign({}, ga.DEFAULT_MOVE_OPTS), o), i = null !== (n = a.cache) && void 0 !== n ? n : xa, s = yi(r, null == o ? void 0 : o.keepTargetInRoom, null == o ? void 0 : o.flee);
if (null == o ? void 0 : o.visualizePathStyle) {
const e = Object.assign(Object.assign({}, ga.DEFAULT_VISUALIZE_OPTS), o.visualizePathStyle);
for (const t of s) new RoomVisual(t.pos.roomName).rect(t.pos.x - t.range - .5, t.pos.y - t.range - .5, 2 * t.range + 1, 2 * t.range + 1, e);
}
const c = i.with(ci).get(ls(e));
if (c) return c;
const l = Zi(t, s, Object.assign(Object.assign({}, a), {
flee: !1
}));
if (l) {
const t = a.reusePath ? Game.time + a.reusePath + 1 : void 0;
i.with(ci).set(ls(e), l, t);
}
return l;
}
function ms(e, t) {
var r;
return (null !== (r = null == t ? void 0 : t.cache) && void 0 !== r ? r : xa).with(ci).get(ls(e));
}
function ps(e, t) {
var r;
(null !== (r = null == t ? void 0 : t.cache) && void 0 !== r ? r : xa).delete(ls(e));
}
function ds(e, t, r) {
var o, n, a, i;
const s = (null !== (o = null == r ? void 0 : r.cache) && void 0 !== o ? o : xa).with(ci).get(ls(t));
if (!e.pos) return ERR_INVALID_ARGS;
if (!s) return ERR_NO_PATH;
if ((null == r ? void 0 : r.reverse) && e.pos.isEqualTo(s[0]) || !(null == r ? void 0 : r.reverse) && e.pos.isEqualTo(s[s.length - 1])) return OK;
let c = Ra.get(Hi(e, us));
if (void 0 !== c) {
let t = Math.max(0, Math.min(s.length - 1, (null == r ? void 0 : r.reverse) ? c - 1 : c + 1));
(null === (n = s[t]) || void 0 === n ? void 0 : n.isEqualTo(e.pos)) ? c = t : (null === (a = s[c]) || void 0 === a ? void 0 : a.isEqualTo(e.pos)) || (c = void 0);
}
if (void 0 === c) {
const t = s.findIndex(t => t.isEqualTo(e.pos));
-1 !== t && (c = t);
}
if (void 0 === c && !(null == r ? void 0 : r.reverse) && Ja(s[0], e.pos) <= 1 && (c = -1), 
void 0 === c && (null == r ? void 0 : r.reverse) && Ja(s[s.length - 1], e.pos) <= 1 && (c = s.length), 
void 0 === c) return ERR_NOT_FOUND;
Ra.set(Hi(e, us), c);
let l = Math.max(0, Math.min(s.length - 1, (null == r ? void 0 : r.reverse) ? c - 1 : c + 1));
if (null == r ? void 0 : r.visualizePathStyle) {
const t = Object.assign(Object.assign({}, ga.DEFAULT_VISUALIZE_OPTS), r.visualizePathStyle), o = _i(s, c, null == r ? void 0 : r.reverse);
null === (i = e.room) || void 0 === i || i.visual.poly(o.filter(t => {
var r;
return t.roomName === (null === (r = e.room) || void 0 === r ? void 0 : r.name);
}), t);
}
return cs(e, [ s[l] ], null == r ? void 0 : r.priority);
}
const ys = (e, t) => 0 !== e.length && 0 !== t.length && e.some(e => t.some(t => e.inRangeTo(t.pos, t.range))), gs = "_csp", hs = "_cst", Es = (e, t) => {
if (!e.pos) return !1;
if ("fatigue" in e && e.fatigue > 0) return !1;
const r = Ra.get(Hi(e, gs)), o = Ra.get(Hi(e, hs));
return Ra.set(Hi(e, gs), e.pos), r && o && e.pos.isEqualTo(r) ? o + t < Game.time : (Ra.set(Hi(e, hs), Game.time), 
!1);
}, Ts = {
key: "js",
serialize(e) {
if (void 0 !== e) return JSON.stringify(e);
},
deserialize(e) {
if (void 0 !== e) return JSON.parse(e);
}
}, Ss = "_cp", Cs = "_ct", bs = "_co", _s = [ "avoidCreeps", "avoidObstacleStructures", "flee", "plainCost", "swampCost", "roadCost" ];
function Os(e, t = mi.HeapCache) {
ps(Hi(e, Ss), {
cache: t
}), t.delete(Hi(e, Cs)), t.delete(Hi(e, bs));
}
const ws = (e, t, r, o = {
avoidCreeps: !0
}) => {
var n, a, i, s;
if (!e.pos) return ERR_INVALID_ARGS;
let c = Object.assign(Object.assign({}, ga.DEFAULT_MOVE_OPTS), r);
const l = null !== (n = null == r ? void 0 : r.cache) && void 0 !== n ? n : mi.HeapCache;
let u = yi(t, c.keepTargetInRoom, c.flee), f = !1, m = l.with(ii).get(Hi(e, Cs));
for (const {pos: t, range: o} of u) {
if (!f && t.inRangeTo(e.pos, o) && e.pos.roomName === t.roomName) {
if (!(null == r ? void 0 : r.flee)) {
Os(e, l);
const t = Yi(c)(e.pos.roomName);
return cs(e, [ e.pos, ...Ti(e.pos, !0).filter(e => u.some(t => t.pos.inRangeTo(e, t.range)) && (!t || 255 !== t.get(e.x, e.y))) ], c.priority), 
OK;
}
f = !0;
}
m && !m.some(e => e && t.isEqualTo(e.pos) && o === e.range) && (Os(e, l), m = void 0);
}
const p = l.with(Ts).get(Hi(e, bs));
p && !_s.some(e => c[e] !== p[e]) || Os(e, l);
const d = [ null == r ? void 0 : r.roadCost, null == r ? void 0 : r.plainCost, null == r ? void 0 : r.swampCost ].some(e => void 0 !== e);
"body" in e && !d && (c = Object.assign(Object.assign({}, c), {
creepMovementInfo: {
usedCapacity: e.store.getUsedCapacity(),
body: e.body
}
}));
const y = c.reusePath ? Game.time + c.reusePath + 1 : void 0;
l.with(ii).set(Hi(e, Cs), u, y), l.with(Ts).set(Hi(e, bs), _s.reduce((e, t) => (e[t] = c[t], 
e), {}), y);
const g = ms(Hi(e, Ss), {
cache: l
}), h = Ra.get(Hi(e, "_cpi")), v = g && _i(g, null != h ? h : 0), R = null !== (i = null === (a = c.avoidTargets) || void 0 === a ? void 0 : a.call(c, e.pos.roomName)) && void 0 !== i ? i : [];
if (c.repathIfStuck && g && Es(e, c.repathIfStuck)) ps(Hi(e, Ss), {
cache: l
}), c = Object.assign(Object.assign({}, c), o); else if ((null == v ? void 0 : v.length) && ys(v, R)) {
let t = 0;
v.forEach((e, r) => {
R.some(t => t.pos.inRangeTo(e, t.range)) && (t = r);
});
const r = v.slice(t), o = Zi(e.pos, r.map(e => ({
pos: e,
range: 0
})), Object.assign(Object.assign({}, c), {
cache: l,
flee: !1
}));
if (o) {
let t;
for (let e = 0; e < r.length; e++) if (o[o.length - 1].inRangeTo(r[e], 1)) t = e; else if (void 0 !== t) break;
void 0 === t ? ps(Hi(e, Ss), {
cache: l
}) : l.with(ci).set(ls(Hi(e, Ss)), o.concat(r.slice(t)), y);
} else ps(Hi(e, Ss), {
cache: l
});
}
const E = fs(Hi(e, Ss), e.pos, t, Object.assign(Object.assign({}, c), {
cache: l
}));
if (!E) return ERR_NO_PATH;
if (E && (null === (s = E[E.length - 2]) || void 0 === s ? void 0 : s.isEqualTo(e.pos))) {
let t = Yi(c)(e.pos.roomName);
const o = t instanceof PathFinder.CostMatrix ? e => t.get(e.x, e.y) < 254 : () => !0, n = (null == r ? void 0 : r.flee) ? e => u.every(t => t.pos.getRangeTo(e) >= t.range) : e => u.some(t => t.pos.inRangeTo(e, t.range)), a = Ti(e.pos, !0).filter(e => n(e) && o(e));
if (a.length) return cs(e, a, c.priority), OK;
}
let T = ds(e, Hi(e, Ss), Object.assign(Object.assign({}, c), {
reverse: !1,
cache: l
}));
return T === ERR_NOT_FOUND && (Os(e, l), fs(Hi(e, Ss), e.pos, u, Object.assign(Object.assign({}, c), {
cache: l
})), T = ds(e, Hi(e, Ss), Object.assign(Object.assign({}, c), {
reverse: !1,
cache: l
}))), T;
}, xs = "_rsi";
return Rs.CachingStrategies = mi, Rs.CoordListSerializer = ui, Rs.CoordSerializer = li, 
Rs.Keys = Wi, Rs.MoveTargetListSerializer = ii, Rs.MoveTargetSerializer = ai, Rs.NumberSerializer = Ca, 
Rs.PositionListSerializer = ci, Rs.PositionSerializer = si, Rs.adjacentWalkablePositions = Ti, 
Rs.blockSquare = function(e) {
es(e.roomName).blockedSquares.add(Ba(e));
}, Rs.cachePath = fs, Rs.cachedPathKey = ls, Rs.calculateAdjacencyMatrix = hi, Rs.calculateAdjacentPositions = vi, 
Rs.calculateNearbyPositions = Ri, Rs.calculatePositionsAtRange = Ei, Rs.cleanAllCaches = fi, 
Rs.clearCachedPath = Os, Rs.compressPath = e => {
const t = [], r = e[0];
if (!r) return "";
let o = r;
for (const r of e.slice(1)) {
if (1 !== Ja(o, r)) throw new Error("Cannot compress path unless each RoomPosition is adjacent to the previous one");
t.push(o.getDirectionTo(r)), o = r;
}
return Ba(r) + La.encode(t);
}, Rs.config = ga, Rs.decompressPath = e => {
let t = ja(e.slice(0, 2));
const r = [ t ], o = La.decode(e.slice(2));
for (const e of o) t = $a(t, e), r.push(t);
return r;
}, Rs.fastRoomPosition = ka, Rs.fixEdgePosition = gi, Rs.follow = function(e, t) {
e.move(t), t.pull(e), function(e, t) {
const r = es(e.pos.roomName);
r.pullers.add(e.id), r.pullees.add(t.id);
}(t, e);
}, Rs.followPath = ds, Rs.fromGlobalPosition = Za, Rs.generatePath = Zi, Rs.getCachedPath = ms, 
Rs.getMoveIntents = es, Rs.getRangeTo = Ja, Rs.globalPosition = Qa, Rs.isExit = di, 
Rs.isPositionWalkable = Si, Rs.move = cs, Rs.moveByPath = function(e, t, r) {
var o, n, a, i;
const s = null !== (o = null == r ? void 0 : r.repathIfStuck) && void 0 !== o ? o : ga.DEFAULT_MOVE_OPTS.repathIfStuck, c = null !== (i = null === (a = null !== (n = null == r ? void 0 : r.avoidTargets) && void 0 !== n ? n : ga.DEFAULT_MOVE_OPTS.avoidTargets) || void 0 === a ? void 0 : a(e.pos.roomName)) && void 0 !== i ? i : [];
let l = Ra.get(Hi(e, xs));
const u = ms(t, r);
if ((s || c.length) && void 0 !== l) {
let t = null == u ? void 0 : u.findIndex(t => t.isEqualTo(e.pos));
-1 === t && (t = void 0), void 0 !== t && ((null == r ? void 0 : r.reverse) ? t <= l : t >= l) && (Ra.delete(Hi(e, xs)), 
l = void 0);
}
let f = ERR_NOT_FOUND;
if (void 0 === l && (f = ds(e, t, r)), f !== ERR_NOT_FOUND) {
const t = Ra.get(Hi(e, "_cpi"));
if (!(s && Es(e, s) || u && ys(_i(u, null != t ? t : 0, null == r ? void 0 : r.reverse), c))) return f;
void 0 !== t && (l = (null == r ? void 0 : r.reverse) ? t - 1 : t + 2, Ra.set(Hi(e, xs), l));
}
let m = ms(t, r);
return m ? (void 0 !== l && (m = _i(m, l, null == r ? void 0 : r.reverse)), 0 === m.length ? ERR_NO_PATH : ws(e, m, r)) : ERR_NO_PATH;
}, Rs.moveTo = ws, Rs.normalizeTargets = yi, Rs.offsetRoomPosition = Pa, Rs.packCoord = Ha, 
Rs.packCoordList = Ya, Rs.packPos = Ba, Rs.packPosList = Va, Rs.packRoomName = ri, 
Rs.packRoomNames = ei, Rs.posAtDirection = $a, Rs.preTick = function() {
fi(), function() {
for (const e in Game.rooms) wi(e), Gi(e);
!function() {
var e, t;
const r = new Set;
Memory[ga.MEMORY_PORTAL_PATH] = [];
for (const o of Ii.values()) for (const n of o.values()) r.has(n) || (r.add(n), 
n.expires && n.expires < Game.time ? (null === (e = Ii.get(n.room1)) || void 0 === e || e.delete(n.room2), 
null === (t = Ii.get(n.room2)) || void 0 === t || t.delete(n.room1)) : Memory[ga.MEMORY_PORTAL_PATH].push(Li(n)));
}();
}();
}, Rs.reconcileTraffic = function(e) {
for (const t of [ ...Ji.keys() ]) Game.rooms[t] && ss(t, e);
xa.with(Ca).set(ns, Game.time);
}, Rs.reconciledRecently = as, Rs.resetCachedPath = ps, Rs.roomNameFromCoords = Xa, 
Rs.roomNameToCoords = qa, Rs.sameRoomPosition = Na, Rs.unpackCoord = Wa, Rs.unpackCoordList = Ka, 
Rs.unpackPos = ja, Rs.unpackPosList = za, Rs.unpackRoomName = oi, Rs.unpackRoomNames = ti, 
Rs;
}(), Ts = jr("TargetAssignmentManager"), Ss = new Map;

function Cs(e) {
var t = Ss.get(e.name);
if (t && Game.time - t.tick < 10) return t;
var a = function(e) {
var t, a, i = {
tick: Game.time,
sources: new Map,
harvesterToSource: new Map,
buildTargets: [],
builderToTarget: new Map,
upgraders: new Set
}, s = e.find(FIND_MY_CREEPS), c = [], l = [], u = [];
try {
for (var f = r(s), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = p.memory.role;
"harvester" === d || "staticMiner" === d ? c.push(p) : "builder" === d ? l.push(p) : "upgrader" === d && (u.push(p), 
i.upgraders.add(p.id));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (t) throw t.error;
}
}
return function(e, t, o) {
var n, a, i, s, c, l, u, f, m = wa(e);
if (0 !== m.length) {
try {
for (var p = r(m), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
o.sources.set(y.id, {
sourceId: y.id,
assignedHarvesters: [],
maxHarvesters: 2
});
}
} catch (e) {
n = {
error: e
};
} finally {
try {
d && !d.done && (a = p.return) && a.call(p);
} finally {
if (n) throw n.error;
}
}
var g = [];
try {
for (var h = r(t), v = h.next(); !v.done; v = h.next()) {
var R = v.value, E = R.memory.targetId;
g.push({
creep: R,
currentSource: null != E ? E : null
});
}
} catch (e) {
i = {
error: e
};
} finally {
try {
v && !v.done && (s = h.return) && s.call(h);
} finally {
if (i) throw i.error;
}
}
try {
for (var T = r(g), S = T.next(); !S.done; S = T.next()) {
var C = S.value, b = C.creep, _ = C.currentSource;
if (_ && (M = o.sources.get(_)) && M.assignedHarvesters.length < M.maxHarvesters) M.assignedHarvesters.push(b.id), 
o.harvesterToSource.set(b.id, _); else {
var O = null, w = 1 / 0;
try {
for (var x = (u = void 0, r(o.sources.values())), U = x.next(); !U.done; U = x.next()) {
var M, A = (M = U.value).assignedHarvesters.length;
A < M.maxHarvesters && A < w && (O = M, w = A);
}
} catch (e) {
u = {
error: e
};
} finally {
try {
U && !U.done && (f = x.return) && f.call(x);
} finally {
if (u) throw u.error;
}
}
O && (O.assignedHarvesters.push(b.id), o.harvesterToSource.set(b.id, O.sourceId));
}
}
} catch (e) {
c = {
error: e
};
} finally {
try {
S && !S.done && (l = T.return) && l.call(T);
} finally {
if (c) throw c.error;
}
}
}
}(e, c, i), function(e, t, a) {
var i, s, c, l, u = Ua(e), f = function(e) {
var t, a, i, s = fi.getSwarmState(e.name);
if (!s || !s.remoteAssignments || 0 === s.remoteAssignments.length) return [];
var c = [];
try {
for (var l = r(s.remoteAssignments), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = Game.rooms[f];
if (m && (!(null === (i = m.controller) || void 0 === i ? void 0 : i.owner) || m.controller.my)) {
var p = Ua(m);
c.push.apply(c, n([], o(p), !1));
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (a = l.return) && a.call(l);
} finally {
if (t) throw t.error;
}
}
return c;
}(e), m = n(n([], o(u), !1), o(f), !1);
if (0 !== m.length) {
var p = m.map(function(t) {
return {
site: t,
priority: bs(t, e.name)
};
}).sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var d = r(p), y = d.next(); !y.done; y = d.next()) {
var g = y.value, h = g.site, v = g.priority;
a.buildTargets.push({
targetId: h.id,
assignedBuilders: [],
priority: v
});
}
} catch (e) {
i = {
error: e
};
} finally {
try {
y && !y.done && (s = d.return) && s.call(d);
} finally {
if (i) throw i.error;
}
}
var R = 0;
try {
for (var E = r(t), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
if (0 === a.buildTargets.length) break;
var C = a.buildTargets[R];
C.assignedBuilders.push(S.id), a.builderToTarget.set(S.id, C.targetId), R = (R + 1) % a.buildTargets.length;
}
} catch (e) {
c = {
error: e
};
} finally {
try {
T && !T.done && (l = E.return) && l.call(E);
} finally {
if (c) throw c.error;
}
}
}
}(e, l, i), i;
}(e);
return Ss.set(e.name, a), Ts.debug("Calculated fresh assignments for ".concat(e.name), {
meta: {
sources: a.sources.size,
buildTargets: a.buildTargets.length,
upgraders: a.upgraders.size
}
}), a;
}

function bs(e, t) {
var r;
if ((null === (r = e.room) || void 0 === r ? void 0 : r.name) !== t) switch (e.structureType) {
case STRUCTURE_CONTAINER:
return 100;

case STRUCTURE_ROAD:
return 80;

case STRUCTURE_RAMPART:
return 40;

case STRUCTURE_WALL:
return 30;

default:
return 60;
}
switch (e.structureType) {
case STRUCTURE_SPAWN:
return 95;

case STRUCTURE_EXTENSION:
return 90;

case STRUCTURE_TOWER:
return 85;

case STRUCTURE_STORAGE:
return 75;

case STRUCTURE_LINK:
return 70;

case STRUCTURE_CONTAINER:
return 65;

case STRUCTURE_ROAD:
return 50;

case STRUCTURE_RAMPART:
return 40;

case STRUCTURE_WALL:
return 30;

default:
return 60;
}
}

var _s, Os, ws, xs = {
minBucket: 0,
criticalEnergyThreshold: 300,
mediumEnergyThreshold: 1e3,
lowEnergyThreshold: 3e3,
surplusEnergyThreshold: 1e4,
minTransferAmount: 500,
maxRequestsPerRoom: 3,
requestTimeout: 500,
focusRoomMediumThreshold: 5e3,
focusRoomLowThreshold: 15e3
}, Us = function() {
function t(t) {
void 0 === t && (t = {}), this.config = e(e({}, xs), t);
}
return t.prototype.processCluster = function(e) {
if (!(Game.cpu.bucket < this.config.minBucket)) {
this.cleanupRequests(e);
var t = this.getRoomStatuses(e).filter(function(e) {
return !e.hasTerminal;
});
t.length < 2 || this.createTransferRequests(e, t);
}
}, t.prototype.cleanupRequests = function(e) {
var t = this;
e.resourceRequests = e.resourceRequests.filter(function(r) {
if (Game.time - r.createdAt > t.config.requestTimeout) return Hr.debug("Resource request from ".concat(r.fromRoom, " to ").concat(r.toRoom, " expired"), {
subsystem: "ResourceSharing"
}), !1;
if (r.delivered >= r.amount) return Hr.info("Resource transfer completed: ".concat(r.delivered, " ").concat(r.resourceType, " from ").concat(r.fromRoom, " to ").concat(r.toRoom), {
subsystem: "ResourceSharing"
}), !1;
if (!e.memberRooms.includes(r.toRoom) || !e.memberRooms.includes(r.fromRoom)) return !1;
if (Game.rooms[r.toRoom]) {
var o = fi.getSwarmState(r.toRoom);
if (o && 0 === o.metrics.energyNeed) return Hr.debug("Resource request from ".concat(r.fromRoom, " to ").concat(r.toRoom, " no longer needed"), {
subsystem: "ResourceSharing"
}), !1;
}
return !0;
});
}, t.prototype.getRoomStatuses = function(e) {
var t, o, n, a = [];
try {
for (var i = r(e.memberRooms), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.rooms[c];
if (l && (null === (n = l.controller) || void 0 === n ? void 0 : n.my)) {
var u = fi.getSwarmState(c);
if (u) {
var f = e.focusRoom === c, m = this.calculateRoomEnergy(l), p = m.energyAvailable, d = m.energyCapacity, y = this.calculateEnergyNeed(l, p, u, f), g = 0;
f ? g = 0 : p > this.config.surplusEnergyThreshold && (g = p - this.config.mediumEnergyThreshold);
var h = 0;
3 === y ? h = this.config.criticalEnergyThreshold - p : 2 === y ? h = this.config.mediumEnergyThreshold - p : 1 === y && (h = this.config.lowEnergyThreshold - p), 
h = f && y > 0 ? Math.max(h, 2 * this.config.minTransferAmount) : Math.max(h, this.config.minTransferAmount), 
a.push({
roomName: c,
hasTerminal: void 0 !== l.terminal && l.terminal.my,
energyAvailable: p,
energyCapacity: d,
energyNeed: y,
canProvide: g,
needsAmount: h
}), u.metrics.energyAvailable = p, u.metrics.energyCapacity = d, u.metrics.energyNeed = y;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return a;
}, t.prototype.calculateRoomEnergy = function(e) {
var t, o, n = 0, a = 0;
e.storage && (n += e.storage.store.getUsedCapacity(RESOURCE_ENERGY), a += e.storage.store.getCapacity());
var i = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
});
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
n += l.store.getUsedCapacity(RESOURCE_ENERGY), a += l.store.getCapacity();
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return {
energyAvailable: n,
energyCapacity: a
};
}, t.prototype.calculateEnergyNeed = function(e, t, r, o) {
return void 0 === o && (o = !1), t < this.config.criticalEnergyThreshold ? (e.find(FIND_MY_SPAWNS).length > 0 && e.energyAvailable, 
3) : o ? t < this.config.focusRoomMediumThreshold ? 2 : t < this.config.focusRoomLowThreshold ? 1 : 0 : t < this.config.mediumEnergyThreshold ? 2 : t < this.config.lowEnergyThreshold ? 1 : 0;
}, t.prototype.createTransferRequests = function(e, t) {
var o, n, a = t.filter(function(e) {
return e.energyNeed > 0;
}).sort(function(e, t) {
return t.energyNeed - e.energyNeed;
}), i = t.filter(function(e) {
return e.canProvide > 0;
}).sort(function(e, t) {
return t.canProvide - e.canProvide;
});
if (0 !== a.length && 0 !== i.length) {
var s = function(t) {
var o, n;
if (e.resourceRequests.filter(function(e) {
return e.toRoom === t.roomName;
}).length >= c.config.maxRequestsPerRoom) return "continue";
var a = null, s = 1 / 0, l = function(r) {
if (r.roomName === t.roomName) return "continue";
if (e.resourceRequests.some(function(e) {
return e.fromRoom === r.roomName && e.toRoom === t.roomName;
})) return "continue";
var o = Game.map.getRoomLinearDistance(r.roomName, t.roomName);
o < s && r.canProvide >= c.config.minTransferAmount && (s = o, a = r);
};
try {
for (var u = (o = void 0, r(i)), f = u.next(); !f.done; f = u.next()) l(f.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
if (a && s <= 3) {
var m = Math.min(t.needsAmount, a.canProvide), p = {
toRoom: t.roomName,
fromRoom: a.roomName,
resourceType: RESOURCE_ENERGY,
amount: m,
priority: t.energyNeed,
createdAt: Game.time,
assignedCreeps: [],
delivered: 0
};
e.resourceRequests.push(p), Hr.info("Created resource transfer: ".concat(m, " energy from ").concat(a.roomName, " to ").concat(t.roomName, " (priority ").concat(p.priority, ", distance ").concat(s, ")"), {
subsystem: "ResourceSharing"
}), a.canProvide -= m;
}
}, c = this;
try {
for (var l = r(a), u = l.next(); !u.done; u = l.next()) s(u.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (o) throw o.error;
}
}
}
}, t.prototype.getRequestsForRoom = function(e, t) {
return e.resourceRequests.filter(function(e) {
return e.toRoom === t || e.fromRoom === t;
});
}, t.prototype.updateRequestProgress = function(e, t, r) {
if (t >= 0 && t < e.resourceRequests.length) {
var o = e.resourceRequests[t];
o.delivered += r, Hr.debug("Updated transfer progress: ".concat(o.delivered, "/").concat(o.amount, " from ").concat(o.fromRoom, " to ").concat(o.toRoom), {
subsystem: "ResourceSharing"
});
}
}, t;
}(), Ms = new Us, As = {
1: {
guards: 1,
rangers: 1,
healers: 0,
siegeUnits: 0
},
2: {
guards: 2,
rangers: 2,
healers: 1,
siegeUnits: 0
},
3: {
guards: 3,
rangers: 3,
healers: 2,
siegeUnits: 1
}
};

function ks(e, t) {
var o, n, a = e.coreRoom, i = 1 / 0;
try {
for (var s = r(e.memberRooms), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.map.getRoomLinearDistance(l, t);
u < i && (i = u, a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
return a;
}

function Ns(e, t) {
var r = function(e) {
var t, r = Math.min(3, Math.max(1, e.urgency)), o = null !== (t = As[r]) && void 0 !== t ? t : As[2];
return {
guards: Math.max(o.guards, e.guardsNeeded),
rangers: Math.max(o.rangers, e.rangersNeeded),
healers: Math.max(o.healers, e.healersNeeded),
siegeUnits: o.siegeUnits
};
}(t), o = "defense_".concat(t.roomName, "_").concat(Game.time), n = ks(e, t.roomName), a = {
id: o,
type: "defense",
members: [],
rallyRoom: n,
targetRooms: [ t.roomName ],
state: "gathering",
createdAt: Game.time
};
return Hr.info("Created defense squad ".concat(o, " for ").concat(t.roomName, ": ") + "".concat(r.guards, "G/").concat(r.rangers, "R/").concat(r.healers, "H rally at ").concat(n), {
subsystem: "Squad"
}), a;
}

function Ps(e) {
var t = Game.time - e.createdAt;
if ("gathering" === e.state && t > 300) return Hr.warn("Squad ".concat(e.id, " timed out during formation (").concat(t, " ticks)"), {
subsystem: "Squad"
}), !0;
if (0 === e.members.length && t > 50) return Hr.info("Squad ".concat(e.id, " has no members, dissolving"), {
subsystem: "Squad"
}), !0;
if ("attacking" === e.state) {
var r = e.targetRooms[0];
if (r) {
var o = Game.rooms[r];
if (o && 0 === o.find(FIND_HOSTILE_CREEPS).length && t > 100) return Hr.info("Squad ".concat(e.id, " mission complete, no more hostiles"), {
subsystem: "Squad"
}), !0;
}
}
return !1;
}

function Is(e) {
var t = e.members.length;
e.members = e.members.filter(function(e) {
return Game.creeps[e];
}), e.members.length < t && Hr.debug("Squad ".concat(e.id, " lost ").concat(t - e.members.length, " members"), {
subsystem: "Squad"
});
var r = e.members.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return !!e;
});
if (0 !== r.length) {
var o = e.targetRooms[0];
if (o) switch (e.state) {
case "gathering":
r.every(function(t) {
return t.room.name === e.rallyRoom;
}) && (e.state = "moving", Hr.info("Squad ".concat(e.id, " gathered, moving to ").concat(o), {
subsystem: "Squad"
}));
break;

case "moving":
r.some(function(e) {
return e.room.name === o;
}) && (e.state = "attacking", Hr.info("Squad ".concat(e.id, " reached ").concat(o, ", engaging"), {
subsystem: "Squad"
}));
break;

case "attacking":
Game.time - e.createdAt > 50 && r.length < 3 && (e.state = "retreating", Hr.warn("Squad ".concat(e.id, " retreating - heavy casualties"), {
subsystem: "Squad"
}));
break;

case "retreating":
r.every(function(t) {
return t.room.name === e.rallyRoom;
}) && (e.state = "dissolving", Hr.info("Squad ".concat(e.id, " retreated to ").concat(e.rallyRoom, ", dissolving"), {
subsystem: "Squad"
}));
}
}
}

(_s = {})[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] = 300, _s[RESOURCE_CATALYZED_UTRIUM_ACID] = 300, 
_s[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] = 300, (Os = {})[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] = 600, 
Os[RESOURCE_CATALYZED_UTRIUM_ACID] = 600, Os[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] = 300, 
Os[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] = 600, (ws = {})[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] = 900, 
ws[RESOURCE_CATALYZED_UTRIUM_ACID] = 600, ws[RESOURCE_CATALYZED_ZYNTHIUM_ACID] = 900, 
ws[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] = 600, ws[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] = 900;

var Gs = {
0: 0,
1: 5e3,
2: 15e3,
3: 5e4
};

function Ls(e, t) {
var r = Gs[t], o = fi.getClusters();
for (var n in o) o[n].defenseRequests.some(function(t) {
return t.roomName === e && t.urgency >= 2;
}) && (r += 1e4);
return r;
}

function Ds(e, t, o) {
var n, a, i, s = 0;
try {
for (var c = r(e.memberRooms), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (u !== t) {
var f = Game.rooms[u];
if (f && f.storage) {
var m = fi.getSwarmState(u);
if (m) {
var p = f.storage.store.getUsedCapacity(RESOURCE_ENERGY) - Ls(u, m.danger);
p > o && p > s && (s = p, i = u);
}
}
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
l && !l.done && (a = c.return) && a.call(c);
} finally {
if (n) throw n.error;
}
}
if (!i) return Hr.warn("No available energy source for emergency routing to ".concat(t, " (need ").concat(o, ")"), {
subsystem: "MilitaryPool"
}), {
success: !1
};
var d = Game.rooms[i], y = Game.rooms[t];
return (null == d ? void 0 : d.terminal) && (null == y ? void 0 : y.terminal) ? d.terminal.send(RESOURCE_ENERGY, o, t) === OK ? (Hr.info("Emergency energy routed: ".concat(o, " from ").concat(i, " to ").concat(t), {
subsystem: "MilitaryPool"
}), {
success: !0,
sourceRoom: i
}) : {
success: !1
} : (Hr.info("Creating hauler transfer request: ".concat(o, " energy from ").concat(i, " to ").concat(t), {
subsystem: "MilitaryPool"
}), e.resourceRequests.push({
toRoom: t,
fromRoom: i,
resourceType: RESOURCE_ENERGY,
amount: o,
priority: 5,
createdAt: Game.time,
assignedCreeps: [],
delivered: 0
}), {
success: !0,
sourceRoom: i
});
}

var Fs = {
harassment: {
composition: {
harassers: 3,
soldiers: 0,
rangers: 1,
healers: 0,
siegeUnits: 0
},
targetPriority: {
workers: 100,
military: 50,
spawns: 20,
towers: 10,
extensions: 15,
storage: 10,
defenses: 5,
labs: 5
},
minEnergy: 5e4,
useBoosts: !1,
retreatThreshold: .5,
creepSize: "small",
engagement: {
engageTowers: !1,
maxTowers: 0,
prioritizeDefenses: !1
}
},
raid: {
composition: {
harassers: 1,
soldiers: 2,
rangers: 3,
healers: 2,
siegeUnits: 0
},
targetPriority: {
military: 100,
towers: 80,
spawns: 90,
workers: 60,
extensions: 50,
storage: 40,
labs: 30,
defenses: 20
},
minEnergy: 1e5,
useBoosts: !1,
retreatThreshold: .4,
creepSize: "medium",
engagement: {
engageTowers: !0,
maxTowers: 2,
prioritizeDefenses: !1
}
},
siege: {
composition: {
harassers: 0,
soldiers: 2,
rangers: 4,
healers: 3,
siegeUnits: 2
},
targetPriority: {
towers: 100,
spawns: 100,
military: 90,
defenses: 80,
storage: 70,
labs: 60,
extensions: 50,
workers: 40
},
minEnergy: 2e5,
useBoosts: !0,
retreatThreshold: .3,
creepSize: "large",
engagement: {
engageTowers: !0,
maxTowers: 6,
prioritizeDefenses: !0
}
}
};

function Bs(e, t) {
var r, o, n, a;
if (!t) return Hr.debug("No intel for ".concat(e, ", defaulting to harassment"), {
subsystem: "Doctrine"
}), "harassment";
var i = null !== (r = t.towerCount) && void 0 !== r ? r : 0, s = null !== (o = t.spawnCount) && void 0 !== o ? o : 0, c = null !== (n = t.rcl) && void 0 !== n ? n : 0, l = 3 * i + 2 * s + 1.5 * (null !== (a = t.militaryPresence) && void 0 !== a ? a : 0) + .5 * c;
return l >= 20 || c >= 7 ? (Hr.info("Selected SIEGE doctrine for ".concat(e, " (threat: ").concat(l, ")"), {
subsystem: "Doctrine"
}), "siege") : l >= 10 || c >= 5 ? (Hr.info("Selected RAID doctrine for ".concat(e, " (threat: ").concat(l, ")"), {
subsystem: "Doctrine"
}), "raid") : (Hr.info("Selected HARASSMENT doctrine for ".concat(e, " (threat: ").concat(l, ")"), {
subsystem: "Doctrine"
}), "harassment");
}

function js(e, t) {
var o, n, a, i = Fs[t], s = 0;
try {
for (var c = r(e.memberRooms), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = Game.rooms[u];
if (f && (null === (a = f.controller) || void 0 === a ? void 0 : a.my)) {
var m = f.storage, p = f.terminal;
m && (s += m.store.energy), p && (s += p.store.energy);
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
var d = s >= i.minEnergy;
return d || Hr.debug("Cannot launch ".concat(t, ": insufficient energy (").concat(s, "/").concat(i.minEnergy, ")"), {
subsystem: "Doctrine"
}), d;
}

var Hs = {
rclWeight: 10,
resourceWeight: 5,
strategicWeight: 3,
distancePenalty: 2,
weakDefenseBonus: 20,
strongDefensePenalty: 15,
warTargetBonus: 50
};

function Ws(e, t, r, o) {
var n, a, i = 0;
i += e.controllerLevel * o.rclWeight, e.controllerLevel >= 6 ? i += 5 * o.resourceWeight : e.controllerLevel >= 4 && (i += 2 * o.resourceWeight), 
i += e.sources * o.strategicWeight, i -= t * o.distancePenalty;
var s = null !== (n = e.towerCount) && void 0 !== n ? n : 0, c = null !== (a = e.spawnCount) && void 0 !== a ? a : 0;
return 0 === s && c <= 1 ? i += o.weakDefenseBonus : (s >= 4 || s >= 2 && c >= 2) && (i -= o.strongDefensePenalty), 
r && (i += o.warTargetBonus), e.threatLevel >= 2 && !r && (i -= 10 * e.threatLevel), 
Math.max(0, i);
}

function Ys(e, t) {
var o, n, a = 1 / 0;
try {
for (var i = r(e.memberRooms), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.map.getRoomLinearDistance(c, t);
l < a && (a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}

var Ks = {
move: 50,
work: 100,
carry: 50,
attack: 80,
ranged_attack: 150,
heal: 250,
claim: 600,
tough: 10
}, Vs = new Map;

function zs(e, t, r) {
for (var a = n([], o(e), !1), i = e.reduce(function(e, t) {
return e + Ks[t];
}, 0), s = r.reduce(function(e, t) {
return e + Ks[t];
}, 0); i + s <= t && a.length < 50; ) a.push.apply(a, n([], o(r), !1)), i += s;
return a.slice(0, 50);
}

var qs = new Map;

function Xs(e) {
e.lastUpdate = Game.time;
var t = fi.getCluster(e.clusterId);
if (!t) return e.state = "failed", void Hr.error("Cluster ".concat(e.clusterId, " not found for operation ").concat(e.id), {
subsystem: "Offensive"
});
switch (e.state) {
case "forming":
!function(e) {
e.squadIds.every(function(e) {
return !function(e) {
return Vs.has(e);
}(e);
}) && (e.state = "executing", Hr.info("Operation ".concat(e.id, " entering execution phase"), {
subsystem: "Offensive"
})), Game.time - e.createdAt > 1e3 && (e.state = "failed", Hr.warn("Operation ".concat(e.id, " formation timed out"), {
subsystem: "Offensive"
}));
}(e);
break;

case "executing":
!function(e, t) {
var o, n, a = function(r) {
var o = t.squads.find(function(e) {
return e.id === r;
});
if (!o) return "continue";
if (Is(o), Ps(o)) {
Hr.info("Squad ".concat(r, " dissolving, operation ").concat(e.id, " may complete"), {
subsystem: "Offensive"
});
var n = t.squads.findIndex(function(e) {
return e.id === r;
});
n >= 0 && t.squads.splice(n, 1);
}
};
try {
for (var i = r(e.squadIds), s = i.next(); !s.done; s = i.next()) a(s.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
0 === e.squadIds.filter(function(e) {
return t.squads.some(function(t) {
return t.id === e;
});
}).length && (e.state = "complete", Hr.info("Operation ".concat(e.id, " complete"), {
subsystem: "Offensive"
}));
}(e, t);
}
}

function Qs(e, t, r) {
var a, i, s, c = 0, l = 0, u = e.getTerrain().get(t.x, t.y);
if (u === TERRAIN_MASK_WALL) return {
position: t,
score: 0,
terrain: 0,
safety: 0,
centrality: 0,
exitAccess: 0
};
if (c += a = 0 === u ? 10 : 5, e.lookForAt(LOOK_STRUCTURES, t).some(function(e) {
return e.structureType !== STRUCTURE_ROAD && e.structureType !== STRUCTURE_RAMPART;
})) return {
position: t,
score: 0,
terrain: 0,
safety: 0,
centrality: 0,
exitAccess: 0
};
var f = e.find(FIND_HOSTILE_CREEPS);
if (f.length > 0) {
var m = Math.min.apply(Math, n([], o(f.map(function(e) {
return t.getRangeTo(e);
})), !1));
l = Math.min(10, m);
} else l = 10;
c += 2 * l;
var p = Math.sqrt(Math.pow(t.x - 25, 2) + Math.pow(t.y - 25, 2));
c += i = "defense" === r || "retreat" === r ? Math.max(0, 10 - p / 2) : Math.max(0, 5 - Math.abs(p - 15) / 2);
var d = Math.min(t.x, t.y, 49 - t.x, 49 - t.y);
return s = "offense" === r || "staging" === r ? Math.max(0, 10 - d / 2) : Math.min(10, d / 2.5), 
{
position: t,
score: c += s,
terrain: a,
safety: l,
centrality: i,
exitAccess: s
};
}

var Zs, Js = {}, $s = {};

function ec() {
return Zs || (Zs = 1, function(e) {
function t(t) {
return e.NON_AGGRESSION_PACT_PLAYERS.includes(t);
}
function r(e) {
return t(e.owner.username);
}
function o(e) {
var r;
return !!(null === (r = e.owner) || void 0 === r ? void 0 : r.username) && t(e.owner.username);
}
function n(e) {
var t, o = e.filter(function(e) {
return !r(e);
}), n = e.length - o.length;
return n > 0 && console.log("[Alliance] Filtered ".concat(n, " allied creeps from hostile detection in ").concat(null === (t = e[0]) || void 0 === t ? void 0 : t.room.name)), 
o;
}
function a(e) {
var t, r = e.filter(function(e) {
return !o(e);
}), n = e.length - r.length;
return n > 0 && console.log("[Alliance] Filtered ".concat(n, " allied structures from hostile detection in ").concat(null === (t = e[0]) || void 0 === t ? void 0 : t.room.name)), 
r;
}
function i(e) {
return n(e.find(FIND_HOSTILE_CREEPS));
}
function s(e) {
return a(e.find(FIND_HOSTILE_STRUCTURES));
}
Object.defineProperty(e, "__esModule", {
value: !0
}), e.NON_AGGRESSION_PACT_PLAYERS = void 0, e.isAllyPlayer = t, e.isAllyCreep = r, 
e.isAllyStructure = o, e.filterAllyCreeps = n, e.filterAllyStructures = a, e.getActualHostileCreeps = i, 
e.getActualHostileStructures = s, e.hasActualHostiles = function(e) {
var t = i(e), r = s(e);
return t.length > 0 || r.length > 0;
}, e.NON_AGGRESSION_PACT_PLAYERS = [ "TooAngel", "TedRoastBeef" ];
}($s)), $s;
}

var tc, rc = {}, oc = m(Wr), nc = m(Ba);

function ac() {
if (tc) return rc;
tc = 1;
var e = rc && rc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(rc, "__esModule", {
value: !0
}), rc.assessThreat = function(t) {
var r, a, i, c, l = t.find(FIND_HOSTILE_CREEPS), u = (0, o.filterAllyCreeps)(l);
if (0 === u.length) return {
roomName: t.name,
dangerLevel: 0,
threatScore: 0,
hostileCount: 0,
totalHostileHitPoints: 0,
totalHostileDPS: 0,
healerCount: 0,
rangedCount: 0,
meleeCount: 0,
boostedCount: 0,
dismantlerCount: 0,
estimatedDefenderCost: 0,
assistanceRequired: !1,
assistancePriority: 0,
recommendedResponse: "monitor"
};
var m = 0, p = 0, d = 0, y = 0, g = 0, h = 0, v = 0, R = 0;
try {
for (var E = e(u), T = E.next(); !T.done; T = E.next()) {
var S = T.value, C = 0, b = 0, _ = 0, O = 0;
try {
for (var w = (i = void 0, e(S.body)), x = w.next(); !x.done; x = w.next()) {
var U = x.value;
if (0 !== U.hits) switch (U.type) {
case ATTACK:
C++;
break;

case RANGED_ATTACK:
b++;
break;

case HEAL:
_++;
break;

case WORK:
O++;
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
x && !x.done && (c = w.return) && c.call(w);
} finally {
if (i) throw i.error;
}
}
p += 30 * C + 10 * b, d += S.hits, S.body.some(function(e) {
return e.boost;
}) && (y++, m += 200), _ > 0 && (g++, m += 100), b > 0 && h++, C > 0 && v++, O >= 5 && (R++, 
m += 150), m += 10 * (C + b);
}
} catch (e) {
r = {
error: e
};
} finally {
try {
T && !T.done && (a = E.return) && a.call(E);
} finally {
if (r) throw r.error;
}
}
var M, A = t.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
}).reduce(function(e, t) {
if (t.store.getUsedCapacity(RESOURCE_ENERGY) < 10) return e;
var r = u.reduce(function(e, r) {
return e + t.pos.getRangeTo(r.pos);
}, 0);
return e + n(r / u.length);
}, 0), k = p > 1.5 * A, N = Math.min(100, Math.max(0, (p - A) / 10)), P = f(p), I = s(m);
return M = m < 100 ? "monitor" : m < 500 && !k ? "defend" : k && m < 1e3 ? "assist" : m > 1e3 || y > 3 ? "safemode" : "defend", 
t.find(FIND_NUKES).length > 0 && (m += 500, M = "safemode", I = 3), {
roomName: t.name,
dangerLevel: I,
threatScore: m,
hostileCount: u.length,
totalHostileHitPoints: d,
totalHostileDPS: p,
healerCount: g,
rangedCount: h,
meleeCount: v,
boostedCount: y,
dismantlerCount: R,
estimatedDefenderCost: P,
assistanceRequired: k,
assistancePriority: N,
recommendedResponse: M
};
}, rc.calculateTowerDamage = n, rc.calculateDangerLevel = s, rc.estimateDefenderCost = f, 
rc.logThreatAnalysis = function(e) {
t.logger.info("Threat Assessment for ".concat(e.roomName, ": ") + "Danger=".concat(e.dangerLevel, ", Score=").concat(e.threatScore, ", ") + "Hostiles=".concat(e.hostileCount, ", DPS=").concat(e.totalHostileDPS, ", ") + "Response=".concat(e.recommendedResponse), {
subsystem: "Defense",
room: e.roomName,
meta: {
threat: {
dangerLevel: e.dangerLevel,
threatScore: e.threatScore,
hostileCount: e.hostileCount,
boostedCount: e.boostedCount,
healerCount: e.healerCount,
dismantlerCount: e.dismantlerCount,
recommendedResponse: e.recommendedResponse
}
}
});
};
var t = oc, r = nc, o = ec();
function n(e) {
return e <= 5 ? 600 : e >= 20 ? 150 : 600 - 30 * (e - 5);
}
var a = 300, i = 800;
function s(e) {
return 0 === e ? 0 : e < a ? 1 : e < i ? 2 : 3;
}
function c(t) {
var r, o, n = 0;
try {
for (var a = e(t), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
s === ATTACK ? n += 30 : s === RANGED_ATTACK && (n += 10);
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
return n;
}
function l(e) {
var t = r.ROLE_DEFINITIONS[e];
return t ? t.bodies.map(function(e) {
return {
parts: e.parts,
cost: e.cost,
dps: c(e.parts)
};
}).sort(function(e, t) {
return e.cost - t.cost;
}) : [];
}
function u(e) {
if (0 === e.length) return {
dpsPerEnergy: 300 / 1300,
avgCost: 1300,
avgDps: 300
};
var t = e.reduce(function(e, t) {
return e + t.cost;
}, 0), r = e.reduce(function(e, t) {
return e + t.dps;
}, 0), o = t / e.length, n = r / e.length;
return {
dpsPerEnergy: n / o,
avgCost: o,
avgDps: n
};
}
function f(e, t, r) {
if (void 0 === t || void 0 === r) {
var o = l("guard"), n = l("ranger"), a = u(o), i = u(n), s = (a.avgDps + i.avgDps) / 2, c = (a.avgCost + i.avgCost) / 2;
t = null != t ? t : s, r = null != r ? r : c;
}
return t <= 0 && (t = 300, r = 1300), Math.ceil(e / t) * r;
}
return rc;
}

var ic, sc, cc = {}, lc = {};

function uc() {
return ic || (ic = 1, Object.defineProperty(lc, "__esModule", {
value: !0
}), lc.calculateWallRepairTarget = function(e, t) {
var r, o, n = null !== (r = {
1: 0,
2: 3e5,
3: 1e6,
4: 3e6,
5: 1e7,
6: 3e7,
7: 1e8,
8: 3e8
}[e]) && void 0 !== r ? r : 0;
if (0 === n) return 0;
var a = null !== (o = {
0: .3,
1: .5,
2: .8,
3: 1
}[t]) && void 0 !== o ? o : 1;
return Math.floor(n * a);
}), lc;
}

var fc, mc = {};

function pc() {
if (fc) return mc;
fc = 1;
var e = mc && mc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = mc && mc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, r = mc && mc.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(mc, "__esModule", {
value: !0
}), mc.findRoomExits = a, mc.identifyChokePoints = function(o, n) {
var a, i, s, c, l, u, f, m = [], p = new Map;
try {
for (var d = e(n), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
(O = null !== (f = p.get(g.exitDirection)) && void 0 !== f ? f : []).push(g), p.set(g.exitDirection, O);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
y && !y.done && (i = d.return) && i.call(d);
} finally {
if (a) throw a.error;
}
}
try {
for (var h = e(p.values()), v = h.next(); !v.done; v = h.next()) for (var R = v.value, E = r([], t(R), !1).sort(function(e, t) {
return e.x === t.x ? e.y - t.y : e.x - t.x;
}), T = 0, S = 1; S <= E.length; S++) {
var C = E[S - 1], b = E[S];
if (!b || C && b && (Math.abs(b.x - C.x) > 1 || Math.abs(b.y - C.y) > 1)) {
var _ = S - T, O = E.slice(T, S);
if (_ >= 2 && _ <= 4) try {
for (var w = (l = void 0, e(O)), x = w.next(); !x.done; x = w.next()) (g = x.value).isChokePoint = !0, 
m.push(g);
} catch (e) {
l = {
error: e
};
} finally {
try {
x && !x.done && (u = w.return) && u.call(w);
} finally {
if (l) throw l.error;
}
}
T = S;
}
}
} catch (e) {
s = {
error: e
};
} finally {
try {
v && !v.done && (c = h.return) && c.call(h);
} finally {
if (s) throw s.error;
}
}
return m;
}, mc.calculatePerimeterPositions = i, mc.placePerimeterDefense = function(t, r, n, a) {
var s, c, l, u, f, m;
if (void 0 === n && (n = 3), r < 2) return 0;
var p = i(t.name), d = t.find(FIND_MY_CONSTRUCTION_SITES), y = t.find(FIND_STRUCTURES);
if (d.length >= 10) return 0;
var g = 0, h = Math.min(n, 10 - d.length), v = y.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}).length + d.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}).length, R = y.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}).length + d.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}).length, E = r >= 2 ? 2500 : 0, T = r >= 2 ? 2500 : 0;
if (r >= 2 && g < h && v < E) {
var S = function(e) {
if (g >= h) return "break";
if (v + g >= E) return "break";
var r = y.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && (t.structureType === STRUCTURE_WALL || t.structureType === STRUCTURE_RAMPART);
}), n = d.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && (t.structureType === STRUCTURE_WALL || t.structureType === STRUCTURE_RAMPART);
});
r || n || t.createConstructionSite(e.x, e.y, STRUCTURE_WALL) === OK && (g++, o.logger.debug("Placed perimeter wall at (".concat(e.x, ",").concat(e.y, ")"), {
subsystem: "Defense"
}));
};
try {
for (var C = e(p.walls), b = C.next(); !b.done && "break" !== S(b.value); b = C.next()) ;
} catch (e) {
s = {
error: e
};
} finally {
try {
b && !b.done && (c = C.return) && c.call(C);
} finally {
if (s) throw s.error;
}
}
}
if (r >= 3) {
var _ = function(e) {
var t = y.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_RAMPART;
}), r = d.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_RAMPART;
});
if (!t && !r) {
var n = y.find(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_WALL;
});
if (n) {
var a = n.destroy();
a === OK ? o.logger.info("Removed wall at gap position (".concat(e.x, ",").concat(e.y, ") to allow friendly passage"), {
subsystem: "Defense"
}) : o.logger.warn("Failed to destroy wall at gap position (".concat(e.x, ",").concat(e.y, "): ").concat(a), {
subsystem: "Defense"
});
}
}
};
try {
for (var O = e(p.ramparts), w = O.next(); !w.done; w = O.next()) _(w.value);
} catch (e) {
l = {
error: e
};
} finally {
try {
w && !w.done && (u = O.return) && u.call(O);
} finally {
if (l) throw l.error;
}
}
}
if (r >= 3 && g < h && R < T) {
var x = function(e) {
if (g >= h) return "break";
if (R + g >= T) return "break";
var r = y.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_RAMPART;
}), n = d.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_RAMPART;
}), a = y.some(function(t) {
return t.pos.x === e.x && t.pos.y === e.y && t.structureType === STRUCTURE_WALL;
});
r || n || a || t.createConstructionSite(e.x, e.y, STRUCTURE_RAMPART) === OK && (g++, 
o.logger.debug("Placed perimeter rampart gap at (".concat(e.x, ",").concat(e.y, ")"), {
subsystem: "Defense"
}));
};
try {
for (var U = e(p.ramparts), M = U.next(); !M.done && "break" !== x(M.value); M = U.next()) ;
} catch (e) {
f = {
error: e
};
} finally {
try {
M && !M.done && (m = U.return) && m.call(U);
} finally {
if (f) throw f.error;
}
}
}
return g;
}, mc.getPerimeterStats = function(t) {
var r, o, n, a, s = i(t.name), c = t.find(FIND_STRUCTURES), l = s.walls.length, u = s.ramparts.length, f = c.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}), m = c.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}), p = 0, d = function(e) {
s.walls.some(function(t) {
return t.x === e.pos.x && t.y === e.pos.y;
}) && p++;
};
try {
for (var y = e(f), g = y.next(); !g.done; g = y.next()) d(g.value);
} catch (e) {
r = {
error: e
};
} finally {
try {
g && !g.done && (o = y.return) && o.call(y);
} finally {
if (r) throw r.error;
}
}
var h = 0, v = function(e) {
s.ramparts.some(function(t) {
return t.x === e.pos.x && t.y === e.pos.y;
}) && h++;
};
try {
for (var R = e(m), E = R.next(); !E.done; E = R.next()) v(E.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
E && !E.done && (a = R.return) && a.call(R);
} finally {
if (n) throw n.error;
}
}
var T = l > 0 ? Math.round(p / l * 100) : 0, S = u > 0 ? Math.round(h / u * 100) : 0;
return {
totalWallPositions: l,
totalGapPositions: u,
wallsBuilt: p,
rampartsBuilt: h,
wallCoveragePercent: T,
gapCoveragePercent: S
};
};
var o = oc, n = 4;
function a(t) {
var r, o, n = [], a = Game.map.getRoomTerrain(t), i = Game.rooms[t], s = new Set;
if (i) {
var c = i.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_WALL || e.structureType === STRUCTURE_RAMPART;
}
});
try {
for (var l = e(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
s.add("".concat(f.pos.x, ",").concat(f.pos.y));
}
} catch (e) {
r = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (r) throw r.error;
}
}
}
for (var m = 0; m < 50; m++) a.get(m, 0) === TERRAIN_MASK_WALL || s.has("".concat(m, ",0")) || n.push({
x: m,
y: 0,
exitDirection: "top",
isChokePoint: !1
});
for (m = 0; m < 50; m++) a.get(m, 49) === TERRAIN_MASK_WALL || s.has("".concat(m, ",49")) || n.push({
x: m,
y: 49,
exitDirection: "bottom",
isChokePoint: !1
});
for (var p = 1; p < 49; p++) a.get(0, p) === TERRAIN_MASK_WALL || s.has("0,".concat(p)) || n.push({
x: 0,
y: p,
exitDirection: "left",
isChokePoint: !1
});
for (p = 1; p < 49; p++) a.get(49, p) === TERRAIN_MASK_WALL || s.has("49,".concat(p)) || n.push({
x: 49,
y: p,
exitDirection: "right",
isChokePoint: !1
});
return n;
}
function i(o) {
var i, s, c, l, u, f, m, p = Game.map.getRoomTerrain(o), d = [], y = [], g = a(o), h = new Map;
try {
for (var v = e(g), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
(N = null !== (m = h.get(E.exitDirection)) && void 0 !== m ? m : []).push(E), h.set(E.exitDirection, N);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
R && !R.done && (s = v.return) && s.call(v);
} finally {
if (i) throw i.error;
}
}
try {
for (var T = e(h), S = T.next(); !S.done; S = T.next()) {
for (var C = t(S.value, 2), b = C[0], _ = C[1], O = r([], t(_), !1).sort(function(e, t) {
return e.x === t.x ? e.y - t.y : e.x - t.x;
}), w = [], x = [], U = 0; U < O.length; U++) {
E = O[U];
var M = O[U - 1];
!(M && Math.abs(E.x - M.x) <= 1 && Math.abs(E.y - M.y) <= 1) && x.length > 0 && (w.push(x), 
x = []), x.push(E);
}
x.length > 0 && w.push(x);
try {
for (var A = (u = void 0, e(w)), k = A.next(); !k.done; k = A.next()) {
var N = k.value, P = Math.floor(N.length / 2);
for (U = 0; U < N.length; U++) {
var I = (E = N[U]).x, G = E.y;
switch (b) {
case "top":
G = 2;
break;

case "bottom":
G = 47;
break;

case "left":
I = 2;
break;

case "right":
I = 47;
}
p.get(I, G) !== TERRAIN_MASK_WALL && (N.length >= n && (U === P || U === P - 1) ? y.push({
x: I,
y: G,
exitDirection: b,
isChokePoint: !1
}) : d.push({
x: I,
y: G,
exitDirection: b,
isChokePoint: !1
}));
}
}
} catch (e) {
u = {
error: e
};
} finally {
try {
k && !k.done && (f = A.return) && f.call(A);
} finally {
if (u) throw u.error;
}
}
}
} catch (e) {
c = {
error: e
};
} finally {
try {
S && !S.done && (l = T.return) && l.call(T);
} finally {
if (c) throw c.error;
}
}
return {
walls: d,
ramparts: y
};
}
return mc;
}

var dc = {}, yc = {
recalculateInterval: 1e3,
maxPathOps: 2e3,
includeRemoteRoads: !0
}, gc = new Map;

function hc(t, o, n) {
var a, i, s, c, l, u, f, m, p, d, y, g, h, v, R, E, T;
void 0 === n && (n = {});
var S = e(e({}, yc), n), C = gc.get(t.name);
if (C && Game.time - C.lastCalculated < S.recalculateInterval) return C;
var b = new Set, _ = null !== (E = null === (R = t.controller) || void 0 === R ? void 0 : R.level) && void 0 !== E ? E : 0, O = t.find(FIND_SOURCES), w = t.controller, x = t.storage, U = t.find(FIND_MINERALS)[0], M = null !== (T = null == x ? void 0 : x.pos) && void 0 !== T ? T : o;
try {
for (var A = r(O), k = A.next(); !k.done; k = A.next()) {
var N = Sc(M, k.value.pos, t.name, S.maxPathOps);
try {
for (var P = (s = void 0, r(N)), I = P.next(); !I.done; I = P.next()) {
var G = I.value;
b.add("".concat(G.x, ",").concat(G.y));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
I && !I.done && (c = P.return) && c.call(P);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
k && !k.done && (i = A.return) && i.call(A);
} finally {
if (a) throw a.error;
}
}
if (w) {
N = Sc(M, w.pos, t.name, S.maxPathOps);
try {
for (var L = r(N), D = L.next(); !D.done; D = L.next()) G = D.value, b.add("".concat(G.x, ",").concat(G.y));
} catch (e) {
l = {
error: e
};
} finally {
try {
D && !D.done && (u = L.return) && u.call(L);
} finally {
if (l) throw l.error;
}
}
}
if (U && _ >= 6) {
N = Sc(M, U.pos, t.name, S.maxPathOps);
try {
for (var F = r(N), B = F.next(); !B.done; B = F.next()) G = B.value, b.add("".concat(G.x, ",").concat(G.y));
} catch (e) {
f = {
error: e
};
} finally {
try {
B && !B.done && (m = F.return) && m.call(F);
} finally {
if (f) throw f.error;
}
}
}
if (!x) {
try {
for (var j = r(O), H = j.next(); !H.done; H = j.next()) {
N = Sc(o, H.value.pos, t.name, S.maxPathOps);
try {
for (var W = (y = void 0, r(N)), Y = W.next(); !Y.done; Y = W.next()) G = Y.value, 
b.add("".concat(G.x, ",").concat(G.y));
} catch (e) {
y = {
error: e
};
} finally {
try {
Y && !Y.done && (g = W.return) && g.call(W);
} finally {
if (y) throw y.error;
}
}
}
} catch (e) {
p = {
error: e
};
} finally {
try {
H && !H.done && (d = j.return) && d.call(j);
} finally {
if (p) throw p.error;
}
}
if (w) {
N = Sc(o, w.pos, t.name, S.maxPathOps);
try {
for (var K = r(N), V = K.next(); !V.done; V = K.next()) G = V.value, b.add("".concat(G.x, ",").concat(G.y));
} catch (e) {
h = {
error: e
};
} finally {
try {
V && !V.done && (v = K.return) && v.call(K);
} finally {
if (h) throw h.error;
}
}
}
}
var z = {
roomName: t.name,
positions: b,
lastCalculated: Game.time
};
return gc.set(t.name, z), Hr.debug("Calculated road network for ".concat(t.name, ": ").concat(b.size, " positions"), {
subsystem: "RoadNetwork"
}), z;
}

function vc(e, t) {
var r = function(e) {
var t = e.match(/([WE])(\d+)([NS])(\d+)/);
return t ? {
x: ("W" === t[1] ? -1 : 1) * parseInt(t[2], 10),
y: ("N" === t[3] ? 1 : -1) * parseInt(t[4], 10)
} : null;
}, o = r(e), n = r(t);
if (!o || !n) return null;
var a = n.x - o.x, i = n.y - o.y;
return a > 0 ? "right" : a < 0 ? "left" : i > 0 ? "top" : i < 0 ? "bottom" : null;
}

function Rc(e, t) {
var r = [], o = Game.map.getRoomTerrain(e);
switch (t) {
case "top":
for (var n = 0; n < 50; n++) o.get(n, 0) !== TERRAIN_MASK_WALL && r.push(new RoomPosition(n, 0, e));
break;

case "bottom":
for (n = 0; n < 50; n++) o.get(n, 49) !== TERRAIN_MASK_WALL && r.push(new RoomPosition(n, 49, e));
break;

case "left":
for (var a = 0; a < 50; a++) o.get(0, a) !== TERRAIN_MASK_WALL && r.push(new RoomPosition(0, a, e));
break;

case "right":
for (a = 0; a < 50; a++) o.get(49, a) !== TERRAIN_MASK_WALL && r.push(new RoomPosition(49, a, e));
}
return r;
}

function Ec(e, t) {
var o, n;
if (0 === t.length) return null;
var a = t[0], i = e.getRangeTo(a);
try {
for (var s = r(t), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = e.getRangeTo(l);
u < i && (i = u, a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
return a;
}

function Tc(t, o, n) {
var a, i, s, c, l, u, f, m, p;
void 0 === n && (n = {});
var d = e(e({}, yc), n), y = new Map;
if (!d.includeRemoteRoads) return y;
var g = t.storage, h = t.find(FIND_MY_SPAWNS)[0], v = null !== (f = null == g ? void 0 : g.pos) && void 0 !== f ? f : null == h ? void 0 : h.pos;
if (!v) return y;
try {
for (var R = r(o), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
try {
var S = vc(t.name, T);
if (!S) {
Hr.warn("Cannot determine exit direction from ".concat(t.name, " to ").concat(T), {
subsystem: "RoadNetwork"
});
continue;
}
var C = Rc(t.name, S);
if (0 === C.length) {
Hr.warn("No valid exit positions found in ".concat(t.name, " towards ").concat(T), {
subsystem: "RoadNetwork"
});
continue;
}
var b = Ec(v, C);
if (!b) continue;
var _ = PathFinder.search(v, {
pos: b,
range: 0
}, {
plainCost: 2,
swampCost: 10,
maxOps: d.maxPathOps,
roomCallback: function(e) {
return e === t.name && Cc(e);
}
});
if (!_.incomplete) try {
for (var O = (s = void 0, r(_.path)), w = O.next(); !w.done; w = O.next()) {
var x = w.value;
y.has(x.roomName) || y.set(x.roomName, new Set), null === (m = y.get(x.roomName)) || void 0 === m || m.add("".concat(x.x, ",").concat(x.y));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
w && !w.done && (c = O.return) && c.call(O);
} finally {
if (s) throw s.error;
}
}
var U = new RoomPosition(25, 25, T), M = PathFinder.search(v, {
pos: U,
range: 20
}, {
plainCost: 2,
swampCost: 10,
maxOps: d.maxPathOps,
roomCallback: function(e) {
return Cc(e);
}
});
if (!M.incomplete) try {
for (var A = (l = void 0, r(M.path)), k = A.next(); !k.done; k = A.next()) x = k.value, 
y.has(x.roomName) || y.set(x.roomName, new Set), null === (p = y.get(x.roomName)) || void 0 === p || p.add("".concat(x.x, ",").concat(x.y));
} catch (e) {
l = {
error: e
};
} finally {
try {
k && !k.done && (u = A.return) && u.call(A);
} finally {
if (l) throw l.error;
}
}
} catch (e) {
var N = e instanceof Error ? e.message : String(e);
Hr.warn("Failed to calculate remote road to ".concat(T, ": ").concat(N), {
subsystem: "RoadNetwork"
});
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
E && !E.done && (i = R.return) && i.call(R);
} finally {
if (a) throw a.error;
}
}
return y;
}

function Sc(e, t, o, n) {
var a, i, s = [], c = PathFinder.search(e, {
pos: t,
range: 1
}, {
plainCost: 2,
swampCost: 10,
maxOps: n,
roomCallback: function(e) {
return e === o && Cc(e);
}
});
if (!c.incomplete) try {
for (var l = r(c.path), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
f.roomName === o && s.push({
x: f.x,
y: f.y
});
}
} catch (e) {
a = {
error: e
};
} finally {
try {
u && !u.done && (i = l.return) && i.call(l);
} finally {
if (a) throw a.error;
}
}
return s;
}

function Cc(e) {
var t, o, n, a, i = Game.rooms[e], s = new PathFinder.CostMatrix;
if (!i) return s;
var c = i.find(FIND_STRUCTURES);
try {
for (var l = r(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
f.structureType === STRUCTURE_ROAD ? s.set(f.pos.x, f.pos.y, 1) : f.structureType === STRUCTURE_CONTAINER || f.structureType === STRUCTURE_RAMPART && "my" in f && f.my || s.set(f.pos.x, f.pos.y, 255);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
var m = i.find(FIND_MY_CONSTRUCTION_SITES);
try {
for (var p = r(m), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
y.structureType === STRUCTURE_ROAD ? s.set(y.pos.x, y.pos.y, 1) : y.structureType !== STRUCTURE_CONTAINER && s.set(y.pos.x, y.pos.y, 255);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
d && !d.done && (a = p.return) && a.call(p);
} finally {
if (n) throw n.error;
}
}
return s;
}

function bc(e, t) {
return e.x <= t || e.x >= 49 - t || e.y <= t || e.y >= 49 - t;
}

function _c(t, o, n, a) {
var i, s, c, l, u, f, m, p, d, y, g;
void 0 === a && (a = []);
var h = new Set, v = t.getTerrain();
try {
for (var R = r(n), E = R.next(); !E.done; E = R.next()) {
var T = E.value, S = o.x + T.x, C = o.y + T.y;
S >= 1 && S <= 48 && C >= 1 && C <= 48 && v.get(S, C) !== TERRAIN_MASK_WALL && h.add("".concat(S, ",").concat(C));
}
} catch (e) {
i = {
error: e
};
} finally {
try {
E && !E.done && (s = R.return) && s.call(R);
} finally {
if (i) throw i.error;
}
}
var b = hc(t, o);
try {
for (var _ = r(b.positions), O = _.next(); !O.done; O = _.next()) {
var w = O.value;
h.add(w);
}
} catch (e) {
c = {
error: e
};
} finally {
try {
O && !O.done && (l = _.return) && l.call(_);
} finally {
if (c) throw c.error;
}
}
var x = t.storage, U = t.find(FIND_MY_SPAWNS)[0], M = null !== (g = null == x ? void 0 : x.pos) && void 0 !== g ? g : null == U ? void 0 : U.pos;
if (M) {
var A = function(t, o, n) {
var a, i, s, c;
void 0 === n && (n = {});
var l = e(e({}, yc), n), u = new Set;
try {
for (var f = r([ "top", "bottom", "left", "right" ]), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
try {
var d = Rc(t.name, p);
if (0 === d.length) continue;
var y = Ec(o, d);
if (!y) continue;
var g = PathFinder.search(o, {
pos: y,
range: 0
}, {
plainCost: 2,
swampCost: 10,
maxOps: l.maxPathOps,
roomCallback: function(e) {
return e === t.name && Cc(e);
}
});
if (g.incomplete) Hr.warn("Incomplete path when calculating exit road for ".concat(p, " in ").concat(t.name, " (target exit: ").concat(y.x, ",").concat(y.y, "). Path length: ").concat(g.path.length), {
subsystem: "RoadNetwork"
}); else try {
for (var h = (s = void 0, r(g.path)), v = h.next(); !v.done; v = h.next()) {
var R = v.value;
R.roomName === t.name && u.add("".concat(R.x, ",").concat(R.y));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
v && !v.done && (c = h.return) && c.call(h);
} finally {
if (s) throw s.error;
}
}
} catch (e) {
var E = e instanceof Error ? e.message : String(e);
Hr.warn("Failed to calculate exit road for ".concat(p, " in ").concat(t.name, ": ").concat(E), {
subsystem: "RoadNetwork"
});
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
m && !m.done && (i = f.return) && i.call(f);
} finally {
if (a) throw a.error;
}
}
return u;
}(t, M);
try {
for (var k = r(A), N = k.next(); !N.done; N = k.next()) w = N.value, h.add(w);
} catch (e) {
u = {
error: e
};
} finally {
try {
N && !N.done && (f = k.return) && f.call(k);
} finally {
if (u) throw u.error;
}
}
}
if (a.length > 0) {
var P = Tc(t, a).get(t.name);
if (P) try {
for (var I = r(P), G = I.next(); !G.done; G = I.next()) w = G.value, h.add(w);
} catch (e) {
m = {
error: e
};
} finally {
try {
G && !G.done && (p = I.return) && p.call(I);
} finally {
if (m) throw m.error;
}
}
}
var L = function(e, t) {
var o, n, a, i;
void 0 === t && (t = 10);
var s = new Set, c = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
}), l = e.find(FIND_CONSTRUCTION_SITES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
});
try {
for (var u = r(c), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
bc(m.pos, t) && s.add("".concat(m.pos.x, ",").concat(m.pos.y));
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
try {
for (var p = r(l), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
bc(y.pos, t) && s.add("".concat(y.pos.x, ",").concat(y.pos.y));
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
return s;
}(t);
try {
for (var D = r(L), F = D.next(); !F.done; F = D.next()) w = F.value, h.add(w);
} catch (e) {
d = {
error: e
};
} finally {
try {
F && !F.done && (y = D.return) && y.call(D);
} finally {
if (d) throw d.error;
}
}
return h;
}

function Oc(e, t, n) {
var a, i;
void 0 === n && (n = 3);
var s = e.find(FIND_MY_CONSTRUCTION_SITES);
if (s.length >= 10) return 0;
var c = hc(e, t), l = e.getTerrain(), u = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
}), f = new Set(u.map(function(e) {
return "".concat(e.pos.x, ",").concat(e.pos.y);
})), m = new Set(s.filter(function(e) {
return e.structureType === STRUCTURE_ROAD;
}).map(function(e) {
return "".concat(e.pos.x, ",").concat(e.pos.y);
})), p = 0;
try {
for (var d = r(c.positions), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
if (p >= n) break;
if (s.length + p >= 10) break;
if (!f.has(g) && !m.has(g)) {
var h = o(g.split(","), 2), v = h[0], R = h[1], E = parseInt(v, 10), T = parseInt(R, 10);
l.get(E, T) !== TERRAIN_MASK_WALL && e.createConstructionSite(E, T, STRUCTURE_ROAD) === OK && p++;
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
y && !y.done && (i = d.return) && i.call(d);
} finally {
if (a) throw a.error;
}
}
return p;
}

var wc, xc, Uc, Mc, Ac, kc, Nc, Pc, Ic, Gc, Lc = m(Object.freeze({
__proto__: null,
calculateRemoteRoads: Tc,
calculateRoadNetwork: hc,
clearAllRoadNetworkCaches: function() {
gc.clear();
},
clearRoadNetworkCache: function(e) {
gc.delete(e);
},
getCachedRoadNetwork: function(e) {
return gc.get(e);
},
getValidRoadPositions: _c,
isValidRoadPosition: function(e, t, r, o, n, a) {
return void 0 === a && (a = []), _c(e, o, n, a).has("".concat(t, ",").concat(r));
},
placeRoadConstructionSites: Oc
})), Dc = {}, Fc = m(Yi), Bc = m(Vo), jc = {}, Hc = {}, Wc = m(mi), Yc = {}, Kc = m(vi), Vc = {}, zc = {}, qc = (Pc || (Pc = 1, 
function(e) {
Object.defineProperty(e, "__esModule", {
value: !0
}), e.EvacuationManager = e.evacuationManager = e.SafeModeManager = e.safeModeManager = e.EmergencyLevel = e.EmergencyResponseManager = e.emergencyResponseManager = e.coordinateClusterDefense = e.clusterDefenseCoordinator = e.ClusterDefenseCoordinator = e.checkAndExecuteRetreat = e.DefenseCoordinator = e.defenseCoordinator = e.placeRoadAwarePerimeterDefense = e.placePerimeterDefense = e.calculateWallRepairTarget = e.placeRampartsOnCriticalStructures = e.logThreatAnalysis = e.estimateDefenderCost = e.calculateDangerLevel = e.calculateTowerDamage = e.assessThreat = e.hasActualHostiles = e.getActualHostileStructures = e.getActualHostileCreeps = e.filterAllyStructures = e.filterAllyCreeps = e.isAllyStructure = e.isAllyCreep = e.isAllyPlayer = e.NON_AGGRESSION_PACT_PLAYERS = void 0;
var t = ec();
Object.defineProperty(e, "NON_AGGRESSION_PACT_PLAYERS", {
enumerable: !0,
get: function() {
return t.NON_AGGRESSION_PACT_PLAYERS;
}
}), Object.defineProperty(e, "isAllyPlayer", {
enumerable: !0,
get: function() {
return t.isAllyPlayer;
}
}), Object.defineProperty(e, "isAllyCreep", {
enumerable: !0,
get: function() {
return t.isAllyCreep;
}
}), Object.defineProperty(e, "isAllyStructure", {
enumerable: !0,
get: function() {
return t.isAllyStructure;
}
}), Object.defineProperty(e, "filterAllyCreeps", {
enumerable: !0,
get: function() {
return t.filterAllyCreeps;
}
}), Object.defineProperty(e, "filterAllyStructures", {
enumerable: !0,
get: function() {
return t.filterAllyStructures;
}
}), Object.defineProperty(e, "getActualHostileCreeps", {
enumerable: !0,
get: function() {
return t.getActualHostileCreeps;
}
}), Object.defineProperty(e, "getActualHostileStructures", {
enumerable: !0,
get: function() {
return t.getActualHostileStructures;
}
}), Object.defineProperty(e, "hasActualHostiles", {
enumerable: !0,
get: function() {
return t.hasActualHostiles;
}
});
var r = ac();
Object.defineProperty(e, "assessThreat", {
enumerable: !0,
get: function() {
return r.assessThreat;
}
}), Object.defineProperty(e, "calculateTowerDamage", {
enumerable: !0,
get: function() {
return r.calculateTowerDamage;
}
}), Object.defineProperty(e, "calculateDangerLevel", {
enumerable: !0,
get: function() {
return r.calculateDangerLevel;
}
}), Object.defineProperty(e, "estimateDefenderCost", {
enumerable: !0,
get: function() {
return r.estimateDefenderCost;
}
}), Object.defineProperty(e, "logThreatAnalysis", {
enumerable: !0,
get: function() {
return r.logThreatAnalysis;
}
});
var o = function() {
if (sc) return cc;
sc = 1;
var e = cc && cc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(cc, "__esModule", {
value: !0
}), cc.placeRampartsOnCriticalStructures = function(o, n, i, s) {
var c, l, u, f;
void 0 === s && (s = 5);
var m = {
placed: 0,
needsRepair: 0,
totalCritical: 0,
protected: 0
};
if (n < 2) return m;
var p = a(o, n);
if (m.totalCritical = p.length, 0 === p.length) return m;
var d = o.find(FIND_MY_CONSTRUCTION_SITES);
if (d.length >= 10) return m;
var y = Math.min(s, 10 - d.length), g = o.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_RAMPART;
}
}), h = (0, r.calculateWallRepairTarget)(n, i), v = [], R = function(e) {
var t = e.pos, r = t.x, n = t.y;
if (function(e, t, r) {
return e.lookForAt(LOOK_STRUCTURES, t, r).some(function(e) {
return e.structureType === STRUCTURE_RAMPART;
});
}(o, r, n)) {
m.protected++;
var a = g.find(function(e) {
return e.pos.x === r && e.pos.y === n;
});
a && a.hits < h && m.needsRepair++;
} else if (!function(e, t, r) {
return e.lookForAt(LOOK_CONSTRUCTION_SITES, t, r).some(function(e) {
return e.structureType === STRUCTURE_RAMPART;
});
}(o, r, n)) {
var s = 10;
e.structureType === STRUCTURE_SPAWN ? s = 100 : e.structureType === STRUCTURE_STORAGE ? s = 90 : e.structureType === STRUCTURE_TOWER ? s = 80 : e.structureType === STRUCTURE_TERMINAL ? s = 70 : e.structureType === STRUCTURE_LAB && (s = 60), 
i >= 2 && (s += 50), v.push({
structure: e,
priority: s
});
}
};
try {
for (var E = e(p), T = E.next(); !T.done; T = E.next()) R(b = T.value);
} catch (e) {
c = {
error: e
};
} finally {
try {
T && !T.done && (l = E.return) && l.call(E);
} finally {
if (c) throw c.error;
}
}
v.sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var S = e(v), C = S.next(); !C.done; C = S.next()) {
var b = C.value.structure;
if (m.placed >= y) break;
var _ = b.pos, O = _.x, w = _.y, x = o.createConstructionSite(O, w, STRUCTURE_RAMPART);
if (x === OK) m.placed++, t.logger.debug("Placed rampart on ".concat(b.structureType, " at (").concat(O, ",").concat(w, ")"), {
subsystem: "Defense"
}); else if (x === ERR_FULL) break;
}
} catch (e) {
u = {
error: e
};
} finally {
try {
C && !C.done && (f = S.return) && f.call(S);
} finally {
if (u) throw u.error;
}
}
return (m.placed > 0 || v.length > 0) && t.logger.info("Rampart automation for ".concat(o.name, ": ") + "".concat(m.protected, "/").concat(m.totalCritical, " protected, ") + "".concat(m.placed, " placed, ") + "".concat(v.length - m.placed, " pending"), {
subsystem: "Defense"
}), m;
}, cc.getEmergencyRampartRepairs = function(e, t, o, n) {
void 0 === n && (n = 5);
var a = .25 * (0, r.calculateWallRepairTarget)(t, o), i = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_RAMPART && e.hits < a;
}
});
return i.sort(function(e, t) {
return e.hits - t.hits;
}), i.slice(0, n);
}, cc.getCriticalRampartRepairs = function(t, o, n, i) {
var s, c;
void 0 === i && (i = 10);
var l = (0, r.calculateWallRepairTarget)(o, n), u = a(t, o), f = [];
try {
for (var m = e(u), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = d.pos, g = y.x, h = y.y, v = t.lookForAt(LOOK_STRUCTURES, g, h).find(function(e) {
return e.structureType === STRUCTURE_RAMPART;
});
if (v && v.hits < l) {
var R = 10;
d.structureType === STRUCTURE_SPAWN ? R = 100 : d.structureType === STRUCTURE_STORAGE ? R = 90 : d.structureType === STRUCTURE_TOWER ? R = 80 : d.structureType === STRUCTURE_TERMINAL && (R = 70), 
R *= 1 - v.hits / l, f.push({
rampart: v,
priority: R
});
}
}
} catch (e) {
s = {
error: e
};
} finally {
try {
p && !p.done && (c = m.return) && c.call(m);
} finally {
if (s) throw s.error;
}
}
return f.sort(function(e, t) {
return t.priority - e.priority;
}), f.slice(0, i).map(function(e) {
return e.rampart;
});
}, cc.getRampartCoverageStats = function(t, o, n) {
var i, s, c = a(t, o), l = (0, r.calculateWallRepairTarget)(o, n), u = 0, f = 0;
try {
for (var m = e(c), p = m.next(); !p.done; p = m.next()) {
var d = p.value.pos, y = d.x, g = d.y, h = t.lookForAt(LOOK_STRUCTURES, y, g).find(function(e) {
return e.structureType === STRUCTURE_RAMPART;
});
h && (u++, h.hits < l && f++);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
p && !p.done && (s = m.return) && s.call(m);
} finally {
if (i) throw i.error;
}
}
var v = c.length - u, R = c.length > 0 ? Math.round(u / c.length * 100) : 0;
return {
totalCritical: c.length,
protected: u,
unprotected: v,
needsRepair: f,
coveragePercent: R
};
};
var t = oc, r = uc(), o = [ STRUCTURE_SPAWN, STRUCTURE_STORAGE, STRUCTURE_TERMINAL, STRUCTURE_TOWER, STRUCTURE_LAB, STRUCTURE_FACTORY, STRUCTURE_POWER_SPAWN, STRUCTURE_NUKER, STRUCTURE_OBSERVER ], n = [ STRUCTURE_SPAWN, STRUCTURE_TOWER, STRUCTURE_STORAGE ];
function a(e, t) {
var r = e.find(FIND_MY_STRUCTURES), a = t < 4 ? n : o;
return r.filter(function(e) {
return a.includes(e.structureType);
});
}
return cc;
}();
Object.defineProperty(e, "placeRampartsOnCriticalStructures", {
enumerable: !0,
get: function() {
return o.placeRampartsOnCriticalStructures;
}
});
var n = uc();
Object.defineProperty(e, "calculateWallRepairTarget", {
enumerable: !0,
get: function() {
return n.calculateWallRepairTarget;
}
});
var a = pc();
Object.defineProperty(e, "placePerimeterDefense", {
enumerable: !0,
get: function() {
return a.placePerimeterDefense;
}
});
var i = function() {
if (wc) return dc;
wc = 1;
var e = dc && dc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, t = dc && dc.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
}, r = dc && dc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(dc, "__esModule", {
value: !0
}), dc.calculateRoadAwarePerimeter = c, dc.placeRoadAwarePerimeterDefense = function(e, t, n, a, l, u) {
var f, m, p, d, y, g;
if (void 0 === l && (l = 3), void 0 === u && (u = []), a < 2) return {
sitesPlaced: 0,
wallsRemoved: 0
};
var h = c(e, t, n, u), v = e.find(FIND_MY_CONSTRUCTION_SITES), R = e.find(FIND_STRUCTURES);
if (v.length >= i) return {
sitesPlaced: 0,
wallsRemoved: 0
};
var E = 0, T = 0, S = Math.min(l, i - v.length), C = R.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}).length + v.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}).length, b = R.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}).length + v.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}).length, _ = a >= 2 ? s : 0, O = a >= 2 ? s : 0;
if (a >= 3 && h.wallsToRemove.length > 0) {
var w = function(e) {
var t = R.find(function(t) {
return t.structureType === STRUCTURE_WALL && t.pos.x === e.x && t.pos.y === e.y;
});
if (t && !R.some(function(t) {
return t.structureType === STRUCTURE_RAMPART && t.pos.x === e.x && t.pos.y === e.y;
})) {
var r = t.destroy();
r === OK ? (T++, o.logger.info("Removed wall at (".concat(e.x, ",").concat(e.y, ") to allow road passage"), {
subsystem: "Defense"
})) : o.logger.warn("Failed to remove wall at (".concat(e.x, ",").concat(e.y, "): ").concat(r), {
subsystem: "Defense"
});
}
};
try {
for (var x = r(h.wallsToRemove), U = x.next(); !U.done; U = x.next()) w(U.value);
} catch (e) {
f = {
error: e
};
} finally {
try {
U && !U.done && (m = x.return) && m.call(x);
} finally {
if (f) throw f.error;
}
}
}
if (a >= 2 && E < S && C < _) {
var M = function(t) {
if (E >= S) return "break";
if (C + E >= _) return "break";
var r = R.some(function(e) {
return e.pos.x === t.x && e.pos.y === t.y && (e.structureType === STRUCTURE_WALL || e.structureType === STRUCTURE_RAMPART);
}), n = v.some(function(e) {
return e.pos.x === t.x && e.pos.y === t.y && (e.structureType === STRUCTURE_WALL || e.structureType === STRUCTURE_RAMPART);
});
r || n || e.createConstructionSite(t.x, t.y, STRUCTURE_WALL) === OK && (E++, o.logger.debug("Placed perimeter wall at (".concat(t.x, ",").concat(t.y, ")"), {
subsystem: "Defense"
}));
};
try {
for (var A = r(h.walls), k = A.next(); !k.done && "break" !== M(k.value); k = A.next()) ;
} catch (e) {
p = {
error: e
};
} finally {
try {
k && !k.done && (d = A.return) && d.call(A);
} finally {
if (p) throw p.error;
}
}
}
if (a >= 3 && E < S && b < O) {
var N = function(t) {
if (E >= S) return "break";
if (b + E >= O) return "break";
var r = R.some(function(e) {
return e.pos.x === t.x && e.pos.y === t.y && e.structureType === STRUCTURE_RAMPART;
}), n = v.some(function(e) {
return e.pos.x === t.x && e.pos.y === t.y && e.structureType === STRUCTURE_RAMPART;
}), a = R.some(function(e) {
return e.pos.x === t.x && e.pos.y === t.y && e.structureType === STRUCTURE_WALL;
});
r || n || a || e.createConstructionSite(t.x, t.y, STRUCTURE_RAMPART) === OK && (E++, 
h.roadCrossings.some(function(e) {
return e.x === t.x && e.y === t.y;
}) ? o.logger.debug("Placed rampart at road crossing (".concat(t.x, ",").concat(t.y, ")"), {
subsystem: "Defense"
}) : o.logger.debug("Placed rampart gap at (".concat(t.x, ",").concat(t.y, ")"), {
subsystem: "Defense"
}));
};
try {
for (var P = r(h.ramparts), I = P.next(); !I.done && "break" !== N(I.value); I = P.next()) ;
} catch (e) {
y = {
error: e
};
} finally {
try {
I && !I.done && (g = P.return) && g.call(P);
} finally {
if (y) throw y.error;
}
}
}
return {
sitesPlaced: E,
wallsRemoved: T
};
}, dc.getRoadAwarePerimeterStats = function(e, t, o, n) {
var a, i, s, l;
void 0 === n && (n = []);
var u = c(e, t, o, n), f = e.find(FIND_STRUCTURES), m = u.walls.length, p = u.ramparts.length, d = u.roadCrossings.length, y = u.wallsToRemove.length, g = f.filter(function(e) {
return e.structureType === STRUCTURE_WALL;
}), h = f.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART;
}), v = 0, R = function(e) {
u.walls.some(function(t) {
return t.x === e.pos.x && t.y === e.pos.y;
}) && v++;
};
try {
for (var E = r(g), T = E.next(); !T.done; T = E.next()) R(T.value);
} catch (e) {
a = {
error: e
};
} finally {
try {
T && !T.done && (i = E.return) && i.call(E);
} finally {
if (a) throw a.error;
}
}
var S = 0, C = function(e) {
u.ramparts.some(function(t) {
return t.x === e.pos.x && t.y === e.pos.y;
}) && S++;
};
try {
for (var b = r(h), _ = b.next(); !_.done; _ = b.next()) C(_.value);
} catch (e) {
s = {
error: e
};
} finally {
try {
_ && !_.done && (l = b.return) && l.call(b);
} finally {
if (s) throw s.error;
}
}
var O = m > 0 ? Math.round(v / m * 100) : 0, w = p > 0 ? Math.round(S / p * 100) : 0;
return {
totalWallPositions: m,
totalRampartPositions: p,
roadCrossings: d,
wallsBuilt: v,
rampartsBuilt: S,
wallsBlockingRoads: y,
wallCoveragePercent: O,
rampartCoveragePercent: w
};
};
var o = oc, n = Lc, a = pc(), i = 10, s = 2500;
function c(o, i, s, c) {
var l, u, f, m;
void 0 === c && (c = []);
var p = (0, n.getValidRoadPositions)(o, i, s, c), d = (0, a.calculatePerimeterPositions)(o.name), y = [], g = [], h = t([], e(d.ramparts), !1);
try {
for (var v = r(d.walls), R = v.next(); !R.done; R = v.next()) {
var E = R.value, T = "".concat(E.x, ",").concat(E.y);
p.has(T) ? (y.push(E), h.push(E)) : g.push(E);
}
} catch (e) {
l = {
error: e
};
} finally {
try {
R && !R.done && (u = v.return) && u.call(v);
} finally {
if (l) throw l.error;
}
}
var S = [], C = o.find(FIND_STRUCTURES);
try {
for (var b = r(C), _ = b.next(); !_.done; _ = b.next()) {
var O = _.value;
O.structureType === STRUCTURE_WALL && (T = "".concat(O.pos.x, ",").concat(O.pos.y), 
p.has(T) && S.push({
x: O.pos.x,
y: O.pos.y
}));
}
} catch (e) {
f = {
error: e
};
} finally {
try {
_ && !_.done && (m = b.return) && m.call(b);
} finally {
if (f) throw f.error;
}
}
return {
walls: g,
ramparts: h,
roadCrossings: y,
wallsToRemove: S
};
}
return dc;
}();
Object.defineProperty(e, "placeRoadAwarePerimeterDefense", {
enumerable: !0,
get: function() {
return i.placeRoadAwarePerimeterDefense;
}
});
var s = function() {
if (xc) return Dc;
xc = 1;
var e = Dc && Dc.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, t = Dc && Dc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = Dc && Dc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(Dc, "__esModule", {
value: !0
}), Dc.defenseCoordinator = Dc.DefenseCoordinator = void 0;
var o = oc, n = Fc, a = Bc, i = ac(), s = ec(), c = function() {
function c() {
this.assignments = new Map;
}
return c.prototype.getDefenseRequestsFromMemory = function() {
var e;
return null !== (e = Memory.defenseRequests) && void 0 !== e ? e : [];
}, c.prototype.setDefenseRequestsInMemory = function(e) {
Memory.defenseRequests = e;
}, c.prototype.run = function() {
var e, r, o = this.getDefenseRequestsFromMemory();
this.cleanupAssignments();
try {
for (var n = t(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
this.processDefenseRequest(i);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (r = n.return) && r.call(n);
} finally {
if (e) throw e.error;
}
}
}, c.prototype.processDefenseRequest = function(e) {
var t = Game.rooms[e.roomName];
if (t) {
var r = (0, i.assessThreat)(t), o = Math.max(e.urgency, r.dangerLevel, r.assistanceRequired ? 3 : 0), n = this.getAssignedDefenders(e.roomName, "guard"), a = this.getAssignedDefenders(e.roomName, "ranger"), s = r.assistanceRequired ? Math.max(0, Math.ceil(r.totalHostileDPS / 300) - n.length) : 0, c = r.assistanceRequired ? Math.max(0, Math.ceil(r.totalHostileDPS / 300) - a.length) : 0, l = Math.max(0, e.guardsNeeded - n.length, s), u = Math.max(0, e.rangersNeeded - a.length, c);
0 === l && 0 === u || (l > 0 && this.assignDefenders(e.roomName, "guard", l, o), 
u > 0 && this.assignDefenders(e.roomName, "ranger", u, o));
}
}, c.prototype.assignDefenders = function(e, r, n, a) {
var i, s, c = this, l = this.findHelperRooms(e, a), u = 0;
try {
for (var f = t(l), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
if (u >= n) break;
for (var d = p.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory;
return t.role === r && !t.assistTarget && !c.assignments.has(e.name);
}
}), y = Math.min(d.length, 2, n - u), g = 0; g < y; g++) {
var h = d[g];
if (h) {
var v = Game.map.getRoomLinearDistance(p.name, e), R = Game.time + 50 * v, E = {
creepName: h.name,
targetRoom: e,
assignedAt: Game.time,
eta: R
};
this.assignments.set(h.name, E), h.memory.assistTarget = e, u++, o.logger.info("Assigned ".concat(r, " ").concat(h.name, " from ").concat(p.name, " to assist ").concat(e, " (ETA: ").concat(R - Game.time, " ticks)"), {
subsystem: "Defense"
});
}
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
m && !m.done && (s = f.return) && s.call(f);
} finally {
if (i) throw i.error;
}
}
u > 0 && o.logger.info("Defense coordination: Assigned ".concat(u, "/").concat(n, " ").concat(r, "s to ").concat(e), {
subsystem: "Defense"
});
}, c.prototype.findHelperRooms = function(e, t) {
var r = Object.values(Game.rooms).filter(function(t) {
var r;
return (null === (r = t.controller) || void 0 === r ? void 0 : r.my) && t.name !== e;
});
return r.map(function(r) {
var o = 0;
o -= 10 * Game.map.getRoomLinearDistance(e, r.name), o += 20 * r.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory, r = t.role;
return ("guard" === r || "ranger" === r) && !t.assistTarget;
}
}).length;
var n = r.find(FIND_HOSTILE_CREEPS), a = (0, s.filterAllyCreeps)(n);
return o -= 30 * a.length, a.length > 0 && t < 3 && (o -= 1e3), {
room: r,
score: o
};
}).filter(function(e) {
return e.score > -500;
}).sort(function(e, t) {
return t.score - e.score;
}).map(function(e) {
return e.room;
});
}, c.prototype.getAssignedDefenders = function(e, o) {
var n, a, i = [];
try {
for (var s = t(this.assignments.entries()), c = s.next(); !c.done; c = s.next()) {
var l = r(c.value, 2), u = l[0], f = l[1];
if (f.targetRoom === e) {
var m = Game.creeps[u];
if (m) {
if (o && m.memory.role !== o) continue;
i.push(f);
}
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
c && !c.done && (a = s.return) && a.call(s);
} finally {
if (n) throw n.error;
}
}
return i;
}, c.prototype.cleanupAssignments = function() {
var e, n, a, i, c = [];
try {
for (var l = t(this.assignments.entries()), u = l.next(); !u.done; u = l.next()) {
var f = r(u.value, 2), m = f[0], p = f[1], d = Game.creeps[m];
if (d) {
if (d.room.name === p.targetRoom) {
var y = d.room.find(FIND_HOSTILE_CREEPS);
0 === (0, s.filterAllyCreeps)(y).length && (delete d.memory.assistTarget, c.push(m), 
o.logger.debug("Released ".concat(m, " from defense assistance (no hostiles in ").concat(p.targetRoom, ")"), {
subsystem: "Defense"
}));
}
Game.time - p.assignedAt > 1e3 && (delete d.memory.assistTarget, c.push(m), o.logger.debug("Removed stale defense assignment for ".concat(m), {
subsystem: "Defense"
}));
} else c.push(m);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (e) throw e.error;
}
}
try {
for (var g = t(c), h = g.next(); !h.done; h = g.next()) m = h.value, this.assignments.delete(m);
} catch (e) {
a = {
error: e
};
} finally {
try {
h && !h.done && (i = g.return) && i.call(g);
} finally {
if (a) throw a.error;
}
}
}, c.prototype.getAssignmentsForRoom = function(e) {
return this.getAssignedDefenders(e);
}, c.prototype.getAllAssignments = function() {
return Array.from(this.assignments.values());
}, c.prototype.cancelAssignment = function(e) {
if (this.assignments.get(e)) {
var t = Game.creeps[e];
t && delete t.memory.assistTarget, this.assignments.delete(e), o.logger.info("Cancelled defense assignment for ".concat(e), {
subsystem: "Defense"
});
}
}, e([ (0, n.MediumFrequencyProcess)("cluster:defense", "Defense Coordinator", {
priority: a.ProcessPriority.HIGH,
interval: 3,
minBucket: 0,
cpuBudget: .05
}) ], c.prototype, "run", null), e([ (0, n.ProcessClass)() ], c);
}();
return Dc.DefenseCoordinator = c, Dc.defenseCoordinator = new c, Dc;
}();
Object.defineProperty(e, "defenseCoordinator", {
enumerable: !0,
get: function() {
return s.defenseCoordinator;
}
}), Object.defineProperty(e, "DefenseCoordinator", {
enumerable: !0,
get: function() {
return s.DefenseCoordinator;
}
});
var c = function() {
if (Uc) return jc;
Uc = 1;
var e = jc && jc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = jc && jc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, r = jc && jc.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(jc, "__esModule", {
value: !0
}), jc.shouldRetreat = a, jc.executeRetreat = i, jc.checkAndExecuteRetreat = function(e) {
return !!a(e, (0, n.assessThreat)(e.room)) && (i(e), !0);
};
var o = oc, n = ac();
function a(e, t) {
if ("retreat" === t.recommendedResponse || "safemode" === t.recommendedResponse) return !0;
var r = e.room.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory;
return "defender" === t.role || "rangedDefender" === t.role || "guard" === t.role || "ranger" === t.role;
}
});
if (t.hostileCount > 3 * r.length) return o.logger.info("Creep ".concat(e.name, " retreating: heavily outnumbered (").concat(t.hostileCount, " hostiles vs ").concat(r.length, " defenders)"), {
subsystem: "Defense",
room: e.room.name,
creep: e.name
}), !0;
var n = e.room.find(FIND_MY_CREEPS, {
filter: function(e) {
return "healer" === e.memory.role;
}
});
return e.hits < .3 * e.hitsMax && t.healerCount > 0 && 0 === n.length ? (o.logger.info("Creep ".concat(e.name, " retreating: damaged (").concat(e.hits, "/").concat(e.hitsMax, ") facing ").concat(t.healerCount, " enemy healers without friendly healer support"), {
subsystem: "Defense",
room: e.room.name,
creep: e.name
}), !0) : t.boostedCount > 0 && r.length < 2 * t.boostedCount && (o.logger.info("Creep ".concat(e.name, " retreating: facing ").concat(t.boostedCount, " boosted hostiles without sufficient support"), {
subsystem: "Defense",
room: e.room.name,
creep: e.name
}), !0);
}
function i(o) {
var n, a, i, s, c = o.room.find(FIND_MY_SPAWNS)[0];
if (c) {
var l = o.moveTo(c, {
range: 3,
visualizePathStyle: {
stroke: "#ffaa00"
}
});
if (l === OK || l === ERR_TIRED) return;
}
var u = Game.map.describeExits(o.room.name);
if (u) {
var f = ((n = {})[TOP] = FIND_EXIT_TOP, n[BOTTOM] = FIND_EXIT_BOTTOM, n[LEFT] = FIND_EXIT_LEFT, 
n[RIGHT] = FIND_EXIT_RIGHT, n), m = [];
try {
for (var p = e(Object.entries(u)), d = p.next(); !d.done; d = p.next()) {
var y = t(d.value, 2), g = y[0], h = y[1], v = Number(g), R = Game.rooms[h];
if (null === (s = null == R ? void 0 : R.controller) || void 0 === s ? void 0 : s.my) {
var E = f[v];
if (E) {
var T = o.room.find(E);
T.length > 0 && m.push.apply(m, r([], t(T), !1));
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
if (m.length > 0) {
var S = o.pos.findClosestByPath(m);
if (S) return void o.moveTo(S, {
visualizePathStyle: {
stroke: "#ffaa00"
}
});
}
}
var C = o.pos.findClosestByPath(FIND_EXIT);
C && o.moveTo(C, {
visualizePathStyle: {
stroke: "#ff0000"
}
});
}
return jc;
}();
Object.defineProperty(e, "checkAndExecuteRetreat", {
enumerable: !0,
get: function() {
return c.checkAndExecuteRetreat;
}
});
var l = (Mc || (Mc = 1, function(e) {
var t = Hc && Hc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, r = Hc && Hc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, o = Hc && Hc.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty(e, "__esModule", {
value: !0
}), e.clusterDefenseCoordinator = e.ClusterDefenseCoordinator = void 0, e.coordinateClusterDefense = function(t) {
var r = function(e) {
return a.memoryManager.getOrInitSwarmState(e).clusterId;
}(t);
r && e.clusterDefenseCoordinator.coordinateDefense(r);
};
var n = oc, a = Wc, i = ac(), s = function() {
function e() {}
return e.prototype.coordinateDefense = function(e) {
var r, o, s, c, l = function(e) {
var t = a.memoryManager.getCluster(e);
return t ? t.memberRooms : [];
}(e);
if (0 !== l.length) {
var u = [];
try {
for (var f = t(l), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = Game.rooms[p];
if (d) {
var y = (0, i.assessThreat)(d);
u.push(y), y.dangerLevel >= 2 && (0, i.logThreatAnalysis)(y);
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
m && !m.done && (o = f.return) && o.call(f);
} finally {
if (r) throw r.error;
}
}
var g = u.filter(function(e) {
return e.assistanceRequired;
}).sort(function(e, t) {
return t.assistancePriority - e.assistancePriority;
});
try {
for (var h = t(g), v = h.next(); !v.done; v = h.next()) {
var R = v.value, E = this.findAvailableDefenders(l, R.roomName);
E.length > 0 && (this.sendDefenders(E, R.roomName), n.logger.info("Cluster Defense: Sending ".concat(E.length, " defenders to ").concat(R.roomName), {
subsystem: "Defense",
room: R.roomName,
meta: {
cluster: e,
targetRoom: R.roomName,
threatScore: R.threatScore,
priority: R.assistancePriority
}
}));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
v && !v.done && (c = h.return) && c.call(h);
} finally {
if (s) throw s.error;
}
}
this.coordinateSafeMode(u);
}
}, e.prototype.findAvailableDefenders = function(e, n) {
var a, s, c = [];
try {
for (var l = t(e), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if (f !== n) {
var m = Game.rooms[f];
if (m && 0 === (0, i.assessThreat)(m).dangerLevel) {
var p = m.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory;
return ("defender" === t.role || "rangedDefender" === t.role || "guard" === t.role || "ranger" === t.role) && !t.assistTarget;
}
});
c.push.apply(c, o([], r(p), !1));
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
u && !u.done && (s = l.return) && s.call(l);
} finally {
if (a) throw a.error;
}
}
return c;
}, e.prototype.sendDefenders = function(e, r) {
var o, n;
try {
for (var a = t(e), i = a.next(); !i.done; i = a.next()) i.value.memory.assistTarget = r;
} catch (e) {
o = {
error: e
};
} finally {
try {
i && !i.done && (n = a.return) && n.call(a);
} finally {
if (o) throw o.error;
}
}
}, e.prototype.coordinateSafeMode = function(e) {
var t, r = e.filter(function(e) {
return "safemode" === e.recommendedResponse;
});
if (0 !== r.length) {
var o = r.reduce(function(e, t) {
return t.threatScore > e.threatScore ? t : e;
}), a = Game.rooms[o.roomName];
if ((null === (t = null == a ? void 0 : a.controller) || void 0 === t ? void 0 : t.my) && a.controller.safeModeAvailable > 0 && !a.controller.safeMode && !a.controller.safeModeCooldown) {
var i = a.controller.activateSafeMode();
i === OK ? n.logger.warn("Activated safe mode in ".concat(o.roomName), {
subsystem: "Defense",
room: o.roomName,
meta: {
threatScore: o.threatScore,
hostiles: o.hostileCount,
dangerLevel: o.dangerLevel
}
}) : n.logger.error("Failed to activate safe mode in ".concat(o.roomName, ": ").concat(i), {
subsystem: "Defense",
room: o.roomName,
meta: {
errorCode: i
}
});
}
}
}, e;
}();
e.ClusterDefenseCoordinator = s, e.clusterDefenseCoordinator = new s;
}(Hc)), Hc);
Object.defineProperty(e, "ClusterDefenseCoordinator", {
enumerable: !0,
get: function() {
return l.ClusterDefenseCoordinator;
}
}), Object.defineProperty(e, "clusterDefenseCoordinator", {
enumerable: !0,
get: function() {
return l.clusterDefenseCoordinator;
}
}), Object.defineProperty(e, "coordinateClusterDefense", {
enumerable: !0,
get: function() {
return l.coordinateClusterDefense;
}
});
var u = function() {
if (Ac) return Yc;
Ac = 1;
var e = Yc && Yc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = Yc && Yc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(Yc, "__esModule", {
value: !0
}), Yc.emergencyResponseManager = Yc.EmergencyResponseManager = Yc.EmergencyLevel = void 0;
var r, o = oc, n = Kc, a = ec();
!function(e) {
e[e.NONE = 0] = "NONE", e[e.LOW = 1] = "LOW", e[e.MEDIUM = 2] = "MEDIUM", e[e.HIGH = 3] = "HIGH", 
e[e.CRITICAL = 4] = "CRITICAL";
}(r || (Yc.EmergencyLevel = r = {}));
var i = function() {
function i() {
this.emergencyStates = new Map;
}
return i.prototype.assess = function(e, t) {
var n, a = this.emergencyStates.get(e.name), i = this.calculateEmergencyLevel(e, t);
return i !== r.NONE || a ? (a ? (n = a).level = i : (n = {
level: i,
startedAt: Game.time,
assistanceRequested: !1,
boostsAllocated: !1,
lastEscalation: 0
}, this.emergencyStates.set(e.name, n)), i === r.NONE ? (a && (o.logger.info("Emergency resolved in ".concat(e.name), {
subsystem: "Defense"
}), this.emergencyStates.delete(e.name)), n) : (a && i > a.level && (o.logger.warn("Emergency escalated in ".concat(e.name, ": Level ").concat(a.level, "  ").concat(i), {
subsystem: "Defense"
}), n.lastEscalation = Game.time), this.executeEmergencyResponse(e, t, n), n)) : {
level: r.NONE,
startedAt: Game.time,
assistanceRequested: !1,
boostsAllocated: !1,
lastEscalation: 0
};
}, i.prototype.calculateEmergencyLevel = function(e, t) {
if (0 === t.danger) return r.NONE;
var o = e.find(FIND_HOSTILE_CREEPS), i = (0, a.filterAllyCreeps)(o), s = (0, n.analyzeDefenderNeeds)(e), c = (0, 
n.getCurrentDefenders)(e);
if (e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return (e.structureType === STRUCTURE_SPAWN || e.structureType === STRUCTURE_STORAGE || e.structureType === STRUCTURE_TERMINAL) && e.hits < .3 * e.hitsMax;
}
}).length > 0) return r.CRITICAL;
var l = i.filter(function(e) {
return e.body.some(function(e) {
return e.boost;
});
}), u = s.guards - c.guards + (s.rangers - c.rangers);
return l.length > 0 && u >= 2 || i.length >= 5 && 0 === c.guards && 0 === c.rangers ? r.HIGH : t.danger >= 2 && u >= 1 ? r.MEDIUM : t.danger >= 1 ? r.LOW : r.NONE;
}, i.prototype.executeEmergencyResponse = function(e, t, o) {
o.level !== r.HIGH && o.level !== r.CRITICAL || o.assistanceRequested || this.requestDefenseAssistance(e, t) && (o.assistanceRequested = !0), 
o.level >= r.MEDIUM && !o.boostsAllocated && e.controller && e.controller.level >= 6 && (this.allocateBoostsForDefense(e, t), 
o.boostsAllocated = !0), this.updateDefensePosture(e, t, o);
}, i.prototype.requestDefenseAssistance = function(e, t) {
var r;
if (!(0, n.needsDefenseAssistance)(e, t)) return !1;
var a = (0, n.createDefenseRequest)(e, t);
if (!a) return !1;
var i = Memory, s = (null !== (r = i.defenseRequests) && void 0 !== r ? r : []).filter(function(t) {
return t.roomName !== e.name || Game.time - t.createdAt < 500;
});
return s.push(a), i.defenseRequests = s, o.logger.warn("Defense assistance requested for ".concat(e.name, ": ") + "".concat(a.guardsNeeded, " guards, ").concat(a.rangersNeeded, " rangers - ").concat(a.threat), {
subsystem: "Defense"
}), !0;
}, i.prototype.allocateBoostsForDefense = function(e, t) {
var r, n = Memory, a = null !== (r = n.boostDefensePriority) && void 0 !== r ? r : {};
a[e.name] = !0, n.boostDefensePriority = a, o.logger.info("Allocated boost priority for defenders in ".concat(e.name), {
subsystem: "Defense"
});
}, i.prototype.updateDefensePosture = function(e, t, n) {
switch (n.level) {
case r.CRITICAL:
"evacuate" !== t.posture && (t.posture = "war", t.pheromones.war = 100, t.pheromones.defense = 100, 
o.logger.warn("".concat(e.name, " posture: CRITICAL DEFENSE"), {
subsystem: "Defense"
}));
break;

case r.HIGH:
"war" !== t.posture && "evacuate" !== t.posture && (t.posture = "defensive", t.pheromones.defense = 80, 
t.pheromones.war = 40, o.logger.info("".concat(e.name, " posture: HIGH DEFENSE"), {
subsystem: "Defense"
}));
break;

case r.MEDIUM:
"eco" !== t.posture && "expand" !== t.posture || (t.posture = "defensive", t.pheromones.defense = 60, 
o.logger.info("".concat(e.name, " posture: MEDIUM DEFENSE"), {
subsystem: "Defense"
}));
break;

case r.LOW:
"eco" !== t.posture && "expand" !== t.posture || (t.pheromones.defense = 30, o.logger.debug("".concat(e.name, ": LOW DEFENSE alert"), {
subsystem: "Defense"
}));
}
}, i.prototype.getDefenseRequests = function() {
var e, t = Memory, r = null !== (e = t.defenseRequests) && void 0 !== e ? e : [], o = r.filter(function(e) {
return Game.time - e.createdAt < 500;
});
return o.length !== r.length && (t.defenseRequests = o), o;
}, i.prototype.clearDefenseRequest = function(e) {
var t, r = Memory, o = (null !== (t = r.defenseRequests) && void 0 !== t ? t : []).filter(function(t) {
return t.roomName !== e;
});
r.defenseRequests = o;
}, i.prototype.getEmergencyState = function(e) {
return this.emergencyStates.get(e);
}, i.prototype.hasEmergency = function(e) {
var t = this.emergencyStates.get(e);
return void 0 !== t && t.level > r.NONE;
}, i.prototype.getActiveEmergencies = function() {
var o, n, a = [];
try {
for (var i = e(this.emergencyStates.entries()), s = i.next(); !s.done; s = i.next()) {
var c = t(s.value, 2), l = c[0], u = c[1];
u.level > r.NONE && a.push({
roomName: l,
state: u
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a.sort(function(e, t) {
return t.state.level - e.state.level;
});
}, i;
}();
return Yc.EmergencyResponseManager = i, Yc.emergencyResponseManager = new i, Yc;
}();
Object.defineProperty(e, "emergencyResponseManager", {
enumerable: !0,
get: function() {
return u.emergencyResponseManager;
}
}), Object.defineProperty(e, "EmergencyResponseManager", {
enumerable: !0,
get: function() {
return u.EmergencyResponseManager;
}
}), Object.defineProperty(e, "EmergencyLevel", {
enumerable: !0,
get: function() {
return u.EmergencyLevel;
}
});
var f = function() {
if (kc) return Vc;
kc = 1;
var e = Vc && Vc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(Vc, "__esModule", {
value: !0
}), Vc.safeModeManager = Vc.SafeModeManager = void 0;
var t = oc, r = ec(), o = function() {
function o() {}
return o.prototype.checkSafeMode = function(e, r) {
var o, n, a, i, s;
if (!(null === (o = e.controller) || void 0 === o ? void 0 : o.safeMode) && !(null === (n = e.controller) || void 0 === n ? void 0 : n.safeModeCooldown) && 0 !== (null !== (i = null === (a = e.controller) || void 0 === a ? void 0 : a.safeModeAvailable) && void 0 !== i ? i : 0) && this.shouldTriggerSafeMode(e, r)) {
var c = null === (s = e.controller) || void 0 === s ? void 0 : s.activateSafeMode();
if (c === OK) t.logger.warn("SAFE MODE ACTIVATED in ".concat(e.name), {
subsystem: "Defense"
}); else {
var l = void 0 !== c ? String(c) : "undefined";
t.logger.error("Failed to activate safe mode in ".concat(e.name, ": ").concat(l), {
subsystem: "Defense"
});
}
}
}, o.prototype.shouldTriggerSafeMode = function(o, n) {
var a, i;
if (n.danger < 2) return !1;
var s = o.find(FIND_MY_SPAWNS);
try {
for (var c = e(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (u.hits < .2 * u.hitsMax) return t.logger.warn("Spawn ".concat(u.name, " critical: ").concat(u.hits, "/").concat(u.hitsMax), {
subsystem: "Defense"
}), !0;
}
} catch (e) {
a = {
error: e
};
} finally {
try {
l && !l.done && (i = c.return) && i.call(c);
} finally {
if (a) throw a.error;
}
}
if (o.storage && o.storage.hits < .2 * o.storage.hitsMax) return t.logger.warn("Storage critical: ".concat(o.storage.hits, "/").concat(o.storage.hitsMax), {
subsystem: "Defense"
}), !0;
if (o.terminal && o.terminal.hits < .2 * o.terminal.hitsMax) return t.logger.warn("Terminal critical: ".concat(o.terminal.hits, "/").concat(o.terminal.hitsMax), {
subsystem: "Defense"
}), !0;
var f = o.find(FIND_HOSTILE_CREEPS), m = (0, r.filterAllyCreeps)(f), p = o.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory.role;
return "guard" === t || "ranger" === t || "soldier" === t;
}
});
if (m.length > 3 * p.length) return t.logger.warn("Overwhelmed: ".concat(m.length, " hostiles vs ").concat(p.length, " defenders"), {
subsystem: "Defense"
}), !0;
var d = m.filter(function(e) {
return e.body.some(function(e) {
return e.boost;
});
});
return d.length > 0 && p.length < 2 * d.length && (t.logger.warn("Boosted hostiles detected: ".concat(d.length), {
subsystem: "Defense"
}), !0);
}, o;
}();
return Vc.SafeModeManager = o, Vc.safeModeManager = new o, Vc;
}();
Object.defineProperty(e, "safeModeManager", {
enumerable: !0,
get: function() {
return f.safeModeManager;
}
}), Object.defineProperty(e, "SafeModeManager", {
enumerable: !0,
get: function() {
return f.SafeModeManager;
}
});
var m = function() {
if (Nc) return zc;
Nc = 1;
var e = zc && zc.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = zc && zc.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, r = zc && zc.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, o = zc && zc.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(zc, "__esModule", {
value: !0
}), zc.evacuationManager = zc.EvacuationManager = void 0;
var n = oc, a = Wc, i = Fc, s = Bc, c = ec(), l = {
triggerDangerLevel: 3,
nukeEvacuationLeadTime: 5e3,
minStorageEnergy: 5e4,
priorityResources: [ RESOURCE_ENERGY, RESOURCE_POWER, RESOURCE_GHODIUM, RESOURCE_CATALYZED_GHODIUM_ACID, RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_LEMERGIUM_ACID, RESOURCE_CATALYZED_KEANIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ACID, RESOURCE_OPS ],
maxTransfersPerTick: 2
}, u = function() {
function u(t) {
void 0 === t && (t = {}), this.evacuations = new Map, this.lastTransferTick = 0, 
this.transfersThisTick = 0, this.config = e(e({}, l), t);
}
return u.prototype.run = function() {
var e, t, n, a;
Game.time !== this.lastTransferTick && (this.transfersThisTick = 0, this.lastTransferTick = Game.time), 
this.checkEvacuationTriggers();
try {
for (var i = r(this.evacuations.values()), s = i.next(); !s.done; s = i.next()) (u = s.value).complete || this.processEvacuation(u);
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
try {
for (var c = r(this.evacuations.entries()), l = c.next(); !l.done; l = c.next()) {
var u, f = o(l.value, 2), m = f[0];
(u = f[1]).complete && Game.time - u.startedAt > 1e3 && this.evacuations.delete(m);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
l && !l.done && (a = c.return) && a.call(c);
} finally {
if (n) throw n.error;
}
}
}, u.prototype.checkEvacuationTriggers = function() {
var e, t, r, o;
for (var i in Game.rooms) {
var s = Game.rooms[i];
if ((null === (e = s.controller) || void 0 === e ? void 0 : e.my) && !this.evacuations.has(i)) {
var l = a.memoryManager.getSwarmState(i);
if (l) {
var u = s.find(FIND_NUKES);
if (u.length > 0) {
var f = u.reduce(function(e, t) {
var r, o;
return (null !== (r = e.timeToLand) && void 0 !== r ? r : 1 / 0) < (null !== (o = t.timeToLand) && void 0 !== o ? o : 1 / 0) ? e : t;
});
if ((null !== (t = f.timeToLand) && void 0 !== t ? t : 1 / 0) <= this.config.nukeEvacuationLeadTime) {
l.nukeDetected || (l.nukeDetected = !0);
var m = u.length;
n.logger.warn("Triggering evacuation for ".concat(i, ": ").concat(m, " nuke(s) detected, impact in ").concat(null !== (r = f.timeToLand) && void 0 !== r ? r : 0, " ticks"), {
subsystem: "Evacuation"
}), this.startEvacuation(i, "nuke", Game.time + (null !== (o = f.timeToLand) && void 0 !== o ? o : 0));
continue;
}
}
if (l.danger >= this.config.triggerDangerLevel && "siege" === l.posture) {
var p = s.find(FIND_HOSTILE_CREEPS), d = (0, c.filterAllyCreeps)(p), y = s.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.body.map(function(e) {
return e.type;
});
return t.includes(ATTACK) || t.includes(RANGED_ATTACK);
}
});
if (d.length > 3 * y.length) {
this.startEvacuation(i, "siege");
continue;
}
}
}
}
}
}, u.prototype.startEvacuation = function(e, t, r) {
var o;
if (this.evacuations.has(e)) return !1;
var i = Game.rooms[e];
if (!i || !(null === (o = i.controller) || void 0 === o ? void 0 : o.my)) return !1;
var s = this.findEvacuationTarget(e);
if (!s) return n.logger.error("Cannot evacuate ".concat(e, ": no valid target room found"), {
subsystem: "Evacuation"
}), !1;
var c = {
roomName: e,
reason: t,
startedAt: Game.time,
targetRoom: s,
resourcesEvacuated: [],
creepsRecalled: [],
progress: 0,
complete: !1,
deadline: r
};
this.evacuations.set(e, c);
var l = a.memoryManager.getSwarmState(e);
return l && (l.posture = "evacuate"), n.logger.warn("Starting evacuation of ".concat(e, " (").concat(t, "), target: ").concat(s) + (r ? ", deadline: ".concat(r - Game.time, " ticks") : ""), {
subsystem: "Evacuation"
}), !0;
}, u.prototype.findEvacuationTarget = function(e) {
var t, r, o = Object.values(Game.rooms).filter(function(t) {
var r;
return (null === (r = t.controller) || void 0 === r ? void 0 : r.my) && t.name !== e;
});
if (0 === o.length) return null;
var n = o.map(function(t) {
var r, o, n = 0;
if (!t.terminal) return {
room: t,
score: -1e3
};
n -= 10 * Game.map.getRoomLinearDistance(e, t.name);
var a = t.terminal.store.getFreeCapacity();
if (n += 10 * Math.min(100, a / 1e4), n += 5 * (null !== (o = null === (r = t.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0), 
t.storage) {
n += 50;
var i = t.storage.store.getFreeCapacity();
n += 5 * Math.min(100, i / 5e4);
}
var s = t.find(FIND_HOSTILE_CREEPS), l = (0, c.filterAllyCreeps)(s);
return l.length > 0 && (n -= 20 * l.length), {
room: t,
score: n
};
}).filter(function(e) {
return e.score > -500;
}).sort(function(e, t) {
return t.score - e.score;
});
return n.length > 0 && null !== (r = null === (t = n[0]) || void 0 === t ? void 0 : t.room.name) && void 0 !== r ? r : null;
}, u.prototype.processEvacuation = function(e) {
var t = Game.rooms[e.roomName], r = Game.rooms[e.targetRoom];
if (!t) return e.complete = !0, void n.logger.error("Lost room ".concat(e.roomName, " during evacuation"), {
subsystem: "Evacuation"
});
this.transfersThisTick < this.config.maxTransfersPerTick && this.transferResources(e, t, r), 
this.recallCreeps(e, t), e.progress = this.calculateProgress(e, t), e.progress >= 100 && (e.complete = !0, 
n.logger.info("Evacuation of ".concat(e.roomName, " complete: ") + "".concat(e.resourcesEvacuated.reduce(function(e, t) {
return e + t.amount;
}, 0), " resources, ") + "".concat(e.creepsRecalled.length, " creeps"), {
subsystem: "Evacuation"
})), e.deadline && Game.time >= e.deadline && (e.complete = !0, n.logger.warn("Evacuation of ".concat(e.roomName, " reached deadline"), {
subsystem: "Evacuation"
}));
}, u.prototype.transferResources = function(e, t, o) {
var a, i, s, c, l = t.terminal, u = null == o ? void 0 : o.terminal;
if (l && u) {
var f = Game.map.getRoomLinearDistance(t.name, e.targetRoom), m = function(e) {
return Math.ceil(e * (1 - Math.exp(-f / 30)));
};
try {
for (var p = r(this.config.priorityResources), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
if (!((E = l.store.getUsedCapacity(y)) <= 0 || (T = u.store.getFreeCapacity(y)) <= 0)) {
var g = m(E), h = l.store.getUsedCapacity(RESOURCE_ENERGY);
if (!(y !== RESOURCE_ENERGY && g > h || (S = Math.min(E, T, 5e4)) <= 0 || l.send(y, S, e.targetRoom) !== OK)) return e.resourcesEvacuated.push({
resourceType: y,
amount: S
}), this.transfersThisTick++, void n.logger.debug("Evacuated ".concat(S, " ").concat(y, " from ").concat(t.name, " to ").concat(e.targetRoom), {
subsystem: "Evacuation"
});
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
try {
for (var v = r(Object.keys(l.store)), R = v.next(); !R.done; R = v.next()) {
var E, T, S;
if (y = R.value, !(this.config.priorityResources.includes(y) || (E = l.store.getUsedCapacity(y)) <= 0 || (T = u.store.getFreeCapacity(y)) <= 0 || (g = m(E), 
h = l.store.getUsedCapacity(RESOURCE_ENERGY), y !== RESOURCE_ENERGY && g > h || (S = Math.min(E, T, 5e4)) <= 0 || l.send(y, S, e.targetRoom) !== OK))) return e.resourcesEvacuated.push({
resourceType: y,
amount: S
}), void this.transfersThisTick++;
}
} catch (e) {
s = {
error: e
};
} finally {
try {
R && !R.done && (c = v.return) && c.call(v);
} finally {
if (s) throw s.error;
}
}
}
}, u.prototype.recallCreeps = function(e, t) {
var o, n;
try {
for (var a = r(t.find(FIND_MY_CREEPS)), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = s.memory;
c.evacuating || (c.evacuating = !0, c.evacuationTarget = e.targetRoom, e.creepsRecalled.push(s.name));
}
} catch (e) {
o = {
error: e
};
} finally {
try {
i && !i.done && (n = a.return) && n.call(a);
} finally {
if (o) throw o.error;
}
}
}, u.prototype.calculateProgress = function(e, t) {
var r = t.terminal, o = t.storage, n = 0, a = 0;
r && (n += 1e5, a += r.store.getUsedCapacity()), o && (n += o.store.getCapacity(), 
a += o.store.getUsedCapacity());
var i = n > 0 ? Math.min(100, (n - a) / n * 100) : 100, s = t.find(FIND_MY_CREEPS).length, c = e.creepsRecalled.length > 0 ? Math.min(100, (e.creepsRecalled.length - s) / e.creepsRecalled.length * 100) : 100;
return Math.round((i + c) / 2);
}, u.prototype.cancelEvacuation = function(e) {
var t, o, i = this.evacuations.get(e);
if (i) {
this.evacuations.delete(e);
try {
for (var s = r(i.creepsRecalled), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.creeps[l];
if (u) {
var f = u.memory;
delete f.evacuating, delete f.evacuationTarget;
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
var m = a.memoryManager.getSwarmState(e);
m && (m.posture = "eco"), n.logger.info("Evacuation of ".concat(e, " cancelled"), {
subsystem: "Evacuation"
});
}
}, u.prototype.getEvacuationState = function(e) {
return this.evacuations.get(e);
}, u.prototype.isEvacuating = function(e) {
var t = this.evacuations.get(e);
return void 0 !== t && !t.complete;
}, u.prototype.getActiveEvacuations = function() {
return Array.from(this.evacuations.values()).filter(function(e) {
return !e.complete;
});
}, t([ (0, i.MediumFrequencyProcess)("cluster:evacuation", "Evacuation Manager", {
priority: s.ProcessPriority.HIGH,
interval: 5,
minBucket: 0,
cpuBudget: .02
}) ], u.prototype, "run", null), t([ (0, i.ProcessClass)() ], u);
}();
return zc.EvacuationManager = u, zc.evacuationManager = new u, zc;
}();
Object.defineProperty(e, "evacuationManager", {
enumerable: !0,
get: function() {
return m.evacuationManager;
}
}), Object.defineProperty(e, "EvacuationManager", {
enumerable: !0,
get: function() {
return m.EvacuationManager;
}
});
}(Js)), Js), Xc = {
updateInterval: 10,
minBucket: 0,
resourceBalanceThreshold: 1e4,
minTerminalEnergy: 5e4
}, Qc = function() {
function a(t) {
void 0 === t && (t = {}), this.lastRun = new Map, this.config = e(e({}, Xc), t);
}
return a.prototype.run = function() {
var e = fi.getClusters();
for (var t in e) {
var r = e[t];
if (this.shouldRunCluster(t)) try {
this.runCluster(r), this.lastRun.set(t, Game.time);
} catch (e) {
var o = e instanceof Error ? e.message : String(e);
Hr.error("Cluster ".concat(t, " error: ").concat(o), {
subsystem: "Cluster"
});
}
}
}, a.prototype.shouldRunCluster = function(e) {
var t, r = null !== (t = this.lastRun.get(e)) && void 0 !== t ? t : 0;
return Game.time - r >= this.config.updateInterval;
}, a.prototype.runCluster = function(e) {
var t = this, o = Game.cpu.getUsed();
Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":metrics"), function() {
t.updateClusterMetrics(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":defense"), function() {
t.processDefenseRequests(e), qc.coordinateClusterDefense(e.id);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":terminals"), function() {
t.balanceTerminalResources(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":resourceSharing"), function() {
Ms.processCluster(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":squads"), function() {
t.updateSquads(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":offensive"), function() {
t.updateOffensiveOperations(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":rallyPoints"), function() {
!function(e) {
var t, o;
e.rallyPoints = e.rallyPoints.filter(function(t) {
return !!(t.lastUsed && Game.time - t.lastUsed < 1e3) || !!e.squads.some(function(e) {
return e.rallyRoom === t.roomName && "dissolving" !== e.state;
}) || "defense" === t.purpose;
});
var n = function(t) {
var r = Game.rooms[t];
if (!r) return "continue";
if (!e.rallyPoints.find(function(e) {
return e.roomName === t && "defense" === e.purpose;
})) {
var o = function(e) {
return e ? function(e) {
var t = e.find(FIND_MY_SPAWNS), r = e.storage;
if (0 === t.length) return null;
for (var o = r ? r.pos : t[0].pos, n = [], a = -5; a <= 5; a++) for (var i = -5; i <= 5; i++) {
var s = o.x + a, c = o.y + i;
if (!(s < 2 || s > 47 || c < 2 || c > 47)) {
var l = Qs(e, new RoomPosition(s, c, e.name), "defense");
l.score > 0 && n.push(l);
}
}
if (n.sort(function(e, t) {
return t.score - e.score;
}), 0 === n.length) return {
roomName: e.name,
x: 25,
y: 25,
purpose: "defense",
createdAt: Game.time
};
var u = n[0];
return {
roomName: e.name,
x: u.position.x,
y: u.position.y,
purpose: "defense",
createdAt: Game.time
};
}(e) : null;
}(r);
o && (e.rallyPoints.push(o), Hr.debug("Created defense rally point for ".concat(t, " at ").concat(o.x, ",").concat(o.y), {
subsystem: "RallyPoint"
}));
}
};
try {
for (var a = r(e.memberRooms), i = a.next(); !i.done; i = a.next()) n(i.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
}(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":militaryResources"), function() {
!function(e) {
var t, o;
try {
for (var n = r(e.memberRooms), a = n.next(); !a.done; a = n.next()) {
var i = a.value, s = fi.getSwarmState(i);
if (s) {
var c = Ls(i, s.danger);
c > 0 && Game.time % 100 == 0 && Hr.debug("Military energy reservation for ".concat(i, ": ").concat(c, " (danger ").concat(s.danger, ")"), {
subsystem: "MilitaryPool"
});
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
a && !a.done && (o = n.return) && o.call(n);
} finally {
if (t) throw t.error;
}
}
}(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":role"), function() {
t.updateClusterRole(e);
}), Io.unifiedStats.measureSubsystem("cluster:".concat(e.id, ":focusRoom"), function() {
t.updateFocusRoom(e);
}), e.lastUpdate = Game.time;
var n = Game.cpu.getUsed() - o;
n > 1 && Game.time % 50 == 0 && Hr.debug("Cluster ".concat(e.id, " tick: ").concat(n.toFixed(2), " CPU"), {
subsystem: "Cluster"
});
}, a.prototype.updateClusterMetrics = function(e) {
var t, o, n = 0, a = 0, i = 0, s = 0, c = 0;
try {
for (var l = r(e.memberRooms), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = fi.getSwarmState(f);
if (m) {
n += m.metrics.energyHarvested, a += m.metrics.energySpawning + m.metrics.energyConstruction + m.metrics.energyRepair, 
i += 25 * m.danger;
var p = Game.rooms[f];
(null == p ? void 0 : p.storage) ? s += p.storage.store.getUsedCapacity(RESOURCE_ENERGY) / p.storage.store.getCapacity() * 100 : s += m.metrics.energyHarvested > 0 ? 50 : 0, 
c++;
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
c > 0 && (e.metrics.energyIncome = n / c, e.metrics.energyConsumption = a / c, e.metrics.energyBalance = e.metrics.energyIncome - e.metrics.energyConsumption, 
e.metrics.warIndex = Math.min(100, i / c), e.metrics.economyIndex = Math.min(100, s / c)), 
e.metrics.militaryReadiness = this.calculateMilitaryReadiness(e);
}, a.prototype.calculateMilitaryReadiness = function(e) {
var t, o, n, a = 0, i = 0;
try {
for (var s = r(e.memberRooms), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.rooms[l];
if (u && (null === (n = u.controller) || void 0 === n ? void 0 : n.my)) {
a += u.find(FIND_MY_CREEPS, {
filter: function(e) {
return "military" === e.memory.family;
}
}).length;
var f = u.controller.level;
i += Math.max(2, Math.floor(f / 2));
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return 0 === i ? 0 : Math.min(100, Math.round(a / i * 100));
}, a.prototype.balanceTerminalResources = function(e) {
var t, o, n, a, i = [];
try {
for (var s = r(e.memberRooms), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.rooms[l];
(null == u ? void 0 : u.terminal) && u.terminal.my && i.push({
room: u,
terminal: u.terminal
});
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
if (!(i.length < 2) && (this.balanceResource(i, RESOURCE_ENERGY), Game.time % 50 == 0)) {
var f = [ RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST ];
try {
for (var m = r(f), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
this.balanceResource(i, d);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (n) throw n.error;
}
}
}
}, a.prototype.balanceResource = function(e, t) {
var o, n, a, i, s, c, l = this, u = 0;
try {
for (var f = r(e), m = f.next(); !m.done; m = f.next()) u += m.value.terminal.store.getUsedCapacity(t);
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (n = f.return) && n.call(f);
} finally {
if (o) throw o.error;
}
}
var p = u / e.length, d = e.filter(function(e) {
return e.terminal.store.getUsedCapacity(t) > p + l.config.resourceBalanceThreshold;
}), y = e.filter(function(e) {
return e.terminal.store.getUsedCapacity(t) < p - l.config.resourceBalanceThreshold;
});
if (0 !== d.length && 0 !== y.length) try {
for (var g = r(d), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
if (!(v.terminal.cooldown > 0 || t === RESOURCE_ENERGY && v.terminal.store.getUsedCapacity(RESOURCE_ENERGY) < this.config.minTerminalEnergy + this.config.resourceBalanceThreshold)) try {
for (var R = (s = void 0, r(y)), E = R.next(); !E.done; E = R.next()) {
var T = E.value, S = Math.min(v.terminal.store.getUsedCapacity(t) - p, p - T.terminal.store.getUsedCapacity(t), 1e4);
if (S > 1e3 && v.terminal.send(t, S, T.room.name) === OK) {
Hr.debug("Transferred ".concat(S, " ").concat(t, " from ").concat(v.room.name, " to ").concat(T.room.name), {
subsystem: "Cluster"
});
break;
}
}
} catch (e) {
s = {
error: e
};
} finally {
try {
E && !E.done && (c = R.return) && c.call(R);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
h && !h.done && (i = g.return) && i.call(g);
} finally {
if (a) throw a.error;
}
}
}, a.prototype.updateSquads = function(e) {
var t, o;
try {
for (var n = r(e.squads), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
Is(i), Ps(i) && (i.state = "dissolving");
}
} catch (e) {
t = {
error: e
};
} finally {
try {
a && !a.done && (o = n.return) && o.call(n);
} finally {
if (t) throw t.error;
}
}
e.squads = e.squads.filter(function(e) {
return "dissolving" !== e.state;
}), this.autoCreateDefenseSquads(e);
}, a.prototype.autoCreateDefenseSquads = function(e) {
var t, o, n = e.defenseRequests.filter(function(t) {
var r = e.squads.some(function(e) {
return "defense" === e.type && e.targetRooms.includes(t.roomName);
});
return !r && t.urgency >= 2;
});
try {
for (var a = r(n), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = Ns(e, s);
e.squads.push(c);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
}, a.prototype.updateOffensiveOperations = function(t) {
Game.time % 100 == 0 && function(t) {
if ("war" === t.role || "mixed" === t.role) {
var r = Array.from(qs.values()).filter(function(e) {
return e.clusterId === t.id && "complete" !== e.state && "failed" !== e.state;
});
if (r.length >= 2) Hr.debug("Cluster ".concat(t.id, " at max operations (").concat(r.length, ")"), {
subsystem: "Offensive"
}); else {
var o = function(t, r, o, n) {
var a, i;
void 0 === n && (n = {});
var s = e(e({}, Hs), n), c = [], l = fi.getEmpire(), u = l.knownRooms, f = new Set(l.warTargets);
for (var m in u) {
var p = u[m];
if (p.scouted && "self" !== p.owner && !p.isHighway && !p.isSK) {
var d = Ys(t, m);
if (!(d > 10)) {
var y = null !== (i = null === (a = Memory.lastAttacked) || void 0 === a ? void 0 : a[m]) && void 0 !== i ? i : 0;
if (!(Game.time - y < 5e3)) {
var g = Ws(p, d, f.has(m), s), h = "neutral";
p.owner && (h = f.has(p.owner) || f.has(m) ? "enemy" : "hostile");
var v = Bs(m, {
towerCount: p.towerCount,
spawnCount: p.spawnCount,
rcl: p.controllerLevel,
owner: p.owner
});
c.push({
roomName: m,
score: g,
distance: d,
doctrine: v,
type: h,
intel: p
});
}
}
}
}
c.sort(function(e, t) {
return t.score - e.score;
});
var R = c.slice(0, 3);
return R.length > 0 && Hr.info("Found ".concat(R.length, " attack targets for cluster ").concat(t.id, ": ") + R.map(function(e) {
return "".concat(e.roomName, "(").concat(e.score.toFixed(0), ")");
}).join(", "), {
subsystem: "AttackTarget"
}), R;
}(t);
if (0 !== o.length) {
var n = o[0];
js(t, n.doctrine) ? function(e, t, r) {
if (!function(e) {
var t = fi.getEmpire().knownRooms[e];
return t ? !(Game.time - t.lastSeen > 5e3 && (Hr.warn("Intel for ".concat(e, " is stale (").concat(Game.time - t.lastSeen, " ticks old)"), {
subsystem: "AttackTarget"
}), 1)) : (Hr.warn("No intel for target ".concat(e), {
subsystem: "AttackTarget"
}), !1);
}(t)) return Hr.warn("Invalid target ".concat(t), {
subsystem: "Offensive"
}), null;
var o = fi.getEmpire().knownRooms[t], n = null != r ? r : Bs(t, {
towerCount: null == o ? void 0 : o.towerCount,
spawnCount: null == o ? void 0 : o.spawnCount,
rcl: null == o ? void 0 : o.controllerLevel,
owner: null == o ? void 0 : o.owner
});
if (!js(e, n)) return Hr.warn("Cannot launch ".concat(n, " operation on ").concat(t, " - insufficient resources"), {
subsystem: "Offensive"
}), null;
var a = "op_".concat(e.id, "_").concat(t, "_").concat(Game.time), i = {
id: a,
clusterId: e.id,
targetRoom: t,
doctrine: n,
squadIds: [],
state: "planning",
createdAt: Game.time,
lastUpdate: Game.time
};
qs.set(a, i);
var s, c = function(e, t, r, o) {
var n = function(e, t) {
var r, o, n = {
guards: 2,
rangers: 3,
healers: 2,
siegeUnits: 1
};
if (t) {
var a = null !== (r = t.towerCount) && void 0 !== r ? r : 0, i = null !== (o = t.spawnCount) && void 0 !== o ? o : 0;
a >= 3 && (n.healers += 1), a >= 2 && i >= 2 && (n.siegeUnits += 1), i >= 2 && (n.guards += 1);
}
return n;
}(0, o), a = "".concat(r, "_").concat(t, "_").concat(Game.time), i = ks(e, t), s = .3;
"harass" === r ? s = .5 : "raid" === r ? s = .4 : "siege" === r && (s = .3);
var c = {
id: a,
type: r,
members: [],
rallyRoom: i,
targetRooms: [ t ],
state: "gathering",
createdAt: Game.time,
retreatThreshold: s
};
return Hr.info("Created ".concat(r, " squad ").concat(a, " for ").concat(t, ": ") + "".concat(n.guards, "G/").concat(n.rangers, "R/").concat(n.healers, "H/").concat(n.siegeUnits, "S rally at ").concat(i), {
subsystem: "Squad"
}), c;
}(e, t, "harassment" === n ? "harass" : n, {
towerCount: null == o ? void 0 : o.towerCount,
spawnCount: null == o ? void 0 : o.spawnCount
});
e.squads.push(c), i.squadIds.push(c.id), function(e, t) {
var r = t.id;
if (Vs.has(r)) Hr.debug("Squad ".concat(r, " already forming"), {
subsystem: "SquadFormation"
}); else {
var o;
if ("defense" === t.type) o = {
harassers: 0,
soldiers: 2,
rangers: 2,
healers: 1,
siegeUnits: 0
}; else {
var n = "harass" === t.type ? "harassment" : t.type;
o = Fs[n].composition;
}
var a = {};
o.harassers > 0 && (a.harasser = o.harassers), o.soldiers > 0 && (a.soldier = o.soldiers), 
o.rangers > 0 && (a.ranger = o.rangers), o.healers > 0 && (a.healer = o.healers), 
o.siegeUnits > 0 && (a.siegeUnit = o.siegeUnits);
var i = {
squadId: r,
targetComposition: a,
currentComposition: {},
spawnRequests: new Set,
formationStarted: Game.time
};
Vs.set(r, i);
var s = Game.rooms[t.rallyRoom];
s ? (function(e, t, r, o) {
var n = !1;
if ("defense" !== t.type) {
var a = "harass" === t.type ? "harassment" : t.type;
n = Fs[a].useBoosts;
}
var i = bi.NORMAL;
"siege" === t.type ? i = bi.HIGH : "defense" === t.type && (i = bi.EMERGENCY);
var s = function(r, a) {
for (var s = function(a) {
var s = function(e, t, r) {
var o = Math.min(r, 3e3);
switch (e) {
case "harasser":
return zs([ MOVE, ATTACK ], o, [ MOVE, ATTACK ]);

case "soldier":
return zs([ TOUGH, MOVE, ATTACK, MOVE, ATTACK ], o, [ TOUGH, MOVE, ATTACK ]);

case "ranger":
return zs([ TOUGH, MOVE, RANGED_ATTACK ], o, [ MOVE, RANGED_ATTACK ]);

case "healer":
return zs([ TOUGH, MOVE, HEAL ], o, [ MOVE, HEAL ]);

case "siegeUnit":
return zs([ TOUGH, MOVE, WORK ], o, [ TOUGH, MOVE, WORK ]);

default:
return [ MOVE, ATTACK ];
}
}(r, 0, e.energyCapacityAvailable), c = s.reduce(function(e, t) {
return e + Ks[t];
}, 0), l = n ? function(e) {
switch (e) {
case "soldier":
return [ {
compound: RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
parts: [ ATTACK ]
} ];

case "ranger":
return [ {
compound: RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
parts: [ RANGED_ATTACK ]
} ];

case "healer":
return [ {
compound: RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
parts: [ HEAL ]
} ];

case "siegeUnit":
return [ {
compound: RESOURCE_CATALYZED_ZYNTHIUM_ACID,
parts: [ WORK ]
} ];

default:
return [];
}
}(r) : [], u = {
id: "".concat(t.id, "_").concat(r, "_").concat(a, "_").concat(Game.time),
roomName: e.name,
role: r,
family: "military",
body: {
parts: s,
cost: c,
minCapacity: c
},
priority: i,
targetRoom: t.targetRooms[0],
boostRequirements: l.length > 0 ? l.map(function(e) {
return {
resourceType: e.compound,
bodyParts: s.filter(function(t) {
return e.parts.includes(t);
})
};
}) : void 0,
createdAt: Game.time,
additionalMemory: {
squadId: t.id
}
};
xi.addRequest(u), o.spawnRequests.add(u.id);
}, c = 0; c < a; c++) s(c);
};
r.harassers > 0 && s("harasser", r.harassers), r.soldiers > 0 && s("soldier", r.soldiers), 
r.rangers > 0 && s("ranger", r.rangers), r.healers > 0 && s("healer", r.healers), 
r.siegeUnits > 0 && s("siegeUnit", r.siegeUnits);
}(s, t, o, i), Hr.info("Started forming squad ".concat(r, ": ").concat(JSON.stringify(a)), {
subsystem: "SquadFormation"
})) : Hr.warn("Rally room ".concat(t.rallyRoom, " not visible for squad ").concat(r), {
subsystem: "SquadFormation"
});
}
}(0, c), i.state = "forming", s = t, Memory.lastAttacked || (Memory.lastAttacked = {}), 
Memory.lastAttacked[s] = Game.time, Hr.info("Marked ".concat(s, " as attacked at tick ").concat(Game.time), {
subsystem: "AttackTarget"
}), Hr.info("Launched ".concat(n, " operation ").concat(a, " on ").concat(t, " with squad ").concat(c.id), {
subsystem: "Offensive"
});
}(t, n.roomName, n.doctrine) : Hr.info("Cluster ".concat(t.id, " cannot launch ").concat(n.doctrine, " doctrine (insufficient resources)"), {
subsystem: "Offensive"
});
} else Hr.debug("No attack targets found for cluster ".concat(t.id), {
subsystem: "Offensive"
});
}
}
}(t), function() {
var e, t;
!function() {
var e, t, n = Game.time;
try {
for (var a = r(Vs.entries()), i = a.next(); !i.done; i = a.next()) {
var s = o(i.value, 2), c = s[0], l = n - s[1].formationStarted;
l > 500 && (Hr.warn("Squad ".concat(c, " formation timed out after ").concat(l, " ticks"), {
subsystem: "SquadFormation"
}), Vs.delete(c));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
}();
try {
for (var n = r(qs.entries()), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2);
i[0], Xs(i[1]);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
!function() {
var e, t;
try {
for (var n = r(qs.entries()), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2), s = i[0], c = i[1], l = Game.time - c.createdAt;
("complete" === c.state || "failed" === c.state) && l > 5e3 && (qs.delete(s), Hr.debug("Cleaned up operation ".concat(s), {
subsystem: "Offensive"
}));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}();
}();
}, a.prototype.updateClusterRole = function(e) {
var t = e.metrics, r = t.warIndex, o = t.economyIndex;
e.role = r > 50 ? "war" : o > 70 && r < 20 ? "economic" : o < 40 ? "frontier" : "mixed";
}, a.prototype.updateFocusRoom = function(e) {
var t, o, n, a, i = [];
try {
for (var s = r(e.memberRooms), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.rooms[l];
u && (null === (n = u.controller) || void 0 === n ? void 0 : n.my) && i.push({
roomName: l,
rcl: u.controller.level
});
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
if (0 !== i.length) {
if (e.focusRoom) {
var f = Game.rooms[e.focusRoom];
8 === (null === (a = null == f ? void 0 : f.controller) || void 0 === a ? void 0 : a.level) && (Hr.info("Focus room ".concat(e.focusRoom, " reached RCL 8, selecting next room"), {
subsystem: "Cluster"
}), e.focusRoom = void 0), f || (Hr.warn("Focus room ".concat(e.focusRoom, " no longer valid, selecting new focus"), {
subsystem: "Cluster"
}), e.focusRoom = void 0);
}
if (!e.focusRoom) {
var m = i.filter(function(e) {
return e.rcl < 8;
});
if (0 === m.length) return;
m.sort(function(e, t) {
return e.rcl !== t.rcl ? e.rcl - t.rcl : e.roomName.localeCompare(t.roomName);
}), e.focusRoom = m[0].roomName, Hr.info("Selected ".concat(e.focusRoom, " (RCL ").concat(m[0].rcl, ") as focus room for upgrading"), {
subsystem: "Cluster"
});
}
}
}, a.prototype.createCluster = function(e) {
var t = "cluster_".concat(e), r = fi.getCluster(t, e);
if (!r) throw new Error("Failed to create cluster for ".concat(e));
return Hr.info("Created cluster ".concat(t, " with core room ").concat(e), {
subsystem: "Cluster"
}), r;
}, a.prototype.addRoomToCluster = function(e, t, r) {
void 0 === r && (r = !1);
var o = fi.getCluster(e);
o ? r ? o.remoteRooms.includes(t) || (o.remoteRooms.push(t), Hr.info("Added remote room ".concat(t, " to cluster ").concat(e), {
subsystem: "Cluster"
})) : o.memberRooms.includes(t) || (o.memberRooms.push(t), Hr.info("Added member room ".concat(t, " to cluster ").concat(e), {
subsystem: "Cluster"
})) : Hr.error("Cluster ".concat(e, " not found"), {
subsystem: "Cluster"
});
}, a.prototype.processDefenseRequests = function(t) {
var o, n, a, i, s;
t.defenseRequests = t.defenseRequests.filter(function(e) {
var t = Game.time - e.createdAt;
if (t > 500) return Hr.debug("Defense request for ".concat(e.roomName, " expired (").concat(t, " ticks old)"), {
subsystem: "Cluster"
}), !1;
var r = Game.rooms[e.roomName];
return !(!r || 0 === r.find(FIND_HOSTILE_CREEPS).length && (Hr.info("Defense request for ".concat(e.roomName, " resolved - no more hostiles"), {
subsystem: "Cluster"
}), 1));
});
try {
for (var c = r(t.defenseRequests), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (u.urgency >= 3) {
var f = Game.rooms[u.roomName];
f && f.storage && f.storage.store.getUsedCapacity(RESOURCE_ENERGY) < 1e4 && Ds(t, u.roomName, 2e4);
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
var m = function(r) {
var o = Game.rooms[r];
if (!o || !(null === (s = o.controller) || void 0 === s ? void 0 : s.my)) return "continue";
var n = fi.getSwarmState(r);
if (!n) return "continue";
if (gi(o, n)) {
var a = t.defenseRequests.find(function(e) {
return e.roomName === r;
});
if (a) {
var i = hi(o, n);
i && i.urgency > a.urgency && (a.urgency = i.urgency, a.guardsNeeded = i.guardsNeeded, 
a.rangersNeeded = i.rangersNeeded, a.healersNeeded = i.healersNeeded, a.threat = i.threat);
} else {
var c = hi(o, n);
c && t.defenseRequests.push(e(e({}, c), {
assignedCreeps: []
}));
}
}
};
try {
for (var p = r(t.memberRooms), d = p.next(); !d.done; d = p.next()) m(d.value);
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
this.assignDefendersToRequests(t);
}, a.prototype.assignDefendersToRequests = function(e) {
var t, a, i, s, c, l;
if (0 !== e.defenseRequests.length) {
var u = n([], o(e.defenseRequests), !1).sort(function(e, t) {
return t.urgency - e.urgency;
}), f = [];
try {
for (var m = r(u), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (Game.rooms[d.roomName]) {
try {
for (var y = (i = void 0, r(e.memberRooms)), g = y.next(); !g.done; g = y.next()) {
var h = g.value;
if (h !== d.roomName) {
var v = Game.rooms[h];
if (v) {
var R = v.find(FIND_MY_CREEPS);
try {
for (var E = (c = void 0, r(R)), T = E.next(); !T.done; T = E.next()) {
var S = T.value, C = S.memory;
if ("military" === C.family && !C.assistTarget && !d.assignedCreeps.includes(S.name)) {
var b = d.guardsNeeded > 0, _ = d.rangersNeeded > 0, O = d.healersNeeded > 0, w = "guard" === C.role, x = "ranger" === C.role, U = "healer" === C.role;
if (b && w || _ && x || O && U) {
var M = Game.map.getRoomLinearDistance(h, d.roomName);
f.push({
creep: S,
room: v,
distance: M,
targetRoom: d.roomName
});
}
}
}
} catch (e) {
c = {
error: e
};
} finally {
try {
T && !T.done && (l = E.return) && l.call(E);
} finally {
if (c) throw c.error;
}
}
}
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
g && !g.done && (s = y.return) && s.call(y);
} finally {
if (i) throw i.error;
}
}
f.sort(function(e, t) {
return e.distance - t.distance;
});
for (var A = d.guardsNeeded + d.rangersNeeded + d.healersNeeded, k = Math.min(A, f.length), N = 0; N < k; N++) {
var P = f[N];
P && (P.creep.memory.assistTarget = d.roomName, d.assignedCreeps.push(P.creep.name), 
Hr.info("Assigned ".concat(P.creep.name, " (").concat(P.creep.memory.role, ") from ").concat(P.room.name, " to assist ").concat(d.roomName, " (distance: ").concat(P.distance, ")"), {
subsystem: "Cluster"
}), "guard" === P.creep.memory.role && d.guardsNeeded--, "ranger" === P.creep.memory.role && d.rangersNeeded--, 
"healer" === P.creep.memory.role && d.healersNeeded--);
}
for (N = f.length - 1; N >= 0; N--) d.assignedCreeps.includes(f[N].creep.name) && f.splice(N, 1);
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (t) throw t.error;
}
}
}
}, t([ Li("cluster:manager", "Cluster Manager", {
priority: Ao.MEDIUM,
interval: 10,
minBucket: 0,
cpuBudget: .03
}) ], a.prototype, "run", null), t([ Bi() ], a);
}(), Zc = new Qc, Jc = {}, $c = {}, el = {}, tl = {}, rl = m(Ka);

function ol() {
if (Gc) return tl;
Gc = 1;
var e, t, r = tl && tl.__assign || function() {
return r = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, r.apply(this, arguments);
}, o = tl && tl.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, n = tl && tl.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(tl, "__esModule", {
value: !0
}), tl.marketManager = tl.MarketManager = void 0;
var a = Wc, i = oc, s = Fc, c = Bc, l = rl, u = {
updateInterval: 100,
priceUpdateInterval: 500,
minBucket: 0,
minCredits: 1e4,
emergencyCredits: 5e3,
tradingCredits: 5e4,
warPriceMultiplier: 2,
buyPriceThreshold: .85,
sellPriceThreshold: 1.15,
maxPriceHistory: 30,
rollingAverageWindow: 10,
lowPriceMultiplier: .9,
highPriceMultiplier: 1.1,
trendChangeThreshold: .05,
buyOpportunityAdjustment: 1.02,
sellOpportunityAdjustment: .98,
sellThresholds: (e = {}, e[RESOURCE_ENERGY] = 5e5, e[RESOURCE_HYDROGEN] = 2e4, e[RESOURCE_OXYGEN] = 2e4, 
e[RESOURCE_UTRIUM] = 2e4, e[RESOURCE_LEMERGIUM] = 2e4, e[RESOURCE_KEANIUM] = 2e4, 
e[RESOURCE_ZYNTHIUM] = 2e4, e[RESOURCE_CATALYST] = 2e4, e),
buyThresholds: (t = {}, t[RESOURCE_ENERGY] = 1e5, t[RESOURCE_HYDROGEN] = 5e3, t[RESOURCE_OXYGEN] = 5e3, 
t[RESOURCE_UTRIUM] = 5e3, t[RESOURCE_LEMERGIUM] = 5e3, t[RESOURCE_KEANIUM] = 5e3, 
t[RESOURCE_ZYNTHIUM] = 5e3, t[RESOURCE_CATALYST] = 5e3, t),
trackedResources: [ RESOURCE_ENERGY, RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST, RESOURCE_GHODIUM, RESOURCE_POWER ],
criticalResources: [ RESOURCE_ENERGY, RESOURCE_GHODIUM ],
emergencyBuyThreshold: 5e3,
orderExtensionAge: 5e3,
maxTransportCostRatio: .3
}, f = function() {
function e(e) {
void 0 === e && (e = {}), this.lastRun = 0, this.config = r(r({}, u), e);
}
return e.prototype.run = function() {
this.lastRun = Game.time, this.ensureMarketMemory(), Game.time % this.config.priceUpdateInterval === 0 && this.updatePriceTracking(), 
this.updateOrderStats(), this.reconcilePendingArbitrage(), this.handleEmergencyBuying(), 
this.cancelOldOrders(), this.manageExistingOrders(), this.updateBuyOrders(), this.updateSellOrders(), 
this.checkArbitrageOpportunities(), this.executeDeal(), Game.time % 200 == 0 && this.balanceResourcesAcrossRooms();
}, e.prototype.ensureMarketMemory = function() {
var e = a.memoryManager.getEmpire();
e.market || (e.market = (0, l.createDefaultMarketMemory)()), e.market.orders || (e.market.orders = {}), 
void 0 === e.market.totalProfit && (e.market.totalProfit = 0), e.market.lastBalance || (e.market.lastBalance = 0), 
e.market.pendingArbitrage || (e.market.pendingArbitrage = []), void 0 === e.market.completedArbitrage && (e.market.completedArbitrage = 0), 
void 0 === e.market.arbitrageProfit && (e.market.arbitrageProfit = 0);
}, e.prototype.updatePriceTracking = function() {
var e, t, r = a.memoryManager.getEmpire();
if (r.market) {
try {
for (var o = n(this.config.trackedResources), s = o.next(); !s.done; s = o.next()) {
var c = s.value;
this.updateResourcePrice(c);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = o.return) && t.call(o);
} finally {
if (e) throw e.error;
}
}
r.market.lastScan = Game.time, i.logger.debug("Updated market prices for ".concat(this.config.trackedResources.length, " resources"), {
subsystem: "Market"
});
}
}, e.prototype.updateResourcePrice = function(e) {
var t = a.memoryManager.getEmpire();
if (t.market) {
var r = Game.market.getHistory(e);
if (0 !== r.length) {
var o = r[r.length - 1], n = t.market.resources[e];
n || (n = {
resource: e,
priceHistory: [],
avgPrice: o.avgPrice,
trend: 0,
lastUpdate: Game.time
}, t.market.resources[e] = n);
var i = {
tick: Game.time,
avgPrice: o.avgPrice,
lowPrice: o.avgPrice * this.config.lowPriceMultiplier,
highPrice: o.avgPrice * this.config.highPriceMultiplier
};
n.priceHistory.push(i), n.priceHistory.length > this.config.maxPriceHistory && n.priceHistory.shift();
var s = n.priceHistory.slice(-this.config.rollingAverageWindow);
if (n.avgPrice = s.reduce(function(e, t) {
return e + t.avgPrice;
}, 0) / s.length, n.priceHistory.length >= 5) {
var c = n.priceHistory.slice(-5, -2).reduce(function(e, t) {
return e + t.avgPrice;
}, 0) / 3, l = (n.priceHistory.slice(-3).reduce(function(e, t) {
return e + t.avgPrice;
}, 0) / 3 - c) / c;
l > this.config.trendChangeThreshold ? n.trend = 1 : l < -this.config.trendChangeThreshold ? n.trend = -1 : n.trend = 0;
}
if (s.length >= 5) {
var u = n.avgPrice, f = s.reduce(function(e, t) {
return e + Math.pow(t.avgPrice - u, 2);
}, 0) / s.length, m = Math.sqrt(f);
n.volatility = m / u;
}
if (n.priceHistory.length >= 3) {
var p = n.priceHistory.slice(-3), d = (p[2].avgPrice - p[0].avgPrice) / 2;
n.predictedPrice = p[2].avgPrice + d;
}
n.lastUpdate = Game.time;
}
}
}, e.prototype.getMarketData = function(e) {
var t;
return null === (t = a.memoryManager.getEmpire().market) || void 0 === t ? void 0 : t.resources[e];
}, e.prototype.isBuyOpportunity = function(e) {
var t = this.getMarketData(e);
if (!t) return !1;
var r = Game.market.getHistory(e);
return 0 !== r.length && r[r.length - 1].avgPrice <= t.avgPrice * this.config.buyPriceThreshold;
}, e.prototype.isSellOpportunity = function(e) {
var t = this.getMarketData(e);
if (!t) return !1;
var r = Game.market.getHistory(e);
return 0 !== r.length && r[r.length - 1].avgPrice >= t.avgPrice * this.config.sellPriceThreshold;
}, e.prototype.cancelOldOrders = function() {
var e = Game.market.orders;
for (var t in e) {
var r = e[t];
Game.time - r.created > 1e4 && (Game.market.cancelOrder(t), i.logger.info("Cancelled old order: ".concat(r.type, " ").concat(r.resourceType), {
subsystem: "Market"
})), r.remainingAmount < 100 && Game.market.cancelOrder(t);
}
}, e.prototype.updateBuyOrders = function() {
var e, t, r, o = a.memoryManager.getEmpire().objectives.warMode, n = {};
for (var s in Game.rooms) {
var c = Game.rooms[s];
if (c.terminal && (null === (e = c.controller) || void 0 === e ? void 0 : e.my)) for (var l in c.terminal.store) n[l] = (null !== (t = n[l]) && void 0 !== t ? t : 0) + c.terminal.store[l];
}
for (var l in this.config.buyThresholds) {
var u = this.config.buyThresholds[l], f = null !== (r = n[l]) && void 0 !== r ? r : 0;
if (f < u) {
var m = this.isBuyOpportunity(l);
o || m ? this.createBuyOrder(l, u - f, o, m) : i.logger.debug("Skipping buy for ".concat(l, ": waiting for better price"), {
subsystem: "Market"
});
}
}
}, e.prototype.createBuyOrder = function(e, t, r, o) {
var n;
if (!(Object.values(Game.market.orders).filter(function(t) {
return t.type === ORDER_BUY && t.resourceType === e;
}).length > 0)) {
var a = Game.market.getHistory(e);
if (0 !== a.length) {
var s, c = a[a.length - 1].avgPrice, l = this.getMarketData(e);
if (s = r ? c * this.config.warPriceMultiplier : o && l ? c * this.config.buyOpportunityAdjustment : null !== (n = null == l ? void 0 : l.avgPrice) && void 0 !== n ? n : c * this.config.highPriceMultiplier, 
!(Game.market.credits < this.config.minCredits)) {
var u = Object.values(Game.rooms).find(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my);
});
if ((null == u ? void 0 : u.terminal) && Game.market.createOrder({
type: ORDER_BUY,
resourceType: e,
price: s,
totalAmount: Math.min(t, 1e4),
roomName: u.name
}) === OK) {
var f = o ? " (LOW PRICE!)" : r ? " (WAR MODE)" : "";
i.logger.info("Created buy order: ".concat(t, " ").concat(e, " at ").concat(s.toFixed(3), " credits").concat(f), {
subsystem: "Market"
});
}
}
}
}
}, e.prototype.sellSurplusFromTerminal = function(e, t, r) {
var o, n = Game.rooms[e];
if (!(null == n ? void 0 : n.terminal) || !(null === (o = n.controller) || void 0 === o ? void 0 : o.my)) return i.logger.warn("Cannot sell from ".concat(e, ": no terminal or not owned"), {
subsystem: "Market"
}), !1;
var s = n.terminal.store.getUsedCapacity(t);
if (s < r) return i.logger.debug("Cannot sell ".concat(r, " ").concat(t, " from ").concat(e, ": only ").concat(s, " available"), {
subsystem: "Market"
}), !1;
var c = a.memoryManager.getEmpire();
if (!c.market) return Game.market.createOrder({
type: ORDER_SELL,
resourceType: t,
price: .5,
totalAmount: r,
roomName: e
}) === OK;
var l = c.market.resources[t], u = .5;
if (null == l ? void 0 : l.avgPrice) u = .95 * l.avgPrice; else {
var f = Game.market.getAllOrders({
type: ORDER_BUY,
resourceType: t
});
f.length > 0 && (f.sort(function(e, t) {
return t.price - e.price;
}), u = f[0].price);
}
var m = Game.market.createOrder({
type: ORDER_SELL,
resourceType: t,
price: u,
totalAmount: r,
roomName: e
});
return m === OK ? (i.logger.info("Created surplus sell order: ".concat(r, " ").concat(t, " from ").concat(e, " at ").concat(u.toFixed(3), " credits/unit"), {
subsystem: "Market"
}), !0) : (i.logger.warn("Failed to create sell order: ".concat(m, " for ").concat(r, " ").concat(t, " from ").concat(e), {
subsystem: "Market"
}), !1);
}, e.prototype.updateSellOrders = function() {
var e, t, r, o = {};
for (var n in Game.rooms) {
var a = Game.rooms[n];
if (a.terminal && (null === (e = a.controller) || void 0 === e ? void 0 : e.my)) for (var s in a.terminal.store) o[s] = (null !== (t = o[s]) && void 0 !== t ? t : 0) + a.terminal.store[s];
}
for (var s in this.config.sellThresholds) {
var c = this.config.sellThresholds[s], l = null !== (r = o[s]) && void 0 !== r ? r : 0;
if (l > c) {
var u = this.isSellOpportunity(s);
u ? this.createSellOrder(s, l - c, u) : i.logger.debug("Holding ".concat(s, " surplus: waiting for better price"), {
subsystem: "Market"
});
}
}
}, e.prototype.createSellOrder = function(e, t, r) {
var o;
if (!(Object.values(Game.market.orders).filter(function(t) {
return t.type === ORDER_SELL && t.resourceType === e;
}).length > 0)) {
var n = Game.market.getHistory(e);
if (0 !== n.length) {
var a, s = n[n.length - 1].avgPrice, c = this.getMarketData(e);
a = r && c ? s * this.config.sellOpportunityAdjustment : null !== (o = null == c ? void 0 : c.avgPrice) && void 0 !== o ? o : s * this.config.lowPriceMultiplier;
var l = Object.values(Game.rooms).find(function(t) {
var r;
return t.terminal && (null === (r = t.controller) || void 0 === r ? void 0 : r.my) && t.terminal.store[e] > 1e3;
});
if ((null == l ? void 0 : l.terminal) && Game.market.createOrder({
type: ORDER_SELL,
resourceType: e,
price: a,
totalAmount: Math.min(t, 1e4),
roomName: l.name
}) === OK) {
var u = r ? " (HIGH PRICE!)" : "";
i.logger.info("Created sell order: ".concat(t, " ").concat(e, " at ").concat(a.toFixed(3), " credits").concat(u), {
subsystem: "Market"
});
}
}
}
}, e.prototype.updateOrderStats = function() {
var e, t, r = a.memoryManager.getEmpire();
if (null === (e = r.market) || void 0 === e ? void 0 : e.orders) {
var o = Game.market.orders;
for (var n in r.market.orders) {
var s = r.market.orders[n], c = o[n];
if (c) {
if (void 0 !== c.totalAmount) {
var l = c.totalAmount - c.remainingAmount, u = l - s.totalTraded;
u > 0 && (s.totalTraded = l, s.totalValue += u * c.price);
}
} else {
if (s.totalTraded > 0) {
var f = "sell" === s.type ? s.totalValue : -s.totalValue;
r.market.totalProfit = (null !== (t = r.market.totalProfit) && void 0 !== t ? t : 0) + f, 
i.logger.info("Order completed: ".concat(s.resource, " ").concat(s.type, " - Traded: ").concat(s.totalTraded, ", Value: ").concat(s.totalValue.toFixed(0), ", Profit: ").concat(f.toFixed(0)), {
subsystem: "Market"
});
}
delete r.market.orders[n];
}
}
}
}, e.prototype.executeDeal = function() {
var e, t;
if (Game.time % 50 == 0 && a.memoryManager.getEmpire().objectives.warMode) {
var r = [ RESOURCE_CATALYZED_GHODIUM_ACID, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE, RESOURCE_CATALYZED_KEANIUM_ALKALIDE ];
try {
for (var o = n(r), s = o.next(); !s.done; s = o.next()) {
var c = s.value, l = Game.market.getAllOrders({
type: ORDER_SELL,
resourceType: c
});
if (l.length > 0) {
l.sort(function(e, t) {
return e.price - t.price;
});
var u = l[0], f = Object.values(Game.rooms).find(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my);
});
if (f && u.price < 10) {
var m = Math.min(u.amount, 1e3);
Game.market.deal(u.id, m, f.name) === OK && i.logger.info("Bought ".concat(m, " ").concat(c, " for ").concat(u.price.toFixed(3), " credits/unit"), {
subsystem: "Market"
});
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = o.return) && t.call(o);
} finally {
if (e) throw e.error;
}
}
}
}, e.prototype.handleEmergencyBuying = function() {
var e, t, r, o, a;
if (!(Game.market.credits < this.config.emergencyCredits)) {
var i = {};
for (var s in Game.rooms) {
var c = Game.rooms[s];
if (c.terminal && (null === (r = c.controller) || void 0 === r ? void 0 : r.my)) for (var l in c.terminal.store) i[l] = (null !== (o = i[l]) && void 0 !== o ? o : 0) + c.terminal.store[l];
}
try {
for (var u = n(this.config.criticalResources), f = u.next(); !f.done; f = u.next()) {
var m = null !== (a = i[l = f.value]) && void 0 !== a ? a : 0;
m < this.config.emergencyBuyThreshold && this.executeEmergencyBuy(l, this.config.emergencyBuyThreshold - m);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
f && !f.done && (t = u.return) && t.call(u);
} finally {
if (e) throw e.error;
}
}
}
}, e.prototype.executeEmergencyBuy = function(e, t) {
var r = Game.market.getAllOrders({
type: ORDER_SELL,
resourceType: e
});
if (0 !== r.length) {
var o = Object.values(Game.rooms).find(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my);
});
if (null == o ? void 0 : o.terminal) {
r.sort(function(e, t) {
return (e.roomName ? e.price + Game.market.calcTransactionCost(1e3, o.name, e.roomName) / 1e3 : e.price) - (t.roomName ? t.price + Game.market.calcTransactionCost(1e3, o.name, t.roomName) / 1e3 : t.price);
});
var n = r[0], a = Math.min(t, n.amount, 1e4);
Game.market.deal(n.id, a, o.name) === OK && i.logger.warn("EMERGENCY BUY: ".concat(a, " ").concat(e, " at ").concat(n.price.toFixed(3), " credits/unit"), {
subsystem: "Market"
});
}
}
}, e.prototype.manageExistingOrders = function() {
var e = Game.market.orders;
for (var t in e) {
var r = e[t];
if (!(Game.time - r.created < this.config.orderExtensionAge)) {
var o = r.resourceType;
if ("token" !== o && this.config.trackedResources.includes(o) && this.getMarketData(o)) {
var n = Game.market.getHistory(o);
if (0 !== n.length) {
var a = n[n.length - 1].avgPrice;
if (r.type === ORDER_BUY) {
var s = a * this.config.buyOpportunityAdjustment;
r.price < .9 * s && r.remainingAmount > 1e3 && (Game.market.extendOrder(t, Math.min(5e3, r.remainingAmount)), 
i.logger.debug("Extended buy order for ".concat(r.resourceType, ": +").concat(r.remainingAmount, " at ").concat(r.price.toFixed(3)), {
subsystem: "Market"
}));
}
r.type === ORDER_SELL && (s = a * this.config.sellOpportunityAdjustment, r.price > 1.1 * s && r.remainingAmount > 1e3 && (Game.market.extendOrder(t, Math.min(5e3, r.remainingAmount)), 
i.logger.debug("Extended sell order for ".concat(r.resourceType, ": +").concat(r.remainingAmount, " at ").concat(r.price.toFixed(3)), {
subsystem: "Market"
})));
}
}
}
}
}, e.prototype.reconcilePendingArbitrage = function() {
var e, t, r, o, s, c, l, u = a.memoryManager.getEmpire().market;
if ((null == u ? void 0 : u.pendingArbitrage) && 0 !== u.pendingArbitrage.length) {
var f = [];
try {
for (var m = n(u.pendingArbitrage), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = Game.rooms[d.destinationRoom], g = null == y ? void 0 : y.terminal;
if (g && (null === (r = null == y ? void 0 : y.controller) || void 0 === r ? void 0 : r.my)) if (Game.time < d.expectedArrival || g.cooldown > 0) f.push(d); else {
var h = null !== (o = g.store[d.resource]) && void 0 !== o ? o : 0;
if (h < d.amount) f.push(d); else {
var v = !1;
if (d.sellOrderId) {
var R = Game.market.getOrderById(d.sellOrderId);
if (R && R.remainingAmount > 0 && R.roomName) {
var E = Math.min(d.amount, R.remainingAmount, h), T = Game.market.calcTransactionCost(E, g.room.name, R.roomName);
if (g.store[RESOURCE_ENERGY] >= T && Game.market.deal(R.id, E, g.room.name) === OK) {
var S = (R.price - d.buyPrice) * E;
u.totalProfit = (null !== (s = u.totalProfit) && void 0 !== s ? s : 0) + S, u.arbitrageProfit = (null !== (c = u.arbitrageProfit) && void 0 !== c ? c : 0) + S, 
u.completedArbitrage = (null !== (l = u.completedArbitrage) && void 0 !== l ? l : 0) + 1, 
i.logger.info("Arbitrage complete: sold ".concat(E, " ").concat(d.resource, " from ").concat(g.room.name, " at ").concat(R.price.toFixed(3), ", profit ").concat(S.toFixed(2)), {
subsystem: "Market"
}), v = !0;
}
}
}
v || Game.market.createOrder({
type: ORDER_SELL,
resourceType: d.resource,
price: d.targetSellPrice,
totalAmount: d.amount,
roomName: g.room.name
}) === OK && (i.logger.info("Arbitrage posted sell order: ".concat(d.amount, " ").concat(d.resource, " at ").concat(d.targetSellPrice.toFixed(3), " from ").concat(g.room.name), {
subsystem: "Market"
}), v = !0), v || f.push(d);
}
} else f.push(d);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
p && !p.done && (t = m.return) && t.call(m);
} finally {
if (e) throw e.error;
}
}
u.pendingArbitrage = f;
}
}, e.prototype.checkArbitrageOpportunities = function() {
var e, t, r, o, s, c;
if (!(Game.cpu.bucket < this.config.minBucket || Game.market.credits < this.config.tradingCredits)) {
var l = a.memoryManager.getEmpire().market, u = Object.values(Game.rooms).filter(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my);
});
if (l && 0 !== u.length) {
var f = function(e) {
var t, r;
return null !== (r = null !== (t = e.remainingAmount) && void 0 !== t ? t : e.amount) && void 0 !== r ? r : 0;
}, m = function(e) {
var t, a, m = Game.market.getAllOrders({
type: ORDER_BUY,
resourceType: e
}).filter(function(e) {
return e.remainingAmount > 0 && e.roomName;
}), d = Game.market.getAllOrders({
type: ORDER_SELL,
resourceType: e
}).filter(function(e) {
return e.remainingAmount > 0 && e.roomName;
});
if (0 === m.length || 0 === d.length) return "continue";
m.sort(function(e, t) {
return t.price - e.price;
}), d.sort(function(e, t) {
return e.price - t.price;
});
var y = m[0], g = d[0];
if (!y.roomName || !g.roomName) return "continue";
if (null === (r = l.pendingArbitrage) || void 0 === r ? void 0 : r.some(function(e) {
return e.buyOrderId === g.id || e.sellOrderId === y.id;
})) return "continue";
var h = Math.min(f(y), f(g), 5e3);
if (h <= 0) return "continue";
try {
for (var v = (t = void 0, n(u)), R = v.next(); !R.done; R = v.next()) {
var E = R.value, T = E.terminal;
if (!((null !== (o = T.store.getFreeCapacity(e)) && void 0 !== o ? o : 0) < h)) {
var S = Game.market.calcTransactionCost(h, E.name, g.roomName), C = (S + Game.market.calcTransactionCost(h, E.name, y.roomName)) / h, b = y.price - g.price - C;
if (!(b <= 0 || C / g.price > p.config.maxTransportCostRatio || T.store[RESOURCE_ENERGY] < S)) {
var _ = g.price * h;
if (!(Game.market.credits - _ < p.config.minCredits) && Game.market.deal(g.id, h, E.name) === OK) {
var O = {
id: "".concat(e, "-").concat(Game.time, "-").concat(g.id),
resource: e,
amount: h,
buyOrderId: g.id,
sellOrderId: y.id,
targetSellPrice: y.price,
destinationRoom: E.name,
expectedArrival: Game.time + (null !== (s = T.cooldown) && void 0 !== s ? s : 0) + 1,
buyPrice: g.price,
transportCost: S
};
null === (c = l.pendingArbitrage) || void 0 === c || c.push(O), i.logger.info("Arbitrage started: bought ".concat(h, " ").concat(e, " at ").concat(g.price.toFixed(3), " to sell @ ").concat(y.price.toFixed(3), " (profit/unit ~").concat(b.toFixed(2), ")"), {
subsystem: "Market"
});
break;
}
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
R && !R.done && (a = v.return) && a.call(v);
} finally {
if (t) throw t.error;
}
}
}, p = this;
try {
for (var d = n(this.config.trackedResources), y = d.next(); !y.done; y = d.next()) m(y.value);
} catch (t) {
e = {
error: t
};
} finally {
try {
y && !y.done && (t = d.return) && t.call(d);
} finally {
if (e) throw e.error;
}
}
}
}
}, e.prototype.balanceResourcesAcrossRooms = function() {
var e, t, r, o, a, s = Object.values(Game.rooms).filter(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my);
});
if (!(s.length < 2)) try {
for (var c = n(this.config.trackedResources), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = [];
try {
for (var m = (r = void 0, n(s)), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (d.terminal) {
var y = null !== (a = d.terminal.store[u]) && void 0 !== a ? a : 0;
f.push({
room: d,
amount: y
});
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (r) throw r.error;
}
}
if (!(f.length < 2)) {
var g = f.reduce(function(e, t) {
return e + t.amount;
}, 0) / f.length;
f.sort(function(e, t) {
return t.amount - e.amount;
});
var h = f[0], v = f[f.length - 1], R = h.amount - v.amount;
if (R > .5 * g && h.amount > 5e3 && h.room.terminal && v.room.terminal) {
var E = Math.min(Math.floor(R / 2), 1e4), T = Game.market.calcTransactionCost(E, h.room.name, v.room.name);
(u === RESOURCE_ENERGY && T < .1 * E || u !== RESOURCE_ENERGY && T < 1e3) && h.room.terminal.send(u, E, v.room.name) === OK && i.logger.info("Balanced ".concat(E, " ").concat(u, ": ").concat(h.room.name, " -> ").concat(v.room.name, " (cost: ").concat(T, " energy)"), {
subsystem: "Market"
});
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
}, o([ (0, s.LowFrequencyProcess)("empire:market", "Market Manager", {
priority: c.ProcessPriority.LOW,
interval: 100,
minBucket: 0,
cpuBudget: .02
}) ], e.prototype, "run", null), o([ (0, s.ProcessClass)() ], e);
}();
return tl.MarketManager = f, tl.marketManager = new f, tl;
}

var nl, al, il = {};

function sl() {
if (nl) return il;
nl = 1;
var e = il && il.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, t = il && il.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(il, "__esModule", {
value: !0
}), il.terminalRouter = il.TerminalRouter = void 0;
var r = oc, o = function() {
function o() {
this.costCache = new Map, this.COST_CACHE_TTL = 100, this.MAX_HOPS = 3;
}
return o.prototype.buildTerminalGraph = function() {
var e, t = [];
for (var r in Game.rooms) {
var o = Game.rooms[r];
o && (null === (e = o.controller) || void 0 === e ? void 0 : e.my) && o.terminal && o.terminal.my && o.terminal.isActive() && t.push({
roomName: r,
terminal: o.terminal
});
}
return t;
}, o.prototype.calculateTransferCost = function(e, t, r) {
var o = "".concat(t, ":").concat(r, ":").concat(e), n = this.costCache.get(o);
if (n && Game.time - n.timestamp < this.COST_CACHE_TTL) return n.cost;
var a = Game.market.calcTransactionCost(e, t, r);
return this.costCache.set(o, {
cost: a,
timestamp: Game.time
}), a;
}, o.prototype.findOptimalRoute = function(t, o, n) {
var a, i, s, c, l, u, f, m, p, d = this.calculateTransferCost(n, t, o), y = {
path: [ t, o ],
cost: d,
isDirect: !0
}, g = this.buildTerminalGraph();
if (g.length < 3) return y;
var h = new Map, v = new Map, R = new Set;
try {
for (var E = e(g), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
h.set(S.roomName, 1 / 0), R.add(S.roomName);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
T && !T.done && (i = E.return) && i.call(E);
} finally {
if (a) throw a.error;
}
}
for (h.set(t, 0); R.size > 0; ) {
var C = null, b = 1 / 0;
try {
for (var _ = (s = void 0, e(R)), O = _.next(); !O.done; O = _.next()) {
var w = O.value, x = null !== (f = h.get(w)) && void 0 !== f ? f : 1 / 0;
x < b && (b = x, C = w);
}
} catch (e) {
s = {
error: e
};
} finally {
try {
O && !O.done && (c = _.return) && c.call(_);
} finally {
if (s) throw s.error;
}
}
if (!C || b === 1 / 0) break;
if (C === o) break;
if (R.delete(C), !(this.getPathLength(C, v) >= this.MAX_HOPS)) try {
for (var U = (l = void 0, e(g)), M = U.next(); !M.done; M = U.next()) {
var A = M.value;
if (R.has(A.roomName) && A.roomName !== C) {
var k = this.calculateTransferCost(n, C, A.roomName), N = (null !== (m = h.get(C)) && void 0 !== m ? m : 1 / 0) + k;
N < (null !== (p = h.get(A.roomName)) && void 0 !== p ? p : 1 / 0) && (h.set(A.roomName, N), 
v.set(A.roomName, C));
}
}
} catch (e) {
l = {
error: e
};
} finally {
try {
M && !M.done && (u = U.return) && u.call(U);
} finally {
if (l) throw l.error;
}
}
}
var P = h.get(o);
if (void 0 !== P && P < d) {
var I = this.reconstructPath(o, v);
I.length > 0 && I[0] === t && (y = {
path: I,
cost: P,
isDirect: !1
}, r.logger.debug("Multi-hop route found: ".concat(I.join(" -> "), " (cost: ").concat(P, " vs direct: ").concat(d, ")"), {
subsystem: "TerminalRouter"
}));
}
return y;
}, o.prototype.getPathLength = function(e, t) {
for (var r = 0, o = e; void 0 !== o && t.has(o) && (r++, o = t.get(o), !(r > this.MAX_HOPS)); ) ;
return r;
}, o.prototype.reconstructPath = function(e, t) {
for (var r = [], o = e; void 0 !== o; ) r.unshift(o), o = t.get(o);
return r;
}, o.prototype.clearOldCache = function() {
var r, o, n = Game.time - this.COST_CACHE_TTL;
try {
for (var a = e(this.costCache.entries()), i = a.next(); !i.done; i = a.next()) {
var s = t(i.value, 2), c = s[0];
s[1].timestamp < n && this.costCache.delete(c);
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
}, o.prototype.getNextHop = function(e, t) {
var r = e.path.indexOf(t);
return -1 === r || r === e.path.length - 1 ? null : e.path[r + 1] || null;
}, o;
}();
return il.TerminalRouter = o, il.terminalRouter = new o, il;
}

var cl, ll, ul, fl = {}, ml = {}, pl = (ul || (ul = 1, function(e) {
Object.defineProperty(e, "__esModule", {
value: !0
}), e.MarketTrendAnalyzer = e.marketManager = e.MarketManager = e.factoryManager = e.FactoryManager = e.terminalRouter = e.TerminalRouter = e.terminalManager = e.TerminalManager = e.linkManager = e.LinkManager = void 0;
var t = function() {
if (Ic) return $c;
Ic = 1;
var e = $c && $c.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = $c && $c.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, r = $c && $c.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, o = $c && $c.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
}, n = $c && $c.__spreadArray || function(e, t, r) {
if (r || 2 === arguments.length) for (var o, n = 0, a = t.length; n < a; n++) !o && n in t || (o || (o = Array.prototype.slice.call(t, 0, n)), 
o[n] = t[n]);
return e.concat(o || Array.prototype.slice.call(t));
};
Object.defineProperty($c, "__esModule", {
value: !0
}), $c.linkManager = $c.LinkManager = void 0;
var a, i = oc, s = Bc, c = Fc, l = {
minBucket: 0,
minSourceLinkEnergy: 400,
controllerLinkMaxEnergy: 700,
transferThreshold: 100,
storageLinkReserve: 100
};
!function(e) {
e.SOURCE = "source", e.CONTROLLER = "controller", e.STORAGE = "storage", e.UNKNOWN = "unknown";
}(a || (a = {}));
var u = function() {
function u(t) {
void 0 === t && (t = {}), this.config = e(e({}, l), t);
}
return u.prototype.run = function() {
var e, t;
if (!(Game.cpu.bucket < this.config.minBucket)) {
var o = Object.values(Game.rooms).filter(function(e) {
var t;
return (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.controller.level >= 5;
});
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
this.processRoomLinks(i);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}
}, u.prototype.processRoomLinks = function(e) {
var t = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK;
}
});
if (!(t.length < 2)) {
var r = this.classifyLinks(e, t), o = r.filter(function(e) {
return e.role === a.SOURCE;
}), n = r.filter(function(e) {
return e.role === a.CONTROLLER;
}), i = r.filter(function(e) {
return e.role === a.STORAGE;
});
this.executeTransfers(e, o, n, i);
}
}, u.prototype.classifyLinks = function(e, t) {
var o = e.controller, n = e.storage, i = e.find(FIND_SOURCES);
return t.map(function(e) {
var t, s;
if (o && e.pos.getRangeTo(o) <= 2) return {
link: e,
role: a.CONTROLLER,
priority: 100
};
if (n && e.pos.getRangeTo(n) <= 2) return {
link: e,
role: a.STORAGE,
priority: 50
};
try {
for (var c = r(i), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if (e.pos.getRangeTo(u) <= 2) return {
link: e,
role: a.SOURCE,
priority: 10
};
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (s = c.return) && s.call(c);
} finally {
if (t) throw t.error;
}
}
return {
link: e,
role: a.UNKNOWN,
priority: 25
};
});
}, u.prototype.executeTransfers = function(e, t, s, c) {
var l, u, f, m, p = this, d = t.filter(function(e) {
return e.link.store.getUsedCapacity(RESOURCE_ENERGY) >= p.config.minSourceLinkEnergy && 0 === e.link.cooldown;
}).sort(function(e, t) {
return t.link.store.getUsedCapacity(RESOURCE_ENERGY) - e.link.store.getUsedCapacity(RESOURCE_ENERGY);
});
if (0 !== d.length) {
var y = n(n([], o(s), !1), o(c), !1).filter(function(e) {
return e.link.store.getFreeCapacity(RESOURCE_ENERGY) > p.config.transferThreshold;
}).sort(function(e, t) {
return t.priority - e.priority;
});
if (0 !== y.length) try {
for (var g = r(d), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
if (!(v.link.cooldown > 0)) {
var R = null;
try {
for (var E = (f = void 0, r(y)), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
if (!(S.link.store.getFreeCapacity(RESOURCE_ENERGY) < this.config.transferThreshold)) {
if (S.role === a.CONTROLLER && S.link.store.getUsedCapacity(RESOURCE_ENERGY) < this.config.controllerLinkMaxEnergy) {
R = S;
break;
}
if (S.role !== a.STORAGE) !R && S.link.store.getFreeCapacity(RESOURCE_ENERGY) > this.config.transferThreshold && (R = S); else if (S.link.store.getUsedCapacity(RESOURCE_ENERGY) < this.config.storageLinkReserve) {
R = S;
break;
}
}
}
} catch (e) {
f = {
error: e
};
} finally {
try {
T && !T.done && (m = E.return) && m.call(E);
} finally {
if (f) throw f.error;
}
}
if (R) {
var C = v.link.store.getUsedCapacity(RESOURCE_ENERGY), b = v.link.transferEnergy(R.link, C);
b === OK ? i.logger.debug("Link transfer: ".concat(C, " energy from ").concat(v.link.pos, " to ").concat(R.link.pos, " (").concat(R.role, ")"), {
subsystem: "Link",
room: e.name
}) : b !== ERR_TIRED && b !== ERR_FULL && i.logger.warn("Link transfer failed: ".concat(b, " from ").concat(v.link.pos, " to ").concat(R.link.pos), {
subsystem: "Link",
room: e.name
});
}
}
}
} catch (e) {
l = {
error: e
};
} finally {
try {
h && !h.done && (u = g.return) && u.call(g);
} finally {
if (l) throw l.error;
}
}
}
}, u.prototype.getLinkRole = function(e) {
var t, o, n = e.room, i = n.controller, s = n.storage, c = n.find(FIND_SOURCES);
if (i && e.pos.getRangeTo(i) <= 2) return a.CONTROLLER;
if (s && e.pos.getRangeTo(s) <= 2) return a.STORAGE;
try {
for (var l = r(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if (e.pos.getRangeTo(f) <= 2) return a.SOURCE;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
return a.UNKNOWN;
}, u.prototype.hasLinkNetwork = function(e) {
var t;
if (!(null === (t = e.controller) || void 0 === t ? void 0 : t.my) || e.controller.level < 5) return !1;
var r = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK;
}
});
if (r.length < 2) return !1;
var o = this.classifyLinks(e, r), n = o.some(function(e) {
return e.role === a.SOURCE;
}), i = o.some(function(e) {
return e.role === a.CONTROLLER || e.role === a.STORAGE;
});
return n && i;
}, t([ (0, c.MediumFrequencyProcess)("link:manager", "Link Manager", {
priority: s.ProcessPriority.MEDIUM,
interval: 5,
minBucket: 0,
cpuBudget: .05
}) ], u.prototype, "run", null), t([ (0, c.ProcessClass)() ], u);
}();
return $c.LinkManager = u, $c.linkManager = new u, $c;
}();
Object.defineProperty(e, "LinkManager", {
enumerable: !0,
get: function() {
return t.LinkManager;
}
}), Object.defineProperty(e, "linkManager", {
enumerable: !0,
get: function() {
return t.linkManager;
}
});
var r = function() {
if (al) return el;
al = 1;
var e = el && el.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = el && el.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, r = el && el.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, o = el && el.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(el, "__esModule", {
value: !0
}), el.terminalManager = el.TerminalManager = void 0;
var n = oc, a = Bc, i = Fc, s = Wc, c = ol(), l = sl(), u = {
minBucket: 0,
minStorageEnergy: 5e4,
terminalEnergyTarget: 2e4,
terminalEnergyMax: 5e4,
energySendThreshold: 1e5,
energyRequestThreshold: 3e4,
minTransferAmount: 5e3,
maxTransferCostRatio: .1,
capacityWarningThreshold: .8,
capacityClearanceThreshold: .9,
emergencyDangerThreshold: 2,
emergencyEnergyAmount: 2e4,
energySurplusThreshold: 5e4,
mineralSurplusThreshold: 5e3
}, f = function() {
function f(t) {
void 0 === t && (t = {}), this.transferQueue = [], this.config = e(e({}, u), t);
}
return f.prototype.requestTransfer = function(e, t, r, o, a) {
if (void 0 === a && (a = 3), this.transferQueue.some(function(o) {
return o.fromRoom === e && o.toRoom === t && o.resourceType === r;
})) return n.logger.debug("Transfer already queued: ".concat(o, " ").concat(r, " from ").concat(e, " to ").concat(t), {
subsystem: "Terminal"
}), !1;
var i = Game.rooms[e], s = Game.rooms[t];
return i && s && i.terminal && s.terminal ? (this.transferQueue.push({
fromRoom: e,
toRoom: t,
resourceType: r,
amount: o,
priority: a
}), n.logger.info("Queued transfer request: ".concat(o, " ").concat(r, " from ").concat(e, " to ").concat(t, " (priority: ").concat(a, ")"), {
subsystem: "Terminal"
}), !0) : (n.logger.warn("Cannot queue transfer: rooms or terminals not available", {
subsystem: "Terminal"
}), !1);
}, f.prototype.run = function() {
if (!(Game.cpu.bucket < this.config.minBucket)) {
var e = Object.values(Game.rooms).filter(function(e) {
var t;
return (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.terminal && e.terminal.my && e.terminal.isActive();
});
e.length < 2 || (l.terminalRouter.clearOldCache(), this.cleanTransferQueue(), this.checkEmergencyTransfers(e), 
this.monitorTerminalCapacity(e), this.balanceEnergy(e), this.balanceMinerals(e), 
this.executeTransfers(e));
}
}, f.prototype.cleanTransferQueue = function() {
this.transferQueue = this.transferQueue.filter(function(e) {
var t = Game.rooms[e.fromRoom], r = Game.rooms[e.toRoom];
return !!(t && r && t.terminal && r.terminal);
});
}, f.prototype.checkEmergencyTransfers = function(e) {
var t, o, a, i, c = this, u = function(t) {
if (!(null === (a = t.controller) || void 0 === a ? void 0 : a.my)) return "continue";
var r = s.memoryManager.getSwarmState(t.name);
if (!r) return "continue";
if (r.danger >= f.config.emergencyDangerThreshold) {
var o = t.storage, u = t.terminal;
if ((null !== (i = null == o ? void 0 : o.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== i ? i : 0) + u.store.getUsedCapacity(RESOURCE_ENERGY) < f.config.energyRequestThreshold / 2) {
var m = e.filter(function(e) {
var r;
return e.name !== t.name && (null === (r = e.controller) || void 0 === r ? void 0 : r.my) && e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > c.config.energySendThreshold;
}).sort(function(e, r) {
return Game.map.getRoomLinearDistance(t.name, e.name) - Game.map.getRoomLinearDistance(t.name, r.name);
});
if (m.length > 0 && m[0]) {
var p = m[0];
if (!f.transferQueue.some(function(e) {
return e.toRoom === t.name && e.resourceType === RESOURCE_ENERGY && e.isEmergency;
})) {
var d = l.terminalRouter.findOptimalRoute(p.name, t.name, f.config.emergencyEnergyAmount);
d && (f.transferQueue.push({
fromRoom: p.name,
toRoom: t.name,
resourceType: RESOURCE_ENERGY,
amount: f.config.emergencyEnergyAmount,
priority: 10,
route: d,
isEmergency: !0
}), n.logger.warn("Emergency energy transfer queued: ".concat(f.config.emergencyEnergyAmount, " from ").concat(p.name, " to ").concat(t.name, " (danger: ").concat(r.danger, ")"), {
subsystem: "Terminal"
}));
}
}
}
}
}, f = this;
try {
for (var m = r(e), p = m.next(); !p.done; p = m.next()) u(p.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (t) throw t.error;
}
}
}, f.prototype.monitorTerminalCapacity = function(e) {
var t, o;
try {
for (var a = r(e), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = s.terminal, l = c.store.getCapacity(), u = c.store.getUsedCapacity(), f = u / l;
f >= this.config.capacityWarningThreshold && f < this.config.capacityClearanceThreshold && Game.time % 100 == 0 && n.logger.warn("Terminal ".concat(s.name, " at ").concat((100 * f).toFixed(1), "% capacity (").concat(u, "/").concat(l, ")"), {
subsystem: "Terminal"
}), f >= this.config.capacityClearanceThreshold && this.clearExcessTerminalResources(s, c);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
}, f.prototype.clearExcessTerminalResources = function(e, t) {
var o, a, i, u, f, m;
n.logger.info("Auto-clearing terminal ".concat(e.name, " (").concat((t.store.getUsedCapacity() / t.store.getCapacity() * 100).toFixed(1), "% full)"), {
subsystem: "Terminal"
});
var p, d = s.memoryManager.getClusters();
for (var y in d) {
var g = d[y];
if (g.memberRooms.includes(e.name)) {
var h = 0;
try {
for (var v = (o = void 0, r(g.memberRooms)), R = v.next(); !R.done; R = v.next()) {
var E = R.value, T = Game.rooms[E];
(null === (f = null == T ? void 0 : T.controller) || void 0 === f ? void 0 : f.my) && T.controller.level > h && (h = T.controller.level, 
p = E);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
R && !R.done && (a = v.return) && a.call(v);
} finally {
if (o) throw o.error;
}
}
break;
}
}
var S = Object.keys(t.store);
try {
for (var C = r(S), b = C.next(); !b.done; b = C.next()) {
var _ = b.value, O = t.store.getUsedCapacity(_);
if (0 !== O) {
var w = _ === RESOURCE_ENERGY ? this.config.energySurplusThreshold : this.config.mineralSurplusThreshold;
if (O > w) {
var x = O - w;
if (p && p !== e.name) {
var U = null === (m = Game.rooms[p]) || void 0 === m ? void 0 : m.terminal;
if (U && U.store.getFreeCapacity() > x) {
var M = l.terminalRouter.findOptimalRoute(e.name, p, x);
if (M) {
this.transferQueue.push({
fromRoom: e.name,
toRoom: p,
resourceType: _,
amount: x,
priority: 5,
route: M
}), n.logger.info("Queued clearance transfer: ".concat(x, " ").concat(_, " from ").concat(e.name, " to hub ").concat(p), {
subsystem: "Terminal"
});
continue;
}
}
}
Game.time % 10 == 0 && c.marketManager.sellSurplusFromTerminal(e.name, _, x) && n.logger.info("Sold ".concat(x, " ").concat(_, " from ").concat(e.name, " terminal via market"), {
subsystem: "Terminal"
});
}
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
b && !b.done && (u = C.return) && u.call(C);
} finally {
if (i) throw i.error;
}
}
}, f.prototype.balanceEnergy = function(e) {
var t, o, a = this, i = e.map(function(e) {
var t, r = e.storage, o = e.terminal, n = null !== (t = null == r ? void 0 : r.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== t ? t : 0, i = o.store.getUsedCapacity(RESOURCE_ENERGY), s = n + i;
return {
room: e,
terminal: o,
totalEnergy: s,
storageEnergy: n,
terminalEnergy: i,
needsEnergy: s < a.config.energyRequestThreshold,
hasExcess: s > a.config.energySendThreshold && n > a.config.minStorageEnergy
};
}), s = i.filter(function(e) {
return e.needsEnergy;
}).sort(function(e, t) {
return e.totalEnergy - t.totalEnergy;
}), c = i.filter(function(e) {
return e.hasExcess;
}).sort(function(e, t) {
return t.totalEnergy - e.totalEnergy;
}), u = function(e) {
var t, o, a = function(t) {
if (t.room.name === e.room.name) return "continue";
if (f.transferQueue.some(function(r) {
return r.fromRoom === t.room.name && r.toRoom === e.room.name && r.resourceType === RESOURCE_ENERGY;
})) return "continue";
var r = Math.min(Math.floor((t.totalEnergy - f.config.energySendThreshold) / 2), f.config.energyRequestThreshold - e.totalEnergy, t.terminal.store.getUsedCapacity(RESOURCE_ENERGY));
if (r < f.config.minTransferAmount) return "continue";
var o = l.terminalRouter.findOptimalRoute(t.room.name, e.room.name, r);
if (!o) return "continue";
var a = o.cost / r;
if (a > f.config.maxTransferCostRatio) return n.logger.debug("Skipping terminal transfer from ".concat(t.room.name, " to ").concat(e.room.name, ": cost ratio ").concat(a.toFixed(2), " too high"), {
subsystem: "Terminal"
}), "continue";
f.transferQueue.push({
fromRoom: t.room.name,
toRoom: e.room.name,
resourceType: RESOURCE_ENERGY,
amount: r,
priority: 2,
route: o
});
var i = o.isDirect ? "direct" : "multi-hop (".concat(o.path.length, " hops)");
return n.logger.info("Queued energy transfer: ".concat(r, " from ").concat(t.room.name, " to ").concat(e.room.name, " (").concat(i, ", cost: ").concat(o.cost, ")"), {
subsystem: "Terminal"
}), "break";
};
try {
for (var i = (t = void 0, r(c)), s = i.next(); !s.done && "break" !== a(s.value); s = i.next()) ;
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
}, f = this;
try {
for (var m = r(s), p = m.next(); !p.done; p = m.next()) u(p.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (t) throw t.error;
}
}
}, f.prototype.balanceMinerals = function(e) {
var t, a, i, s, c, l, u = new Map;
try {
for (var f = r(e), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = p.terminal, y = Object.keys(d.store);
try {
for (var g = (i = void 0, r(y)), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
if (v !== RESOURCE_ENERGY) {
var R = d.store.getUsedCapacity(v);
0 !== R && (u.has(v) || u.set(v, []), u.get(v).push({
room: p,
amount: R
}));
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
h && !h.done && (s = g.return) && s.call(g);
} finally {
if (i) throw i.error;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (t) throw t.error;
}
}
var E = function(e, t) {
if (t.length < 2) return "continue";
t.sort(function(e, t) {
return t.amount - e.amount;
});
var r = t[0], o = t[t.length - 1], a = r.amount - o.amount;
if (a < 5e3) return "continue";
if (T.transferQueue.some(function(t) {
return t.fromRoom === r.room.name && t.toRoom === o.room.name && t.resourceType === e;
})) return "continue";
var i = Math.min(Math.floor(a / 2), r.amount - 1e3);
if (i < 1e3) return "continue";
T.transferQueue.push({
fromRoom: r.room.name,
toRoom: o.room.name,
resourceType: e,
amount: i,
priority: 1
}), n.logger.info("Queued mineral transfer: ".concat(i, " ").concat(e, " from ").concat(r.room.name, " to ").concat(o.room.name), {
subsystem: "Terminal"
});
}, T = this;
try {
for (var S = r(u.entries()), C = S.next(); !C.done; C = S.next()) {
var b = o(C.value, 2);
E(b[0], b[1]);
}
} catch (e) {
c = {
error: e
};
} finally {
try {
C && !C.done && (l = S.return) && l.call(S);
} finally {
if (c) throw c.error;
}
}
}, f.prototype.executeTransfers = function(e) {
var t, o;
this.transferQueue.sort(function(e, t) {
return t.priority - e.priority;
});
var a = new Set, i = function(t) {
if (a.has(t.fromRoom)) return "continue";
var r = e.find(function(e) {
return e.name === t.fromRoom;
});
if (!r || !r.terminal) return "continue";
var o = r.terminal;
if (o.cooldown > 0) return "continue";
var i = o.store.getUsedCapacity(t.resourceType);
if (i < t.amount) return n.logger.debug("Terminal transfer cancelled: insufficient ".concat(t.resourceType, " in ").concat(t.fromRoom, " (need ").concat(t.amount, ", have ").concat(i, ")"), {
subsystem: "Terminal"
}), s.transferQueue = s.transferQueue.filter(function(e) {
return e !== t;
}), "continue";
var c = t.toRoom;
if (t.route && !t.route.isDirect) {
var u = l.terminalRouter.getNextHop(t.route, t.fromRoom);
u && (c = u);
}
var f = o.send(t.resourceType, t.amount, c, "Terminal auto-balance".concat(t.isEmergency ? " [EMERGENCY]" : ""));
if (f === OK) {
var m = t.route && !t.route.isDirect, p = c === t.toRoom;
n.logger.info("Terminal transfer executed: ".concat(t.amount, " ").concat(t.resourceType, " from ").concat(t.fromRoom, " to ").concat(c).concat(m && !p ? " (hop to ".concat(t.toRoom, ")") : "").concat(t.isEmergency ? " [EMERGENCY]" : ""), {
subsystem: "Terminal"
}), a.add(t.fromRoom), m && !p ? t.fromRoom = c : s.transferQueue = s.transferQueue.filter(function(e) {
return e !== t;
});
} else n.logger.warn("Terminal transfer failed: ".concat(f, " for ").concat(t.amount, " ").concat(t.resourceType, " from ").concat(t.fromRoom, " to ").concat(c), {
subsystem: "Terminal"
}), s.transferQueue = s.transferQueue.filter(function(e) {
return e !== t;
});
}, s = this;
try {
for (var c = r(this.transferQueue), u = c.next(); !u.done; u = c.next()) i(u.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
}, f.prototype.queueTransfer = function(e, t, r, o, n) {
void 0 === n && (n = 1), this.transferQueue.push({
fromRoom: e,
toRoom: t,
resourceType: r,
amount: o,
priority: n
});
}, f.prototype.balanceCompoundsAcrossCluster = function(e, t) {
var a, i, s, c, l, u, f, m = new Map;
try {
for (var p = r(e), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = Game.rooms[y];
if (null == g ? void 0 : g.terminal) try {
for (var h = (s = void 0, r(t)), v = h.next(); !v.done; v = h.next()) {
var R = v.value, E = null !== (f = g.terminal.store[R]) && void 0 !== f ? f : 0;
m.has(R) || m.set(R, []), m.get(R).push({
roomName: y,
amount: E,
terminal: g.terminal
});
}
} catch (e) {
s = {
error: e
};
} finally {
try {
v && !v.done && (c = h.return) && c.call(h);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
var T = function(e, t) {
var o, a, i, s;
if (t.length < 2) return "continue";
var c = t.reduce(function(e, t) {
return e + t.amount;
}, 0) / t.length;
t.sort(function(e, t) {
return e.amount - t.amount;
});
var l = t.filter(function(e) {
return e.amount < .7 * c;
}), u = t.filter(function(e) {
return e.amount > 1.3 * c;
});
try {
for (var f = (o = void 0, r(u)), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
try {
for (var d = (i = void 0, r(l)), y = d.next(); !y.done; y = d.next()) {
var g = y.value, h = Math.min(Math.floor((p.amount - c) / 2), Math.floor((c - g.amount) / 2), 3e3), v = e === RESOURCE_CATALYZED_UTRIUM_ACID || e === RESOURCE_CATALYZED_KEANIUM_ALKALIDE || e === RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE || e === RESOURCE_CATALYZED_GHODIUM_ACID || e === RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE || e === RESOURCE_CATALYZED_GHODIUM_ALKALIDE;
h >= (v ? 300 : 500) && (S.queueTransfer(p.roomName, g.roomName, e, h, v ? 8 : 5), 
n.logger.info("Queued compound balance: ".concat(h, " ").concat(e, " from ").concat(p.roomName, " to ").concat(g.roomName), {
subsystem: "Terminal"
}), p.amount -= h, g.amount += h);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
y && !y.done && (s = d.return) && s.call(d);
} finally {
if (i) throw i.error;
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (o) throw o.error;
}
}
}, S = this;
try {
for (var C = r(m.entries()), b = C.next(); !b.done; b = C.next()) {
var _ = o(b.value, 2);
T(R = _[0], _[1]);
}
} catch (e) {
l = {
error: e
};
} finally {
try {
b && !b.done && (u = C.return) && u.call(C);
} finally {
if (l) throw l.error;
}
}
}, t([ (0, i.MediumFrequencyProcess)("terminal:manager", "Terminal Manager", {
priority: a.ProcessPriority.MEDIUM,
interval: 20,
minBucket: 0,
cpuBudget: .1
}) ], f.prototype, "run", null), t([ (0, i.ProcessClass)() ], f);
}();
return el.TerminalManager = f, el.terminalManager = new f, el;
}();
Object.defineProperty(e, "TerminalManager", {
enumerable: !0,
get: function() {
return r.TerminalManager;
}
}), Object.defineProperty(e, "terminalManager", {
enumerable: !0,
get: function() {
return r.terminalManager;
}
});
var o = sl();
Object.defineProperty(e, "TerminalRouter", {
enumerable: !0,
get: function() {
return o.TerminalRouter;
}
}), Object.defineProperty(e, "terminalRouter", {
enumerable: !0,
get: function() {
return o.terminalRouter;
}
});
var n = function() {
if (cl) return fl;
cl = 1;
var e, t, r, o, n, a, i, s, c, l, u, f = fl && fl.__assign || function() {
return f = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, f.apply(this, arguments);
}, m = fl && fl.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, p = fl && fl.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
}, d = fl && fl.__read || function(e, t) {
var r = "function" == typeof Symbol && e[Symbol.iterator];
if (!r) return e;
var o, n, a = r.call(e), i = [];
try {
for (;(void 0 === t || t-- > 0) && !(o = a.next()).done; ) i.push(o.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
o && !o.done && (r = a.return) && r.call(a);
} finally {
if (n) throw n.error;
}
}
return i;
};
Object.defineProperty(fl, "__esModule", {
value: !0
}), fl.factoryManager = fl.FactoryManager = void 0;
var y = oc, g = Bc, h = Fc, v = {
minBucket: 0,
minStorageEnergy: 8e4,
inputBufferAmount: 2e3,
outputBufferAmount: 5e3
}, R = ((e = {})[RESOURCE_UTRIUM_BAR] = ((t = {})[RESOURCE_UTRIUM] = 500, t[RESOURCE_ENERGY] = 200, 
t), e[RESOURCE_LEMERGIUM_BAR] = ((r = {})[RESOURCE_LEMERGIUM] = 500, r[RESOURCE_ENERGY] = 200, 
r), e[RESOURCE_ZYNTHIUM_BAR] = ((o = {})[RESOURCE_ZYNTHIUM] = 500, o[RESOURCE_ENERGY] = 200, 
o), e[RESOURCE_KEANIUM_BAR] = ((n = {})[RESOURCE_KEANIUM] = 500, n[RESOURCE_ENERGY] = 200, 
n), e[RESOURCE_GHODIUM_MELT] = ((a = {})[RESOURCE_GHODIUM] = 500, a[RESOURCE_ENERGY] = 200, 
a), e[RESOURCE_OXIDANT] = ((i = {})[RESOURCE_OXYGEN] = 500, i[RESOURCE_ENERGY] = 200, 
i), e[RESOURCE_REDUCTANT] = ((s = {})[RESOURCE_HYDROGEN] = 500, s[RESOURCE_ENERGY] = 200, 
s), e[RESOURCE_PURIFIER] = ((c = {})[RESOURCE_CATALYST] = 500, c[RESOURCE_ENERGY] = 200, 
c), e[RESOURCE_BATTERY] = ((l = {})[RESOURCE_ENERGY] = 600, l), e), E = ((u = {})[RESOURCE_BATTERY] = 10, 
u[RESOURCE_UTRIUM_BAR] = 5, u[RESOURCE_LEMERGIUM_BAR] = 5, u[RESOURCE_ZYNTHIUM_BAR] = 5, 
u[RESOURCE_KEANIUM_BAR] = 5, u[RESOURCE_GHODIUM_MELT] = 4, u[RESOURCE_OXIDANT] = 3, 
u[RESOURCE_REDUCTANT] = 3, u[RESOURCE_PURIFIER] = 3, u), T = function() {
function e(e) {
void 0 === e && (e = {}), this.config = f(f({}, v), e);
}
return e.prototype.run = function() {
var e, t;
if (!(Game.cpu.bucket < this.config.minBucket)) {
var r = Object.values(Game.rooms).filter(function(e) {
var t;
return !!(null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_FACTORY;
}
}).length > 0;
});
try {
for (var o = p(r), n = o.next(); !n.done; n = o.next()) {
var a = n.value;
this.processFactory(a);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
n && !n.done && (t = o.return) && t.call(o);
} finally {
if (e) throw e.error;
}
}
}
}, e.prototype.processFactory = function(e) {
var t, r, o = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_FACTORY;
}
});
if (0 !== o.length) {
var n = o[0];
if (n && !(n.cooldown > 0)) {
var a = e.storage;
if (a && !(a.store.getUsedCapacity(RESOURCE_ENERGY) < this.config.minStorageEnergy)) {
var i = this.selectProduction(e, n, a);
if (i) {
var s = R[i];
if (s) {
var c = !0;
try {
for (var l = p(Object.entries(s)), u = l.next(); !u.done; u = l.next()) {
var f = d(u.value, 2), m = f[0], g = f[1];
if (n.store.getUsedCapacity(m) < g) {
c = !1;
break;
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (r = l.return) && r.call(l);
} finally {
if (t) throw t.error;
}
}
if (c) {
var h = n.produce(i);
h === OK ? y.logger.info("Factory in ".concat(e.name, " producing ").concat(i), {
subsystem: "Factory"
}) : h !== ERR_TIRED && y.logger.debug("Factory production failed in ".concat(e.name, ": ").concat(h), {
subsystem: "Factory"
});
}
}
}
}
}
}
}, e.prototype.selectProduction = function(e, t, r) {
var o, n, a, i, s, c = [];
try {
for (var l = p(Object.entries(R)), u = l.next(); !u.done; u = l.next()) {
var f = d(u.value, 2), m = f[0], y = f[1], g = m, h = !0, v = 0;
try {
for (var T = (a = void 0, p(Object.entries(y))), S = T.next(); !S.done; S = T.next()) {
var C = d(S.value, 2), b = C[0], _ = C[1], O = b, w = r.store.getUsedCapacity(O);
if (w < 2 * _) {
h = !1;
break;
}
v += w / (10 * _);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
S && !S.done && (i = T.return) && i.call(T);
} finally {
if (a) throw a.error;
}
}
if (h) {
var x = t.store.getUsedCapacity(g) + r.store.getUsedCapacity(g);
if (!(x > this.config.outputBufferAmount)) {
var U = null !== (s = E[g]) && void 0 !== s ? s : 1, M = U * v * (1 - x / this.config.outputBufferAmount);
c.push({
commodity: g,
priority: U,
score: M
});
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (o) throw o.error;
}
}
return 0 === c.length ? null : (c.sort(function(e, t) {
return t.score - e.score;
}), c[0].commodity);
}, e.prototype.getRequiredInputs = function(e, t) {
var r, o, n = t.storage;
if (!n) return [];
var a = this.selectProduction(t, e, n);
if (!a) return [];
var i = R[a];
if (!i) return [];
var s = [];
try {
for (var c = p(Object.entries(i)), l = c.next(); !l.done; l = c.next()) {
var u = d(l.value, 2), f = u[0], m = u[1], y = f, g = e.store.getUsedCapacity(y), h = Math.max(0, this.config.inputBufferAmount - g);
h > 0 && s.push({
resource: y,
amount: Math.min(h, 2 * m)
});
}
} catch (e) {
r = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (r) throw r.error;
}
}
return s;
}, e.prototype.hasOutputsToRemove = function(e) {
var t, r;
try {
for (var o = p(Object.keys(R)), n = o.next(); !n.done; n = o.next()) {
var a = n.value;
if (e.store.getUsedCapacity(a) > 0) return !0;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
n && !n.done && (r = o.return) && r.call(o);
} finally {
if (t) throw t.error;
}
}
return !1;
}, e.prototype.canOperateWithoutLabConflict = function(e) {
if (!e.terminal) return !1;
var t = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
return t.filter(function(e) {
return e.cooldown > 0;
}).length < t.length / 2 || 0 === t.length;
}, m([ (0, h.MediumFrequencyProcess)("factory:manager", "Factory Manager", {
priority: g.ProcessPriority.LOW,
interval: 30,
minBucket: 0,
cpuBudget: .05
}) ], e.prototype, "run", null), m([ (0, h.ProcessClass)() ], e);
}();
return fl.FactoryManager = T, fl.factoryManager = new T, fl;
}();
Object.defineProperty(e, "FactoryManager", {
enumerable: !0,
get: function() {
return n.FactoryManager;
}
}), Object.defineProperty(e, "factoryManager", {
enumerable: !0,
get: function() {
return n.factoryManager;
}
});
var a = ol();
Object.defineProperty(e, "MarketManager", {
enumerable: !0,
get: function() {
return a.MarketManager;
}
}), Object.defineProperty(e, "marketManager", {
enumerable: !0,
get: function() {
return a.marketManager;
}
});
var i = function() {
if (ll) return ml;
ll = 1;
var e = ml && ml.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
}, t = ml && ml.__decorate || function(e, t, r, o) {
var n, a = arguments.length, i = a < 3 ? t : null === o ? o = Object.getOwnPropertyDescriptor(t, r) : o;
if ("object" == typeof Reflect && "function" == typeof Reflect.decorate) i = Reflect.decorate(e, t, r, o); else for (var s = e.length - 1; s >= 0; s--) (n = e[s]) && (i = (a < 3 ? n(i) : a > 3 ? n(t, r, i) : n(t, r)) || i);
return a > 3 && i && Object.defineProperty(t, r, i), i;
}, r = ml && ml.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(ml, "__esModule", {
value: !0
}), ml.MarketTrendAnalyzer = void 0;
var o = Fc, n = Bc, a = oc, i = Wc, s = {
updateInterval: 500,
minBucket: 0,
maxCpuBudget: .02,
trackedResources: [ RESOURCE_ENERGY, RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST, RESOURCE_GHODIUM ],
highVolatilityThreshold: .3,
opportunityConfidenceThreshold: .7
}, c = function() {
function c(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.supplyDemandCache = new Map, this.opportunities = [], 
this.config = e(e({}, s), t);
}
return c.prototype.run = function() {
var e, t, o = Game.cpu.getUsed();
this.lastRun = Game.time;
try {
for (var n = r(this.config.trackedResources), i = n.next(); !i.done; i = n.next()) {
var s = i.value, c = this.analyzeSupplyDemand(s);
c && this.supplyDemandCache.set(s, c);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
this.detectTradingOpportunities();
var l = Game.cpu.getUsed() - o;
Game.time % 1e3 == 0 && a.logger.info("Market trend analysis completed in ".concat(l.toFixed(2), " CPU, ").concat(this.opportunities.length, " opportunities detected"), {
subsystem: "MarketTrends"
});
}, c.prototype.analyzeSupplyDemand = function(e) {
var t = Game.market.getAllOrders({
resourceType: e
});
if (0 === t.length) return null;
var r = t.filter(function(e) {
return e.type === ORDER_BUY;
}), o = t.filter(function(e) {
return e.type === ORDER_SELL;
}), n = r.reduce(function(e, t) {
return e + t.amount;
}, 0), a = o.reduce(function(e, t) {
return e + t.amount;
}, 0), i = r.length > 0 ? r.reduce(function(e, t) {
return e + t.price;
}, 0) / r.length : 0, s = o.length > 0 ? o.reduce(function(e, t) {
return e + t.price;
}, 0) / o.length : 0, c = Math.min(100, a / (n + a) * 100), l = Math.min(100, n / (n + a) * 100), u = n + a, f = s > 0 ? (s - i) / s : 0;
return {
resource: e,
supplyScore: c,
demandScore: l,
sentiment: (l - c) / 100,
tightness: 1 - Math.min(1, u / 1e6) * (1 - Math.min(1, 10 * f)),
lastUpdate: Game.time
};
}, c.prototype.detectTradingOpportunities = function() {
var e, t, o, n, s, c, l, u, f, m, p, d = i.memoryManager.getEmpire(), y = [];
try {
for (var g = r(this.config.trackedResources), h = g.next(); !h.done; h = g.next()) {
var v = h.value, R = null === (s = d.market) || void 0 === s ? void 0 : s.resources[v];
if (R) {
var E = this.supplyDemandCache.get(v);
if (E) {
-1 === R.trend && E.sentiment < -.3 && (_ = Math.abs(E.sentiment) * (1 - (null !== (c = R.volatility) && void 0 !== c ? c : .5))) >= this.config.opportunityConfidenceThreshold && y.push({
resource: v,
type: "buy",
expectedValue: 1e4 * (R.avgPrice - (null !== (l = R.predictedPrice) && void 0 !== l ? l : R.avgPrice)),
confidence: _,
action: "Buy ".concat(v, " at current price (falling trend, oversupply)"),
urgency: this.calculateUrgency(_, Math.abs(E.sentiment)),
createdAt: Game.time
}), 1 === R.trend && E.sentiment > .3 && (_ = E.sentiment * (1 - (null !== (u = R.volatility) && void 0 !== u ? u : .5))) >= this.config.opportunityConfidenceThreshold && y.push({
resource: v,
type: "sell",
expectedValue: 1e4 * ((null !== (f = R.predictedPrice) && void 0 !== f ? f : R.avgPrice) - R.avgPrice),
confidence: _,
action: "Sell ".concat(v, " at current price (rising trend, high demand)"),
urgency: this.calculateUrgency(_, E.sentiment),
createdAt: Game.time
});
var T = Game.market.getAllOrders({
resourceType: v
}), S = T.filter(function(e) {
return e.type === ORDER_BUY;
}).sort(function(e, t) {
return t.price - e.price;
})[0], C = T.filter(function(e) {
return e.type === ORDER_SELL;
}).sort(function(e, t) {
return e.price - t.price;
})[0];
if (S && C && S.price > 1.1 * C.price) {
var b = (S.price - C.price) * Math.min(S.amount, C.amount), _ = .9;
y.push({
resource: v,
type: "arbitrage",
expectedValue: b,
confidence: _,
action: "Arbitrage ".concat(v, ": buy at ").concat(C.price.toFixed(3), ", sell at ").concat(S.price.toFixed(3)),
urgency: 3,
createdAt: Game.time
});
}
(null !== (m = R.volatility) && void 0 !== m ? m : 0) >= this.config.highVolatilityThreshold && a.logger.warn("High volatility detected for ".concat(v, ": ").concat((100 * (null !== (p = R.volatility) && void 0 !== p ? p : 0)).toFixed(1), "%"), {
subsystem: "MarketTrends"
});
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
h && !h.done && (t = g.return) && t.call(g);
} finally {
if (e) throw e.error;
}
}
this.opportunities = y;
try {
for (var O = r(y), w = O.next(); !w.done; w = O.next()) {
var x = w.value;
x.urgency >= 2 && a.logger.info("Trading opportunity: ".concat(x.action, ", expected value: ").concat(x.expectedValue.toFixed(0), " credits, confidence: ").concat((100 * x.confidence).toFixed(0), "%"), {
subsystem: "MarketTrends"
});
}
} catch (e) {
o = {
error: e
};
} finally {
try {
w && !w.done && (n = O.return) && n.call(O);
} finally {
if (o) throw o.error;
}
}
}, c.prototype.calculateUrgency = function(e, t) {
var r = e * Math.abs(t);
return r >= .8 ? 3 : r >= .6 ? 2 : r >= .4 ? 1 : 0;
}, c.prototype.getSupplyDemand = function(e) {
return this.supplyDemandCache.get(e);
}, c.prototype.getOpportunities = function() {
return this.opportunities;
}, c.prototype.getOpportunitiesForResource = function(e) {
return this.opportunities.filter(function(t) {
return t.resource === e;
});
}, c.prototype.getUrgentOpportunities = function() {
return this.opportunities.filter(function(e) {
return e.urgency >= 2;
});
}, c.prototype.getMarketSentiment = function(e) {
var t, r = this.supplyDemandCache.get(e);
return null !== (t = null == r ? void 0 : r.sentiment) && void 0 !== t ? t : 0;
}, c.prototype.isMarketTight = function(e) {
var t, r = this.supplyDemandCache.get(e);
return (null !== (t = null == r ? void 0 : r.tightness) && void 0 !== t ? t : 0) > .7;
}, t([ (0, o.LowFrequencyProcess)("empire:marketTrends", "Market Trend Analyzer", {
priority: n.ProcessPriority.LOW,
interval: 500,
minBucket: 0,
cpuBudget: .02
}) ], c.prototype, "run", null), t([ (0, o.ProcessClass)() ], c);
}();
return ml.MarketTrendAnalyzer = c, ml;
}();
Object.defineProperty(e, "MarketTrendAnalyzer", {
enumerable: !0,
get: function() {
return i.MarketTrendAnalyzer;
}
});
}(Jc)), Jc);

function dl(e) {
var t;
return e ? null !== (t = {
X: 15,
Z: 12,
K: 12,
L: 10,
U: 10,
O: 8,
H: 8
}[e]) && void 0 !== t ? t : 5 : 0;
}

function yl(e) {
var t, o, n = fi.getEmpire(), a = 0, i = El(e);
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = n.knownRooms[l];
u && (u.owner && !Sl(u.owner) && (a += 30), u.threatLevel >= 2 && (a += 10 * u.threatLevel), 
u.towerCount && u.towerCount > 0 && (a += 5 * u.towerCount));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return a;
}

function gl(e) {
return "plains" === e ? 15 : "swamp" === e ? -10 : 0;
}

function hl(e) {
var t, o, n = El(e);
try {
for (var a = r(n), i = a.next(); !i.done; i = a.next()) {
var s = Tl(i.value);
if (s && (s.x % 10 == 0 || s.y % 10 == 0)) return !0;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
return !1;
}

function vl(e) {
var t, o, n = fi.getEmpire(), a = El(e);
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = n.knownRooms[c];
if (l && l.hasPortal) return 10;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return 0;
}

function Rl(e, t, r) {
return 0 === t.length ? 0 : r <= 2 ? 25 : r <= 3 ? 15 : r <= 5 ? 5 : 0;
}

function El(e) {
var t = Tl(e);
if (!t) return [];
for (var r = t.x, o = t.y, n = t.xDir, a = t.yDir, i = [], s = -1; s <= 1; s++) for (var c = -1; c <= 1; c++) if (0 !== s || 0 !== c) {
var l = r + s, u = o + c, f = n, m = a, p = l, d = u;
l < 0 && (f = "E" === n ? "W" : "E", p = Math.abs(l) - 1), u < 0 && (m = "N" === a ? "S" : "N", 
d = Math.abs(u) - 1), i.push("".concat(f).concat(p).concat(m).concat(d));
}
return i;
}

function Tl(e) {
var t = e.match(/^([WE])(\d+)([NS])(\d+)$/);
return t ? {
xDir: t[1],
x: parseInt(t[2], 10),
yDir: t[3],
y: parseInt(t[4], 10)
} : null;
}

function Sl(e) {
return !1;
}

function Cl(e, t) {
var r = [], o = Tl(e);
if (!o) return [];
for (var n = o.x, a = o.y, i = o.xDir, s = o.yDir, c = -t; c <= t; c++) for (var l = -t; l <= t; l++) if (0 !== c || 0 !== l) {
var u = n + c, f = a + l, m = i, p = s, d = u, y = f;
u < 0 && (m = "E" === i ? "W" : "E", d = Math.abs(u) - 1), f < 0 && (p = "N" === s ? "S" : "N", 
y = Math.abs(f) - 1), r.push("".concat(m).concat(d).concat(p).concat(y));
}
return r;
}

function bl(e, t, r, o) {
var n, a = Game.map.getRoomLinearDistance(t, e);
if (!Number.isFinite(a) || a <= 0) throw new Error("calculateRemoteProfitability: invalid distance ".concat(a, " between ").concat(t, " and ").concat(e));
if (r.sources <= 0) throw new Error("calculateRemoteProfitability: intel.sources must be positive, got ".concat(r.sources, " for ").concat(e));
if (void 0 !== r.threatLevel && null !== r.threatLevel && (r.threatLevel < 0 || r.threatLevel > 3)) throw new Error("calculateRemoteProfitability: intel.threatLevel must be in [0, 3], got ".concat(r.threatLevel, " for ").concat(e));
var i, s, c, l, u, f = 10 * r.sources, m = 50 * a * 2, p = (650 + 450 * r.sources) / (1500 / m) / m, d = 5e3 * r.sources + 50 * a * 300, y = d / 5e4, g = f * (null !== (n = [ 0, .1, .3, .6 ][r.threatLevel]) && void 0 !== n ? n : 0), h = f - p - y - g, v = p + y, R = v > 0 ? h / v : 0;
return {
roomName: e,
sourceId: o,
energyPerTick: f,
carrierCostPerTick: p,
pathDistance: a,
infrastructureCost: d,
threatCost: g,
netProfitPerTick: h,
roi: R,
profitabilityScore: (s = 2 * (i = {
distance: a,
threatCost: g,
roi: R,
netProfitPerTick: h
}).distance, c = i.netProfitPerTick / 10, l = i.threatCost > 0 ? 10 : 0, u = 5 * i.roi, 
Math.max(0, Math.min(100, 50 - s + c - l + u))),
isProfitable: R > 2 && h > 0
};
}

var _l, Ol, wl = {
updateInterval: 30,
minBucket: 0,
maxCpuBudget: .05,
minGclForExpansion: 2,
maxExpansionDistance: 10,
minExpansionScore: 50,
intelRefreshInterval: 100,
minStableRcl: 4,
gclNotifyThreshold: 90,
roomDiscoveryInterval: 100,
maxRoomDiscoveryDistance: 5,
maxRoomsToDiscoverPerTick: 50
}, xl = function() {
function o(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.config = e(e({}, wl), t);
}
return o.prototype.run = function() {
var e = this, t = Game.cpu.getUsed(), r = fi.getEmpire();
this.lastRun = Game.time, r.lastUpdate = Game.time, Io.unifiedStats.measureSubsystem("empire:expansion", function() {
e.updateExpansionQueue(r);
}), Io.unifiedStats.measureSubsystem("empire:powerBanks", function() {
e.updatePowerBanks(r);
}), Io.unifiedStats.measureSubsystem("empire:warTargets", function() {
e.updateWarTargets(r);
}), Io.unifiedStats.measureSubsystem("empire:objectives", function() {
e.updateObjectives(r);
}), Io.unifiedStats.measureSubsystem("empire:intelRefresh", function() {
e.refreshRoomIntel(r);
}), Io.unifiedStats.measureSubsystem("empire:roomDiscovery", function() {
e.discoverNearbyRooms(r);
}), Io.unifiedStats.measureSubsystem("empire:gclTracking", function() {
e.trackGCLProgress(r);
}), Io.unifiedStats.measureSubsystem("empire:expansionReadiness", function() {
e.checkExpansionReadiness(r);
}), Io.unifiedStats.measureSubsystem("empire:nukeCandidates", function() {
e.refreshNukeCandidates(r);
}), Io.unifiedStats.measureSubsystem("empire:clusterHealth", function() {
e.monitorClusterHealth();
}), Io.unifiedStats.measureSubsystem("empire:powerBankProfitability", function() {
e.assessPowerBankProfitability(r);
});
var o = Game.cpu.getUsed() - t;
Game.time % 100 == 0 && Hr.info("Empire tick completed in ".concat(o.toFixed(2), " CPU"), {
subsystem: "Empire"
});
}, o.prototype.cleanupClaimQueue = function(e, t) {
var r = e.claimQueue.length;
e.claimQueue = e.claimQueue.filter(function(e) {
return !t.has(e.roomName) || (Hr.info("Removing ".concat(e.roomName, " from claim queue - now owned"), {
subsystem: "Empire"
}), !1);
}), e.claimQueue.length < r && Hr.info("Cleaned up claim queue: removed ".concat(r - e.claimQueue.length, " owned room(s)"), {
subsystem: "Empire"
});
}, o.prototype.updateExpansionQueue = function(e) {
var t, o, n = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), a = new Set(n.map(function(e) {
return e.name;
})), i = Game.gcl.level, s = Object.values(Game.spawns);
if (s.length > 0 && s[0].owner) {
var c = s[0].owner.username;
try {
for (var l = r(n), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
(d = e.knownRooms[f.name]) && d.owner !== c && (d.owner = c, Hr.info("Updated room intel for ".concat(f.name, " - now owned by ").concat(c), {
subsystem: "Empire"
}));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
}
if (this.cleanupClaimQueue(e, a), !(n.length >= i || i < this.config.minGclForExpansion || e.objectives.expansionPaused)) {
var m = [];
for (var p in e.knownRooms) {
var d;
if (!(d = e.knownRooms[p]).owner && !d.reserver && d.scouted) {
var y = this.scoreExpansionCandidate(d, n);
y >= this.config.minExpansionScore && m.push({
roomName: d.name,
score: y,
distance: this.getMinDistanceToOwned(d.name, n),
claimed: !1,
lastEvaluated: Game.time
});
}
}
m.sort(function(e, t) {
return t.score - e.score;
}), e.claimQueue = m.slice(0, 10), m.length > 0 && Game.time % 100 == 0 && Hr.info("Expansion queue updated: ".concat(m.length, " candidates, top score: ").concat(m[0].score), {
subsystem: "Empire"
});
}
}, o.prototype.scoreExpansionCandidate = function(e, t) {
var r = 0;
2 === e.sources ? r += 40 : 1 === e.sources && (r += 20), r += dl(e.mineralType);
var o = this.getMinDistanceToOwned(e.name, t);
return o > this.config.maxExpansionDistance ? 0 : (r -= 5 * o, r -= yl(e.name), 
r -= 15 * e.threatLevel, r += gl(e.terrain), hl(e.name) && (r += 10), r += vl(e.name), 
e.controllerLevel > 0 && !e.owner && (r += 2 * e.controllerLevel), r += Rl(e.name, t, o), 
e.isHighway ? 0 : (e.isSK && (r -= 50), Math.max(0, r)));
}, o.prototype.getMinDistanceToOwned = function(e, t) {
var o, n, a = 1 / 0;
try {
for (var i = r(t), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.map.getRoomLinearDistance(e, c.name);
l < a && (a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}, o.prototype.updatePowerBanks = function(e) {
var t;
e.powerBanks = e.powerBanks.filter(function(e) {
return e.decayTick > Game.time;
});
var o = function(o) {
var n, a, i = Game.rooms[o].find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_BANK;
}
}), s = function(r) {
e.powerBanks.find(function(e) {
return e.roomName === o && e.pos.x === r.pos.x && e.pos.y === r.pos.y;
}) || (e.powerBanks.push({
roomName: o,
pos: {
x: r.pos.x,
y: r.pos.y
},
power: r.power,
decayTick: Game.time + (null !== (t = r.ticksToDecay) && void 0 !== t ? t : 5e3),
active: !1
}), Hr.info("Power bank discovered in ".concat(o, ": ").concat(r.power, " power"), {
subsystem: "Empire"
}));
};
try {
for (var c = (n = void 0, r(i)), l = c.next(); !l.done; l = c.next()) s(l.value);
} catch (e) {
n = {
error: e
};
} finally {
try {
l && !l.done && (a = c.return) && a.call(c);
} finally {
if (n) throw n.error;
}
}
};
for (var n in Game.rooms) o(n);
}, o.prototype.updateWarTargets = function(e) {
if (e.warTargets = e.warTargets.filter(function(t) {
var r, o, n = e.knownRooms[t];
return !!n && n.owner !== (null !== (o = null === (r = Object.values(Game.spawns)[0]) || void 0 === r ? void 0 : r.owner.username) && void 0 !== o ? o : "");
}), e.objectives.warMode) for (var t in e.knownRooms) {
var r = e.knownRooms[t];
r.threatLevel >= 2 && !e.warTargets.includes(t) && (e.warTargets.push(t), Hr.warn("Added war target: ".concat(t, " (threat level ").concat(r.threatLevel, ")"), {
subsystem: "Empire"
}));
}
}, o.prototype.updateObjectives = function(e) {
var t = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
e.objectives.targetRoomCount = Game.gcl.level, e.objectives.targetPowerLevel = Math.min(25, 3 * t.length), 
e.warTargets.length > 0 && !e.objectives.warMode && (e.objectives.warMode = !0, 
Hr.warn("War mode enabled due to active war targets", {
subsystem: "Empire"
})), 0 === e.warTargets.length && e.objectives.warMode && (e.objectives.warMode = !1, 
Hr.info("War mode disabled - no active war targets", {
subsystem: "Empire"
}));
}, o.prototype.getNextExpansionTarget = function() {
var e = fi.getEmpire().claimQueue.filter(function(e) {
return !e.claimed;
});
return e.length > 0 ? e[0] : null;
}, o.prototype.markExpansionClaimed = function(e) {
var t = fi.getEmpire().claimQueue.find(function(t) {
return t.roomName === e;
});
t && (t.claimed = !0, Hr.info("Marked expansion target as claimed: ".concat(e), {
subsystem: "Empire"
}));
}, o.prototype.refreshRoomIntel = function(e) {
if (Game.time % this.config.intelRefreshInterval === 0) {
var t = 0;
for (var r in Game.rooms) {
var o = Game.rooms[r];
e.knownRooms[r] ? (this.updateRoomIntel(e.knownRooms[r], o), t++) : (e.knownRooms[r] = this.createRoomIntel(o), 
t++);
}
t > 0 && Game.time % 500 == 0 && Hr.info("Refreshed intel for ".concat(t, " rooms"), {
subsystem: "Empire"
});
}
}, o.prototype.discoverNearbyRooms = function(e) {
var t, o, n, a;
if (Game.time % this.config.roomDiscoveryInterval === 0) {
var i = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (0 !== i.length) {
var s = 0;
try {
for (var c = r(i), l = c.next(); !l.done; l = c.next()) {
var u = Cl(l.value.name, this.config.maxRoomDiscoveryDistance);
try {
for (var f = (n = void 0, r(u)), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
if (s >= this.config.maxRoomsToDiscoverPerTick) return void Hr.debug("Reached discovery limit of ".concat(this.config.maxRoomsToDiscoverPerTick, " rooms per tick"), {
subsystem: "Empire"
});
e.knownRooms[p] || (e.knownRooms[p] = this.createStubIntel(p), s++);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (n) throw n.error;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
s > 0 && Hr.info("Discovered ".concat(s, " nearby rooms for scouting"), {
subsystem: "Empire"
});
}
}
}, o.prototype.createStubIntel = function(e) {
var t = Tl(e);
return {
name: e,
lastSeen: 0,
sources: 0,
controllerLevel: 0,
threatLevel: 0,
scouted: !1,
terrain: "mixed",
isHighway: !!t && (t.x % 10 == 0 || t.y % 10 == 0),
isSK: !!t && !(t.x % 10 != 4 && t.x % 10 != 5 && t.x % 10 != 6 || t.y % 10 != 4 && t.y % 10 != 5 && t.y % 10 != 6)
};
}, o.prototype.createRoomIntel = function(e) {
for (var t, r, o, n = e.find(FIND_SOURCES), a = e.find(FIND_MINERALS)[0], i = e.controller, s = 0, c = 0, l = new Room.Terrain(e.name), u = 0; u < 50; u++) for (var f = 0; f < 50; f++) {
var m = l.get(u, f);
m === TERRAIN_MASK_SWAMP ? c++ : 0 === m && s++;
}
var p = c > s ? "swamp" : s > c ? "plains" : "mixed";
return {
name: e.name,
lastSeen: Game.time,
sources: n.length,
controllerLevel: null !== (t = null == i ? void 0 : i.level) && void 0 !== t ? t : 0,
owner: null === (r = null == i ? void 0 : i.owner) || void 0 === r ? void 0 : r.username,
reserver: null === (o = null == i ? void 0 : i.reservation) || void 0 === o ? void 0 : o.username,
mineralType: null == a ? void 0 : a.mineralType,
threatLevel: 0,
scouted: !0,
terrain: p,
isHighway: !1,
isSK: !1,
towerCount: e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
}).length,
spawnCount: e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_SPAWN;
}
}).length
};
}, o.prototype.updateRoomIntel = function(e, t) {
var r, o, n;
e.lastSeen = Game.time;
var a = t.controller;
a && (e.controllerLevel = null !== (r = a.level) && void 0 !== r ? r : 0, e.owner = null === (o = a.owner) || void 0 === o ? void 0 : o.username, 
e.reserver = null === (n = a.reservation) || void 0 === n ? void 0 : n.username);
var i = t.find(FIND_HOSTILE_CREEPS).filter(function(e) {
return e.body.some(function(e) {
return e.type === ATTACK || e.type === RANGED_ATTACK || e.type === WORK;
});
});
i.length >= 5 ? e.threatLevel = 3 : i.length >= 2 ? e.threatLevel = 2 : i.length > 0 ? e.threatLevel = 1 : e.threatLevel = 0, 
e.towerCount = t.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
}).length, e.spawnCount = t.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_SPAWN;
}
}).length;
}, o.prototype.trackGCLProgress = function(e) {
var t = Game.gcl.progress / Game.gcl.progressTotal * 100;
t >= this.config.gclNotifyThreshold && Game.time % 500 == 0 && Hr.info("GCL ".concat(Game.gcl.level, " progress: ").concat(t.toFixed(1), "% (").concat(Game.gcl.progress, "/").concat(Game.gcl.progressTotal, ")"), {
subsystem: "Empire"
}), e.objectives.targetRoomCount = Game.gcl.level;
}, o.prototype.checkExpansionReadiness = function(e) {
var t = this, r = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (!(r.length >= Game.gcl.level)) {
var o = r.filter(function(e) {
var r, o, n = null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0, a = void 0 !== e.storage;
return n >= t.config.minStableRcl && a;
});
if (0 !== o.length) {
var n = o.reduce(function(e, t) {
var r, o;
return e + (null !== (o = null === (r = t.storage) || void 0 === r ? void 0 : r.store[RESOURCE_ENERGY]) && void 0 !== o ? o : 0);
}, 0), a = n / o.length;
a < 5e4 ? e.objectives.expansionPaused || (e.objectives.expansionPaused = !0, Hr.info("Expansion paused: insufficient energy reserves (".concat(a.toFixed(0), " < ").concat(5e4, ")"), {
subsystem: "Empire"
})) : e.objectives.expansionPaused && (e.objectives.expansionPaused = !1, Hr.info("Expansion resumed: ".concat(o.length, " stable rooms with ").concat(a.toFixed(0), " avg energy"), {
subsystem: "Empire"
}));
} else e.objectives.expansionPaused || (e.objectives.expansionPaused = !0, Hr.info("Expansion paused: waiting for stable room (RCL >= 4 with storage)", {
subsystem: "Empire"
}));
}
}, o.prototype.refreshNukeCandidates = function(e) {
var t, o;
if (Game.time % 500 == 0 && (e.nukeCandidates = e.nukeCandidates.filter(function(e) {
return !(e.launched && Game.time - e.launchTick > 5e4);
}), e.objectives.warMode && 0 !== e.warTargets.length)) {
var n = function(t) {
var r = e.knownRooms[t];
if (!r || !r.scouted) return "continue";
var o = e.nukeCandidates.find(function(e) {
return e.roomName === t;
});
if (o && !o.launched) return "continue";
var n = a.scoreNukeCandidate(r);
n >= 50 && (e.nukeCandidates.push({
roomName: t,
score: n,
launched: !1,
launchTick: 0
}), Hr.info("Added nuke candidate: ".concat(t, " (score: ").concat(n, ")"), {
subsystem: "Empire"
}));
}, a = this;
try {
for (var i = r(e.warTargets), s = i.next(); !s.done; s = i.next()) n(s.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
e.nukeCandidates.sort(function(e, t) {
return t.score - e.score;
}), e.nukeCandidates = e.nukeCandidates.slice(0, 10);
}
}, o.prototype.scoreNukeCandidate = function(e) {
var t, r, o = 0;
return o += 10 * e.controllerLevel, o += 15 * (null !== (t = e.towerCount) && void 0 !== t ? t : 0), 
o += 20 * (null !== (r = e.spawnCount) && void 0 !== r ? r : 0), e.isSK || e.isHighway ? 0 : o;
}, o.prototype.monitorClusterHealth = function() {
if (Game.time % 50 == 0) {
var e = fi.getClusters(), t = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), r = function(r) {
var o = e[r], n = t.filter(function(e) {
return o.memberRooms.includes(e.name);
});
if (0 === n.length) return "continue";
var a = n.reduce(function(e, t) {
var r, o, n, a;
return e + (null !== (o = null === (r = t.storage) || void 0 === r ? void 0 : r.store[RESOURCE_ENERGY]) && void 0 !== o ? o : 0) + (null !== (a = null === (n = t.terminal) || void 0 === n ? void 0 : n.store[RESOURCE_ENERGY]) && void 0 !== a ? a : 0);
}, 0), i = a / n.length, s = Game.cpu.getUsed() / t.length, c = s > 2;
i < 3e4 && Game.time % 500 == 0 && Hr.warn("Cluster ".concat(r, " has low energy: ").concat(i.toFixed(0), " avg (threshold: 30000)"), {
subsystem: "Empire"
}), c && Game.time % 500 == 0 && Hr.warn("Cluster ".concat(r, " has high CPU usage: ").concat(s.toFixed(2), " per room"), {
subsystem: "Empire"
}), o.metrics || (o.metrics = {
energyIncome: 0,
energyConsumption: 0,
energyBalance: 0,
warIndex: 0,
economyIndex: 0
});
var l = Math.min(100, i / 1e5 * 100), u = n.length / o.memberRooms.length * 100;
o.metrics.economyIndex = Math.round((l + u) / 2), o.metrics.economyIndex < 40 && Game.time % 500 == 0 && Hr.warn("Cluster ".concat(r, " economy index low: ").concat(o.metrics.economyIndex, " - consider rebalancing"), {
subsystem: "Empire"
});
};
for (var o in e) r(o);
}
}, o.prototype.assessPowerBankProfitability = function(e) {
var t, o, n, a, i, s;
if (Game.time % 100 == 0) {
var c = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (0 !== c.length) try {
for (var l = r(e.powerBanks), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if (!f.active) {
var m = 1 / 0, p = null;
try {
for (var d = (n = void 0, r(c)), y = d.next(); !y.done; y = d.next()) {
var g = y.value, h = Game.map.getRoomLinearDistance(g.name, f.roomName);
h < m && (m = h, p = g);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
if (p) {
var v = f.decayTick - Game.time, R = 50 * m * 2 + f.power / 2, E = v > 1.5 * R && m <= 5 && f.power >= 1e3 && (null !== (s = null === (i = p.controller) || void 0 === i ? void 0 : i.level) && void 0 !== s ? s : 0) >= 7;
E || Game.time % 500 != 0 ? E && Game.time % 500 == 0 && Hr.info("Profitable power bank in ".concat(f.roomName, ": ") + "power=".concat(f.power, ", distance=").concat(m, ", timeRemaining=").concat(v), {
subsystem: "Empire"
}) : Hr.debug("Power bank in ".concat(f.roomName, " not profitable: ") + "power=".concat(f.power, ", distance=").concat(m, ", timeRemaining=").concat(v, ", ") + "requiredTime=".concat(R.toFixed(0)), {
subsystem: "Empire"
});
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
}
}, t([ Di("empire:manager", "Empire Manager", {
priority: Ao.MEDIUM,
interval: 30,
minBucket: 0,
cpuBudget: .05
}) ], o.prototype, "run", null), t([ Bi() ], o);
}(), Ul = new xl, Ml = {
updateInterval: 20,
minBucket: 0,
maxRemoteDistance: 2,
maxRemotesPerRoom: 4,
minRemoteSources: 1,
minRclForRemotes: 3,
minRclForClaiming: 4,
minGclProgressForClaim: .7,
clusterExpansionDistance: 5,
minStableRoomPercentage: .6
}, Al = function() {
function o(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.cachedUsername = "", this.usernameLastTick = 0, 
this.config = e(e({}, Ml), t);
}
return o.prototype.run = function() {
var e = fi.getEmpire();
this.lastRun = Game.time, this.monitorExpansionProgress(e), this.updateRemoteAssignments(e), 
this.isExpansionReady(e) && this.assignClaimerTargets(e), this.assignReserverTargets();
}, o.prototype.updateRemoteAssignments = function(e) {
var t, o, n, a, i, s, c, l = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value, p = fi.getSwarmState(m.name);
if (p && !((null !== (s = null === (i = m.controller) || void 0 === i ? void 0 : i.level) && void 0 !== s ? s : 0) < this.config.minRclForRemotes)) {
var d = null !== (c = p.remoteAssignments) && void 0 !== c ? c : [], y = this.validateRemoteAssignments(d, e, m.name), g = this.calculateRemoteCapacity(m, p);
if (y.length < g) {
var h = this.findRemoteCandidates(m.name, e, y), v = g - y.length, R = h.slice(0, v);
try {
for (var E = (n = void 0, r(R)), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
y.includes(S) || (y.push(S), Hr.info("Assigned remote room ".concat(S, " to ").concat(m.name), {
subsystem: "Expansion"
}));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
T && !T.done && (a = E.return) && a.call(E);
} finally {
if (n) throw n.error;
}
}
}
JSON.stringify(y) !== JSON.stringify(p.remoteAssignments) && (p.remoteAssignments = y);
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (t) throw t.error;
}
}
}, o.prototype.calculateRemoteCapacity = function(e, t) {
var r, o, n = null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0;
if (t.danger >= 2) return Math.min(1, this.config.maxRemotesPerRoom);
var a = e.storage;
return a && a.store.getUsedCapacity(RESOURCE_ENERGY) < 1e4 || n < 4 ? Math.min(1, this.config.maxRemotesPerRoom) : 4 === n ? Math.min(2, this.config.maxRemotesPerRoom) : n < 7 ? Math.min(3, this.config.maxRemotesPerRoom) : this.config.maxRemotesPerRoom;
}, o.prototype.validateRemoteAssignments = function(e, t, r) {
var o = this;
return e.filter(function(e) {
var n = t.knownRooms[e];
if (!n) return !0;
var a = null;
n.owner && (Hr.info("Removing remote ".concat(e, " - now owned by ").concat(n.owner), {
subsystem: "Expansion"
}), a = "claimed");
var i = o.getMyUsername();
if (!a && n.reserver && n.reserver !== i && (Hr.info("Removing remote ".concat(e, " - reserved by ").concat(n.reserver), {
subsystem: "Expansion"
}), a = "hostile"), !a && n.threatLevel >= 3 && (Hr.info("Removing remote ".concat(e, " - threat level ").concat(n.threatLevel), {
subsystem: "Expansion"
}), a = "hostile"), !a) {
var s = Game.map.getRoomLinearDistance(r, e);
s > o.config.maxRemoteDistance && (Hr.info("Removing remote ".concat(e, " - too far (").concat(s, ")"), {
subsystem: "Expansion"
}), a = "unreachable");
}
return !a || (Ko.emit("remote.lost", {
homeRoom: r,
remoteRoom: e,
reason: a,
source: r
}), !1);
});
}, o.prototype.findRemoteCandidates = function(e, t, r) {
var o = [], n = this.getMyUsername();
for (var a in t.knownRooms) if (!r.includes(a) && !this.isRemoteAssignedElsewhere(a, e)) {
var i = t.knownRooms[a];
if (i.scouted && !i.owner && !(i.reserver && i.reserver !== n || i.isHighway || i.isSK || i.sources < this.config.minRemoteSources || i.threatLevel >= 2)) {
var s = Game.map.getRoomLinearDistance(e, a);
if (!(s < 1 || s > this.config.maxRemoteDistance)) {
var c = bl(a, e, i);
if (c.isProfitable) {
var l = this.scoreRemoteCandidate(i, s);
o.push({
roomName: a,
score: l
});
} else Game.time % 1e3 == 0 && Hr.debug("Skipping remote ".concat(a, " - not profitable (ROI: ").concat(c.roi.toFixed(2), ")"), {
subsystem: "Expansion"
});
}
}
}
return o.sort(function(e, t) {
return t.score - e.score;
}), o.map(function(e) {
return e.roomName;
});
}, o.prototype.scoreRemoteCandidate = function(e, t) {
var r = 0;
return r += 50 * e.sources, r -= 20 * t, r -= 30 * e.threatLevel, "plains" === e.terrain ? r += 10 : "swamp" === e.terrain && (r -= 10), 
r;
}, o.prototype.scoreClaimCandidate = function(e, t, r) {
var o = 0;
return 2 === e.sources ? o += 40 : 1 === e.sources && (o += 20), o += dl(e.mineralType), 
o -= 5 * t, o -= yl(e.name), o -= 15 * e.threatLevel, o += gl(e.terrain), hl(e.name) && (o += 10), 
o += vl(e.name), e.controllerLevel > 0 && !e.owner && (o += 2 * e.controllerLevel), 
o + Rl(e.name, r, t);
}, o.prototype.isRemoteAssignedElsewhere = function(e, t) {
var o, n, a, i = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
if (l.name !== t) {
var u = fi.getSwarmState(l.name);
if (null === (a = null == u ? void 0 : u.remoteAssignments) || void 0 === a ? void 0 : a.includes(e)) return !0;
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
return !1;
}, o.prototype.assignClaimerTargets = function(e) {
var t, o, n = this.getNextExpansionTarget(e);
if (n) {
var a = Object.values(Game.creeps).some(function(e) {
var t = e.memory;
return "claimer" === t.role && t.targetRoom === n.roomName && "claim" === t.task;
});
if (!a) {
var i = !1;
try {
for (var s = r(Object.values(Game.creeps)), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = l.memory;
if ("claimer" === u.role && !u.targetRoom) {
u.targetRoom = n.roomName, u.task = "claim", Hr.info("Assigned claim target ".concat(n.roomName, " to ").concat(l.name), {
subsystem: "Expansion"
}), n.claimed = !0, i = !0;
break;
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
i || this.requestClaimerSpawn(n.roomName, e);
}
}
}, o.prototype.requestClaimerSpawn = function(e, t) {
var o, n, a = this, i = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), s = i.filter(function(e) {
var t, r;
return (null !== (r = null === (t = e.controller) || void 0 === t ? void 0 : t.level) && void 0 !== r ? r : 0) >= a.config.minRclForClaiming;
});
if (0 !== s.length) {
var c = null, l = 999;
try {
for (var u = r(s), f = u.next(); !f.done; f = u.next()) {
var m = f.value, p = Game.map.getRoomLinearDistance(m.name, e);
p < l && (l = p, c = m);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
if (c) {
var d = fi.getSwarmState(c.name);
d && "defensive" !== d.posture && "evacuate" !== d.posture && d.danger < 2 && "expand" !== d.posture && (d.posture = "expand", 
Hr.info("Set ".concat(c.name, " to expand posture for claiming ").concat(e, " (distance: ").concat(l, ")"), {
subsystem: "Expansion"
}));
}
}
}, o.prototype.assignReserverTargets = function() {
var e, t, o, n, a;
try {
for (var i = r(Object.values(Game.creeps)), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = c.memory;
if ("claimer" === l.role && !l.targetRoom) {
var u = l.homeRoom;
if (u) {
var f = fi.getSwarmState(u);
if (null === (a = null == f ? void 0 : f.remoteAssignments) || void 0 === a ? void 0 : a.length) try {
for (var m = (o = void 0, r(f.remoteAssignments)), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (!this.hasReserverAssigned(d)) {
l.targetRoom = d, l.task = "reserve", Hr.info("Assigned reserve target ".concat(d, " to ").concat(c.name), {
subsystem: "Expansion"
});
break;
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
}, o.prototype.hasReserverAssigned = function(e) {
var t, o;
try {
for (var n = r(Object.values(Game.creeps)), a = n.next(); !a.done; a = n.next()) {
var i = a.value.memory;
if ("claimer" === i.role && i.targetRoom === e && "reserve" === i.task) return !0;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
a && !a.done && (o = n.return) && o.call(n);
} finally {
if (t) throw t.error;
}
}
return !1;
}, o.prototype.isExpansionReady = function(e) {
var t = this;
if (e.objectives.expansionPaused) return !1;
var r = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (r.length >= Game.gcl.level) return !1;
var o = Game.gcl.progress / Game.gcl.progressTotal;
if (o < this.config.minGclProgressForClaim) return Game.time % 500 == 0 && Hr.info("Waiting for GCL progress: ".concat((100 * o).toFixed(1), "% (need ").concat((100 * this.config.minGclProgressForClaim).toFixed(0), "%)"), {
subsystem: "Expansion"
}), !1;
var n = r.filter(function(e) {
var r, o;
return (null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0) >= t.config.minRclForClaiming;
}), a = n.length / r.length;
return !(a < this.config.minStableRoomPercentage && (Game.time % 500 == 0 && Hr.info("Waiting for room stability: ".concat(n.length, "/").concat(r.length, " rooms stable (").concat((100 * a).toFixed(0), "%, need ").concat((100 * this.config.minStableRoomPercentage).toFixed(0), "%)"), {
subsystem: "Expansion"
}), 1));
}, o.prototype.getNextExpansionTarget = function(t) {
var r = this, o = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (o.length >= Game.gcl.level) return null;
var n = t.claimQueue.filter(function(e) {
return !e.claimed;
});
if (0 === n.length) return null;
var a = n.map(function(t) {
var n = r.getMinDistanceToOwned(t.roomName, o), a = n <= r.config.clusterExpansionDistance ? 100 : 0;
return e(e({}, t), {
clusterScore: t.score + a,
distanceToCluster: n
});
});
if (a.sort(function(e, t) {
return t.clusterScore - e.clusterScore;
}), Game.time % 100 == 0 && a.length > 0) {
var i = a[0];
Hr.info("Next expansion target: ".concat(i.roomName, " (score: ").concat(i.score, ", cluster bonus: ").concat(i.clusterScore - i.score, ", distance: ").concat(i.distanceToCluster, ")"), {
subsystem: "Expansion"
});
}
return a[0];
}, o.prototype.getMinDistanceToOwned = function(e, t) {
var o, n;
if (0 === t.length) return 999;
var a = 999;
try {
for (var i = r(t), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.map.getRoomLinearDistance(e, c.name);
l < a && (a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}, o.prototype.getMyUsername = function() {
if (this.usernameLastTick !== Game.time || !this.cachedUsername) {
var e = Object.values(Game.spawns);
e.length > 0 && (this.cachedUsername = e[0].owner.username), this.usernameLastTick = Game.time;
}
return this.cachedUsername;
}, o.prototype.performSafetyAnalysis = function(e, t) {
var o, n, a = [], i = Cl(e, 2);
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = t.knownRooms[l];
u && (u.owner && !Sl(u.owner) && a.push("Hostile player ".concat(u.owner, " in ").concat(l)), 
u.towerCount && u.towerCount > 0 && a.push("".concat(u.towerCount, " towers in ").concat(l)), 
u.spawnCount && u.spawnCount > 0 && a.push("".concat(u.spawnCount, " spawns in ").concat(l)), 
u.threatLevel >= 2 && a.push("Threat level ".concat(u.threatLevel, " in ").concat(l)));
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
return function(e) {
var t, o, n = fi.getEmpire(), a = El(e), i = new Set;
try {
for (var s = r(a), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = n.knownRooms[l];
(null == u ? void 0 : u.owner) && !Sl(u.owner) && i.add(u.owner);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return i.size >= 2;
}(e) && a.push("Room is in potential war zone between hostile players"), {
isSafe: 0 === a.length,
threatDescription: a.length > 0 ? a.join("; ") : "No threats detected"
};
}, o.prototype.monitorExpansionProgress = function(e) {
var t, o, n, a = Game.time, i = function(t) {
if (!t.claimed) return "continue";
var r = a - t.lastEvaluated;
if (r > 5e3) {
var o = Game.rooms[t.roomName];
return (null === (n = null == o ? void 0 : o.controller) || void 0 === n ? void 0 : n.my) ? (Hr.info("Expansion to ".concat(t.roomName, " completed successfully"), {
subsystem: "Expansion"
}), s.removeFromClaimQueue(e, t.roomName), "continue") : (Hr.warn("Expansion to ".concat(t.roomName, " timed out after ").concat(r, " ticks"), {
subsystem: "Expansion"
}), s.cancelExpansion(e, t.roomName, "timeout"), "continue");
}
if (!Object.values(Game.creeps).some(function(e) {
var r = e.memory;
return "claimer" === r.role && r.targetRoom === t.roomName && "claim" === r.task;
}) && r > 1e3) return Hr.warn("No active claimer for ".concat(t.roomName, " expansion"), {
subsystem: "Expansion"
}), s.cancelExpansion(e, t.roomName, "claimer_died"), "continue";
var i = e.knownRooms[t.roomName];
if ((null == i ? void 0 : i.owner) && i.owner !== s.getMyUsername()) return Hr.warn("".concat(t.roomName, " claimed by ").concat(i.owner, " before we could claim it"), {
subsystem: "Expansion"
}), s.cancelExpansion(e, t.roomName, "hostile_claim"), "continue";
var c = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), l = c.reduce(function(e, t) {
var r, o;
return e + (null !== (o = null === (r = t.storage) || void 0 === r ? void 0 : r.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== o ? o : 0);
}, 0), u = c.length > 0 ? l / c.length : 0;
return u < 2e4 ? (Hr.warn("Cancelling expansion to ".concat(t.roomName, " due to low energy (avg: ").concat(u, ")"), {
subsystem: "Expansion"
}), s.cancelExpansion(e, t.roomName, "low_energy"), "continue") : void 0;
}, s = this;
try {
for (var c = r(e.claimQueue), l = c.next(); !l.done; l = c.next()) i(l.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
}, o.prototype.cancelExpansion = function(e, t, o) {
var n, a;
this.removeFromClaimQueue(e, t);
try {
for (var i = r(Object.values(Game.creeps)), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = c.memory;
"claimer" === l.role && l.targetRoom === t && "claim" === l.task && (l.targetRoom = void 0, 
l.task = void 0, Hr.info("Cleared target for ".concat(c.name, " due to expansion cancellation"), {
subsystem: "Expansion"
}));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
s && !s.done && (a = i.return) && a.call(i);
} finally {
if (n) throw n.error;
}
}
Hr.info("Cancelled expansion to ".concat(t, ", reason: ").concat(o), {
subsystem: "Expansion"
});
}, o.prototype.removeFromClaimQueue = function(e, t) {
var r = e.claimQueue.findIndex(function(e) {
return e.roomName === t;
});
-1 !== r && e.claimQueue.splice(r, 1);
}, o.prototype.addRemoteRoom = function(e, t) {
var r = fi.getSwarmState(e);
return r ? (r.remoteAssignments || (r.remoteAssignments = []), r.remoteAssignments.includes(t) ? (Hr.warn("Remote ".concat(t, " already assigned to ").concat(e), {
subsystem: "Expansion"
}), !1) : (r.remoteAssignments.push(t), Hr.info("Manually added remote ".concat(t, " to ").concat(e), {
subsystem: "Expansion"
}), !0)) : (Hr.error("Cannot add remote: ".concat(e, " not found"), {
subsystem: "Expansion"
}), !1);
}, o.prototype.removeRemoteRoom = function(e, t) {
var r = fi.getSwarmState(e);
if (!(null == r ? void 0 : r.remoteAssignments)) return !1;
var o = r.remoteAssignments.indexOf(t);
return -1 !== o && (r.remoteAssignments.splice(o, 1), Hr.info("Manually removed remote ".concat(t, " from ").concat(e), {
subsystem: "Expansion"
}), !0);
}, t([ Li("expansion:manager", "Expansion Manager", {
priority: Ao.LOW,
interval: 20,
minBucket: 0,
cpuBudget: .02
}) ], o.prototype, "run", null), t([ Bi() ], o);
}(), kl = new Al, Nl = {
updateInterval: 500,
minGhodium: 5e3,
minEnergy: 3e5,
minScore: 35,
siegeCoordinationWindow: 1e3,
nukeFlightTime: 5e4,
terminalPriority: 5,
donorRoomBuffer: 1e3,
salvoSyncWindow: 10,
roiThreshold: 2,
counterNukeWarThreshold: 60
}, Pl = 1e7, Il = 5e6, Gl = ((_l = {})[STRUCTURE_SPAWN] = 15e3, _l[STRUCTURE_TOWER] = 5e3, 
_l[STRUCTURE_STORAGE] = 3e4, _l[STRUCTURE_TERMINAL] = 1e5, _l[STRUCTURE_LAB] = 5e4, 
_l[STRUCTURE_NUKER] = 1e5, _l[STRUCTURE_POWER_SPAWN] = 1e5, _l[STRUCTURE_OBSERVER] = 8e3, 
_l[STRUCTURE_EXTENSION] = 3e3, _l[STRUCTURE_LINK] = 5e3, _l), Ll = function() {
function a(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.nukerReadyLogged = new Set, this.config = e(e({}, Nl), t);
}
return a.prototype.run = function() {
this.lastRun = Game.time, this.initializeNukeTracking(), this.detectIncomingNukes(), 
this.processCounterNukeStrategies(), this.manageNukeResources(), this.loadNukers(), 
this.evaluateNukeCandidates(), this.updateNukeEconomics(), this.coordinateWithSieges(), 
this.coordinateNukeSalvos(), this.launchNukes(), this.cleanupNukeTracking();
}, a.prototype.loadNukers = function() {
var e;
for (var t in Game.rooms) {
var r = Game.rooms[t];
if (null === (e = r.controller) || void 0 === e ? void 0 : e.my) {
var o = r.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_NUKER;
}
})[0];
if (o) {
var n = o.store.getFreeCapacity(RESOURCE_ENERGY), a = o.store.getFreeCapacity(RESOURCE_GHODIUM);
(n > 0 || a > 0) && Hr.debug("Nuker in ".concat(t, " needs ").concat(n, " energy, ").concat(a, " ghodium"), {
subsystem: "Nuke"
});
}
}
}
}, a.prototype.evaluateNukeCandidates = function() {
var e, t, o = fi.getEmpire();
if (o.nukeCandidates = [], o.objectives.warMode) {
try {
for (var n = r(o.warTargets), a = n.next(); !a.done; a = n.next()) {
var i = a.value, s = this.scoreNukeCandidate(i);
s.score >= this.config.minScore && (o.nukeCandidates.push({
roomName: i,
score: s.score,
launched: !1,
launchTick: 0
}), Hr.info("Nuke candidate: ".concat(i, " (score: ").concat(s.score, ") - ").concat(s.reasons.join(", ")), {
subsystem: "Nuke"
}));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
o.nukeCandidates.sort(function(e, t) {
return t.score - e.score;
});
}
}, a.prototype.scoreNukeCandidate = function(e) {
var t = 0, r = [], a = fi.getEmpire().knownRooms[e];
if (!a) return {
roomName: e,
score: 0,
reasons: [ "No intel" ]
};
a.controllerLevel && (t += 3 * a.controllerLevel, r.push("RCL ".concat(a.controllerLevel))), 
a.towerCount && (t += 5 * a.towerCount, r.push("".concat(a.towerCount, " towers"))), 
a.spawnCount && (t += 10 * a.spawnCount, r.push("".concat(a.spawnCount, " spawns"))), 
a.owner && "" !== a.owner && (t += 30, r.push("Owned room"));
var i = fi.getSwarmState(e);
if (i) {
var s = Math.floor(i.pheromones.war / 10);
s > 0 && (t += s, r.push("War intensity: ".concat(i.pheromones.war)));
}
a.isHighway && (t += 10, r.push("Highway (strategic)")), a.threatLevel >= 2 && (t += 20, 
r.push("High threat"));
var c = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
if (c.length > 0) {
var l = Math.min.apply(Math, n([], o(c.map(function(t) {
return Game.map.getRoomLinearDistance(e, t.name);
})), !1));
t -= 2 * l, r.push("".concat(l, " rooms away"));
}
fi.getEmpire().warTargets.includes(e) && (t += 15, r.push("War target"));
var u = new RoomPosition(25, 25, e), f = this.calculateNukeROI(e, u);
return f >= this.config.roiThreshold ? (t += Math.min(20, Math.floor(5 * f)), r.push("ROI: ".concat(f.toFixed(1), "x"))) : (t -= 20, 
r.push("Low ROI: ".concat(f.toFixed(1), "x"))), {
roomName: e,
score: t,
reasons: r
};
}, a.prototype.launchNukes = function() {
var e, t, o, n, a, i = fi.getEmpire();
if (i.objectives.warMode) {
var s = [];
for (var c in Game.rooms) {
var l = Game.rooms[c];
(null === (a = l.controller) || void 0 === a ? void 0 : a.my) && (y = l.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_NUKER;
}
})[0]) && y.store.getUsedCapacity(RESOURCE_ENERGY) >= this.config.minEnergy && y.store.getUsedCapacity(RESOURCE_GHODIUM) >= this.config.minGhodium && s.push(y);
}
if (0 !== s.length) try {
for (var u = r(i.nukeCandidates), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (!m.launched) {
try {
for (var p = (o = void 0, r(s)), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
if (!(Game.map.getRoomLinearDistance(y.room.name, m.roomName) > 10)) {
var g = new RoomPosition(25, 25, m.roomName), h = this.predictNukeImpact(m.roomName, g), v = this.calculateNukeROI(m.roomName, g);
if (v < this.config.roiThreshold) Hr.warn("Skipping nuke launch on ".concat(m.roomName, ": ROI ").concat(v.toFixed(2), "x below threshold ").concat(this.config.roiThreshold, "x"), {
subsystem: "Nuke"
}); else {
var R = y.launchNuke(g);
if (R === OK) {
m.launched = !0, m.launchTick = Game.time;
var E = {
id: "".concat(y.room.name, "-").concat(m.roomName, "-").concat(Game.time),
sourceRoom: y.room.name,
targetRoom: m.roomName,
targetPos: {
x: g.x,
y: g.y
},
launchTick: Game.time,
impactTick: Game.time + this.config.nukeFlightTime,
estimatedDamage: h.estimatedDamage,
estimatedValue: h.estimatedValue
};
i.nukesInFlight || (i.nukesInFlight = []), i.nukesInFlight.push(E), i.nukeEconomics || (i.nukeEconomics = {
nukesLaunched: 0,
totalEnergyCost: 0,
totalGhodiumCost: 0,
totalDamageDealt: 0,
totalValueDestroyed: 0
}), i.nukeEconomics.nukesLaunched++, i.nukeEconomics.totalEnergyCost += 3e5, i.nukeEconomics.totalGhodiumCost += 5e3, 
i.nukeEconomics.totalDamageDealt += h.estimatedDamage, i.nukeEconomics.totalValueDestroyed += h.estimatedValue, 
i.nukeEconomics.lastLaunchTick = Game.time, Hr.warn("NUKE LAUNCHED from ".concat(y.room.name, " to ").concat(m.roomName, "! ") + "Impact in ".concat(this.config.nukeFlightTime, " ticks. ") + "Predicted damage: ".concat((h.estimatedDamage / 1e6).toFixed(1), "M hits, ") + "value: ".concat((h.estimatedValue / 1e3).toFixed(0), "k, ROI: ").concat(v.toFixed(2), "x"), {
subsystem: "Nuke"
});
var T = s.indexOf(y);
T > -1 && s.splice(T, 1);
break;
}
Hr.error("Failed to launch nuke: ".concat(R), {
subsystem: "Nuke"
});
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
d && !d.done && (n = p.return) && n.call(p);
} finally {
if (o) throw o.error;
}
}
if (0 === s.length) break;
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
f && !f.done && (t = u.return) && t.call(u);
} finally {
if (e) throw e.error;
}
}
}
}, a.prototype.detectIncomingNukes = function() {
var e, t = fi.getEmpire();
t.incomingNukes || (t.incomingNukes = []);
var o = function(o) {
var a, i, s = Game.rooms[o];
if (!(null === (e = s.controller) || void 0 === e ? void 0 : e.my)) return "continue";
var c = fi.getSwarmState(o);
if (!c) return "continue";
var l = s.find(FIND_NUKES);
if (l.length > 0) {
var u = function(e) {
"".concat(o, "-").concat(e.pos.x, "-").concat(e.pos.y, "-").concat(e.launchRoomName || "unknown");
var r = t.incomingNukes.find(function(t) {
return t.roomName === o && t.landingPos.x === e.pos.x && t.landingPos.y === e.pos.y;
});
if (r) r.timeToLand = e.timeToLand || 0; else {
var a = {
roomName: o,
landingPos: {
x: e.pos.x,
y: e.pos.y
},
impactTick: Game.time + (e.timeToLand || 0),
timeToLand: e.timeToLand || 0,
detectedAt: Game.time,
evacuationTriggered: !1,
sourceRoom: e.launchRoomName
}, i = n.identifyThreatenedStructures(s, e.pos);
a.threatenedStructures = i, t.incomingNukes.push(a), c.nukeDetected || (c.nukeDetected = !0, 
c.pheromones.defense = Math.min(100, c.pheromones.defense + 50), c.pheromones.siege = Math.min(100, c.pheromones.siege + 30), 
c.danger = 3, Hr.warn("INCOMING NUKE DETECTED in ".concat(o, "! ") + "Landing at (".concat(e.pos.x, ", ").concat(e.pos.y, "), impact in ").concat(e.timeToLand, " ticks. ") + "Source: ".concat(e.launchRoomName || "unknown", ". ") + "Threatened structures: ".concat(i.length), {
subsystem: "Nuke"
}), c.eventLog.push({
type: "nuke_incoming",
time: Game.time,
details: "Impact in ".concat(e.timeToLand, " ticks at (").concat(e.pos.x, ",").concat(e.pos.y, ")")
}), c.eventLog.length > 20 && c.eventLog.shift()), i.some(function(e) {
return e.includes(STRUCTURE_SPAWN) || e.includes(STRUCTURE_STORAGE) || e.includes(STRUCTURE_TERMINAL);
}) && !a.evacuationTriggered && (n.triggerEvacuation(s, a), a.evacuationTriggered = !0);
}
};
try {
for (var f = (a = void 0, r(l)), m = f.next(); !m.done; m = f.next()) u(m.value);
} catch (e) {
a = {
error: e
};
} finally {
try {
m && !m.done && (i = f.return) && i.call(f);
} finally {
if (a) throw a.error;
}
}
} else c.nukeDetected && (c.nukeDetected = !1, Hr.info("Nuke threat cleared in ".concat(o), {
subsystem: "Nuke"
}));
}, n = this;
for (var a in Game.rooms) o(a);
}, a.prototype.identifyThreatenedStructures = function(e, t) {
var o, n, a = [], i = e.lookForAtArea(LOOK_STRUCTURES, Math.max(0, t.y - 2), Math.max(0, t.x - 2), Math.min(49, t.y + 2), Math.min(49, t.x + 2), !0);
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value.structure, u = Math.abs(l.pos.x - t.x), f = Math.abs(l.pos.y - t.y), m = Math.max(u, f);
if (m <= 2) {
var p = 0 === m ? Pl : Il;
l.hits <= p && a.push("".concat(l.structureType, "-").concat(l.pos.x, ",").concat(l.pos.y));
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
return a;
}, a.prototype.triggerEvacuation = function(e, t) {
var r = fi.getSwarmState(e.name);
r && (t.timeToLand < 5e3 ? (r.posture = "evacuate", Hr.warn("EVACUATION TRIGGERED for ".concat(e.name, ": Critical structures threatened by nuke!"), {
subsystem: "Nuke"
})) : ("war" !== r.posture && "evacuate" !== r.posture && (r.posture = "defensive"), 
Hr.warn("NUKE DEFENSE PREPARATION in ".concat(e.name, ": Critical structures in blast radius"), {
subsystem: "Nuke"
})), r.pheromones.defense = 100);
}, a.prototype.manageNukeResources = function() {
var e, t;
if (fi.getEmpire().objectives.warMode) for (var r in Game.rooms) {
var o = Game.rooms[r];
if (null === (e = o.controller) || void 0 === e ? void 0 : e.my) {
var n = o.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_NUKER;
}
})[0];
if (n) {
var a = o.terminal;
if (a && a.my) {
var i = n.store.getFreeCapacity(RESOURCE_ENERGY), s = n.store.getFreeCapacity(RESOURCE_GHODIUM);
if (s > 0) {
var c = null !== (t = a.store.getUsedCapacity(RESOURCE_GHODIUM)) && void 0 !== t ? t : 0;
c < s && this.requestResourceTransfer(r, RESOURCE_GHODIUM, s - c);
}
var l = "".concat(r, "-nuker");
0 === i && 0 === s ? this.nukerReadyLogged.has(l) || (Hr.info("Nuker in ".concat(r, " is fully loaded and ready to launch"), {
subsystem: "Nuke"
}), this.nukerReadyLogged.add(l)) : this.nukerReadyLogged.delete(l);
}
}
}
}
}, a.prototype.requestResourceTransfer = function(e, t, r) {
var o = this.findDonorRoom(e, t, r);
o ? pl.terminalManager.requestTransfer(o, e, t, r, this.config.terminalPriority) && Hr.info("Requested ".concat(r, " ").concat(t, " transfer from ").concat(o, " to ").concat(e, " for nuker"), {
subsystem: "Nuke"
}) : Hr.debug("No donor room found for ".concat(r, " ").concat(t, " to ").concat(e), {
subsystem: "Nuke"
});
}, a.prototype.findDonorRoom = function(e, t, r) {
var o, n, a, i, s = [];
for (var c in Game.rooms) {
var l = Game.rooms[c];
if ((null === (o = l.controller) || void 0 === o ? void 0 : o.my) && c !== e) {
var u = l.terminal;
if (u && u.my) {
var f = null !== (n = u.store.getUsedCapacity(t)) && void 0 !== n ? n : 0;
if (!(f < r + this.config.donorRoomBuffer)) {
var m = Game.map.getRoomLinearDistance(c, e);
s.push({
room: c,
amount: f,
distance: m
});
}
}
}
}
return 0 === s.length ? null : (s.sort(function(e, t) {
return e.distance - t.distance;
}), null !== (i = null === (a = s[0]) || void 0 === a ? void 0 : a.room) && void 0 !== i ? i : null);
}, a.prototype.coordinateWithSieges = function() {
var e, t, o, n, a, i, s, c = fi.getEmpire();
if (c.objectives.warMode && c.nukesInFlight && 0 !== c.nukesInFlight.length) {
try {
for (var l = r(c.nukesInFlight), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = f.impactTick - Game.time;
f.siegeSquadId || m <= this.config.siegeCoordinationWindow && m > 0 && this.deploySiegeSquadForNuke(f) && Hr.info("Siege squad deployment coordinated with nuke on ".concat(f.targetRoom, ", ") + "impact in ".concat(m, " ticks"), {
subsystem: "Nuke"
});
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
var p = fi.getClusters();
try {
for (var d = r(Object.values(p)), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
if (g.squads && 0 !== g.squads.length) {
var h = g.squads.filter(function(e) {
return "siege" === e.type;
}), v = function(e) {
if ("moving" !== e.state && "attacking" !== e.state) return "continue";
var t = e.targetRooms[0];
if (!t) return "continue";
var r = null === (s = c.nukesInFlight) || void 0 === s ? void 0 : s.find(function(e) {
return e.targetRoom === t;
});
r && !r.siegeSquadId && (r.siegeSquadId = e.id, Hr.info("Linked siege squad ".concat(e.id, " with nuke on ").concat(t), {
subsystem: "Nuke"
}));
};
try {
for (var R = (a = void 0, r(h)), E = R.next(); !E.done; E = R.next()) v(E.value);
} catch (e) {
a = {
error: e
};
} finally {
try {
E && !E.done && (i = R.return) && i.call(R);
} finally {
if (a) throw a.error;
}
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
y && !y.done && (n = d.return) && n.call(d);
} finally {
if (o) throw o.error;
}
}
}
}, a.prototype.deploySiegeSquadForNuke = function(e) {
var t, o, n, a = fi.getClusters(), i = null;
try {
for (var s = r(Object.values(a)), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.map.getRoomLinearDistance(l.coreRoom, e.targetRoom);
(!i || u < i.distance) && (i = {
id: l.id,
distance: u
});
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
if (!i) return Hr.warn("Cannot deploy siege squad for nuke on ".concat(e.targetRoom, ": No clusters available"), {
subsystem: "Nuke"
}), !1;
var f = a[i.id];
if (!f) return !1;
var m = null === (n = f.squads) || void 0 === n ? void 0 : n.find(function(t) {
return "siege" === t.type && t.targetRooms.includes(e.targetRoom);
});
if (m) return e.siegeSquadId = m.id, !0;
var p = fi.getSwarmState(e.targetRoom);
p && (p.pheromones.siege = Math.min(100, p.pheromones.siege + 80), p.pheromones.war = Math.min(100, p.pheromones.war + 60), 
Hr.info("Siege pheromones increased for ".concat(e.targetRoom, " to coordinate with nuke strike"), {
subsystem: "Nuke"
}));
var d = "siege-nuke-".concat(e.targetRoom, "-").concat(Game.time), y = {
id: d,
type: "siege",
members: [],
rallyRoom: f.coreRoom,
targetRooms: [ e.targetRoom ],
state: "gathering",
createdAt: Game.time,
retreatThreshold: .3
};
return f.squads || (f.squads = []), f.squads.push(y), e.siegeSquadId = d, Hr.warn("SIEGE SQUAD DEPLOYED: Squad ".concat(d, " will coordinate with nuke on ").concat(e.targetRoom), {
subsystem: "Nuke"
}), !0;
}, a.prototype.estimateSquadEta = function(e, t) {
var r = e.members.map(function(e) {
return Game.creeps[e];
}).filter(function(e) {
return null != e;
});
if (0 === r.length) return 50 * Game.map.getRoomLinearDistance(e.rallyRoom, t);
var a = r.map(function(e) {
return 50 * Game.map.getRoomLinearDistance(e.room.name, t);
});
return Math.min.apply(Math, n([], o(a), !1));
}, a.prototype.initializeNukeTracking = function() {
var e = fi.getEmpire();
e.nukesInFlight || (e.nukesInFlight = []), e.incomingNukes || (e.incomingNukes = []), 
e.nukeEconomics || (e.nukeEconomics = {
nukesLaunched: 0,
totalEnergyCost: 0,
totalGhodiumCost: 0,
totalDamageDealt: 0,
totalValueDestroyed: 0
});
}, a.prototype.coordinateNukeSalvos = function() {
var e, t, a, i, s, c, l = fi.getEmpire();
if (l.nukesInFlight && 0 !== l.nukesInFlight.length) {
var u = new Map;
try {
for (var f = r(l.nukesInFlight), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = u.get(p.targetRoom) || [];
d.push(p), u.set(p.targetRoom, d);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
m && !m.done && (t = f.return) && t.call(f);
} finally {
if (e) throw e.error;
}
}
try {
for (var y = r(u.entries()), g = y.next(); !g.done; g = y.next()) {
var h = o(g.value, 2), v = h[0], R = h[1];
if (!(R.length < 2)) {
var E = R.map(function(e) {
return e.impactTick;
}), T = Math.min.apply(Math, n([], o(E), !1)), S = Math.max.apply(Math, n([], o(E), !1)) - T;
if (S <= this.config.salvoSyncWindow) {
var C = R[0].salvoId || "salvo-".concat(v, "-").concat(T);
try {
for (var b = (s = void 0, r(R)), _ = b.next(); !_.done; _ = b.next()) (p = _.value).salvoId = C;
} catch (e) {
s = {
error: e
};
} finally {
try {
_ && !_.done && (c = b.return) && c.call(b);
} finally {
if (s) throw s.error;
}
}
Hr.info("Nuke salvo ".concat(C, " coordinated: ").concat(R.length, " nukes on ").concat(v, ", impact spread: ").concat(S, " ticks"), {
subsystem: "Nuke"
});
} else Hr.warn("Nukes on ".concat(v, " not synchronized (spread: ").concat(S, " ticks > ").concat(this.config.salvoSyncWindow, ")"), {
subsystem: "Nuke"
});
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
g && !g.done && (i = y.return) && i.call(y);
} finally {
if (a) throw a.error;
}
}
}
}, a.prototype.predictNukeImpact = function(e, t) {
var o, n, a = {
estimatedDamage: 0,
estimatedValue: 0,
threatenedStructures: []
}, i = Game.rooms[e];
if (!i) {
var s = fi.getEmpire().knownRooms[e];
if (s) {
var c = 5 * (s.towerCount || 0) + 10 * (s.spawnCount || 0) + 5;
a.estimatedDamage = Pl + Il * c, a.estimatedValue = .01 * a.estimatedDamage;
}
return a;
}
var l = i.lookForAtArea(LOOK_STRUCTURES, Math.max(0, t.y - 2), Math.max(0, t.x - 2), Math.min(49, t.y + 2), Math.min(49, t.x + 2), !0);
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value.structure, p = Math.abs(m.pos.x - t.x), d = Math.abs(m.pos.y - t.y), y = 0 === Math.max(p, d) ? Pl : Il;
m.hits <= y ? (a.estimatedDamage += m.hits, a.threatenedStructures.push("".concat(m.structureType, "-").concat(m.pos.x, ",").concat(m.pos.y)), 
a.estimatedValue += this.estimateStructureValue(m)) : a.estimatedDamage += y;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
return a;
}, a.prototype.estimateStructureValue = function(e) {
return Gl[e.structureType] || 1e3;
}, a.prototype.processCounterNukeStrategies = function() {
var e, t, o, n = fi.getEmpire();
if (n.incomingNukes && 0 !== n.incomingNukes.length) try {
for (var a = r(n.incomingNukes), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
if (s.sourceRoom && !n.warTargets.includes(s.sourceRoom)) {
var c = n.knownRooms[s.sourceRoom];
if (c && !(c.controllerLevel < 8)) {
var l = fi.getSwarmState(s.roomName);
if (l && !(l.pheromones.war < this.config.counterNukeWarThreshold)) if (this.canAffordNuke()) {
if (!n.warTargets.includes(s.sourceRoom)) for (var u in n.warTargets.push(s.sourceRoom), 
Hr.warn("COUNTER-NUKE AUTHORIZED: ".concat(s.sourceRoom, " added to war targets for nuke retaliation"), {
subsystem: "Nuke"
}), Game.rooms) if (null === (o = Game.rooms[u].controller) || void 0 === o ? void 0 : o.my) {
var f = fi.getSwarmState(u);
f && (f.pheromones.war = Math.min(100, f.pheromones.war + 30));
}
} else Hr.warn("Counter-nuke desired against ".concat(s.sourceRoom, " but insufficient resources"), {
subsystem: "Nuke"
});
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
}, a.prototype.canAffordNuke = function() {
var e, t = 0, r = 0;
for (var o in Game.rooms) {
var n = Game.rooms[o];
(null === (e = n.controller) || void 0 === e ? void 0 : e.my) && (n.storage && (t += n.storage.store.getUsedCapacity(RESOURCE_ENERGY) || 0), 
n.terminal && (t += n.terminal.store.getUsedCapacity(RESOURCE_ENERGY) || 0, r += n.terminal.store.getUsedCapacity(RESOURCE_GHODIUM) || 0));
}
return t >= 6e5 && r >= 1e4;
}, a.prototype.updateNukeEconomics = function() {
var e, t = fi.getEmpire();
if (t.nukeEconomics) {
var r = t.nukeEconomics, o = r.totalEnergyCost + r.totalGhodiumCost;
if (o > 0) {
var n = r.totalValueDestroyed;
r.lastROI = n / o, r.nukesLaunched > 0 && r.nukesLaunched % 5 == 0 && Hr.info("Nuke economics: ".concat(r.nukesLaunched, " nukes, ROI: ").concat(null === (e = r.lastROI) || void 0 === e ? void 0 : e.toFixed(2), "x, ") + "Value destroyed: ".concat((r.totalValueDestroyed / 1e3).toFixed(0), "k"), {
subsystem: "Nuke"
});
}
}
}, a.prototype.cleanupNukeTracking = function() {
var e = fi.getEmpire();
if (e.nukesInFlight && (e.nukesInFlight = e.nukesInFlight.filter(function(e) {
return e.impactTick > Game.time;
})), e.incomingNukes) {
var t = e.incomingNukes.length;
e.incomingNukes = e.incomingNukes.filter(function(e) {
return e.impactTick > Game.time;
});
var r = t - e.incomingNukes.length;
r > 0 && Hr.info("Cleaned up ".concat(r, " impacted nuke alert(s)"), {
subsystem: "Nuke"
});
}
}, a.prototype.calculateNukeROI = function(e, t) {
var r = this.predictNukeImpact(e, t);
return 0 === r.estimatedValue ? 0 : r.estimatedValue / 305e3;
}, t([ Di("empire:nuke", "Nuke Manager", {
priority: Ao.LOW,
interval: 500,
minBucket: 0,
cpuBudget: .01
}) ], a.prototype, "run", null), t([ Bi() ], a);
}(), Dl = new Ll, Fl = {
updateInterval: 200,
minBucket: 0,
minCreditsForPixels: 5e5,
creditReserve: 1e5,
minEnergySurplus: 5e5,
energyThresholdPerRoom: 1e5,
maxPixelPrice: 5e3,
targetPixelPrice: 2e3,
maxPixelsPerTransaction: 10,
purchaseCooldown: 1e3,
minBaseMineralReserve: 1e4,
criticalResourceThresholds: (Ol = {}, Ol[RESOURCE_GHODIUM] = 5e3, Ol),
enabled: !0
}, Bl = function() {
function n(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.config = e(e({}, Fl), t);
}
return n.prototype.run = function() {
this.config.enabled && (this.lastRun = Game.time, this.ensurePixelBuyingMemory(), 
this.isPurchaseCooldownComplete() && (this.hasSurplusResources() ? this.hasEnoughCredits() ? (this.attemptPixelPurchase(), 
this.updateMemory()) : Hr.debug("Pixel buying skipped: insufficient credits", {
subsystem: "PixelBuying"
}) : Hr.debug("Pixel buying skipped: no resource surplus", {
subsystem: "PixelBuying"
})));
}, n.prototype.ensurePixelBuyingMemory = function() {
var e = fi.getEmpire();
if (e.market) {
var t = e.market;
t.pixelBuying || (t.pixelBuying = {
lastPurchaseTick: 0,
totalPixelsPurchased: 0,
totalCreditsSpent: 0,
purchaseHistory: [],
lastScan: 0
});
}
}, n.prototype.getPixelBuyingMemory = function() {
var e = fi.getEmpire();
if (e.market) return e.market.pixelBuying;
}, n.prototype.isPurchaseCooldownComplete = function() {
var e = this.getPixelBuyingMemory();
return !e || Game.time - e.lastPurchaseTick >= this.config.purchaseCooldown;
}, n.prototype.hasSurplusResources = function() {
var e, t, n, a, i, s, c = this.calculateTotalResources(), l = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}).length, u = l * this.config.energyThresholdPerRoom;
if (c.energy < u + this.config.minEnergySurplus) return Hr.debug("Pixel buying: energy below surplus (".concat(c.energy, " < ").concat(u + this.config.minEnergySurplus, ")"), {
subsystem: "PixelBuying"
}), !1;
try {
for (var f = r(Object.entries(this.config.criticalResourceThresholds)), m = f.next(); !m.done; m = f.next()) {
var p = o(m.value, 2), d = p[0], y = p[1];
if ((R = null !== (i = c[d]) && void 0 !== i ? i : 0) < y) return Hr.debug("Pixel buying: ".concat(d, " below threshold (").concat(R, " < ").concat(y, ")"), {
subsystem: "PixelBuying"
}), !1;
}
} catch (t) {
e = {
error: t
};
} finally {
try {
m && !m.done && (t = f.return) && t.call(f);
} finally {
if (e) throw e.error;
}
}
var g = [ RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST ];
try {
for (var h = r(g), v = h.next(); !v.done; v = h.next()) {
var R, E = v.value;
if ((R = null !== (s = c[E]) && void 0 !== s ? s : 0) < this.config.minBaseMineralReserve) return Hr.debug("Pixel buying: ".concat(E, " below reserve (").concat(R, " < ").concat(this.config.minBaseMineralReserve, ")"), {
subsystem: "PixelBuying"
}), !1;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
v && !v.done && (a = h.return) && a.call(h);
} finally {
if (n) throw n.error;
}
}
return !0;
}, n.prototype.hasEnoughCredits = function() {
return Game.market.credits - this.config.creditReserve >= this.config.minCreditsForPixels;
}, n.prototype.calculateTotalResources = function() {
var e, t, r, o, n, a = {};
for (var i in Game.rooms) {
var s = Game.rooms[i];
if (null === (e = s.controller) || void 0 === e ? void 0 : e.my) {
if (s.terminal) for (var c in s.terminal.store) a[l = c] = (null !== (t = a[l]) && void 0 !== t ? t : 0) + (null !== (r = s.terminal.store[l]) && void 0 !== r ? r : 0);
if (s.storage) for (var c in s.storage.store) {
var l;
a[l = c] = (null !== (o = a[l]) && void 0 !== o ? o : 0) + (null !== (n = s.storage.store[l]) && void 0 !== n ? n : 0);
}
}
}
return a;
}, n.prototype.attemptPixelPurchase = function() {
var e = this, t = Game.market.getAllOrders({
type: ORDER_SELL,
resourceType: PIXEL
});
if (0 !== t.length) {
var r = t.filter(function(t) {
return t.price <= e.config.maxPixelPrice && t.amount > 0;
}).sort(function(e, t) {
return e.price - t.price;
});
if (0 !== r.length) {
var o = r[0], n = o.price <= this.config.targetPixelPrice;
if (n || Game.time % 1e3 == 0) {
var a = Object.values(Game.rooms).find(function(e) {
var t;
return e.terminal && (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && !e.terminal.cooldown;
});
if (null == a ? void 0 : a.terminal) {
var i = Game.market.credits - this.config.creditReserve, s = Math.floor(i / o.price), c = Math.min(this.config.maxPixelsPerTransaction, o.amount, s);
if (c <= 0) Hr.debug("Cannot afford any pixels after reserve", {
subsystem: "PixelBuying"
}); else {
var l = o.roomName ? Game.market.calcTransactionCost(c, a.name, o.roomName) : 0;
if (a.terminal.store[RESOURCE_ENERGY] < l) Hr.debug("Not enough energy for pixel transaction (need ".concat(l, ")"), {
subsystem: "PixelBuying"
}); else {
var u = Game.market.deal(o.id, c, a.name);
if (u === OK) {
var f = c * o.price;
this.recordPurchase({
tick: Game.time,
amount: c,
pricePerUnit: o.price,
totalCost: f,
orderId: o.id,
fromRoom: a.name
}), Hr.info("Purchased ".concat(c, " pixels at ").concat(o.price.toFixed(2), " credits each ") + "(total: ".concat(f.toFixed(0), " credits)").concat(n ? " (GOOD PRICE!)" : ""), {
subsystem: "PixelBuying"
});
} else Hr.warn("Failed to purchase pixels: error code ".concat(u), {
subsystem: "PixelBuying"
});
}
}
} else Hr.debug("No terminal available for pixel purchase", {
subsystem: "PixelBuying"
});
} else Hr.debug("Pixel price (".concat(o.price, ") above target (").concat(this.config.targetPixelPrice, "), waiting"), {
subsystem: "PixelBuying"
});
} else Hr.debug("No pixel orders below max price (".concat(this.config.maxPixelPrice, ")"), {
subsystem: "PixelBuying"
});
} else Hr.debug("No pixel sell orders available", {
subsystem: "PixelBuying"
});
}, n.prototype.recordPurchase = function(e) {
var t = this.getPixelBuyingMemory();
if (t) for (t.lastPurchaseTick = e.tick, t.totalPixelsPurchased += e.amount, t.totalCreditsSpent += e.totalCost, 
t.purchaseHistory.push(e); t.purchaseHistory.length > 50; ) t.purchaseHistory.shift();
}, n.prototype.updateMemory = function() {
var e = this.getPixelBuyingMemory();
e && (e.lastScan = Game.time);
}, n.prototype.getStats = function() {
var e = this.getPixelBuyingMemory();
if (e) return {
totalPurchased: e.totalPixelsPurchased,
totalSpent: e.totalCreditsSpent,
averagePrice: e.totalPixelsPurchased > 0 ? e.totalCreditsSpent / e.totalPixelsPurchased : 0,
lastPurchaseTick: e.lastPurchaseTick,
recentPurchases: e.purchaseHistory.slice(-10)
};
}, n.prototype.canBuyPixels = function() {
var e = [];
if (this.config.enabled || e.push("Pixel buying is disabled"), !this.isPurchaseCooldownComplete()) {
var t = this.getPixelBuyingMemory(), r = t ? this.config.purchaseCooldown - (Game.time - t.lastPurchaseTick) : 0;
e.push("On cooldown (".concat(r, " ticks remaining)"));
}
return this.hasSurplusResources() || e.push("No resource surplus"), this.hasEnoughCredits() || e.push("Insufficient credits (need ".concat(this.config.minCreditsForPixels, " above ").concat(this.config.creditReserve, " reserve)")), 
{
canBuy: 0 === e.length,
reasons: e
};
}, n.prototype.updateConfig = function(t) {
this.config = e(e({}, this.config), t);
}, n.prototype.getConfig = function() {
return e({}, this.config);
}, n.prototype.enable = function() {
this.config.enabled = !0, Hr.info("Pixel buying enabled", {
subsystem: "PixelBuying"
});
}, n.prototype.disable = function() {
this.config.enabled = !1, Hr.info("Pixel buying disabled", {
subsystem: "PixelBuying"
});
}, t([ Di("empire:pixelBuying", "Pixel Buying Manager", {
priority: Ao.IDLE,
interval: 200,
minBucket: 0,
cpuBudget: .01
}) ], n.prototype, "run", null), t([ Bi() ], n);
}(), jl = new Bl, Hl = {
enabled: !0,
fullBucketTicksRequired: 25,
bucketMax: 1e4,
cpuCostPerPixel: 1e4,
minBucketAfterGeneration: 0
}, Wl = function() {
function r(t) {
void 0 === t && (t = {}), this.config = e(e({}, Hl), t);
}
return r.prototype.run = function() {
if (this.config.enabled) {
this.ensurePixelGenerationMemory();
var e = this.getPixelGenerationMemory();
e && (Game.cpu.bucket >= this.config.bucketMax ? (0 === e.consecutiveFullTicks && (e.bucketFullSince = Game.time), 
e.consecutiveFullTicks++) : (e.consecutiveFullTicks = 0, e.bucketFullSince = 0), 
this.shouldGeneratePixel(e) && this.generatePixel(e));
}
}, r.prototype.ensurePixelGenerationMemory = function() {
var e = global;
e._pixelGenerationMemory || (e._pixelGenerationMemory = {
bucketFullSince: 0,
consecutiveFullTicks: 0,
totalPixelsGenerated: 0,
lastGenerationTick: 0
});
}, r.prototype.getPixelGenerationMemory = function() {
return global._pixelGenerationMemory;
}, r.prototype.shouldGeneratePixel = function(e) {
return !(e.consecutiveFullTicks < this.config.fullBucketTicksRequired || Game.cpu.bucket < this.config.bucketMax || Game.cpu.bucket < this.config.cpuCostPerPixel);
}, r.prototype.generatePixel = function(e) {
var t = Game.cpu.generatePixel();
if (t === OK) {
e.totalPixelsGenerated++, e.lastGenerationTick = Game.time;
var r = e.bucketFullSince > 0 ? Game.time - e.bucketFullSince : e.consecutiveFullTicks;
e.consecutiveFullTicks = 0, e.bucketFullSince = 0, Hr.info("Generated pixel from CPU bucket (total generated: ".concat(e.totalPixelsGenerated, ")"), {
subsystem: "PixelGeneration",
meta: {
bucket: Game.cpu.bucket,
ticksWaited: r
}
});
} else Hr.warn("Failed to generate pixel: error code ".concat(t), {
subsystem: "PixelGeneration",
meta: {
bucket: Game.cpu.bucket,
result: t
}
});
}, r.prototype.getStats = function() {
var e, t, r, o, n = this.getPixelGenerationMemory(), a = !!n && this.shouldGeneratePixel(n), i = n ? Math.max(0, this.config.fullBucketTicksRequired - n.consecutiveFullTicks) : this.config.fullBucketTicksRequired;
return {
enabled: this.config.enabled,
totalGenerated: null !== (e = null == n ? void 0 : n.totalPixelsGenerated) && void 0 !== e ? e : 0,
lastGenerationTick: null !== (t = null == n ? void 0 : n.lastGenerationTick) && void 0 !== t ? t : 0,
bucketFullSince: null !== (r = null == n ? void 0 : n.bucketFullSince) && void 0 !== r ? r : 0,
consecutiveFullTicks: null !== (o = null == n ? void 0 : n.consecutiveFullTicks) && void 0 !== o ? o : 0,
canGenerate: a,
ticksUntilGeneration: i
};
}, r.prototype.enable = function() {
this.config.enabled = !0, Hr.info("Pixel generation enabled", {
subsystem: "PixelGeneration"
});
}, r.prototype.disable = function() {
this.config.enabled = !1, Hr.info("Pixel generation disabled", {
subsystem: "PixelGeneration"
});
}, r.prototype.updateConfig = function(t) {
this.config = e(e({}, this.config), t);
}, r.prototype.getConfig = function() {
return e({}, this.config);
}, t([ Di("empire:pixelGeneration", "Pixel Generation Manager", {
priority: Ao.IDLE,
interval: 1,
minBucket: 0,
cpuBudget: .01
}) ], r.prototype, "run", null), t([ Bi() ], r);
}(), Yl = new Wl, Kl = {
minPower: 1e3,
maxDistance: 5,
minTicksRemaining: 3e3,
healerRatio: .5,
minBucket: 0,
maxConcurrentOps: 2
}, Vl = function() {
function n(t) {
void 0 === t && (t = {}), this.operations = new Map, this.lastScan = 0, this.config = e(e({}, Kl), t);
}
return n.prototype.run = function() {
Game.time - this.lastScan >= 50 && (this.scanForPowerBanks(), this.lastScan = Game.time), 
this.updateOperations(), this.evaluateOpportunities(), Game.time % 100 == 0 && this.operations.size > 0 && this.logStatus();
}, n.prototype.scanForPowerBanks = function() {
var e, t, o = fi.getEmpire(), n = function(n) {
var i, s, c = Game.rooms[n], l = n.match(/^[WE](\d+)[NS](\d+)$/);
if (!l) return "continue";
var u = parseInt(l[1], 10), f = parseInt(l[2], 10);
if (u % 10 != 0 && f % 10 != 0) return "continue";
var m = c.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_BANK;
}
}), p = function(r) {
var i = o.powerBanks.find(function(e) {
return e.roomName === n && e.pos.x === r.pos.x && e.pos.y === r.pos.y;
});
if (i) i.power = r.power, i.decayTick = Game.time + (null !== (t = r.ticksToDecay) && void 0 !== t ? t : 5e3); else {
var s = {
roomName: n,
pos: {
x: r.pos.x,
y: r.pos.y
},
power: r.power,
decayTick: Game.time + (null !== (e = r.ticksToDecay) && void 0 !== e ? e : 5e3),
active: !1
};
o.powerBanks.push(s), r.power >= a.config.minPower && Hr.info("Power bank discovered in ".concat(n, ": ").concat(r.power, " power"), {
subsystem: "PowerBank"
});
}
};
try {
for (var d = (i = void 0, r(m)), y = d.next(); !y.done; y = d.next()) p(y.value);
} catch (e) {
i = {
error: e
};
} finally {
try {
y && !y.done && (s = d.return) && s.call(d);
} finally {
if (i) throw i.error;
}
}
}, a = this;
for (var i in Game.rooms) n(i);
o.powerBanks = o.powerBanks.filter(function(e) {
return e.decayTick > Game.time;
});
}, n.prototype.updateOperations = function() {
var e, t;
try {
for (var n = r(this.operations), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2), s = i[0], c = i[1];
switch (c.state) {
case "scouting":
this.updateScoutingOp(c);
break;

case "attacking":
this.updateAttackingOp(c);
break;

case "collecting":
this.updateCollectingOp(c);
break;

case "complete":
case "failed":
Game.time - c.startedAt > 1e4 && this.operations.delete(s);
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, n.prototype.updateScoutingOp = function(e) {
var t, r = Game.rooms[e.roomName];
if (r) {
var o = r.find(FIND_STRUCTURES, {
filter: function(t) {
return t.structureType === STRUCTURE_POWER_BANK && t.pos.x === e.pos.x && t.pos.y === e.pos.y;
}
})[0];
if (!o) return e.state = "failed", void Hr.warn("Power bank in ".concat(e.roomName, " disappeared"), {
subsystem: "PowerBank"
});
e.power = o.power, e.decayTick = Game.time + (null !== (t = o.ticksToDecay) && void 0 !== t ? t : 0), 
e.assignedCreeps.attackers.length > 0 && (e.state = "attacking", Hr.info("Starting attack on power bank in ".concat(e.roomName), {
subsystem: "PowerBank"
}));
}
}, n.prototype.updateAttackingOp = function(e) {
var t, r = Game.rooms[e.roomName];
if (e.assignedCreeps.attackers = e.assignedCreeps.attackers.filter(function(e) {
return Game.creeps[e];
}), e.assignedCreeps.healers = e.assignedCreeps.healers.filter(function(e) {
return Game.creeps[e];
}), r) {
var o = r.find(FIND_STRUCTURES, {
filter: function(t) {
return t.structureType === STRUCTURE_POWER_BANK && t.pos.x === e.pos.x && t.pos.y === e.pos.y;
}
})[0];
if (!o) return e.state = "collecting", void Hr.info("Power bank destroyed in ".concat(e.roomName, ", collecting power"), {
subsystem: "PowerBank"
});
var n = null !== (t = e.lastHits) && void 0 !== t ? t : 2e6;
e.lastHits = o.hits, n > o.hits && (e.damageDealt += n - o.hits);
var a = e.decayTick - Game.time, i = e.damageDealt / Math.max(1, Game.time - e.startedAt), s = o.hits / Math.max(1, i);
s > .9 * a && Hr.warn("Power bank in ".concat(e.roomName, " may decay before completion (").concat(Math.round(s), " > ").concat(a, ")"), {
subsystem: "PowerBank"
}), e.estimatedCompletion = Game.time + Math.round(s);
} else 0 === e.assignedCreeps.attackers.length && 0 === e.assignedCreeps.healers.length && (e.state = "failed");
}, n.prototype.updateCollectingOp = function(e) {
var t = Game.rooms[e.roomName];
if (e.assignedCreeps.carriers = e.assignedCreeps.carriers.filter(function(e) {
return Game.creeps[e];
}), t) {
var r = t.find(FIND_DROPPED_RESOURCES, {
filter: function(e) {
return e.resourceType === RESOURCE_POWER;
}
}), o = t.find(FIND_RUINS, {
filter: function(e) {
return e.store.getUsedCapacity(RESOURCE_POWER) > 0;
}
});
0 === r.length && 0 === o.length && (e.state = "complete", Hr.info("Power bank operation complete in ".concat(e.roomName, ": ").concat(e.powerCollected, " power collected"), {
subsystem: "PowerBank"
}));
} else 0 === e.assignedCreeps.carriers.length && (e.state = "failed");
}, n.prototype.evaluateOpportunities = function() {
var e, t, r = this;
if (!(Array.from(this.operations.values()).filter(function(e) {
return "complete" !== e.state && "failed" !== e.state;
}).length >= this.config.maxConcurrentOps)) {
var o = fi.getEmpire(), n = Object.values(Game.rooms).filter(function(e) {
var t;
return (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.controller.level >= 7;
});
if (0 !== n.length) {
var a = o.powerBanks.filter(function(e) {
return !(e.active || r.operations.has(e.roomName) || e.power < r.config.minPower || e.decayTick - Game.time < r.config.minTicksRemaining || r.getMinDistanceToOwned(e.roomName, n) > r.config.maxDistance);
}).map(function(e) {
return {
entry: e,
score: r.scorePowerBank(e, n)
};
}).sort(function(e, t) {
return t.score - e.score;
});
if (a.length > 0 && (null !== (t = null === (e = a[0]) || void 0 === e ? void 0 : e.score) && void 0 !== t ? t : 0) > 0) {
var i = a[0];
this.startOperation(i.entry, n);
}
}
}
}, n.prototype.scorePowerBank = function(e, t) {
var r = 0;
r += .01 * e.power;
var o = e.decayTick - Game.time;
return o > 4e3 && (r += 50), o > 5e3 && (r += 30), r -= 20 * this.getMinDistanceToOwned(e.roomName, t), 
e.power >= 3e3 && (r += 50), e.power >= 5e3 && (r += 50), r;
}, n.prototype.getMinDistanceToOwned = function(e, t) {
var o, n, a = 1 / 0;
try {
for (var i = r(t), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.map.getRoomLinearDistance(e, c.name);
l < a && (a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return a;
}, n.prototype.startOperation = function(e, t) {
var o, n, a = null, i = 1 / 0;
try {
for (var s = r(t), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.map.getRoomLinearDistance(e.roomName, l.name);
u < i && (i = u, a = l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
if (a) {
var f = {
roomName: e.roomName,
pos: e.pos,
power: e.power,
decayTick: e.decayTick,
homeRoom: a.name,
state: "scouting",
assignedCreeps: {
attackers: [],
healers: [],
carriers: []
},
damageDealt: 0,
powerCollected: 0,
startedAt: Game.time,
estimatedCompletion: 0
};
this.operations.set(e.roomName, f), e.active = !0, Hr.info("Started power bank operation in ".concat(e.roomName, " (").concat(e.power, " power, home: ").concat(a.name, ")"), {
subsystem: "PowerBank"
});
}
}, n.prototype.assignCreep = function(e, t, r) {
var o = this.operations.get(t);
if (!o) return !1;
switch (r) {
case "attacker":
o.assignedCreeps.attackers.includes(e) || o.assignedCreeps.attackers.push(e);
break;

case "healer":
o.assignedCreeps.healers.includes(e) || o.assignedCreeps.healers.push(e);
break;

case "carrier":
o.assignedCreeps.carriers.includes(e) || o.assignedCreeps.carriers.push(e);
}
return !0;
}, n.prototype.recordPowerCollected = function(e, t) {
var r = this.operations.get(e);
r && (r.powerCollected += t);
}, n.prototype.getActiveOperations = function() {
return Array.from(this.operations.values()).filter(function(e) {
return "complete" !== e.state && "failed" !== e.state;
});
}, n.prototype.getOperation = function(e) {
return this.operations.get(e);
}, n.prototype.getRequiredCreeps = function(e) {
var t = e.decayTick - Game.time, r = (2e6 - e.damageDealt) / (.8 * t), o = Math.ceil(r / 600), n = Math.ceil(o * this.config.healerRatio), a = Math.ceil(e.power / 2e3);
return {
attackers: Math.max(1, o),
healers: Math.max(1, n),
carriers: Math.max(1, a)
};
}, n.prototype.requestSpawns = function(e) {
var t, n, a = 0, i = 0, s = 0;
try {
for (var c = r(this.operations), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = (u[0], u[1]);
if (f.homeRoom === e && "complete" !== f.state && "failed" !== f.state) {
var m = this.getRequiredCreeps(f), p = {
attackers: f.assignedCreeps.attackers.filter(function(e) {
return Game.creeps[e];
}).length,
healers: f.assignedCreeps.healers.filter(function(e) {
return Game.creeps[e];
}).length,
carriers: f.assignedCreeps.carriers.filter(function(e) {
return Game.creeps[e];
}).length
};
"attacking" !== f.state && "scouting" !== f.state || (a += Math.max(0, m.attackers - p.attackers), 
i += Math.max(0, m.healers - p.healers)), "collecting" !== f.state && "attacking" !== f.state || (s += Math.max(0, m.carriers - p.carriers));
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (t) throw t.error;
}
}
return {
powerHarvesters: a,
healers: i,
powerCarriers: s
};
}, n.prototype.getProfitability = function(e, t) {
var r = Game.map.getRoomLinearDistance(e.roomName, t);
e.decayTick, Game.time;
var o = 50 * r + Math.ceil(2e6 / 1200), n = 7200 + .1 * o, a = 10 * e.power - n, i = o > 0 ? a / o : 0;
return {
power: e.power,
energyCost: n,
netProfit: a,
profitPerTick: i
};
}, n.prototype.logStatus = function() {
var e, t, o = Array.from(this.operations.values()).filter(function(e) {
return "complete" !== e.state && "failed" !== e.state;
});
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
Hr.info("Power bank op ".concat(i.roomName, ": ").concat(i.state, ", ") + "".concat(i.assignedCreeps.attackers.length, "A/").concat(i.assignedCreeps.healers.length, "H/").concat(i.assignedCreeps.carriers.length, "C, ") + "".concat(Math.round(i.damageDealt / 1e3), "k damage, ").concat(i.powerCollected, " collected"), {
subsystem: "PowerBank"
});
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, t([ Di("empire:powerBank", "Power Bank Harvesting", {
priority: Ao.LOW,
interval: 50,
minBucket: 0,
cpuBudget: .02
}) ], n.prototype, "run", null), t([ Bi() ], n);
}(), zl = new Vl, ql = {
minGPL: 1,
minPowerReserve: 1e4,
energyPerPower: 50,
minEnergyReserve: 1e5,
gplMilestones: [ 1, 2, 5, 10, 15, 20 ]
}, Xl = [ PWR_GENERATE_OPS, PWR_OPERATE_SPAWN, PWR_OPERATE_EXTENSION, PWR_OPERATE_TOWER, PWR_OPERATE_LAB, PWR_OPERATE_STORAGE, PWR_REGEN_SOURCE, PWR_OPERATE_FACTORY ], Ql = [ PWR_GENERATE_OPS, PWR_OPERATE_SPAWN, PWR_SHIELD, PWR_DISRUPT_SPAWN, PWR_DISRUPT_TOWER, PWR_FORTIFY, PWR_OPERATE_TOWER, PWR_DISRUPT_TERMINAL ], Zl = function() {
function n(t) {
void 0 === t && (t = {}), this.assignments = new Map, this.gplState = null, this.lastGPLUpdate = 0, 
this.config = e(e({}, ql), t);
}
return n.prototype.run = function() {
this.updateGPLState(), this.managePowerProcessing(), this.manageAssignments(), this.checkPowerUpgrades(), 
this.checkRespawnNeeds(), Game.time % 100 == 0 && this.logStatus();
}, n.prototype.updateGPLState = function() {
var e, t, r, o, n;
if (Game.gpl) {
var a = Game.gpl.level, i = Game.gpl.progress, s = Game.gpl.progressTotal, c = 0;
this.gplState && this.gplState.currentProgress < i && (c = i - this.gplState.currentProgress);
var l = s - i, u = null !== (t = null === (e = this.gplState) || void 0 === e ? void 0 : e.powerProcessedThisTick) && void 0 !== t ? t : 1, f = u > 0 ? Math.ceil(l / u) : 1 / 0, m = null !== (r = this.config.gplMilestones.find(function(e) {
return e > a;
})) && void 0 !== r ? r : a + 1;
this.gplState = {
currentLevel: a,
currentProgress: i,
progressNeeded: s,
powerProcessedThisTick: c,
totalPowerProcessed: (null !== (n = null === (o = this.gplState) || void 0 === o ? void 0 : o.totalPowerProcessed) && void 0 !== n ? n : 0) + c,
ticksToNextLevel: f,
targetMilestone: m,
lastUpdate: Game.time
}, this.lastGPLUpdate !== a && a > 0 && (Hr.info("GPL milestone reached: Level ".concat(a), {
subsystem: "PowerCreep"
}), this.lastGPLUpdate = a);
} else this.gplState = null;
}, n.prototype.managePowerProcessing = function() {
var e, t, o = this.evaluatePowerProcessing();
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
if (i.shouldProcess) {
var s = Game.rooms[i.roomName];
if (s) {
var c = s.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}
})[0];
if (c) {
var l = c.store.getUsedCapacity(RESOURCE_POWER) > 0, u = c.store.getUsedCapacity(RESOURCE_ENERGY) >= 50;
l && u && c.processPower() === OK && Hr.debug("Processing power in ".concat(i.roomName, ": ").concat(i.reason), {
subsystem: "PowerCreep"
});
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, n.prototype.evaluatePowerProcessing = function() {
var e, t, o, n, a, i = [], s = Object.values(Game.rooms).filter(function(e) {
var t;
return (null === (t = e.controller) || void 0 === t ? void 0 : t.my) && e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}
}).length > 0;
});
try {
for (var c = r(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = u.storage, m = u.terminal;
if (f || m) {
var p = (null !== (o = null == f ? void 0 : f.store.getUsedCapacity(RESOURCE_POWER)) && void 0 !== o ? o : 0) + (null !== (n = null == m ? void 0 : m.store.getUsedCapacity(RESOURCE_POWER)) && void 0 !== n ? n : 0), d = null !== (a = null == f ? void 0 : f.store.getUsedCapacity(RESOURCE_ENERGY)) && void 0 !== a ? a : 0, y = !1, g = "", h = 0;
p < 100 ? (y = !1, g = "Insufficient power (<100)") : d < this.config.minEnergyReserve ? (y = !1, 
g = "Insufficient energy (<".concat(this.config.minEnergyReserve, ")")) : this.gplState && this.gplState.currentLevel < this.gplState.targetMilestone ? (y = !0, 
g = "GPL progression: ".concat(this.gplState.currentLevel, "  ").concat(this.gplState.targetMilestone), 
h = 100 - Math.abs(this.gplState.currentLevel - this.gplState.targetMilestone)) : p > this.config.minPowerReserve ? (y = !0, 
g = "Excess power (".concat(p, " > ").concat(this.config.minPowerReserve, ")"), 
h = 50) : (y = !1, g = "Power reserved for power banks"), i.push({
roomName: u.name,
shouldProcess: y,
reason: g,
powerAvailable: p,
energyAvailable: d,
priority: h
});
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return i.sort(function(e, t) {
return t.priority - e.priority;
});
}, n.prototype.manageAssignments = function() {
for (var e in Game.powerCreeps) {
var t = Game.powerCreeps[e];
if (t) {
var r = this.assignments.get(e);
r ? (r.level = t.level, r.spawned = void 0 !== t.ticksToLive, r.spawned && !r.lastRespawnTick && (r.lastRespawnTick = Game.time)) : (r = this.createAssignment(t), 
this.assignments.set(e, r));
}
}
this.considerNewPowerCreeps();
}, n.prototype.createAssignment = function(e) {
var t, r;
e.powers[PWR_OPERATE_SPAWN];
var o = void 0 !== e.powers[PWR_DISRUPT_SPAWN] ? "powerWarrior" : "powerQueen", n = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), a = null !== (r = null === (t = n[0]) || void 0 === t ? void 0 : t.name) && void 0 !== r ? r : "";
if ("powerQueen" === o) {
var i = n.filter(function(e) {
return e.controller && e.controller.level >= 7;
}).sort(function(e, t) {
var r, o, n, a, i = 100 * (null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0) + e.find(FIND_MY_STRUCTURES).length;
return 100 * (null !== (a = null === (n = t.controller) || void 0 === n ? void 0 : n.level) && void 0 !== a ? a : 0) + t.find(FIND_MY_STRUCTURES).length - i;
})[0];
i && (a = i.name);
} else {
var s = n.map(function(e) {
return {
room: e,
swarm: fi.getSwarmState(e.name)
};
}).filter(function(e) {
return null !== e.swarm;
}).sort(function(e, t) {
var r = 100 * e.swarm.danger + e.swarm.metrics.hostileCount;
return 100 * t.swarm.danger + t.swarm.metrics.hostileCount - r;
})[0];
s && (a = s.room.name);
}
var c = this.generatePowerPath(o), l = {
name: e.name,
className: e.className,
role: o,
assignedRoom: a,
level: e.level,
spawned: void 0 !== e.ticksToLive,
lastRespawnTick: void 0 !== e.ticksToLive ? Game.time : void 0,
priority: "powerQueen" === o ? 100 : 80,
powerPath: c
}, u = e.memory;
return u.homeRoom = a, u.role = o, Hr.info("Power creep ".concat(e.name, " assigned as ").concat(o, " to ").concat(a), {
subsystem: "PowerCreep"
}), l;
}, n.prototype.generatePowerPath = function(e) {
var t = this, r = ("powerQueen" === e ? Xl : Ql).filter(function(e) {
var r, o, n = POWER_INFO[e];
return n && void 0 !== n.level && n.level[0] <= (null !== (o = null === (r = t.gplState) || void 0 === r ? void 0 : r.currentLevel) && void 0 !== o ? o : 0);
});
return r;
}, n.prototype.checkPowerUpgrades = function() {
var e, t;
if (this.gplState) try {
for (var n = r(this.assignments), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2), s = i[0], c = i[1], l = Game.powerCreeps[s];
if (l && !(l.level >= this.gplState.currentLevel)) {
var u = this.selectNextPower(l, c);
if (u) {
var f = l.upgrade(u);
f === OK ? (Hr.info("Upgraded ".concat(l.name, " to level ").concat(l.level + 1, " with ").concat(u), {
subsystem: "PowerCreep"
}), c.level = l.level) : f !== ERR_NOT_ENOUGH_RESOURCES && Hr.warn("Failed to upgrade ".concat(l.name, ": ").concat(f), {
subsystem: "PowerCreep"
});
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, n.prototype.selectNextPower = function(e, t) {
var o, n, a, i, s, c = null !== (a = t.powerPath) && void 0 !== a ? a : this.generatePowerPath(t.role);
try {
for (var l = r(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
if (!e.powers[f]) {
var m = POWER_INFO[f];
if (m && void 0 !== m.level && m.level[0] <= (null !== (s = null === (i = this.gplState) || void 0 === i ? void 0 : i.currentLevel) && void 0 !== s ? s : 0)) return f;
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (o) throw o.error;
}
}
return null;
}, n.prototype.considerNewPowerCreeps = function() {
if (this.gplState && !(this.gplState.currentLevel < this.config.minGPL)) {
var e = Object.keys(Game.powerCreeps).length, t = this.gplState.currentLevel;
if (!(e >= t)) {
var r = Array.from(this.assignments.values()).filter(function(e) {
return "powerQueen" === e.role;
}).length, o = Array.from(this.assignments.values()).filter(function(e) {
return "powerWarrior" === e.role;
}).length, n = r < Math.ceil(.7 * t), a = o < Math.floor(.3 * t);
if (n || a) {
var i = "operator_".concat(Game.time), s = POWER_CLASS.OPERATOR, c = PowerCreep.create(i, s);
c === OK ? Hr.info("Created new power creep: ".concat(i, " (").concat(s, ")"), {
subsystem: "PowerCreep"
}) : Hr.warn("Failed to create power creep: ".concat(c), {
subsystem: "PowerCreep"
});
}
}
}
}, n.prototype.checkRespawnNeeds = function() {
var e, t;
try {
for (var n = r(this.assignments), a = n.next(); !a.done; a = n.next()) {
var i = o(a.value, 2), s = i[0], c = i[1], l = Game.powerCreeps[s];
if (l) if (void 0 === l.ticksToLive) {
if (!(u = Game.rooms[c.assignedRoom])) continue;
(f = u.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}
})[0]) && l.spawn(f) === OK && (Hr.info("Power creep ".concat(s, " spawned at ").concat(u.name), {
subsystem: "PowerCreep"
}), c.spawned = !0, c.lastRespawnTick = Game.time);
} else if (l.ticksToLive < 500) {
var u, f;
if (!(u = l.room)) continue;
(f = u.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}
})[0]) && l.pos.getRangeTo(f) <= 1 && l.renew(f) === OK && Hr.debug("Power creep ".concat(s, " renewed"), {
subsystem: "PowerCreep"
});
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, n.prototype.getGPLState = function() {
return this.gplState;
}, n.prototype.getAssignments = function() {
return Array.from(this.assignments.values());
}, n.prototype.getAssignment = function(e) {
return this.assignments.get(e);
}, n.prototype.reassignPowerCreep = function(e, t) {
var r = this.assignments.get(e);
if (!r) return !1;
r.assignedRoom = t;
var o = Game.powerCreeps[e];
return o && (o.memory.homeRoom = t), Hr.info("Power creep ".concat(e, " reassigned to ").concat(t), {
subsystem: "PowerCreep"
}), !0;
}, n.prototype.logStatus = function() {
if (this.gplState) {
var e = Array.from(this.assignments.values()).filter(function(e) {
return e.spawned;
}), t = e.filter(function(e) {
return "powerQueen" === e.role;
}).length, r = e.filter(function(e) {
return "powerWarrior" === e.role;
}).length;
Hr.info("Power System: GPL ".concat(this.gplState.currentLevel, " ") + "(".concat(this.gplState.currentProgress, "/").concat(this.gplState.progressNeeded, "), ") + "Operators: ".concat(e.length, "/").concat(this.gplState.currentLevel, " ") + "(".concat(t, " eco, ").concat(r, " combat)"), {
subsystem: "PowerCreep"
});
}
}, t([ Di("empire:powerCreep", "Power Creep Management", {
priority: Ao.LOW,
interval: 20,
minBucket: 0,
cpuBudget: .03
}) ], n.prototype, "run", null), t([ Bi() ], n);
}(), Jl = new Zl;

function $l(e, t) {
var r, o;
if ((null === (r = e.controller) || void 0 === r ? void 0 : r.owner) && !e.controller.my) return {
lost: !0,
reason: "enemyOwned"
};
var n, a = (n = Object.values(Game.spawns)).length > 0 ? n[0].owner.username : "";
return (null === (o = e.controller) || void 0 === o ? void 0 : o.reservation) && e.controller.reservation.username !== a ? {
lost: !0,
reason: "enemyReserved"
} : e.find(FIND_HOSTILE_CREEPS).filter(function(e) {
return e.body.some(function(e) {
return e.type === ATTACK || e.type === RANGED_ATTACK || e.type === WORK;
});
}).length >= 2 ? {
lost: !0,
reason: "hostile"
} : {
lost: !1
};
}

function eu(e, t, r) {
var o, n = fi.getSwarmState(e);
if (n) {
var a = null !== (o = n.remoteAssignments) && void 0 !== o ? o : [], i = a.indexOf(t);
if (-1 !== i) {
a.splice(i, 1), n.remoteAssignments = a;
var s = fi.getEmpire().knownRooms[t];
s && (s.threatLevel = 3, s.lastSeen = Game.time), Hr.warn("Removed remote room ".concat(t, " from ").concat(e, " due to: ").concat(r), {
subsystem: "RemoteRoomManager"
});
}
}
}

function tu(e) {
var t, o, n, a = fi.getSwarmState(e);
if (a) {
var i = null !== (n = a.remoteAssignments) && void 0 !== n ? n : [];
if (0 !== i.length) try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.rooms[l];
if (u) {
var f = $l(u);
f.lost && f.reason && eu(e, l, f.reason);
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
}
}

var ru = {
updateInterval: 50,
minBucket: 0,
maxSitesPerRemotePerTick: 2
}, ou = function() {
function n(t) {
void 0 === t && (t = {}), this.config = e(e({}, ru), t);
}
return n.prototype.run = function() {
var e, t, o, n, a, i = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = fi.getSwarmState(l.name);
if (u) {
tu(l.name);
var f = null !== (a = u.remoteAssignments) && void 0 !== a ? a : [];
if (0 !== f.length) {
try {
for (var m = (o = void 0, r(f)), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
this.planRemoteInfrastructure(l, d);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
this.placeRemoteRoads(l, f);
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
}, n.prototype.planRemoteInfrastructure = function(e, t) {
var o, n, a = Game.rooms[t];
if (a) {
var i = a.controller, s = this.getMyUsername();
if (i) {
if (i.owner && i.owner.username !== s) return;
if (i.reservation && i.reservation.username !== s) return;
}
var c = a.find(FIND_SOURCES), l = 0;
try {
for (var u = r(c), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (l >= this.config.maxSitesPerRemotePerTick) break;
this.placeSourceContainer(a, m) && l++;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
}
}, n.prototype.placeSourceContainer = function(e, t) {
if (t.pos.findInRange(FIND_STRUCTURES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
}).length > 0) return !1;
if (t.pos.findInRange(FIND_CONSTRUCTION_SITES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
}).length > 0) return !1;
var r = this.findBestContainerPosition(t);
if (!r) return Hr.warn("Could not find valid position for container at source ".concat(t.id, " in ").concat(e.name), {
subsystem: "RemoteInfra"
}), !1;
if (e.find(FIND_CONSTRUCTION_SITES).length >= 5) return !1;
var o = e.createConstructionSite(r.x, r.y, STRUCTURE_CONTAINER);
return o === OK ? (Hr.info("Placed container construction site at source ".concat(t.id, " in ").concat(e.name), {
subsystem: "RemoteInfra"
}), !0) : (Hr.debug("Failed to place container at source ".concat(t.id, " in ").concat(e.name, ": ").concat(o), {
subsystem: "RemoteInfra"
}), !1);
}, n.prototype.findBestContainerPosition = function(e) {
for (var t = e.room, r = t.getTerrain(), o = [], n = -1; n <= 1; n++) for (var a = -1; a <= 1; a++) if (0 !== n || 0 !== a) {
var i = e.pos.x + n, s = e.pos.y + a;
if (!(i < 1 || i > 48 || s < 1 || s > 48 || r.get(i, s) === TERRAIN_MASK_WALL || new RoomPosition(i, s, t.name).lookFor(LOOK_STRUCTURES).length > 0)) {
for (var c = 0, l = -1; l <= 1; l++) for (var u = -1; u <= 1; u++) if (0 !== l || 0 !== u) {
var f = i + l, m = s + u;
f >= 1 && f <= 48 && m >= 1 && m <= 48 && r.get(f, m) !== TERRAIN_MASK_WALL && c++;
}
o.push({
x: i,
y: s,
score: c
});
}
}
return 0 === o.length ? null : (o.sort(function(e, t) {
return t.score - e.score;
}), o[0]);
}, n.prototype.placeRemoteRoads = function(e, t) {
var o, n, a = Tc(e, t), i = a.get(e.name);
i && this.placeRoadsInRoom(e, i);
try {
for (var s = r(t), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = Game.rooms[l];
if (u) {
var f = a.get(l);
f && this.placeRoadsInRoom(u, f);
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
c && !c.done && (n = s.return) && n.call(s);
} finally {
if (o) throw o.error;
}
}
}, n.prototype.placeRoadsInRoom = function(e, t) {
var n, a, i = e.find(FIND_CONSTRUCTION_SITES), s = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
});
if (!(i.length >= 5)) {
var c = new Set(s.map(function(e) {
return "".concat(e.pos.x, ",").concat(e.pos.y);
})), l = new Set(i.filter(function(e) {
return e.structureType === STRUCTURE_ROAD;
}).map(function(e) {
return "".concat(e.pos.x, ",").concat(e.pos.y);
})), u = e.getTerrain(), f = 0;
try {
for (var m = r(t), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (f >= 3) break;
if (i.length + f >= 5) break;
if (!c.has(d) && !l.has(d)) {
var y = o(d.split(","), 2), g = y[0], h = y[1], v = parseInt(g, 10), R = parseInt(h, 10);
u.get(v, R) !== TERRAIN_MASK_WALL && e.createConstructionSite(v, R, STRUCTURE_ROAD) === OK && f++;
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (n) throw n.error;
}
}
f > 0 && Hr.debug("Placed ".concat(f, " remote road construction sites in ").concat(e.name), {
subsystem: "RemoteInfra"
});
}
}, n.prototype.getMyUsername = function() {
var e = Object.values(Game.spawns);
return e.length > 0 ? e[0].owner.username : "";
}, t([ Li("remote:infrastructure", "Remote Infrastructure Manager", {
priority: Ao.LOW,
interval: 50,
minBucket: 0,
cpuBudget: .05
}) ], n.prototype, "run", null), t([ Bi() ], n);
}(), nu = new ou, au = {
updateInterval: 50,
minBucket: 0,
maxCpuBudget: .01
}, iu = function() {
function o(t) {
void 0 === t && (t = {}), this.lastRun = 0, this.config = e(e({}, au), t);
}
return o.prototype.run = function() {
this.lastRun = Game.time;
var e = InterShardMemory.getLocal();
if (e) {
var t = ki(e);
if (t) {
this.updateEnemyIntelligence(t);
var r = Ai(t);
InterShardMemory.setLocal(r);
}
}
}, o.prototype.updateEnemyIntelligence = function(e) {
var t, o, n, a;
if (e) {
var i = fi.getEmpire(), s = new Map;
if (e.globalTargets.enemies) try {
for (var c = r(e.globalTargets.enemies), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
s.set(u.username, u);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
if (i.warTargets) try {
for (var f = r(i.warTargets), m = f.next(); !m.done; m = f.next()) {
var p = m.value;
(y = s.get(p)) ? (y.lastSeen = Game.time, y.threatLevel = Math.max(y.threatLevel, 1)) : s.set(p, {
username: p,
rooms: [],
threatLevel: 1,
lastSeen: Game.time,
isAlly: !1
});
}
} catch (e) {
n = {
error: e
};
} finally {
try {
m && !m.done && (a = f.return) && a.call(f);
} finally {
if (n) throw n.error;
}
}
if (i.knownRooms) for (var d in i.knownRooms) {
var y, g = i.knownRooms[d];
g && g.owner && !g.owner.includes("Source Keeper") && ((y = s.get(g.owner)) ? (y.rooms.includes(d) || y.rooms.push(d), 
y.lastSeen = Math.max(y.lastSeen, g.lastSeen), y.threatLevel = Math.max(y.threatLevel, g.threatLevel)) : s.set(g.owner, {
username: g.owner,
rooms: [ d ],
threatLevel: g.threatLevel,
lastSeen: g.lastSeen,
isAlly: !1
}));
}
if (e.globalTargets.enemies = Array.from(s.values()), Game.time % 500 == 0) {
var h = e.globalTargets.enemies.length, v = e.globalTargets.enemies.filter(function(e) {
return e.threatLevel >= 2;
}).length;
Hr.info("Cross-shard intel: ".concat(h, " enemies tracked, ").concat(v, " high threat"), {
subsystem: "CrossShardIntel"
});
}
}
}, o.prototype.getGlobalEnemies = function() {
var e = InterShardMemory.getLocal();
if (!e) return [];
var t = ki(e);
return t && t.globalTargets.enemies || [];
}, t([ Di("empire:crossShardIntel", "Cross-Shard Intel", {
priority: Ao.LOW,
interval: 50,
minBucket: 0,
cpuBudget: .01
}) ], o.prototype, "run", null), t([ Bi() ], o);
}(), su = new iu;

function cu(e) {
var t;
if (!e.controller) return null;
var r = function(e) {
if (!e) return null;
try {
var t = JSON.parse(e);
if ("quest" === t.type && t.id && t.origin && "string" == typeof t.info) return t;
} catch (e) {}
return null;
}(null === (t = e.controller.sign) || void 0 === t ? void 0 : t.text);
if (!r) return null;
var o = e.terminal;
return {
roomName: e.name,
lastSeen: Game.time,
hasTerminal: void 0 !== o && !o.my,
availableQuests: [ r.id ]
};
}

function lu() {
var e;
return (null === (e = Memory.tooangel) || void 0 === e ? void 0 : e.npcRooms) || {};
}

function uu(e) {
var t = Memory;
t.tooangel || (t.tooangel = {}), t.tooangel.npcRooms || (t.tooangel.npcRooms = {});
var r = t.tooangel.npcRooms[e.roomName];
if (r) {
var a = new Set(n(n([], o(r.availableQuests), !1), o(e.availableQuests), !1));
e.availableQuests = Array.from(a);
}
t.tooangel.npcRooms[e.roomName] = e;
}

function fu() {
var e = Memory;
return e.tooangel || (e.tooangel = {
enabled: !0,
reputation: {
value: 0,
lastUpdated: 0
},
npcRooms: {},
activeQuests: {},
completedQuests: [],
lastProcessedTick: 0
}), e.tooangel.reputation || (e.tooangel.reputation = {
value: 0,
lastUpdated: 0
}), e.tooangel.npcRooms || (e.tooangel.npcRooms = {}), e.tooangel.activeQuests || (e.tooangel.activeQuests = {}), 
e.tooangel.completedQuests || (e.tooangel.completedQuests = []), e.tooangel;
}

function mu() {
var e;
return (null === (e = fu().reputation) || void 0 === e ? void 0 : e.value) || 0;
}

function pu(e) {
try {
var t = JSON.parse(e);
if ("reputation" === t.type && "number" == typeof t.reputation) return t.reputation;
} catch (e) {}
return null;
}

function du(e) {
var t, r, o, n = fu(), a = (null === (t = n.reputation) || void 0 === t ? void 0 : t.lastRequestedAt) || 0;
if (Game.time - a < 1e3) return Hr.debug("Reputation request on cooldown (".concat(1e3 - (Game.time - a), " ticks remaining)"), {
subsystem: "TooAngel"
}), !1;
if (e) o = Game.rooms[e]; else for (var i in Game.rooms) {
var s = Game.rooms[i];
if ((null === (r = s.controller) || void 0 === r ? void 0 : r.my) && s.terminal && s.terminal.my) {
o = s;
break;
}
}
if (!o || !o.terminal || !o.terminal.my) return Hr.warn("No terminal available to request reputation", {
subsystem: "TooAngel"
}), !1;
var c = function(e) {
var t = lu(), r = null, o = 1 / 0;
for (var n in t) {
var a = Game.map.getRoomLinearDistance(e, n);
a < o && (o = a, r = t[n]);
}
return r;
}(o.name);
if (!c || !c.hasTerminal) return Hr.warn("No TooAngel NPC room with terminal found", {
subsystem: "TooAngel"
}), !1;
var l = o.terminal, u = l.store[RESOURCE_ENERGY];
if (u < 100) return Hr.warn("Insufficient energy for reputation request: ".concat(u, " < ").concat(100), {
subsystem: "TooAngel"
}), !1;
var f = l.send(RESOURCE_ENERGY, 100, c.roomName, JSON.stringify({
type: "reputation"
}));
return f === OK ? (Hr.info("Sent reputation request to ".concat(c.roomName, " from ").concat(o.name), {
subsystem: "TooAngel"
}), n.reputation.lastRequestedAt = Game.time, !0) : (Hr.warn("Failed to send reputation request: ".concat(f), {
subsystem: "TooAngel"
}), !1);
}

var yu = {
MAX_ACTIVE_QUESTS: 3,
MIN_APPLICATION_ENERGY: 100,
DEADLINE_BUFFER: 500,
SUPPORTED_TYPES: [ "buildcs" ]
};

function gu(e) {
try {
var t = JSON.parse(e);
if ("quest" === t.type && t.id && t.room && t.quest && "number" == typeof t.end) return !t.result && t.end <= Game.time ? (Hr.debug("Ignoring quest ".concat(t.id, " with past deadline: ").concat(t.end, " (current: ").concat(Game.time, ")"), {
subsystem: "TooAngel"
}), null) : t;
} catch (e) {}
return null;
}

function hu() {
return fu().activeQuests || {};
}

function vu() {
var e = hu();
return Object.values(e).filter(function(e) {
return "active" === e.status || "applied" === e.status;
}).length < yu.MAX_ACTIVE_QUESTS;
}

function Ru(e) {
return yu.SUPPORTED_TYPES.includes(e);
}

function Eu(e, t, r) {
var o, n;
if (!vu()) return Hr.debug("Cannot accept more quests (at max capacity)", {
subsystem: "TooAngel"
}), !1;
if (r) n = Game.rooms[r]; else {
var a = 1 / 0;
for (var i in Game.rooms) {
var s = Game.rooms[i];
if ((null === (o = s.controller) || void 0 === o ? void 0 : o.my) && s.terminal && s.terminal.my) {
var c = Game.map.getRoomLinearDistance(i, t);
c < a && (a = c, n = s);
}
}
}
if (!n || !n.terminal || !n.terminal.my) return Hr.warn("No terminal available to apply for quest", {
subsystem: "TooAngel"
}), !1;
var l = n.terminal, u = l.store[RESOURCE_ENERGY];
if (u < yu.MIN_APPLICATION_ENERGY) return Hr.warn("Insufficient energy for quest application: ".concat(u, " < ").concat(yu.MIN_APPLICATION_ENERGY), {
subsystem: "TooAngel"
}), !1;
var f = {
type: "quest",
id: e,
action: "apply"
}, m = l.send(RESOURCE_ENERGY, yu.MIN_APPLICATION_ENERGY, t, JSON.stringify(f));
return m === OK ? (Hr.info("Applied for quest ".concat(e, " from ").concat(n.name, " to ").concat(t), {
subsystem: "TooAngel"
}), fu().activeQuests[e] = {
id: e,
type: "buildcs",
status: "applied",
targetRoom: "",
originRoom: t,
deadline: 0,
appliedAt: Game.time
}, !0) : (Hr.warn("Failed to apply for quest: ".concat(m), {
subsystem: "TooAngel"
}), !1);
}

function Tu(e) {
var t = fu(), r = t.activeQuests[e.id];
r ? ("won" === e.result ? (Hr.info("Quest ".concat(e.id, " completed successfully!"), {
subsystem: "TooAngel"
}), r.status = "completed") : (Hr.warn("Quest ".concat(e.id, " failed"), {
subsystem: "TooAngel"
}), r.status = "failed"), r.completedAt = Game.time, t.completedQuests.includes(e.id) || t.completedQuests.push(e.id)) : Hr.warn("Received completion for unknown quest: ".concat(e.id), {
subsystem: "TooAngel"
});
}

function Su(e) {
var t, o, n, a, i, s, c, l = Game.rooms[e.targetRoom];
if (l) {
if (function(e) {
var t = Game.rooms[e];
return !!t && 0 === t.find(FIND_CONSTRUCTION_SITES).length;
}(e.targetRoom)) return Hr.info("Quest ".concat(e.id, " (buildcs) completed! All construction sites built in ").concat(e.targetRoom), {
subsystem: "TooAngel"
}), function(e) {
var t, r, o = function(e) {
return hu()[e] || null;
}(e);
if (!o) return Hr.warn("Cannot notify completion for unknown quest: ".concat(e), {
subsystem: "TooAngel"
}), !1;
for (var n in Game.rooms) {
var a = Game.rooms[n];
if ((null === (t = a.controller) || void 0 === t ? void 0 : t.my) && a.terminal && a.terminal.my) {
r = a;
break;
}
}
if (!r || !r.terminal) return !1;
var i = {
type: "quest",
id: e,
room: o.targetRoom,
quest: o.type,
end: o.deadline,
result: "won"
};
r.terminal.send(RESOURCE_ENERGY, 100, o.originRoom, JSON.stringify(i)) === OK && Hr.info("Notified quest completion: ".concat(e, " (").concat("won", ")"), {
subsystem: "TooAngel"
});
}(e.id), e.status = "completed", void (e.completedAt = Game.time);
var u = l.find(FIND_CONSTRUCTION_SITES);
Hr.debug("Quest ".concat(e.id, " (buildcs): ").concat(u.length, " construction sites remaining in ").concat(e.targetRoom), {
subsystem: "TooAngel"
});
var f = e.assignedCreeps || [], m = [];
try {
for (var p = r(f), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = Game.creeps[y];
g && m.push(g);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
d && !d.done && (o = p.return) && o.call(p);
} finally {
if (t) throw t.error;
}
}
if (m.length < 3 && u.length > 0) for (var h in Game.rooms) {
var v = Game.rooms[h];
if (null === (c = v.controller) || void 0 === c ? void 0 : c.my) {
var R = v.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory, r = t.role;
return !("larvaWorker" !== r && "builder" !== r || t.questId || t.assistTarget);
}
});
try {
for (var E = (n = void 0, r(R)), T = E.next(); !(T.done || ((_ = (b = T.value).memory).questId = e.id, 
m.push(b), f.push(b.name), Hr.info("Assigned ".concat(b.name, " to quest ").concat(e.id, " (buildcs)"), {
subsystem: "TooAngel"
}), m.length >= 3)); T = E.next()) ;
} catch (e) {
n = {
error: e
};
} finally {
try {
T && !T.done && (a = E.return) && a.call(E);
} finally {
if (n) throw n.error;
}
}
if (m.length >= 3) break;
}
}
e.assignedCreeps = f;
try {
for (var S = r(m), C = S.next(); !C.done; C = S.next()) {
var b, _;
(_ = (b = C.value).memory).questId = e.id, _.questTarget = e.targetRoom, _.questAction = "build";
}
} catch (e) {
i = {
error: e
};
} finally {
try {
C && !C.done && (s = S.return) && s.call(S);
} finally {
if (i) throw i.error;
}
}
} else Hr.debug("Cannot execute buildcs quest ".concat(e.id, ": room ").concat(e.targetRoom, " not visible"), {
subsystem: "TooAngel"
});
}

var Cu = function() {
function e() {
this.lastScanTick = 0, this.lastReputationRequestTick = 0, this.lastQuestDiscoveryTick = 0;
}
return e.prototype.isEnabled = function() {
var e, t;
return null === (t = null === (e = Memory.tooangel) || void 0 === e ? void 0 : e.enabled) || void 0 === t || t;
}, e.prototype.enable = function() {
var e = Memory;
e.tooangel || (e.tooangel = {}), e.tooangel.enabled = !0, Hr.info("TooAngel integration enabled", {
subsystem: "TooAngel"
});
}, e.prototype.disable = function() {
var e = Memory;
e.tooangel || (e.tooangel = {}), e.tooangel.enabled = !1, Hr.info("TooAngel integration disabled", {
subsystem: "TooAngel"
});
}, e.prototype.run = function() {
if (this.isEnabled() && !(Game.cpu.bucket < 2e3)) try {
!function() {
var e, t;
if (Game.market.incomingTransactions) {
var o = fu();
try {
for (var n = r(Game.market.incomingTransactions), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
if (!i.order && i.description) {
var s = pu(i.description);
null !== s && (Hr.info("Received reputation update from TooAngel: ".concat(s), {
subsystem: "TooAngel"
}), o.reputation = {
value: s,
lastUpdated: Game.time
});
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}
}(), function() {
var e, t;
if (Game.market.incomingTransactions) {
var o = fu();
try {
for (var n = r(Game.market.incomingTransactions), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
if (!i.order && i.description) {
var s = gu(i.description);
if (s) {
if (Hr.info("Received quest ".concat(s.id, ": ").concat(s.quest, " in ").concat(s.room, " (deadline: ").concat(s.end, ")"), {
subsystem: "TooAngel"
}), s.result) {
Tu(s);
continue;
}
var c = o.activeQuests[s.id];
o.activeQuests[s.id] = {
id: s.id,
type: s.quest,
status: "completed" === (null == c ? void 0 : c.status) || "failed" === (null == c ? void 0 : c.status) ? c.status : "active",
targetRoom: s.room,
originRoom: s.origin || i.from,
deadline: s.end,
appliedAt: null == c ? void 0 : c.appliedAt,
receivedAt: Game.time,
assignedCreeps: []
}, Ru(s.quest) || (Hr.warn("Received unsupported quest type: ".concat(s.quest), {
subsystem: "TooAngel"
}), o.activeQuests[s.id].status = "failed");
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}
}(), function() {
var e, t = (null === (e = Memory.tooangel) || void 0 === e ? void 0 : e.activeQuests) || {};
for (var r in t) {
var o = t[r];
o.assignedCreeps && (o.assignedCreeps = o.assignedCreeps.filter(function(e) {
return void 0 !== Game.creeps[e];
}));
}
}(), function() {
var e, t = (null === (e = Memory.tooangel) || void 0 === e ? void 0 : e.activeQuests) || {};
for (var r in t) {
var o = t[r];
"active" === o.status && (o.deadline > 0 && Game.time > o.deadline ? (Hr.warn("Quest ".concat(r, " missed deadline (").concat(o.deadline, ")"), {
subsystem: "TooAngel"
}), o.status = "failed", o.completedAt = Game.time) : "buildcs" === o.type ? Su(o) : (Hr.warn("Unsupported quest type for execution: ".concat(o.type), {
subsystem: "TooAngel"
}), o.status = "failed", o.completedAt = Game.time));
}
}(), function() {
var e = fu().activeQuests || {};
for (var t in e) {
var r = e[t];
r.deadline > 0 && Game.time >= r.deadline - yu.DEADLINE_BUFFER && ("active" !== r.status && "applied" !== r.status || (Hr.warn("Quest ".concat(t, " expired (deadline: ").concat(r.deadline, ", current: ").concat(Game.time, ")"), {
subsystem: "TooAngel"
}), r.status = "failed", r.completedAt = Game.time)), ("completed" === r.status || "failed" === r.status) && r.completedAt && Game.time - r.completedAt > 1e4 && delete e[t];
}
}(), Game.time - this.lastScanTick >= 500 && (this.scanForNPCs(), this.lastScanTick = Game.time), 
Game.time - this.lastReputationRequestTick >= 2e3 && (this.updateReputation(), this.lastReputationRequestTick = Game.time), 
Game.time - this.lastQuestDiscoveryTick >= 1e3 && (this.discoverQuests(), this.lastQuestDiscoveryTick = Game.time);
} catch (t) {
var e = "tooangel_error_".concat(Game.time % 100);
Memory[e] || (Hr.error("TooAngel manager error: ".concat(t), {
subsystem: "TooAngel"
}), Memory[e] = !0);
}
}, e.prototype.scanForNPCs = function() {
var e, t, o = function() {
var e = [];
for (var t in Game.rooms) {
var r = cu(Game.rooms[t]);
r && (Hr.info("Detected TooAngel NPC room: ".concat(t), {
subsystem: "TooAngel"
}), e.push(r));
}
return e;
}();
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) uu(a.value);
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
o.length > 0 && Hr.info("Scanned ".concat(o.length, " TooAngel NPC rooms"), {
subsystem: "TooAngel"
});
}, e.prototype.updateReputation = function() {
du();
}, e.prototype.discoverQuests = function() {
!function() {
var e, t;
if (vu()) {
var o = lu(), n = hu();
for (var a in o) {
var i = o[a];
try {
for (var s = (e = void 0, r(i.availableQuests)), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
if (!n[l]) return Hr.info("Auto-applying for quest ".concat(l, " from ").concat(a), {
subsystem: "TooAngel"
}), void Eu(l, a);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
}
}
}();
}, e.prototype.getReputation = function() {
return mu();
}, e.prototype.getActiveQuests = function() {
return hu();
}, e.prototype.applyForQuest = function(e, t, r) {
return Eu(e, t, r);
}, e.prototype.getStatus = function() {
var e = this.getReputation(), t = this.getActiveQuests(), r = Object.values(t).filter(function(e) {
return "active" === e.status;
}).length, o = Object.values(t).filter(function(e) {
return "applied" === e.status;
}).length, n = [];
if (n.push("=== TooAngel Integration ==="), n.push("Enabled: ".concat(this.isEnabled())), 
n.push("Reputation: ".concat(e)), n.push("Active Quests: ".concat(r)), n.push("Applied Quests: ".concat(o)), 
n.push(""), Object.keys(t).length > 0) for (var a in n.push("Quests:"), t) {
var i = t[a], s = i.deadline - Game.time;
n.push("  ".concat(a, ": ").concat(i.type, " in ").concat(i.targetRoom, " (").concat(i.status, ", ").concat(s, " ticks left)"));
}
return n.join("\n");
}, t([ Di("empire:tooangel", "TooAngel Manager", {
priority: Ao.LOW,
interval: 10
}) ], e.prototype, "run", null), t([ Bi() ], e);
}(), bu = new Cu, _u = {
updateInterval: 5,
decayFactors: {
expand: .95,
harvest: .9,
build: .92,
upgrade: .93,
defense: .97,
war: .98,
siege: .99,
logistics: .91,
nukeTarget: .99
},
diffusionRates: {
expand: .3,
harvest: .1,
build: .15,
upgrade: .1,
defense: .4,
war: .5,
siege: .6,
logistics: .2,
nukeTarget: .1
},
maxValue: 100,
minValue: 0
}, Ou = function() {
function e(e) {
void 0 === e && (e = 10), this.maxSamples = e, this.values = [], this.sum = 0;
}
return e.prototype.add = function(e) {
if (this.values.push(e), this.sum += e, this.values.length > this.maxSamples) {
var t = this.values.shift();
this.sum -= null != t ? t : 0;
}
return this.get();
}, e.prototype.get = function() {
return this.values.length > 0 ? this.sum / this.values.length : 0;
}, e.prototype.reset = function() {
this.values = [], this.sum = 0;
}, e;
}(), wu = function() {
function t(t) {
void 0 === t && (t = {}), this.trackers = new Map, this.config = e(e({}, _u), t);
}
return t.prototype.getTracker = function(e) {
var t = this.trackers.get(e);
return t || (t = {
energyHarvested: new Ou(10),
energySpawning: new Ou(10),
energyConstruction: new Ou(10),
energyRepair: new Ou(10),
energyTower: new Ou(10),
controllerProgress: new Ou(10),
hostileCount: new Ou(5),
damageReceived: new Ou(5),
idleWorkers: new Ou(10),
lastControllerProgress: 0
}, this.trackers.set(e, t)), t;
}, t.prototype.updateMetrics = function(e, t) {
var o, n, a, i, s, c, l, u, f = this.getTracker(e.name), m = "sources_".concat(e.name), p = global[m];
p && p.tick === Game.time ? u = p.sources : (u = e.find(FIND_SOURCES), global[m] = {
sources: u,
tick: Game.time
});
var d = 0, y = 0;
try {
for (var g = r(u), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
d += v.energyCapacity, y += v.energy;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
h && !h.done && (n = g.return) && n.call(g);
} finally {
if (o) throw o.error;
}
}
var R = d - y;
if (f.energyHarvested.add(R), null === (l = e.controller) || void 0 === l ? void 0 : l.my) {
var E = e.controller.progress - f.lastControllerProgress;
E > 0 && E < 1e5 && f.controllerProgress.add(E), f.lastControllerProgress = e.controller.progress;
}
var T = qn.safeFind(e, FIND_HOSTILE_CREEPS);
f.hostileCount.add(T.length);
var S = 0;
try {
for (var C = r(T), b = C.next(); !b.done; b = C.next()) {
var _ = b.value;
try {
for (var O = (s = void 0, r(_.body)), w = O.next(); !w.done; w = O.next()) {
var x = w.value;
x.hits > 0 && (x.type === ATTACK ? S += 30 : x.type === RANGED_ATTACK && (S += 10));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
w && !w.done && (c = O.return) && c.call(O);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
b && !b.done && (i = C.return) && i.call(C);
} finally {
if (a) throw a.error;
}
}
f.damageReceived.add(S), t.metrics.energyHarvested = f.energyHarvested.get(), t.metrics.controllerProgress = f.controllerProgress.get(), 
t.metrics.hostileCount = Math.round(f.hostileCount.get()), t.metrics.damageReceived = f.damageReceived.get();
}, t.prototype.updatePheromones = function(e, t) {
var o, n;
if (!(Game.time < e.nextUpdateTick)) {
var a = e.pheromones;
try {
for (var i = r(Object.keys(a)), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = this.config.decayFactors[c];
a[c] = this.clamp(a[c] * l);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
this.calculateContributions(e, t), e.nextUpdateTick = Game.time + this.config.updateInterval, 
e.lastUpdate = Game.time;
}
}, t.prototype.calculateContributions = function(e, t) {
var r, o, n = e.pheromones, a = this.getTracker(t.name), i = "sources_".concat(t.name), s = global[i];
if (s && s.tick === Game.time ? o = s.sources : (o = t.find(FIND_SOURCES), global[i] = {
sources: o,
tick: Game.time
}), o.length > 0) {
var c = o.reduce(function(e, t) {
return e + t.energy;
}, 0) / o.length;
n.harvest = this.clamp(n.harvest + c / 3e3 * 10);
}
var l = t.find(FIND_MY_CONSTRUCTION_SITES);
if (l.length > 0 && (n.build = this.clamp(n.build + Math.min(2 * l.length, 20))), 
null === (r = t.controller) || void 0 === r ? void 0 : r.my) {
var u = t.controller.progress / t.controller.progressTotal;
u < .5 && (n.upgrade = this.clamp(n.upgrade + 15 * (1 - u)));
}
var f = a.hostileCount.get();
if (f > 0 && (n.defense = this.clamp(n.defense + 10 * f)), e.danger >= 2 && (n.war = this.clamp(n.war + 10 * e.danger)), 
e.danger >= 3 && (n.siege = this.clamp(n.siege + 20)), t.storage) {
var m = t.find(FIND_MY_SPAWNS);
m.reduce(function(e, t) {
return e + t.store.getUsedCapacity(RESOURCE_ENERGY);
}, 0) < 300 * m.length * .5 && (n.logistics = this.clamp(n.logistics + 10));
}
var p = a.energyHarvested.get() - e.metrics.energySpawning;
p > 0 && 0 === e.danger && (n.expand = this.clamp(n.expand + Math.min(p / 100, 10)));
}, t.prototype.clamp = function(e) {
return Math.max(this.config.minValue, Math.min(this.config.maxValue, e));
}, t.prototype.onHostileDetected = function(e, t, r) {
e.danger = r, e.pheromones.defense = this.clamp(e.pheromones.defense + 5 * t), r >= 2 && (e.pheromones.war = this.clamp(e.pheromones.war + 10 * r)), 
r >= 3 && (e.pheromones.siege = this.clamp(e.pheromones.siege + 20)), Hr.info("Hostile detected: ".concat(t, " hostiles, danger=").concat(r), {
room: e.role,
subsystem: "Pheromone"
});
}, t.prototype.updateDangerFromThreat = function(e, t, r) {
e.danger = r, e.pheromones.defense = this.clamp(t / 10), r >= 2 && (e.pheromones.war = this.clamp(e.pheromones.war + 10 * r)), 
r >= 3 && (e.pheromones.siege = this.clamp(e.pheromones.siege + 20));
}, t.prototype.diffuseDangerToCluster = function(e, t, o) {
var n, a, i;
try {
for (var s = r(o), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
if (l !== e) {
var u = Game.rooms[l];
if (null === (i = null == u ? void 0 : u.controller) || void 0 === i ? void 0 : i.my) {
var f = u.memory.swarm;
if (f) {
var m = this.clamp(t / 10), p = f.pheromones.defense, d = .05 * Math.max(0, m - p);
f.pheromones.defense = this.clamp(p + d);
}
}
}
}
} catch (e) {
n = {
error: e
};
} finally {
try {
c && !c.done && (a = s.return) && a.call(s);
} finally {
if (n) throw n.error;
}
}
}, t.prototype.onStructureDestroyed = function(e, t) {
e.pheromones.defense = this.clamp(e.pheromones.defense + 5), e.pheromones.build = this.clamp(e.pheromones.build + 10), 
t !== STRUCTURE_SPAWN && t !== STRUCTURE_STORAGE && t !== STRUCTURE_TOWER || (e.danger = Math.min(3, e.danger + 1), 
e.pheromones.siege = this.clamp(e.pheromones.siege + 15));
}, t.prototype.onNukeDetected = function(e) {
e.danger = 3, e.pheromones.siege = this.clamp(e.pheromones.siege + 50), e.pheromones.defense = this.clamp(e.pheromones.defense + 30);
}, t.prototype.onRemoteSourceLost = function(e) {
e.pheromones.expand = this.clamp(e.pheromones.expand - 10), e.pheromones.defense = this.clamp(e.pheromones.defense + 5);
}, t.prototype.applyDiffusion = function(e) {
var t, n, a, i, s, c, l, u, f = [];
try {
for (var m = r(e), p = m.next(); !p.done; p = m.next()) {
var d = o(p.value, 2), y = d[0], g = d[1], h = this.getNeighborRoomNames(y);
try {
for (var v = (a = void 0, r(h)), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
if (e.get(E)) try {
for (var T = (s = void 0, r([ "defense", "war", "expand", "siege" ])), S = T.next(); !S.done; S = T.next()) {
var C = S.value, b = g.pheromones[C];
if (b > 1) {
var _ = this.config.diffusionRates[C];
f.push({
source: y,
target: E,
type: C,
amount: b * _ * .5,
sourceIntensity: b
});
}
}
} catch (e) {
s = {
error: e
};
} finally {
try {
S && !S.done && (c = T.return) && c.call(T);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
R && !R.done && (i = v.return) && i.call(v);
} finally {
if (a) throw a.error;
}
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (t) throw t.error;
}
}
try {
for (var O = r(f), w = O.next(); !w.done; w = O.next()) {
var x = w.value, U = e.get(x.target);
if (U) {
var M = U.pheromones[x.type] + x.amount;
U.pheromones[x.type] = this.clamp(Math.min(M, x.sourceIntensity));
}
}
} catch (e) {
l = {
error: e
};
} finally {
try {
w && !w.done && (u = O.return) && u.call(O);
} finally {
if (l) throw l.error;
}
}
}, t.prototype.getNeighborRoomNames = function(e) {
var t = e.match(/^([WE])(\d+)([NS])(\d+)$/);
if (!t) return [];
var r = o(t, 5), n = r[1], a = r[2], i = r[3], s = r[4];
if (!(n && a && i && s)) return [];
var c = parseInt(a, 10), l = parseInt(s, 10), u = [];
return "N" === i ? u.push("".concat(n).concat(c, "N").concat(l + 1)) : l > 0 ? u.push("".concat(n).concat(c, "S").concat(l - 1)) : u.push("".concat(n).concat(c, "N0")), 
"S" === i ? u.push("".concat(n).concat(c, "S").concat(l + 1)) : l > 0 ? u.push("".concat(n).concat(c, "N").concat(l - 1)) : u.push("".concat(n).concat(c, "S0")), 
"E" === n ? u.push("E".concat(c + 1).concat(i).concat(l)) : c > 0 ? u.push("W".concat(c - 1).concat(i).concat(l)) : u.push("E0".concat(i).concat(l)), 
"W" === n ? u.push("W".concat(c + 1).concat(i).concat(l)) : c > 0 ? u.push("E".concat(c - 1).concat(i).concat(l)) : u.push("W0".concat(i).concat(l)), 
u;
}, t.prototype.getDominantPheromone = function(e) {
var t, o, n = null, a = 1;
try {
for (var i = r(Object.keys(e)), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
e[c] > a && (a = e[c], n = c);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return n;
}, t;
}(), xu = new wu, Uu = function() {
function e() {
this.configs = new Map;
}
return e.prototype.initialize = function(e) {
var t, r = Game.rooms[e];
if (r && (null === (t = r.controller) || void 0 === t ? void 0 : t.my)) {
var o = r.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
if (0 !== o.length) {
var n = this.configs.get(e);
n || (n = {
roomName: e,
labs: [],
lastUpdate: Game.time,
isValid: !1
}, this.configs.set(e, n)), this.updateLabEntries(n, o), n.isValid || this.autoAssignRoles(n, o);
} else this.configs.delete(e);
}
}, e.prototype.updateLabEntries = function(e, t) {
var o, n;
e.labs = e.labs.filter(function(e) {
return t.some(function(t) {
return t.id === e.labId;
});
});
var a = function(t) {
e.labs.find(function(e) {
return e.labId === t.id;
}) || e.labs.push({
labId: t.id,
role: "unassigned",
pos: {
x: t.pos.x,
y: t.pos.y
},
lastConfigured: Game.time
});
};
try {
for (var i = r(t), s = i.next(); !s.done; s = i.next()) a(s.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
e.lastUpdate = Game.time;
}, e.prototype.autoAssignRoles = function(e, t) {
var o, n, a, i, s, c, l, u, f, m;
if (t.length < 3) e.isValid = !1; else {
var p = new Map;
try {
for (var d = r(t), y = d.next(); !y.done; y = d.next()) {
var g = y.value, h = [];
try {
for (var v = (a = void 0, r(t)), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
g.id !== E.id && g.pos.getRangeTo(E) <= 2 && h.push(E.id);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
R && !R.done && (i = v.return) && i.call(v);
} finally {
if (a) throw a.error;
}
}
p.set(g.id, h);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
y && !y.done && (n = d.return) && n.call(d);
} finally {
if (o) throw o.error;
}
}
var T = t.map(function(e) {
var t, r;
return {
lab: e,
reach: null !== (r = null === (t = p.get(e.id)) || void 0 === t ? void 0 : t.length) && void 0 !== r ? r : 0
};
}).sort(function(e, t) {
return t.reach - e.reach;
});
if (T.length < 3 || (null !== (u = null === (l = T[0]) || void 0 === l ? void 0 : l.reach) && void 0 !== u ? u : 0) < 2) return e.isValid = !1, 
void Hr.warn("Lab layout in ".concat(e.roomName, " is not optimal for reactions"), {
subsystem: "Labs"
});
var S = null === (f = T[0]) || void 0 === f ? void 0 : f.lab, C = null === (m = T[1]) || void 0 === m ? void 0 : m.lab;
if (S && C) {
try {
for (var b = r(e.labs), _ = b.next(); !_.done; _ = b.next()) {
var O = _.value;
if (O.labId === S.id) O.role = "input1", O.lastConfigured = Game.time; else if (O.labId === C.id) O.role = "input2", 
O.lastConfigured = Game.time; else {
var w = S.pos.getRangeTo(Game.getObjectById(O.labId)) <= 2, x = C.pos.getRangeTo(Game.getObjectById(O.labId)) <= 2;
O.role = w && x ? "output" : "boost", O.lastConfigured = Game.time;
}
}
} catch (e) {
s = {
error: e
};
} finally {
try {
_ && !_.done && (c = b.return) && c.call(b);
} finally {
if (s) throw s.error;
}
}
e.isValid = !0, e.lastUpdate = Game.time, Hr.info("Auto-assigned lab roles in ".concat(e.roomName, ": ") + "".concat(e.labs.filter(function(e) {
return "input1" === e.role;
}).length, " input1, ") + "".concat(e.labs.filter(function(e) {
return "input2" === e.role;
}).length, " input2, ") + "".concat(e.labs.filter(function(e) {
return "output" === e.role;
}).length, " output, ") + "".concat(e.labs.filter(function(e) {
return "boost" === e.role;
}).length, " boost"), {
subsystem: "Labs"
});
} else e.isValid = !1;
}
}, e.prototype.getConfig = function(e) {
return this.configs.get(e);
}, e.prototype.getLabsByRole = function(e, t) {
var r = this.configs.get(e);
return r ? r.labs.filter(function(e) {
return e.role === t;
}).map(function(e) {
return Game.getObjectById(e.labId);
}).filter(function(e) {
return null !== e;
}) : [];
}, e.prototype.getInputLabs = function(e) {
var t, r, o = this.configs.get(e);
if (!o) return {};
var n = o.labs.find(function(e) {
return "input1" === e.role;
}), a = o.labs.find(function(e) {
return "input2" === e.role;
});
return {
input1: n && null !== (t = Game.getObjectById(n.labId)) && void 0 !== t ? t : void 0,
input2: a && null !== (r = Game.getObjectById(a.labId)) && void 0 !== r ? r : void 0
};
}, e.prototype.getOutputLabs = function(e) {
return this.getLabsByRole(e, "output");
}, e.prototype.getBoostLabs = function(e) {
return this.getLabsByRole(e, "boost");
}, e.prototype.setActiveReaction = function(e, t, o, n) {
var a, i, s = this.configs.get(e);
if (!s || !s.isValid) return !1;
s.activeReaction = {
input1: t,
input2: o,
output: n
};
var c = s.labs.find(function(e) {
return "input1" === e.role;
}), l = s.labs.find(function(e) {
return "input2" === e.role;
});
c && (c.resourceType = t), l && (l.resourceType = o);
try {
for (var u = r(s.labs.filter(function(e) {
return "output" === e.role;
})), f = u.next(); !f.done; f = u.next()) f.value.resourceType = n;
} catch (e) {
a = {
error: e
};
} finally {
try {
f && !f.done && (i = u.return) && i.call(u);
} finally {
if (a) throw a.error;
}
}
return s.lastUpdate = Game.time, Hr.info("Set active reaction in ".concat(e, ": ").concat(t, " + ").concat(o, " -> ").concat(n), {
subsystem: "Labs"
}), !0;
}, e.prototype.clearActiveReaction = function(e) {
var t, o, n = this.configs.get(e);
if (n) {
delete n.activeReaction;
try {
for (var a = r(n.labs), i = a.next(); !i.done; i = a.next()) delete i.value.resourceType;
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
n.lastUpdate = Game.time;
}
}, e.prototype.setLabRole = function(e, t, r, o) {
var n = this.configs.get(e);
if (!n) return !1;
var a = n.labs.find(function(e) {
return e.labId === t;
});
return !!a && (a.role = r, a.resourceType = o, a.lastConfigured = Game.time, this.validateConfig(n), 
!0);
}, e.prototype.validateConfig = function(e) {
var t = e.labs.some(function(e) {
return "input1" === e.role;
}), r = e.labs.some(function(e) {
return "input2" === e.role;
}), o = e.labs.some(function(e) {
return "output" === e.role;
});
if (e.isValid = t && r && o, e.isValid) {
var n = e.labs.find(function(e) {
return "input1" === e.role;
}), a = e.labs.find(function(e) {
return "input2" === e.role;
}), i = e.labs.filter(function(e) {
return "output" === e.role;
});
if (n && a && i.length > 0) {
var s = Game.getObjectById(n.labId), c = Game.getObjectById(a.labId);
if (s && c) {
var l = i.some(function(e) {
var t = Game.getObjectById(e.labId);
return t && s.pos.getRangeTo(t) <= 2 && c.pos.getRangeTo(t) <= 2;
});
e.isValid = l;
} else e.isValid = !1;
}
}
}, e.prototype.runReactions = function(e) {
var t, o, n = this.configs.get(e);
if (!n || !n.isValid || !n.activeReaction) return 0;
var a = this.getInputLabs(e), i = a.input1, s = a.input2;
if (!i || !s) return 0;
var c = this.getOutputLabs(e), l = 0;
try {
for (var u = r(c), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
0 === m.cooldown && m.runReaction(i, s) === OK && l++;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (t) throw t.error;
}
}
return l;
}, e.prototype.saveToMemory = function(e) {
var t = this.configs.get(e);
if (t) {
var r = Memory.rooms[e];
if (r) {
r.labConfig = t;
var o = "memory:room:".concat(e, ":labConfig");
qr.set(o, t, Yr);
}
}
}, e.prototype.loadFromMemory = function(e) {
var t = "memory:room:".concat(e, ":labConfig"), r = qr.get(t);
if (!r) {
var o = Memory.rooms[e], n = null == o ? void 0 : o.labConfig;
n && (qr.set(t, n, Yr), r = n);
}
r && this.configs.set(e, r);
}, e.prototype.getConfiguredRooms = function() {
return Array.from(this.configs.keys());
}, e.prototype.hasValidConfig = function(e) {
var t, r = this.configs.get(e);
return null !== (t = null == r ? void 0 : r.isValid) && void 0 !== t && t;
}, e;
}(), Mu = new Uu, Au = function() {
function e() {}
return e.prototype.cleanupMemory = function() {
for (var e in Memory.creeps) Game.creeps[e] || delete Memory.creeps[e];
}, e.prototype.checkMemorySize = function() {
var e = RawMemory.get().length, t = 2097152, r = e / t * 100;
r > 90 ? Hr.error("Memory usage critical: ".concat(r.toFixed(1), "% (").concat(e, "/").concat(t, " bytes)"), {
subsystem: "Memory"
}) : r > 75 && Hr.warn("Memory usage high: ".concat(r.toFixed(1), "% (").concat(e, "/").concat(t, " bytes)"), {
subsystem: "Memory"
});
}, e.prototype.updateMemorySegmentStats = function() {
Io.memorySegmentStats.run();
}, e.prototype.runPheromoneDiffusion = function() {
var e, t, o = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), n = new Map;
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = fi.getSwarmState(s.name);
c && n.set(s.name, c);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
xu.applyDiffusion(n);
}, e.prototype.initializeLabConfigs = function() {
var e, t, o = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
Mu.initialize(i.name);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, e.prototype.precacheRoomPaths = function() {}, t([ Di("core:memoryCleanup", "Memory Cleanup", {
priority: Ao.LOW,
interval: 50,
cpuBudget: .01
}) ], e.prototype, "cleanupMemory", null), t([ Fi("core:memorySizeCheck", "Memory Size Check", {
interval: 100,
cpuBudget: .005
}) ], e.prototype, "checkMemorySize", null), t([ Li("core:memorySegmentStats", "Memory Segment Stats", {
priority: Ao.IDLE,
interval: 10,
cpuBudget: .01
}) ], e.prototype, "updateMemorySegmentStats", null), t([ Li("cluster:pheromoneDiffusion", "Pheromone Diffusion", {
priority: Ao.MEDIUM,
interval: 10,
cpuBudget: .02
}) ], e.prototype, "runPheromoneDiffusion", null), t([ Di("room:labConfig", "Lab Config Manager", {
priority: Ao.LOW,
interval: 200,
cpuBudget: .01
}) ], e.prototype, "initializeLabConfigs", null), t([ Fi("room:pathCachePrecache", "Path Cache Precache (Disabled)", {
interval: 1e3,
cpuBudget: .01
}) ], e.prototype, "precacheRoomPaths", null), t([ Bi() ], e);
}(), ku = new Au, Nu = jr("NativeCallsTracker");

function Pu(e, t, r) {
var o = e[t];
if (o && !o.__nativeCallsTrackerWrapped) {
var n = Object.getOwnPropertyDescriptor(e, t);
if (n && !1 === n.configurable) Nu.warn("Cannot wrap method - property is not configurable", {
meta: {
methodName: t
}
}); else try {
var a = function() {
for (var e = [], t = 0; t < arguments.length; t++) e[t] = arguments[t];
return Io.unifiedStats.recordNativeCall(r), o.apply(this, e);
};
a.__nativeCallsTrackerWrapped = !0, Object.defineProperty(e, t, {
value: a,
writable: !0,
enumerable: !0,
configurable: !0
});
} catch (e) {
Nu.warn("Failed to wrap method", {
meta: {
methodName: t,
error: String(e)
}
});
}
}
}

var Iu = jr("OpportunisticActions");

function Gu() {
return Game.cpu.bucket >= 2e3;
}

var Lu = jr("CollectionPoint"), Du = "collectionPoint";

function Fu(e, t) {
var o = va.get(e.name, {
namespace: Du,
ttl: 500
});
if (o) return new RoomPosition(o.x, o.y, e.name);
if (t.collectionPoint) {
var n = t.collectionPoint.x, a = t.collectionPoint.y;
if ("number" == typeof n && "number" == typeof a && !isNaN(n) && !isNaN(a) && n >= 0 && n < 50 && a >= 0 && a < 50) {
var i = new RoomPosition(n, a, e.name);
if (function(e, t) {
var r = e.getTerrain();
if (!function(e, t, r) {
return r.get(t.x, t.y) !== TERRAIN_MASK_WALL && !e.lookForAt(LOOK_STRUCTURES, t.x, t.y).some(function(e) {
return e.structureType !== STRUCTURE_ROAD && e.structureType !== STRUCTURE_CONTAINER && (e.structureType !== STRUCTURE_RAMPART || !e.my);
});
}(e, t, r)) return !1;
var o = e.find(FIND_MY_SPAWNS);
if (0 === o.length) return !1;
var n = t.getRangeTo(o[0].pos);
return !(n < 5 || n > 15);
}(e, i)) return va.set(e.name, {
x: n,
y: a
}, {
namespace: Du,
ttl: 500
}), i;
}
}
var s = function(e) {
var t, o, n, a = e.find(FIND_MY_SPAWNS);
if (0 === a.length) return null;
var i = a[0], s = e.storage, c = e.controller, l = new Map, u = new Map, f = e.find(FIND_STRUCTURES);
try {
for (var m = r(f), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = "".concat(d.pos.x, ",").concat(d.pos.y);
d.structureType === STRUCTURE_ROAD && l.set(y, !0), d.structureType !== STRUCTURE_ROAD && d.structureType !== STRUCTURE_CONTAINER && (d.structureType !== STRUCTURE_RAMPART || !d.my) && u.set(y, !0);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (t) throw t.error;
}
}
for (var g = [], h = e.getTerrain(), v = 5; v <= 15; v++) {
for (var R = i.pos.x, E = i.pos.y, T = -v; T <= v; T++) {
for (var S = -v; S <= v; S++) if (Math.max(Math.abs(T), Math.abs(S)) === v) {
var C = R + T, b = E + S;
if (!(C < 3 || C > 46 || b < 3 || b > 46)) {
var _ = new RoomPosition(C, b, e.name);
if (ju(_, h, u)) {
var O = 0;
if (O -= Math.abs(v - 8), s && (O -= .5 * _.getRangeTo(s.pos)), c && (O -= .3 * _.getRangeTo(c.pos)), 
null !== (n = l.get("".concat(C, ",").concat(b))) && void 0 !== n && n && (O -= 5), 
g.push({
pos: _,
score: O
}), Bu(g.length, v)) break;
}
}
}
if (Bu(g.length, v)) break;
}
if (Bu(g.length, v)) break;
}
return g.sort(function(e, t) {
return t.score - e.score;
}), g.length > 0 ? g[0].pos : null;
}(e);
return s ? (t.collectionPoint = {
x: s.x,
y: s.y
}, va.set(e.name, {
x: s.x,
y: s.y
}, {
namespace: Du,
ttl: 500
}), Lu.info("Calculated new collection point at ".concat(s.x, ",").concat(s.y), e.name)) : (t.collectionPoint = void 0, 
va.invalidate(e.name, Du), Lu.warn("Failed to calculate collection point for room", e.name)), 
s;
}

function Bu(e, t) {
return e >= 50 && t >= 8;
}

function ju(e, t, r) {
var o;
if (t.get(e.x, e.y) === TERRAIN_MASK_WALL) return !1;
var n = "".concat(e.x, ",").concat(e.y);
return !(null !== (o = r.get(n)) && void 0 !== o && o);
}

var Hu = jr("ActionExecutor"), Wu = "#ffaa00", Yu = "#ffffff", Ku = "#ff0000", Vu = "#00ff00", zu = "#0000ff";

function qu(e, t, r) {
var o, n;
if (!t || !t.type) return Hu.warn("".concat(e.name, " received invalid action, clearing state")), 
void delete r.memory.state;
var a = function(e, t) {
if ("idle" === t.type) return t;
var r = function(e, t) {
if (!Gu()) return t;
if (e.store.getFreeCapacity() < 50) return t;
if ("pickup" === t.type || "withdraw" === t.type) return t;
var r = e.pos.findInRange(FIND_DROPPED_RESOURCES, 3, {
filter: function(e) {
return e.resourceType === RESOURCE_ENERGY && e.amount >= 50;
}
});
if (r.length > 0) {
var o = r.reduce(function(t, r) {
return e.pos.getRangeTo(r) < e.pos.getRangeTo(t) ? r : t;
});
if (e.pos.isNearTo(o)) return Iu.debug("".concat(e.name, " opportunistically picking up ").concat(o.amount, " energy at ").concat(o.pos)), 
{
type: "pickup",
target: o
};
}
return t;
}(e, t);
return r.type !== t.type || (r = function(e, t) {
if (!Gu()) return t;
if (0 === e.store.getUsedCapacity(RESOURCE_ENERGY)) return t;
if ("transfer" === t.type) return t;
var r = e.pos.findInRange(FIND_MY_STRUCTURES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_SPAWN || e.structureType === STRUCTURE_EXTENSION ? e.store.getFreeCapacity(RESOURCE_ENERGY) > 0 : e.structureType === STRUCTURE_TOWER && e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
}
});
if (r.length > 0) {
var o = r.sort(function(e, t) {
var r = e.structureType === STRUCTURE_SPAWN ? 3 : e.structureType === STRUCTURE_EXTENSION ? 2 : 1;
return (t.structureType === STRUCTURE_SPAWN ? 3 : t.structureType === STRUCTURE_EXTENSION ? 2 : 1) - r;
})[0];
return Iu.debug("".concat(e.name, " opportunistically transferring to ").concat(o.structureType, " at ").concat(o.pos)), 
{
type: "transfer",
target: o,
resourceType: RESOURCE_ENERGY
};
}
return t;
}(e, r), r.type !== t.type || (r = function(e, t) {
if (!Gu()) return t;
if (0 === e.getActiveBodyparts(WORK)) return t;
if (0 === e.store.getUsedCapacity(RESOURCE_ENERGY)) return t;
if ("repair" === t.type) return t;
var r = e.pos.findInRange(FIND_STRUCTURES, 3, {
filter: function(e) {
return e.hits < .5 * e.hitsMax && e.structureType !== STRUCTURE_WALL && e.structureType !== STRUCTURE_RAMPART;
}
});
if (r.length > 0) {
var o = r.reduce(function(t, r) {
return e.pos.getRangeTo(r) < e.pos.getRangeTo(t) ? r : t;
});
if (e.pos.isNearTo(o) && o.hits < .3 * o.hitsMax) return Iu.debug("".concat(e.name, " opportunistically repairing ").concat(o.structureType, " at ").concat(o.pos, " (").concat(o.hits, "/").concat(o.hitsMax, ")")), 
{
type: "repair",
target: o
};
}
return t;
}(e, r))), r;
}(e, t);
t.type !== a.type && Hu.debug("".concat(e.name, " opportunistic action: ").concat(t.type, "  ").concat(a.type)), 
"idle" === a.type ? Hu.warn("".concat(e.name, " (").concat(r.memory.role, ") executing IDLE action")) : Hu.debug("".concat(e.name, " (").concat(r.memory.role, ") executing ").concat(a.type));
var i = !1;
switch (a.type) {
case "harvest":
i = Xu(e, function() {
return e.harvest(a.target);
}, a.target, Wu, a.type);
break;

case "harvestMineral":
i = Xu(e, function() {
return e.harvest(a.target);
}, a.target, "#00ff00", a.type);
break;

case "harvestDeposit":
i = Xu(e, function() {
return e.harvest(a.target);
}, a.target, "#00ffff", a.type);
break;

case "pickup":
i = Xu(e, function() {
return e.pickup(a.target);
}, a.target, Wu, a.type);
break;

case "withdraw":
i = Xu(e, function() {
return e.withdraw(a.target, a.resourceType);
}, a.target, Wu, a.type);
break;

case "transfer":
i = Xu(e, function() {
return e.transfer(a.target, a.resourceType);
}, a.target, Yu, a.type, {
resourceType: a.resourceType
});
break;

case "drop":
e.drop(a.resourceType);
break;

case "build":
i = Xu(e, function() {
return e.build(a.target);
}, a.target, "#ffffff", a.type);
break;

case "repair":
i = Xu(e, function() {
return e.repair(a.target);
}, a.target, "#ffff00", a.type);
break;

case "upgrade":
i = Xu(e, function() {
return e.upgradeController(a.target);
}, a.target, Yu, a.type);
break;

case "dismantle":
i = Xu(e, function() {
return e.dismantle(a.target);
}, a.target, Ku, a.type);
break;

case "attack":
Xu(e, function() {
return e.attack(a.target);
}, a.target, Ku, a.type);
break;

case "rangedAttack":
Xu(e, function() {
return e.rangedAttack(a.target);
}, a.target, Ku, a.type);
break;

case "heal":
Xu(e, function() {
return e.heal(a.target);
}, a.target, Vu, a.type);
break;

case "rangedHeal":
e.rangedHeal(a.target), Es.moveTo(e, a.target, {
visualizePathStyle: {
stroke: Vu
}
}) === ERR_NO_PATH && (i = !0);
break;

case "claim":
Xu(e, function() {
return e.claimController(a.target);
}, a.target, Vu, a.type);
break;

case "reserve":
Xu(e, function() {
return e.reserveController(a.target);
}, a.target, Vu, a.type);
break;

case "attackController":
Xu(e, function() {
return e.attackController(a.target);
}, a.target, Ku, a.type);
break;

case "moveTo":
Es.moveTo(e, a.target, {
visualizePathStyle: {
stroke: zu
}
}) === ERR_NO_PATH && (i = !0);
break;

case "moveToRoom":
var s = new RoomPosition(25, 25, a.roomName);
Es.moveTo(e, {
pos: s,
range: 20
}, {
visualizePathStyle: {
stroke: zu
},
maxRooms: 16
}) === ERR_NO_PATH && (i = !0);
break;

case "flee":
var c = a.from.map(function(e) {
return {
pos: e,
range: 10
};
});
Es.moveTo(e, c, {
flee: !0
}) === ERR_NO_PATH && (i = !0);
break;

case "wait":
if (Es.isExit(e.pos)) {
var l = new RoomPosition(25, 25, e.pos.roomName);
Es.moveTo(e, l, {
priority: 2
});
break;
}
e.pos.isEqualTo(a.position) || Es.moveTo(e, a.position) === ERR_NO_PATH && (i = !0);
break;

case "requestMove":
Es.moveTo(e, a.target, {
visualizePathStyle: {
stroke: zu
},
priority: 5
}) === ERR_NO_PATH && (i = !0);
break;

case "idle":
if (Es.isExit(e.pos)) {
l = new RoomPosition(25, 25, e.pos.roomName), Es.moveTo(e, l, {
priority: 2
});
break;
}
var u = Game.rooms[e.pos.roomName];
if (u && (null === (o = u.controller) || void 0 === o ? void 0 : o.my)) {
var f = Fu(u, fi.getOrInitSwarmState(u.name));
if (f && !e.pos.isEqualTo(f)) {
Es.moveTo(e, f, {
visualizePathStyle: {
stroke: "#888888"
},
priority: 2
}) === ERR_NO_PATH && (i = !0);
break;
}
}
var m = ((null === (n = Game.rooms[e.pos.roomName]) || void 0 === n ? void 0 : n.find(FIND_MY_SPAWNS)) || []).find(function(t) {
return e.pos.inRangeTo(t.pos, 1);
});
m && Es.moveTo(e, {
pos: m.pos,
range: 3
}, {
flee: !0,
priority: 2
});
}
i && (delete r.memory.state, Es.clearCachedPath(e), Pa(e)), function(e) {
var t = 0 === e.creep.store.getUsedCapacity(), r = 0 === e.creep.store.getFreeCapacity();
void 0 === e.memory.working && (e.memory.working = !t), t && (e.memory.working = !1), 
r && (e.memory.working = !0);
}(r);
}

function Xu(e, t, r, o, n, a) {
var i = t();
if (i === ERR_NOT_IN_RANGE) {
var s = Es.moveTo(e, r, {
visualizePathStyle: {
stroke: o
}
});
return s !== OK && Hu.info("Movement attempt returned non-OK result", {
room: e.pos.roomName,
creep: e.name,
meta: {
action: null != n ? n : "rangeAction",
moveResult: s,
target: r.pos.toString()
}
}), s === ERR_NO_PATH;
}
return i === OK && n && function(e, t, r, o) {
var n, a, i;
switch (Io.initializeMetrics(e.memory), t) {
case "harvest":
case "harvestMineral":
case "harvestDeposit":
var s = 2 * (h = e.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length);
Io.recordHarvest(e.memory, s);
break;

case "transfer":
var c = null !== (n = null == o ? void 0 : o.resourceType) && void 0 !== n ? n : RESOURCE_ENERGY, l = Math.min(e.store.getUsedCapacity(c), null !== (i = null === (a = r.store) || void 0 === a ? void 0 : a.getFreeCapacity(c)) && void 0 !== i ? i : 0);
l > 0 && Io.recordTransfer(e.memory, l);
break;

case "build":
var u = 5 * (h = e.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length);
Io.recordBuild(e.memory, u);
break;

case "repair":
var f = 100 * (h = e.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length);
Io.recordRepair(e.memory, f);
break;

case "attack":
var m = 30 * e.body.filter(function(e) {
return e.type === ATTACK && e.hits > 0;
}).length;
Io.recordDamage(e.memory, m);
break;

case "rangedAttack":
var p = e.body.filter(function(e) {
return e.type === RANGED_ATTACK && e.hits > 0;
}).length, d = e.pos.getRangeTo(r);
m = 0, d <= 1 ? m = 10 * p : d <= 2 ? m = 4 * p : d <= 3 && (m = 1 * p), Io.recordDamage(e.memory, m);
break;

case "heal":
case "rangedHeal":
var y = e.body.filter(function(e) {
return e.type === HEAL && e.hits > 0;
}).length, g = "heal" === t ? 12 * y : 4 * y;
Io.recordHealing(e.memory, g);
break;

case "upgrade":
var h = e.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length;
Io.recordUpgrade(e.memory, h);
}
}(e, n, r, a), (i === ERR_FULL || i === ERR_NOT_ENOUGH_RESOURCES || i === ERR_INVALID_TARGET) && (Hu.info("Clearing state after action error", {
room: e.pos.roomName,
creep: e.name,
meta: {
action: null != n ? n : "rangeAction",
result: i,
target: r.pos.toString()
}
}), !0);
}

function Qu(e) {
var t = 0 === e.creep.store.getUsedCapacity(), r = 0 === e.creep.store.getFreeCapacity();
void 0 === e.memory.working && (e.memory.working = !t);
var o = e.memory.working;
t ? e.memory.working = !1 : r && (e.memory.working = !0);
var n = e.memory.working;
return o !== n && Ia(e.creep), n;
}

function Zu(e) {
e.memory.working = !1, Ia(e.creep);
}

var Ju = jr("EnergyCollection");

function $u(e) {
if (e.droppedResources.length > 0) {
var t = Na(e.creep, e.droppedResources, "energy_drop", 5);
if (t) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") selecting dropped resource at ").concat(t.pos)), 
{
type: "pickup",
target: t
};
}
var r = e.containers.filter(function(e) {
return e.store.getUsedCapacity(RESOURCE_ENERGY) > 100;
});
if (r.length > 0) {
var o = qn.findDistributedTarget(e.creep, r, "energy_container");
if (o) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") selecting container ").concat(o.id, " at ").concat(o.pos, " with ").concat(o.store.getUsedCapacity(RESOURCE_ENERGY), " energy")), 
{
type: "withdraw",
target: o,
resourceType: RESOURCE_ENERGY
};
if (Ju.warn("".concat(e.creep.name, " (").concat(e.memory.role, ") found ").concat(r.length, " containers but distribution returned null, falling back to closest")), 
a = e.creep.pos.findClosestByRange(r)) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") using fallback container ").concat(a.id, " at ").concat(a.pos)), 
{
type: "withdraw",
target: a,
resourceType: RESOURCE_ENERGY
};
}
if (e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 0) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") selecting storage at ").concat(e.storage.pos)), 
{
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var n = wa(e.room).filter(function(e) {
return e.energy > 0;
});
if (n.length > 0) {
var a, i = qn.findDistributedTarget(e.creep, n, "energy_source");
if (i) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") selecting source ").concat(i.id, " at ").concat(i.pos)), 
{
type: "harvest",
target: i
};
if (Ju.warn("".concat(e.creep.name, " (").concat(e.memory.role, ") found ").concat(n.length, " sources but distribution returned null, falling back to closest")), 
a = e.creep.pos.findClosestByRange(n)) return Ju.debug("".concat(e.creep.name, " (").concat(e.memory.role, ") using fallback source ").concat(a.id, " at ").concat(a.pos)), 
{
type: "harvest",
target: a
};
}
return Ju.warn("".concat(e.creep.name, " (").concat(e.memory.role, ") findEnergy returning idle - no energy sources available")), 
{
type: "idle"
};
}

function ef(e) {
var t = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (t.length > 0 && (n = Na(e.creep, t, "deliver_spawn", 5))) return {
type: "transfer",
target: n,
resourceType: RESOURCE_ENERGY
};
var r = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (r.length > 0 && (n = Na(e.creep, r, "deliver_ext", 5))) return {
type: "transfer",
target: n,
resourceType: RESOURCE_ENERGY
};
var o = e.towers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
});
if (o.length > 0 && (n = Na(e.creep, o, "deliver_tower", 10))) return {
type: "transfer",
target: n,
resourceType: RESOURCE_ENERGY
};
if (e.storage && e.storage.store.getFreeCapacity(RESOURCE_ENERGY) > 0) return {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var n, a = e.depositContainers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
return a.length > 0 && (n = Na(e.creep, a, "deliver_cont", 10)) ? {
type: "transfer",
target: n,
resourceType: RESOURCE_ENERGY
} : null;
}

var tf = jr("LarvaWorkerBehavior");

function rf(e) {
if (Qu(e)) {
tf.debug("".concat(e.creep.name, " larvaWorker working with ").concat(e.creep.store.getUsedCapacity(RESOURCE_ENERGY), " energy"));
var t = ef(e);
if (t) return tf.debug("".concat(e.creep.name, " larvaWorker delivering via ").concat(t.type)), 
t;
var r = function(e) {
var t, r = fi.getSwarmState(e.room.name);
return null !== (t = null == r ? void 0 : r.pheromones) && void 0 !== t ? t : null;
}(e.creep);
if (r) {
if (function(e) {
return e.build > 15;
}(r) && e.prioritizedSites.length > 0) return {
type: "build",
target: e.prioritizedSites[0]
};
if (function(e) {
return e.upgrade > 15;
}(r) && e.room.controller) return {
type: "upgrade",
target: e.room.controller
};
}
if (e.prioritizedSites.length > 0) return tf.debug("".concat(e.creep.name, " larvaWorker building site")), 
{
type: "build",
target: e.prioritizedSites[0]
};
if (e.room.controller) return {
type: "upgrade",
target: e.room.controller
};
if (e.isEmpty) return tf.warn("".concat(e.creep.name, " larvaWorker idle (empty, working=true, no targets) - this indicates a bug")), 
{
type: "idle"
};
tf.debug("".concat(e.creep.name, " larvaWorker has energy but no targets, switching to collection mode")), 
Zu(e);
}
return $u(e);
}

var of = jr("HarvesterBehavior"), nf = jr("HaulerBehavior"), af = function() {
function e() {}
return e.prototype.getLabResourceNeeds = function(e) {
var t, o, n, a, i;
if (!Game.rooms[e]) return [];
var s = Mu.getConfig(e);
if (!s || !s.isValid) return [];
var c, l = [], u = Mu.getInputLabs(e), f = u.input1, m = u.input2;
f && s.activeReaction && (c = null !== (n = f.store[s.activeReaction.input1]) && void 0 !== n ? n : 0) < 1e3 && l.push({
labId: f.id,
resourceType: s.activeReaction.input1,
amount: 2e3 - c,
priority: 10
}), m && s.activeReaction && (c = null !== (a = m.store[s.activeReaction.input2]) && void 0 !== a ? a : 0) < 1e3 && l.push({
labId: m.id,
resourceType: s.activeReaction.input2,
amount: 2e3 - c,
priority: 10
});
var p = Mu.getBoostLabs(e), d = function(e) {
var t = s.labs.find(function(t) {
return t.labId === e.id;
});
if (null == t ? void 0 : t.resourceType) {
var r = null !== (i = e.store[t.resourceType]) && void 0 !== i ? i : 0;
r < 1e3 && l.push({
labId: e.id,
resourceType: t.resourceType,
amount: 1500 - r,
priority: 8
});
}
};
try {
for (var y = r(p), g = y.next(); !g.done; g = y.next()) d(g.value);
} catch (e) {
t = {
error: e
};
} finally {
try {
g && !g.done && (o = y.return) && o.call(y);
} finally {
if (t) throw t.error;
}
}
return l;
}, e.prototype.getLabOverflow = function(e) {
var t, o, n, a, i, s;
if (!Game.rooms[e]) return [];
var c = Mu.getConfig(e);
if (!c) return [];
var l = [], u = Mu.getOutputLabs(e);
try {
for (var f = r(u), m = f.next(); !m.done; m = f.next()) {
var p = (T = m.value).mineralType;
if (p) {
var d = null !== (i = T.store[p]) && void 0 !== i ? i : 0, y = c.activeReaction && p !== c.activeReaction.output;
(d > 2e3 || y && d > 0) && l.push({
labId: T.id,
resourceType: p,
amount: d,
priority: y ? 10 : 5
});
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
m && !m.done && (o = f.return) && o.call(f);
} finally {
if (t) throw t.error;
}
}
var g = Mu.getInputLabs(e), h = [ g.input1, g.input2 ].filter(function(e) {
return void 0 !== e;
}), v = function(e) {
var t = e.mineralType;
if (!t) return "continue";
var r = c.labs.find(function(t) {
return t.labId === e.id;
}), o = null == r ? void 0 : r.resourceType;
if (o && t !== o) {
var n = null !== (s = e.store[t]) && void 0 !== s ? s : 0;
n > 0 && l.push({
labId: e.id,
resourceType: t,
amount: n,
priority: 9
});
}
};
try {
for (var R = r(h), E = R.next(); !E.done; E = R.next()) {
var T;
v(T = E.value);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
E && !E.done && (a = R.return) && a.call(R);
} finally {
if (n) throw n.error;
}
}
return l;
}, e.prototype.areLabsReady = function(e, t) {
var o, n, a, i, s = Mu.getConfig(e);
if (!s || !s.isValid) return !1;
var c = Mu.getInputLabs(e), l = c.input1, u = c.input2;
if (!l || !u) return !1;
if ((null !== (a = l.store[t.input1]) && void 0 !== a ? a : 0) < 500) return !1;
if ((null !== (i = u.store[t.input2]) && void 0 !== i ? i : 0) < 500) return !1;
var f = Mu.getOutputLabs(e);
if (0 === f.length) return !1;
try {
for (var m = r(f), p = m.next(); !p.done; p = m.next()) {
var d = p.value.store.getFreeCapacity();
if (null === d || d < 100) return !1;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
return !0;
}, e.prototype.clearReactions = function(e) {
Mu.clearActiveReaction(e), Hr.info("Cleared active reactions in ".concat(e), {
subsystem: "Labs"
});
}, e.prototype.setActiveReaction = function(e, t, r, o) {
var n = Mu.setActiveReaction(e, t, r, o);
return n && Hr.info("Set active reaction: ".concat(t, " + ").concat(r, " -> ").concat(o), {
subsystem: "Labs",
room: e
}), n;
}, e.prototype.runReactions = function(e) {
return Mu.runReactions(e);
}, e.prototype.hasAvailableBoostLabs = function(e) {
return Mu.getBoostLabs(e).length > 0;
}, e.prototype.prepareBoostLab = function(e, t) {
var o, n, a, i, s, c = Mu.getConfig(e);
if (!c) return null;
var l = Mu.getBoostLabs(e);
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) if ((y = f.value).mineralType === t && (null !== (s = y.store[t]) && void 0 !== s ? s : 0) >= 30) return y.id;
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
var m = function(e) {
if (!e.mineralType) {
var r = c.labs.find(function(t) {
return t.labId === e.id;
});
return r && (r.resourceType = t, c.lastUpdate = Game.time), {
value: e.id
};
}
};
try {
for (var p = r(l), d = p.next(); !d.done; d = p.next()) {
var y, g = m(y = d.value);
if ("object" == typeof g) return g.value;
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
return null;
}, e.prototype.scheduleBoostedCreepUnboost = function(e) {
var t, o, n = Game.rooms[e];
if (!n) return 0;
var a = n.find(FIND_MY_CREEPS, {
filter: function(e) {
return e.body.some(function(e) {
return e.boost;
}) && e.ticksToLive && e.ticksToLive <= 50;
}
}), i = 0;
try {
for (var s = r(a), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
this.handleUnboost(l, n) && i++;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
return i;
}, e.prototype.handleUnboost = function(e, t) {
var o, n;
if (!e.body.some(function(e) {
return e.boost;
})) return !1;
if (!e.ticksToLive || e.ticksToLive > 50) return !1;
var a = t.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
if (0 === a.length) return !1;
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = c.store.getFreeCapacity();
if (null !== l && l >= 50) {
if (!e.pos.isNearTo(c)) return e.moveTo(c), !1;
if (c.unboostCreep(e) === OK) return Hr.info("Unboosted ".concat(e.name, ", recovered resources"), {
subsystem: "Labs",
room: t.name
}), !0;
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return !1;
}, e.prototype.getLabTaskStatus = function(e) {
var t = Mu.getConfig(e);
return t && t.isValid ? t.activeReaction ? "reacting" : this.getLabResourceNeeds(e).length > 0 ? "loading" : this.getLabOverflow(e).length > 0 ? "unloading" : "idle" : "idle";
}, e.prototype.initialize = function(e) {
Mu.initialize(e), Mu.loadFromMemory(e);
}, e.prototype.save = function(e) {
Mu.saveToMemory(e);
}, e;
}(), sf = new af, cf = {
larvaWorker: rf,
harvester: function(e) {
var t, o, n = (o = Cs((t = e.creep).room).harvesterToSource.get(t.id)) ? Game.getObjectById(o) : null;
if (n || (n = e.assignedSource), n || (n = function(e) {
var t, o, n, a, i, s, c = wa(e.room);
if (0 === c.length) return null;
var l, u = "sourceCounts_".concat(e.room.name), f = "sourceCounts_tick_".concat(e.room.name), m = global, p = m[u], d = m[f];
if (p && d === Game.time) l = p; else {
l = new Map;
try {
for (var y = r(c), g = y.next(); !g.done; g = y.next()) {
var h = g.value;
l.set(h.id, 0);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
g && !g.done && (o = y.return) && o.call(y);
} finally {
if (t) throw t.error;
}
}
for (var v in Game.creeps) {
var R = Game.creeps[v].memory;
"harvester" === R.role && R.sourceId && l.has(R.sourceId) && l.set(R.sourceId, (null !== (i = l.get(R.sourceId)) && void 0 !== i ? i : 0) + 1);
}
m[u] = l, m[f] = Game.time;
}
var E = null, T = 1 / 0;
try {
for (var S = r(c), C = S.next(); !C.done; C = S.next()) {
h = C.value;
var b = null !== (s = l.get(h.id)) && void 0 !== s ? s : 0;
b < T && (T = b, E = h);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
C && !C.done && (a = S.return) && a.call(S);
} finally {
if (n) throw n.error;
}
}
return E && (e.memory.sourceId = E.id), E;
}(e), of.debug("".concat(e.creep.name, " harvester assigned to source ").concat(null == n ? void 0 : n.id))), 
!n) return of.warn("".concat(e.creep.name, " harvester has no source to harvest")), 
{
type: "idle"
};
if (!e.creep.pos.isNearTo(n)) return {
type: "moveTo",
target: n
};
var a = e.creep.store.getCapacity(), i = e.creep.store.getFreeCapacity() > 0;
if (null === a || 0 === a || i) return {
type: "harvest",
target: n
};
var s = function(e) {
var t, r = null !== (t = e.memory) && void 0 !== t ? t : {};
if (r.nearbyContainerId && r.nearbyContainerTick && Game.time - r.nearbyContainerTick < 50) {
var o = Game.getObjectById(r.nearbyContainerId);
if (o) return o.store.getFreeCapacity(RESOURCE_ENERGY) > 0 ? o : void 0;
delete r.nearbyContainerId, delete r.nearbyContainerTick;
}
var n = e.pos.findInRange(FIND_STRUCTURES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
})[0];
return n ? (r.nearbyContainerId = n.id, r.nearbyContainerTick = Game.time, n.store.getFreeCapacity(RESOURCE_ENERGY) > 0 ? n : void 0) : (delete r.nearbyContainerId, 
void delete r.nearbyContainerTick);
}(e.creep);
if (s) return of.debug("".concat(e.creep.name, " harvester transferring to container ").concat(s.id)), 
{
type: "transfer",
target: s,
resourceType: RESOURCE_ENERGY
};
var c = function(e) {
var t, r = null !== (t = e.memory) && void 0 !== t ? t : {};
if (r.nearbyLinkId && r.nearbyLinkTick && Game.time - r.nearbyLinkTick < 50) {
var o = Game.getObjectById(r.nearbyLinkId);
if (o) return o.store.getFreeCapacity(RESOURCE_ENERGY) > 0 ? o : void 0;
delete r.nearbyLinkId, delete r.nearbyLinkTick;
}
var n = e.pos.findInRange(FIND_MY_STRUCTURES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK;
}
})[0];
return n ? (r.nearbyLinkId = n.id, r.nearbyLinkTick = Game.time, n.store.getFreeCapacity(RESOURCE_ENERGY) > 0 ? n : void 0) : (delete r.nearbyLinkId, 
void delete r.nearbyLinkTick);
}(e.creep);
return c ? (of.debug("".concat(e.creep.name, " harvester transferring to link ").concat(c.id)), 
{
type: "transfer",
target: c,
resourceType: RESOURCE_ENERGY
}) : (of.debug("".concat(e.creep.name, " harvester dropping energy on ground")), 
{
type: "drop",
resourceType: RESOURCE_ENERGY
});
},
hauler: function(e) {
var t, r = Qu(e);
if (nf.debug("".concat(e.creep.name, " hauler state: working=").concat(r, ", energy=").concat(e.creep.store.getUsedCapacity(RESOURCE_ENERGY), "/").concat(e.creep.store.getCapacity())), 
r) {
var o = Object.keys(e.creep.store)[0];
if (0 === e.creep.store.getUsedCapacity(RESOURCE_ENERGY) && o && o !== RESOURCE_ENERGY) {
var n = null !== (t = e.terminal) && void 0 !== t ? t : e.storage;
if (n) return {
type: "transfer",
target: n,
resourceType: o
};
}
var a = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (a.length > 0 && (c = Na(e.creep, a, "hauler_spawn", 10))) return nf.debug("".concat(e.creep.name, " hauler delivering to spawn ").concat(c.id)), 
{
type: "transfer",
target: c,
resourceType: RESOURCE_ENERGY
};
var i = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (i.length > 0 && (c = Na(e.creep, i, "hauler_ext", 10))) return {
type: "transfer",
target: c,
resourceType: RESOURCE_ENERGY
};
var s = e.towers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
});
if (s.length > 0 && (c = Na(e.creep, s, "hauler_tower", 15))) return {
type: "transfer",
target: c,
resourceType: RESOURCE_ENERGY
};
if (e.storage && e.storage.store.getFreeCapacity(RESOURCE_ENERGY) > 0) return {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var c, l = e.depositContainers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (l.length > 0 && (c = Na(e.creep, l, "hauler_cont", 15))) return {
type: "transfer",
target: c,
resourceType: RESOURCE_ENERGY
};
if (e.isEmpty) return nf.warn("".concat(e.creep.name, " hauler idle (empty, working=true, no targets)")), 
{
type: "idle"
};
nf.debug("".concat(e.creep.name, " hauler has energy but no targets, switching to collection mode")), 
Zu(e);
}
if (e.droppedResources.length > 0 && (c = Na(e.creep, e.droppedResources, "hauler_drop", 5))) return {
type: "pickup",
target: c
};
var u = e.tombstones.filter(function(e) {
return e.store.getUsedCapacity() > 0;
});
if (u.length > 0) {
var f = Na(e.creep, u, "hauler_tomb", 10);
if (f) {
if (f.store.getUsedCapacity(RESOURCE_ENERGY) > 0) return {
type: "withdraw",
target: f,
resourceType: RESOURCE_ENERGY
};
var m = Object.keys(f.store).find(function(e) {
return e !== RESOURCE_ENERGY && f.store.getUsedCapacity(e) > 0;
});
if (m) return {
type: "withdraw",
target: f,
resourceType: m
};
}
}
var p = e.containers.filter(function(e) {
return e.store.getUsedCapacity(RESOURCE_ENERGY) > 100;
});
if (p.length > 0) {
var d = qn.findDistributedTarget(e.creep, p, "energy_container");
if (d) return nf.debug("".concat(e.creep.name, " hauler withdrawing from container ").concat(d.id, " with ").concat(d.store.getUsedCapacity(RESOURCE_ENERGY), " energy")), 
{
type: "withdraw",
target: d,
resourceType: RESOURCE_ENERGY
};
nf.warn("".concat(e.creep.name, " hauler found ").concat(p.length, " containers but distribution returned null, falling back to closest"));
var y = e.creep.pos.findClosestByRange(p);
if (y) return nf.debug("".concat(e.creep.name, " hauler using fallback container ").concat(y.id)), 
{
type: "withdraw",
target: y,
resourceType: RESOURCE_ENERGY
};
}
if (e.mineralContainers.length > 0) {
var g = qn.findDistributedTarget(e.creep, e.mineralContainers, "mineral_container");
if (g) {
if (h = Object.keys(g.store).find(function(e) {
return e !== RESOURCE_ENERGY && g.store.getUsedCapacity(e) > 0;
})) return {
type: "withdraw",
target: g,
resourceType: h
};
} else {
nf.warn("".concat(e.creep.name, " hauler found ").concat(e.mineralContainers.length, " mineral containers but distribution returned null, falling back to closest"));
var h, v = e.creep.pos.findClosestByRange(e.mineralContainers);
if (v && (h = Object.keys(v.store).find(function(e) {
return e !== RESOURCE_ENERGY && v.store.getUsedCapacity(e) > 0;
}))) return nf.debug("".concat(e.creep.name, " hauler using fallback mineral container ").concat(v.id)), 
{
type: "withdraw",
target: v,
resourceType: h
};
}
}
return e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 0 ? (nf.debug("".concat(e.creep.name, " hauler withdrawing from storage")), 
{
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
}) : (nf.warn("".concat(e.creep.name, " hauler idle (no energy sources found)")), 
{
type: "idle"
});
},
builder: function(e) {
var t, r;
if (Qu(e)) {
var o = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (o.length > 0 && (a = Na(e.creep, o, "builder_spawn", 5))) return {
type: "transfer",
target: a,
resourceType: RESOURCE_ENERGY
};
var n = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (n.length > 0 && (a = Na(e.creep, n, "builder_ext", 5))) return {
type: "transfer",
target: a,
resourceType: RESOURCE_ENERGY
};
var a, i = e.towers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
});
if (i.length > 0 && (a = Na(e.creep, i, "builder_tower", 10))) return {
type: "transfer",
target: a,
resourceType: RESOURCE_ENERGY
};
var s = (r = Cs((t = e.creep).room).builderToTarget.get(t.id)) ? Game.getObjectById(r) : null;
return s ? {
type: "build",
target: s
} : e.prioritizedSites.length > 0 ? {
type: "build",
target: e.prioritizedSites[0]
} : e.room.controller ? {
type: "upgrade",
target: e.room.controller
} : {
type: "idle"
};
}
return $u(e);
},
upgrader: function(e) {
if (Qu(e)) {
var t = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (t.length > 0 && (u = Na(e.creep, t, "upgrader_spawn", 5))) return {
type: "transfer",
target: u,
resourceType: RESOURCE_ENERGY
};
var r = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (r.length > 0 && (u = Na(e.creep, r, "upgrader_ext", 5))) return {
type: "transfer",
target: u,
resourceType: RESOURCE_ENERGY
};
var o = e.towers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
});
return o.length > 0 && (u = Na(e.creep, o, "upgrader_tower", 10)) ? {
type: "transfer",
target: u,
resourceType: RESOURCE_ENERGY
} : e.room.controller ? {
type: "upgrade",
target: e.room.controller
} : {
type: "idle"
};
}
var n = e.room.controller;
if (n) {
var a = n.pos.findInRange(FIND_MY_STRUCTURES, 2, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK && e.store.getUsedCapacity(RESOURCE_ENERGY) > 50;
}
});
if (a.length > 0) return {
type: "withdraw",
target: a.reduce(function(e, t) {
return e.store.getUsedCapacity(RESOURCE_ENERGY) > t.store.getUsedCapacity(RESOURCE_ENERGY) ? e : t;
}),
resourceType: RESOURCE_ENERGY
};
}
var i = "upgrader_nearby_containers", s = e.creep.memory, c = s[i], l = [];
if (c && Game.time - c.tick < 30 ? l = c.ids.map(function(e) {
return Game.getObjectById(e);
}).filter(function(e) {
return null !== e;
}) : (l = e.creep.pos.findInRange(FIND_STRUCTURES, 3, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getUsedCapacity(RESOURCE_ENERGY) > 50;
}
}), s[i] = {
ids: l.map(function(e) {
return e.id;
}),
tick: Game.time
}), l.length > 0 && (u = Na(e.creep, l, "upgrader_nearby", 30))) return {
type: "withdraw",
target: u,
resourceType: RESOURCE_ENERGY
};
if (e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 1e3) return {
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var u, f = e.containers.filter(function(e) {
return e.store.getUsedCapacity(RESOURCE_ENERGY) > 100;
});
if (f.length > 0 && (u = Na(e.creep, f, "upgrader_cont", 30))) return {
type: "withdraw",
target: u,
resourceType: RESOURCE_ENERGY
};
var m = wa(e.room).filter(function(e) {
return e.energy > 0;
});
if (m.length > 0) {
var p = Na(e.creep, m, "upgrader_source", 30);
if (p) return {
type: "harvest",
target: p
};
}
return {
type: "idle"
};
},
queenCarrier: function(e) {
return Qu(e) ? ef(e) || (e.storage ? {
type: "moveTo",
target: e.storage
} : {
type: "idle"
}) : e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 0 ? {
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
} : e.terminal && e.terminal.store.getUsedCapacity(RESOURCE_ENERGY) > 0 ? {
type: "withdraw",
target: e.terminal,
resourceType: RESOURCE_ENERGY
} : {
type: "idle"
};
},
mineralHarvester: function(e) {
var t, r = Oa(e.room, FIND_MINERALS)[0];
if (!r) return {
type: "idle"
};
if (!r.pos.lookFor(LOOK_STRUCTURES).find(function(e) {
return e.structureType === STRUCTURE_EXTRACTOR;
})) return {
type: "idle"
};
if (0 === r.mineralAmount) return e.storage ? {
type: "moveTo",
target: e.storage
} : {
type: "idle"
};
if (e.isFull) {
var o = Object.keys(e.creep.store)[0], n = e.creep.pos.findInRange(FIND_STRUCTURES, 1, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getFreeCapacity(o) > 0;
}
})[0];
if (n) return {
type: "transfer",
target: n,
resourceType: o
};
var a = null !== (t = e.terminal) && void 0 !== t ? t : e.storage;
if (a) return {
type: "transfer",
target: a,
resourceType: o
};
}
return {
type: "harvestMineral",
target: r
};
},
depositHarvester: function(e) {
var t;
if (!e.memory.targetId) {
var r = Oa(e.room, FIND_DEPOSITS);
if (r.length > 0) {
var o = r.reduce(function(e, t) {
return e.cooldown < t.cooldown ? e : t;
});
e.memory.targetId = o.id;
}
}
if (!e.memory.targetId) return {
type: "idle"
};
var n, a = Game.getObjectById(e.memory.targetId);
if (!a || null === (n = a) || "object" != typeof n || !("depositType" in n) || !("cooldown" in n) || "structureType" in n) return delete e.memory.targetId, 
{
type: "idle"
};
var i = a;
if (i.cooldown > 100) return delete e.memory.targetId, {
type: "idle"
};
if (e.isFull) {
var s = Game.rooms[e.homeRoom];
if (s) {
var c = null !== (t = s.terminal) && void 0 !== t ? t : s.storage;
if (c) return {
type: "transfer",
target: c,
resourceType: Object.keys(e.creep.store)[0]
};
}
return {
type: "moveToRoom",
roomName: e.homeRoom
};
}
return {
type: "harvestDeposit",
target: i
};
},
labTech: function(e) {
var t, o, n, a, i, s, c, l, u, f;
if (0 === e.labs.length) return {
type: "idle"
};
var m = e.labs.slice(0, 2), p = e.labs.slice(2);
if (e.creep.store.getUsedCapacity() > 0) {
var d = Object.keys(e.creep.store)[0], y = [ RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST ];
if (d !== RESOURCE_ENERGY && !y.includes(d)) {
var g = null !== (u = e.terminal) && void 0 !== u ? u : e.storage;
if (g) return {
type: "transfer",
target: g,
resourceType: d
};
}
try {
for (var h = r(m), v = h.next(); !v.done; v = h.next()) {
var R = (w = v.value).store.getFreeCapacity(d);
if (null !== R && R > 0) return {
type: "transfer",
target: w,
resourceType: d
};
}
} catch (e) {
t = {
error: e
};
} finally {
try {
v && !v.done && (o = h.return) && o.call(h);
} finally {
if (t) throw t.error;
}
}
}
try {
for (var E = r(p), T = E.next(); !T.done; T = E.next()) {
var S = (w = T.value).mineralType;
if (S && w.store.getUsedCapacity(S) > 100) return {
type: "withdraw",
target: w,
resourceType: S
};
}
} catch (e) {
n = {
error: e
};
} finally {
try {
T && !T.done && (a = E.return) && a.call(E);
} finally {
if (n) throw n.error;
}
}
var C = null !== (f = e.terminal) && void 0 !== f ? f : e.storage;
if (C) {
var b = [ RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_CATALYST ];
try {
for (var _ = r(m), O = _.next(); !O.done; O = _.next()) {
var w = O.value;
try {
for (var x = (c = void 0, r(b)), U = x.next(); !U.done; U = x.next()) {
var M = U.value;
if (C.store.getUsedCapacity(M) > 0 && w.store.getFreeCapacity(M) > 0) return {
type: "withdraw",
target: C,
resourceType: M
};
}
} catch (e) {
c = {
error: e
};
} finally {
try {
U && !U.done && (l = x.return) && l.call(x);
} finally {
if (c) throw c.error;
}
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
O && !O.done && (s = _.return) && s.call(_);
} finally {
if (i) throw i.error;
}
}
}
return {
type: "idle"
};
},
labSupply: function(e) {
var t = function(e) {
var t, r, o = null !== (t = e.memory.working) && void 0 !== t && t;
e.isEmpty && (e.memory.working = !1), e.isFull && (e.memory.working = !0);
var n = null !== (r = e.memory.working) && void 0 !== r && r;
return o !== n && (Ia(e.creep), delete e.memory.targetId), n;
}(e);
return t ? function(e) {
if (e.memory.targetId) {
var t = Game.getObjectById(e.memory.targetId);
if (t && t.structureType === STRUCTURE_LAB) {
var r = t, o = Object.keys(e.creep.store).find(function(t) {
return e.creep.store[t] > 0;
});
if (o) return {
type: "transfer",
target: r,
resourceType: o
};
}
delete e.memory.targetId;
}
var n = sf.getLabResourceNeeds(e.room.name);
if (0 === n.length) return {
type: "idle"
};
n.sort(function(e, t) {
return t.priority - e.priority;
});
var a = n[0];
if (!a) return {
type: "idle"
};
var i = Object.keys(e.creep.store).find(function(t) {
return e.creep.store[t] > 0;
});
if (i && i !== a.resourceType && e.terminal) return {
type: "transfer",
target: e.terminal,
resourceType: i
};
var s = Game.getObjectById(a.labId);
return s ? (e.memory.targetId = a.labId, {
type: "transfer",
target: s,
resourceType: a.resourceType
}) : {
type: "idle"
};
}(e) : function(e) {
var t, r = sf.getLabOverflow(e.room.name);
if (r.length > 0) {
r.sort(function(e, t) {
return t.priority - e.priority;
});
var o = r[0];
if (o) {
var n = Game.getObjectById(o.labId);
if (n) return {
type: "withdraw",
target: n,
resourceType: o.resourceType
};
}
}
var a = sf.getLabResourceNeeds(e.room.name);
if (a.length > 0 && e.terminal) {
a.sort(function(e, t) {
return t.priority - e.priority;
});
var i = a[0];
if (i && (null !== (t = e.terminal.store[i.resourceType]) && void 0 !== t ? t : 0) > 0) return e.memory.targetId = i.labId, 
{
type: "withdraw",
target: e.terminal,
resourceType: i.resourceType
};
}
return {
type: "idle"
};
}(e);
},
factoryWorker: function(e) {
var t, o, n, a, i;
if (!e.factory) return {
type: "idle"
};
if (Qu(e)) {
var s = Object.keys(e.creep.store)[0];
return {
type: "transfer",
target: e.factory,
resourceType: s
};
}
var c = null !== (i = e.terminal) && void 0 !== i ? i : e.storage;
if (!c) return {
type: "idle"
};
var l = [ RESOURCE_UTRIUM_BAR, RESOURCE_LEMERGIUM_BAR, RESOURCE_KEANIUM_BAR, RESOURCE_ZYNTHIUM_BAR, RESOURCE_GHODIUM_MELT, RESOURCE_OXIDANT, RESOURCE_REDUCTANT, RESOURCE_PURIFIER, RESOURCE_BATTERY ];
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (e.factory.store.getUsedCapacity(m) > 100) return {
type: "withdraw",
target: e.factory,
resourceType: m
};
}
} catch (e) {
t = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (t) throw t.error;
}
}
if (e.factory.store.getUsedCapacity(RESOURCE_ENERGY) < 5e3 && c.store.getUsedCapacity(RESOURCE_ENERGY) > 1e4) return {
type: "withdraw",
target: c,
resourceType: RESOURCE_ENERGY
};
var p = [ RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_OXYGEN, RESOURCE_HYDROGEN, RESOURCE_CATALYST, RESOURCE_GHODIUM ];
try {
for (var d = r(p), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
if (e.factory.store.getUsedCapacity(g) < 1e3 && c.store.getUsedCapacity(g) > 500) return {
type: "withdraw",
target: c,
resourceType: g
};
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
return {
type: "idle"
};
},
remoteHarvester: function(e) {
var t = e.memory.targetRoom;
if (!t || t === e.memory.homeRoom) return {
type: "idle"
};
if (e.nearbyEnemies && e.hostiles.length > 0) {
var r = e.hostiles.filter(function(t) {
return e.creep.pos.getRangeTo(t) <= 5 && (t.getActiveBodyparts(ATTACK) > 0 || t.getActiveBodyparts(RANGED_ATTACK) > 0);
});
if (r.length > 0) return e.room.name === t ? {
type: "moveToRoom",
roomName: e.memory.homeRoom
} : {
type: "flee",
from: r.map(function(e) {
return e.pos;
})
};
}
if (e.room.name !== t) return {
type: "moveToRoom",
roomName: t
};
var o = e.assignedSource;
if (o || (o = function(e) {
var t = wa(e.room);
if (0 === t.length) return null;
var r = t[0];
return r && (e.memory.sourceId = r.id), r;
}(e)), !o) return {
type: "idle"
};
if (!e.creep.pos.isNearTo(o)) return {
type: "moveTo",
target: o
};
var n = e.creep.store.getCapacity(), a = e.creep.store.getFreeCapacity() > 0;
if (null === n || 0 === n || a) return {
type: "harvest",
target: o
};
var i = function(e, t) {
var r = e.memory;
if (r.remoteContainerId && r.remoteContainerTick && Game.time - r.remoteContainerTick < 50) {
var o = Game.getObjectById(r.remoteContainerId);
if (o) return o;
delete r.remoteContainerId, delete r.remoteContainerTick;
}
var n = t.pos.findInRange(FIND_STRUCTURES, 2, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
})[0];
return n ? (r.remoteContainerId = n.id, r.remoteContainerTick = Game.time) : (delete r.remoteContainerId, 
delete r.remoteContainerTick), n;
}(e.creep, o);
return i ? {
type: "transfer",
target: i,
resourceType: RESOURCE_ENERGY
} : {
type: "drop",
resourceType: RESOURCE_ENERGY
};
},
remoteHauler: function(e) {
var t = Qu(e), r = e.memory.targetRoom, o = e.memory.homeRoom;
if (!r || r === o) return {
type: "idle"
};
if (e.nearbyEnemies && e.hostiles.length > 0) {
var n = e.hostiles.filter(function(t) {
return e.creep.pos.getRangeTo(t) <= 5 && (t.getActiveBodyparts(ATTACK) > 0 || t.getActiveBodyparts(RANGED_ATTACK) > 0);
});
if (n.length > 0) return t && e.room.name !== o ? {
type: "moveToRoom",
roomName: o
} : {
type: "flee",
from: n.map(function(e) {
return e.pos;
})
};
}
if (t) {
if (e.room.name !== o) return {
type: "moveToRoom",
roomName: o
};
var a = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (a.length > 0 && (m = Na(e.creep, a, "remoteHauler_spawn", 5))) return {
type: "transfer",
target: m,
resourceType: RESOURCE_ENERGY
};
var i = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION && e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
if (i.length > 0 && (m = Na(e.creep, i, "remoteHauler_ext", 5))) return {
type: "transfer",
target: m,
resourceType: RESOURCE_ENERGY
};
var s = e.towers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) >= 100;
});
if (s.length > 0 && (m = Na(e.creep, s, "remoteHauler_tower", 10))) return {
type: "transfer",
target: m,
resourceType: RESOURCE_ENERGY
};
if (e.storage && e.storage.store.getFreeCapacity(RESOURCE_ENERGY) > 0) return {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var c = e.depositContainers.filter(function(e) {
return e.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
});
return c.length > 0 && (m = Na(e.creep, c, "remoteHauler_cont", 10)) ? {
type: "transfer",
target: m,
resourceType: RESOURCE_ENERGY
} : e.isEmpty || e.room.name !== o ? {
type: "idle"
} : (Zu(e), {
type: "moveToRoom",
roomName: r
});
}
if (e.room.name !== r) return {
type: "moveToRoom",
roomName: r
};
var l = .3 * e.creep.store.getCapacity(RESOURCE_ENERGY), u = Oa(e.room, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getUsedCapacity(RESOURCE_ENERGY) >= l;
},
filterKey: "remoteContainers"
});
if (u.length > 0 && (m = Na(e.creep, u, "remoteHauler_remoteCont", 10))) return {
type: "withdraw",
target: m,
resourceType: RESOURCE_ENERGY
};
var f = Ma(e.room, RESOURCE_ENERGY).filter(function(e) {
return e.amount > 50;
});
if (f.length > 0 && (m = Na(e.creep, f, "remoteHauler_remoteDrop", 3))) return {
type: "pickup",
target: m
};
if (0 === u.length) {
var m, p = Oa(e.room, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
},
filterKey: "containers"
});
if (p.length > 0 && (m = Na(e.creep, p, "remoteHauler_waitCont", 20)) && e.creep.pos.getRangeTo(m) > 2) return {
type: "moveTo",
target: m
};
}
return {
type: "idle"
};
},
interRoomCarrier: function(e) {
var t = e.memory;
if (!t.transferRequest) return {
type: "idle"
};
var r = t.transferRequest, o = r.fromRoom, n = r.toRoom, a = r.resourceType;
if (e.creep.store.getUsedCapacity(a) > 0) {
if (e.room.name !== n) return {
type: "moveToRoom",
roomName: n
};
var i, s, c;
if (!(i = Game.rooms[n])) return {
type: "moveToRoom",
roomName: n
};
if (i.storage) return {
type: "transfer",
target: i.storage,
resourceType: a
};
if ((s = Oa(i, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getFreeCapacity(a) > 0;
},
filterKey: "container_".concat(a)
})).length > 0 && (c = Na(e.creep, s, "interRoomCarrier_targetCont", 10))) return {
type: "transfer",
target: c,
resourceType: a
};
var l = xa(i, STRUCTURE_SPAWN);
return l.length > 0 ? e.creep.pos.isNearTo(l[0]) ? {
type: "drop",
resourceType: a
} : {
type: "moveTo",
target: l[0].pos
} : {
type: "idle"
};
}
return e.room.name !== o ? {
type: "moveToRoom",
roomName: o
} : (i = Game.rooms[o]) ? i.storage && i.storage.store.getUsedCapacity(a) > 0 ? {
type: "withdraw",
target: i.storage,
resourceType: a
} : (s = Oa(i, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER && e.store.getUsedCapacity(a) > 0;
},
filterKey: "container_".concat(a)
})).length > 0 && (c = Na(e.creep, s, "interRoomCarrier_sourceCont", 10)) ? {
type: "withdraw",
target: c,
resourceType: a
} : {
type: "idle"
} : {
type: "moveToRoom",
roomName: o
};
}
};

function lf(e) {
var t;
return (null !== (t = cf[e.memory.role]) && void 0 !== t ? t : rf)(e);
}

var uf = jr("MilitaryBehaviors"), ff = "patrol";

function mf(e) {
var t, o, n = e.find(FIND_MY_SPAWNS), a = n.length, i = e.name, s = va.get(i, {
namespace: ff
});
if (s && s.metadata.spawnCount === a) return s.waypoints.map(function(e) {
return new RoomPosition(e.x, e.y, e.roomName);
});
var c = e.name, l = [];
try {
for (var u = r(n), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
l.push(new RoomPosition(m.pos.x + 3, m.pos.y + 3, c)), l.push(new RoomPosition(m.pos.x - 3, m.pos.y - 3, c));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (t) throw t.error;
}
}
l.push(new RoomPosition(10, 5, c)), l.push(new RoomPosition(25, 5, c)), l.push(new RoomPosition(39, 5, c)), 
l.push(new RoomPosition(10, 44, c)), l.push(new RoomPosition(25, 44, c)), l.push(new RoomPosition(39, 44, c)), 
l.push(new RoomPosition(5, 10, c)), l.push(new RoomPosition(5, 25, c)), l.push(new RoomPosition(5, 39, c)), 
l.push(new RoomPosition(44, 10, c)), l.push(new RoomPosition(44, 25, c)), l.push(new RoomPosition(44, 39, c)), 
l.push(new RoomPosition(10, 10, c)), l.push(new RoomPosition(39, 10, c)), l.push(new RoomPosition(10, 39, c)), 
l.push(new RoomPosition(39, 39, c)), l.push(new RoomPosition(25, 25, c));
var p = l.map(function(e) {
return {
x: Math.max(2, Math.min(47, e.x)),
y: Math.max(2, Math.min(47, e.y)),
roomName: c
};
}).filter(function(t) {
return e.getTerrain().get(t.x, t.y) !== TERRAIN_MASK_WALL;
}).map(function(e) {
return new RoomPosition(e.x, e.y, e.roomName);
}), d = {
waypoints: p.map(function(e) {
return {
x: e.x,
y: e.y,
roomName: e.roomName
};
}),
metadata: {
spawnCount: a
}
};
return va.set(i, d, {
namespace: ff,
ttl: 1e3
}), p;
}

function pf(e, t) {
var r;
if (0 === t.length) return null;
var o = e.memory;
void 0 === o.patrolIndex && (o.patrolIndex = 0);
var n = t[o.patrolIndex % t.length];
return n && e.pos.getRangeTo(n) <= 2 && (o.patrolIndex = (o.patrolIndex + 1) % t.length), 
null !== (r = t[o.patrolIndex % t.length]) && void 0 !== r ? r : null;
}

function df(e) {
var t, o;
if (0 === e.hostiles.length) return null;
var n = e.hostiles.map(function(e) {
var t, o, n = 0;
if (n += 100 * e.getActiveBodyparts(HEAL), n += 50 * e.getActiveBodyparts(RANGED_ATTACK), 
n += 40 * e.getActiveBodyparts(ATTACK), n += 60 * e.getActiveBodyparts(CLAIM), (n += 30 * e.getActiveBodyparts(WORK)) > 0) try {
for (var a = r(e.body), i = a.next(); !i.done; i = a.next()) if (i.value.boost) {
n += 20;
break;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
return {
hostile: e,
score: n
};
});
return n.sort(function(e, t) {
return t.score - e.score;
}), null !== (o = null === (t = n[0]) || void 0 === t ? void 0 : t.hostile) && void 0 !== o ? o : null;
}

function yf(e, t) {
return e.getActiveBodyparts(t) > 0;
}

function gf(e, t) {
if (!e.swarmState) return null;
var r = Fu(e.room, e.swarmState);
return r && e.creep.pos.getRangeTo(r) > 2 ? (uf.debug("".concat(e.creep.name, " ").concat(t, " moving to collection point at ").concat(r.x, ",").concat(r.y)), 
{
type: "moveTo",
target: r
}) : null;
}

function hf(e) {
var t;
return null === (t = Memory.squads) || void 0 === t ? void 0 : t[e];
}

function vf(e) {
var t = e.creep.memory;
if (qc.checkAndExecuteRetreat(e.creep)) return {
type: "idle"
};
if (t.assistTarget) {
if (e.creep.room.name !== t.assistTarget) return {
type: "moveToRoom",
roomName: t.assistTarget
};
if (0 === e.hostiles.length) {
if (delete t.assistTarget, e.creep.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
} else {
var r = df(e);
if (r) {
var o = e.creep.pos.getRangeTo(r), n = yf(e.creep, RANGED_ATTACK), a = yf(e.creep, ATTACK);
return n && o <= 3 ? {
type: "rangedAttack",
target: r
} : a && o <= 1 ? {
type: "attack",
target: r
} : {
type: "moveTo",
target: r
};
}
}
}
if (e.creep.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var i = df(e);
if (i) return o = e.creep.pos.getRangeTo(i), n = yf(e.creep, RANGED_ATTACK), a = yf(e.creep, ATTACK), 
n && o <= 3 ? {
type: "rangedAttack",
target: i
} : a && o <= 1 ? {
type: "attack",
target: i
} : {
type: "moveTo",
target: i
};
var s = mf(e.room), c = pf(e.creep, s);
if (c) return {
type: "moveTo",
target: c
};
var l = e.creep.pos.findClosestByRange(FIND_MY_SPAWNS);
return l && e.creep.pos.getRangeTo(l) > 5 ? {
type: "moveTo",
target: l
} : {
type: "idle"
};
}

function Rf(e) {
var t = e.creep.memory;
if (e.creep.hits < .5 * e.creep.hitsMax) return {
type: "heal",
target: e.creep
};
if (t.targetRoom) {
if (e.room.name !== t.targetRoom) return {
type: "moveToRoom",
roomName: t.targetRoom
};
var r = e.room.find(FIND_MY_CREEPS, {
filter: function(e) {
var r = e.memory;
return "powerHarvester" === r.role && r.targetRoom === t.targetRoom;
}
});
if (r.length > 0) {
r.sort(function(e, t) {
return (e.hitsMax > 0 ? e.hits / e.hitsMax : 1) - (t.hitsMax > 0 ? t.hits / t.hitsMax : 1);
});
var o = r[0];
return (i = e.creep.pos.getRangeTo(o)) > 3 ? {
type: "moveTo",
target: o
} : i <= 1 ? {
type: "heal",
target: o
} : {
type: "rangedHeal",
target: o
};
}
var n = e.room.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_BANK;
}
})[0];
if (!n && 0 === r.length) return delete t.targetRoom, {
type: "moveToRoom",
roomName: e.homeRoom
};
if (n && e.creep.pos.getRangeTo(n) > 3) return {
type: "moveTo",
target: n
};
}
if (t.assistTarget) {
var a = Game.rooms[t.assistTarget];
if (!a) return {
type: "moveToRoom",
roomName: t.assistTarget
};
if (0 === a.find(FIND_HOSTILE_CREEPS).length) return delete t.assistTarget, {
type: "idle"
};
if (e.creep.room.name !== t.assistTarget) return {
type: "moveToRoom",
roomName: t.assistTarget
};
}
var i, s = e.creep.pos.findInRange(FIND_MY_CREEPS, 3, {
filter: function(e) {
return e.hits < e.hitsMax;
}
});
if (s.length > 0) return s.sort(function(e, t) {
return (e.hitsMax > 0 ? e.hits / e.hitsMax : 1) - (t.hitsMax > 0 ? t.hits / t.hitsMax : 1);
}), o = s[0], (i = e.creep.pos.getRangeTo(o)) <= 1 ? {
type: "heal",
target: o
} : {
type: "rangedHeal",
target: o
};
var c = e.room.find(FIND_MY_CREEPS, {
filter: function(e) {
var t = e.memory;
return "military" === t.family && "healer" !== t.role;
}
});
if (c.length > 0) {
var l = Na(e.creep, c, "healer_follow", 5);
if (l) return {
type: "moveTo",
target: l
};
}
var u = mf(e.room), f = pf(e.creep, u);
return f ? {
type: "moveTo",
target: f
} : {
type: "idle"
};
}

function Ef(e) {
var t;
if (e.memory.squadId) {
var r = hf(e.memory.squadId);
if (r) return Cf(e, r);
}
if (e.creep.hits / e.creep.hitsMax < .3) {
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var o = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
return o.length > 0 && e.creep.pos.getRangeTo(o[0]) > 3 ? {
type: "moveTo",
target: o[0]
} : {
type: "idle"
};
}
var n = null !== (t = e.memory.targetRoom) && void 0 !== t ? t : e.homeRoom;
if (e.room.name !== n) return {
type: "moveToRoom",
roomName: n
};
var a = df(e);
if (a) {
var i = e.creep.pos.getRangeTo(a), s = yf(e.creep, RANGED_ATTACK), c = yf(e.creep, ATTACK);
return s && i <= 3 ? {
type: "rangedAttack",
target: a
} : c && i <= 1 ? {
type: "attack",
target: a
} : {
type: "moveTo",
target: a
};
}
var l = qn.safeFindClosestByRange(e.creep.pos, FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType !== STRUCTURE_CONTROLLER;
}
});
if (l) return {
type: "attack",
target: l
};
var u = mf(e.room), f = pf(e.creep, u);
if (f) return {
type: "moveTo",
target: f
};
var m = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
if (m.length > 0) {
var p = Na(e.creep, m, "soldier_spawn", 20);
if (p && e.creep.pos.getRangeTo(p) > 5) return {
type: "moveTo",
target: p
};
}
return {
type: "idle"
};
}

function Tf(e) {
var t;
if (e.memory.squadId) {
var r = hf(e.memory.squadId);
if (r) return Cf(e, r);
}
if (e.creep.hits / e.creep.hitsMax < .3) {
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var o = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
return o.length > 0 && e.creep.pos.getRangeTo(o[0]) > 3 ? {
type: "moveTo",
target: o[0]
} : {
type: "idle"
};
}
var n = null !== (t = e.memory.targetRoom) && void 0 !== t ? t : e.homeRoom;
if (e.room.name !== n) return {
type: "moveToRoom",
roomName: n
};
var a = qn.safeFindClosestByRange(e.creep.pos, FIND_HOSTILE_SPAWNS);
if (a) return {
type: "dismantle",
target: a
};
var i = qn.safeFindClosestByRange(e.creep.pos, FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
});
if (i) return {
type: "dismantle",
target: i
};
var s = e.room.find(FIND_STRUCTURES, {
filter: function(t) {
var r;
return t.structureType === STRUCTURE_WALL ? t.hits < 1e5 && !(null === (r = e.room.controller) || void 0 === r ? void 0 : r.my) : t.structureType === STRUCTURE_RAMPART && t.hits < 1e5 && !t.my;
}
});
if (s.length > 0) {
var c = Na(e.creep, s, "siege_wall", 10);
if (c) return {
type: "dismantle",
target: c
};
}
var l = qn.safeFindClosestByRange(e.creep.pos, FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType !== STRUCTURE_CONTROLLER;
}
});
if (l) return {
type: "dismantle",
target: l
};
var u = gf(e, "siegeUnit");
if (u) return u;
var f = mf(e.room), m = pf(e.creep, f);
return m ? {
type: "moveTo",
target: m
} : {
type: "idle"
};
}

function Sf(e) {
var t = e.creep.memory;
if (qc.checkAndExecuteRetreat(e.creep)) return {
type: "idle"
};
if (e.creep.hits / e.creep.hitsMax < .3) {
if (t.assistTarget && delete t.assistTarget, e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var r = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
return r.length > 0 && e.creep.pos.getRangeTo(r[0]) > 3 ? {
type: "moveTo",
target: r[0]
} : {
type: "idle"
};
}
if (t.assistTarget) {
var o = Game.rooms[t.assistTarget];
if (!o) return {
type: "moveToRoom",
roomName: t.assistTarget
};
if (0 === o.find(FIND_HOSTILE_CREEPS).length) return delete t.assistTarget, {
type: "idle"
};
if (e.creep.room.name !== t.assistTarget) return {
type: "moveToRoom",
roomName: t.assistTarget
};
var n = df(e);
if (n) return (i = e.creep.pos.getRangeTo(n)) < 3 ? {
type: "flee",
from: [ n.pos ]
} : i <= 3 ? {
type: "rangedAttack",
target: n
} : {
type: "moveTo",
target: n
};
}
if (e.memory.squadId) {
var a = hf(e.memory.squadId);
if (a) return Cf(e, a);
}
var i, s = df(e);
if (s) return (i = e.creep.pos.getRangeTo(s)) < 3 ? {
type: "flee",
from: [ s.pos ]
} : i <= 3 ? {
type: "rangedAttack",
target: s
} : {
type: "moveTo",
target: s
};
var c = mf(e.room), l = pf(e.creep, c);
if (l) return {
type: "moveTo",
target: l
};
var u = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
if (u.length > 0) {
var f = Na(e.creep, u, "harasser_home_spawn", 20);
if (f && e.creep.pos.getRangeTo(f) > 10) return {
type: "moveTo",
target: f
};
}
return {
type: "idle"
};
}

function Cf(e, t) {
var r, o, n;
switch (t.state) {
case "gathering":
if (e.room.name !== t.rallyRoom) return {
type: "moveToRoom",
roomName: t.rallyRoom
};
var a = new RoomPosition(25, 25, t.rallyRoom);
return e.creep.pos.getRangeTo(a) > 3 ? {
type: "moveTo",
target: a
} : {
type: "idle"
};

case "moving":
var i = t.targetRooms[0];
return i && e.room.name !== i ? (o = t.members.filter(function(t) {
var r = Game.creeps[t];
return r && r.room.name === e.room.name;
}).length, n = t.members.length, o < Math.max(2, .5 * n) ? {
type: "idle"
} : {
type: "moveToRoom",
roomName: i
}) : {
type: "idle"
};

case "attacking":
if (e.creep.hits / e.creep.hitsMax < (null !== (r = t.retreatThreshold) && void 0 !== r ? r : .3) && e.room.name !== t.rallyRoom) return {
type: "moveToRoom",
roomName: t.rallyRoom
};
switch (e.memory.role) {
case "soldier":
case "guard":
default:
return Ef(e);

case "healer":
return Rf(e);

case "siegeUnit":
return Tf(e);

case "ranger":
return Sf(e);
}

case "retreating":
return e.room.name !== t.rallyRoom ? {
type: "moveToRoom",
roomName: t.rallyRoom
} : {
type: "moveTo",
target: new RoomPosition(25, 25, t.rallyRoom)
};

case "dissolving":
return e.room.name !== e.homeRoom ? {
type: "moveToRoom",
roomName: e.homeRoom
} : (delete e.memory.squadId, {
type: "idle"
});

default:
return {
type: "idle"
};
}
}

var bf = {
guard: vf,
remoteGuard: function(e) {
var t = e.creep.memory;
if (!t.targetRoom) {
if (e.creep.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var o = mf(e.room);
return (n = pf(e.creep, o)) ? {
type: "moveTo",
target: n
} : {
type: "idle"
};
}
if (e.creep.room.name !== t.targetRoom) return {
type: "moveToRoom",
roomName: t.targetRoom
};
var n, a = e.room.find(FIND_HOSTILE_CREEPS).filter(function(e) {
return e.body.some(function(e) {
return e.type === ATTACK || e.type === RANGED_ATTACK || e.type === WORK;
});
});
if (0 === a.length) return e.creep.room.name !== e.homeRoom ? {
type: "moveToRoom",
roomName: e.homeRoom
} : (o = mf(e.room), (n = pf(e.creep, o)) ? {
type: "moveTo",
target: n
} : {
type: "idle"
});
var i = function(e, t) {
var o, n;
if (0 === t.length) return null;
var a = [ t.filter(function(e) {
return e.body.some(function(e) {
return e.boost;
});
}), t.filter(function(e) {
return yf(e, HEAL);
}), t.filter(function(e) {
return yf(e, RANGED_ATTACK);
}), t.filter(function(e) {
return yf(e, ATTACK);
}), t ];
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if (c.length > 0) return e.creep.pos.findClosestByRange(c);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
s && !s.done && (n = i.return) && n.call(i);
} finally {
if (o) throw o.error;
}
}
return null;
}(e, a);
if (i) {
var s = e.creep.pos.getRangeTo(i), c = yf(e.creep, RANGED_ATTACK), l = yf(e.creep, ATTACK);
return c && s <= 3 ? {
type: "rangedAttack",
target: i
} : l && s <= 1 ? {
type: "attack",
target: i
} : {
type: "moveTo",
target: i
};
}
var u = e.room.find(FIND_SOURCES);
if (u.length > 0) {
var f = e.creep.pos.findClosestByRange(u);
if (f && e.creep.pos.getRangeTo(f) > 3) return {
type: "moveTo",
target: f
};
}
return {
type: "idle"
};
},
healer: Rf,
soldier: Ef,
siegeUnit: Tf,
harasser: function(e) {
var t = e.memory.targetRoom;
if (e.creep.hits / e.creep.hitsMax < .4) {
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var r = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
return r.length > 0 && e.creep.pos.getRangeTo(r[0]) > 3 ? {
type: "moveTo",
target: r[0]
} : {
type: "idle"
};
}
if (!t) return gf(e, "harasser (no target)") || {
type: "idle"
};
if (e.room.name !== t) return {
type: "moveToRoom",
roomName: t
};
var o = e.hostiles.filter(function(t) {
return e.creep.pos.getRangeTo(t) < 5 && t.body.some(function(e) {
return e.type === ATTACK || e.type === RANGED_ATTACK;
});
});
if (o.length > 0) return {
type: "flee",
from: o.map(function(e) {
return e.pos;
})
};
var n = e.hostiles.filter(function(e) {
return e.body.some(function(e) {
return e.type === WORK || e.type === CARRY;
});
});
if (n.length > 0) {
var a = n.reduce(function(t, r) {
return e.creep.pos.getRangeTo(t) < e.creep.pos.getRangeTo(r) ? t : r;
}), i = e.creep.pos.getRangeTo(a);
return i <= 1 ? {
type: "attack",
target: a
} : i <= 3 ? {
type: "rangedAttack",
target: a
} : {
type: "moveTo",
target: a
};
}
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var s = gf(e, "harasser (no targets)");
if (s) return s;
var c = mf(e.room), l = pf(e.creep, c);
return l ? {
type: "moveTo",
target: l
} : {
type: "idle"
};
},
ranger: Sf
};

function _f(e) {
var t;
return (null !== (t = bf[e.memory.role]) && void 0 !== t ? t : vf)(e);
}

function Of(e, t) {
var r, o, n, a, i, s, c, l = t.knownRooms, u = l[e.name], f = null !== (r = null == u ? void 0 : u.lastSeen) && void 0 !== r ? r : 0, m = Game.time - f;
if (u && m < 2e3) {
u.lastSeen = Game.time;
var p = qn.safeFind(e, FIND_HOSTILE_CREEPS);
return u.threatLevel = p.length > 5 ? 3 : p.length > 2 ? 2 : p.length > 0 ? 1 : 0, 
void (e.controller && (u.controllerLevel = null !== (o = e.controller.level) && void 0 !== o ? o : 0, 
(null === (n = e.controller.owner) || void 0 === n ? void 0 : n.username) && (u.owner = e.controller.owner.username), 
(null === (a = e.controller.reservation) || void 0 === a ? void 0 : a.username) && (u.reserver = e.controller.reservation.username)));
}
for (var d = e.find(FIND_SOURCES), y = e.find(FIND_MINERALS)[0], g = e.controller, h = qn.safeFind(e, FIND_HOSTILE_CREEPS), v = e.getTerrain(), R = 0, E = 0, T = 5; T < 50; T += 10) for (var S = 5; S < 50; S += 10) {
var C = v.get(T, S);
C === TERRAIN_MASK_SWAMP ? R++ : 0 === C && E++;
}
var b = R > 2 * E ? "swamp" : E > 2 * R ? "plains" : "mixed", _ = e.name.match(/^[WE](\d+)[NS](\d+)$/), O = !!_ && (parseInt(_[1], 10) % 10 == 0 || parseInt(_[2], 10) % 10 == 0), w = e.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_KEEPER_LAIR;
}
}).length > 0, x = {
name: e.name,
lastSeen: Game.time,
sources: d.length,
controllerLevel: null !== (i = null == g ? void 0 : g.level) && void 0 !== i ? i : 0,
threatLevel: h.length > 5 ? 3 : h.length > 2 ? 2 : h.length > 0 ? 1 : 0,
scouted: !0,
terrain: b,
isHighway: O,
isSK: w
};
(null === (s = null == g ? void 0 : g.owner) || void 0 === s ? void 0 : s.username) && (x.owner = g.owner.username), 
(null === (c = null == g ? void 0 : g.reservation) || void 0 === c ? void 0 : c.username) && (x.reserver = g.reservation.username), 
(null == y ? void 0 : y.mineralType) && (x.mineralType = y.mineralType), l[e.name] = x;
}

function wf(e) {
return {
type: "moveTo",
target: new RoomPosition(25, 25, e)
};
}

function xf(e) {
var t = fi.getEmpire();
if (Es.isExit(e.creep.pos)) return wf(e.room.name);
var n = e.memory.lastExploredRoom, a = e.memory.targetRoom;
if (!a) {
if (a = function(e, t, n) {
var a, i, s, c, l, u = t.knownRooms, f = Game.map.describeExits(e);
if (f) {
var m = [];
try {
for (var p = r(Object.entries(f)), d = p.next(); !d.done; d = p.next()) {
var y = o(d.value, 2)[1];
if (!n || y !== n) {
var g = null !== (c = null === (s = u[y]) || void 0 === s ? void 0 : s.lastSeen) && void 0 !== c ? c : 0;
Game.time - g > 1e3 && m.push({
room: y,
lastSeen: g
});
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
d && !d.done && (i = p.return) && i.call(p);
} finally {
if (a) throw a.error;
}
}
return m.sort(function(e, t) {
return e.lastSeen - t.lastSeen;
}), null === (l = m[0]) || void 0 === l ? void 0 : l.room;
}
}(e.room.name, t, n), !a) return delete e.memory.targetRoom, delete e.memory.lastExploredRoom, 
{
type: "idle"
};
e.memory.targetRoom = a;
}
if (a && e.room.name !== a) return {
type: "moveToRoom",
roomName: a
};
if (a && e.room.name === a) {
var i = function(e) {
var t, o, n = [ new RoomPosition(5, 5, e.name), new RoomPosition(44, 5, e.name), new RoomPosition(5, 44, e.name), new RoomPosition(44, 44, e.name), new RoomPosition(25, 25, e.name) ], a = e.getTerrain();
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if (a.get(c.x, c.y) !== TERRAIN_MASK_WALL) return c;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return null;
}(e.room);
return i ? e.creep.pos.getRangeTo(i) <= 3 ? (Of(e.room, t), e.memory.lastExploredRoom = e.room.name, 
delete e.memory.targetRoom, {
type: "idle"
}) : {
type: "moveTo",
target: i
} : (Of(e.room, t), e.memory.lastExploredRoom = e.room.name, delete e.memory.targetRoom, 
{
type: "idle"
});
}
return {
type: "idle"
};
}

var Uf = {
scout: xf,
claimer: function(e) {
var t = e.memory.targetRoom;
if (!t) {
var r = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
if (r.length > 0) {
var o = Na(e.creep, r, "claimer_spawn", 20);
if (o) return {
type: "moveTo",
target: o
};
}
return {
type: "idle"
};
}
if (Es.isExit(e.creep.pos)) return wf(e.room.name);
if (e.room.name !== t) return {
type: "moveToRoom",
roomName: t
};
var n = e.room.controller;
if (!n) return {
type: "idle"
};
var a = e.memory.task;
return "claim" === a ? {
type: "claim",
target: n
} : "attack" === a ? {
type: "attackController",
target: n
} : {
type: "reserve",
target: n
};
},
engineer: function(e) {
var t, r;
if (e.isEmpty && (e.memory.working = !1), e.isFull && (e.memory.working = !0), e.memory.working) {
var o = e.repairTargets.filter(function(e) {
return (e.structureType === STRUCTURE_SPAWN || e.structureType === STRUCTURE_TOWER || e.structureType === STRUCTURE_STORAGE) && e.hits < .5 * e.hitsMax;
});
if (o.length > 0) {
var n = Na(e.creep, o, "engineer_critical", 5);
if (n) return {
type: "repair",
target: n
};
}
var a = e.repairTargets.filter(function(e) {
return (e.structureType === STRUCTURE_ROAD || e.structureType === STRUCTURE_CONTAINER) && e.hits < .75 * e.hitsMax;
});
if (a.length > 0) {
var i = Na(e.creep, a, "engineer_infra", 5);
if (i) return {
type: "repair",
target: i
};
}
var s = null !== (r = null === (t = e.swarmState) || void 0 === t ? void 0 : t.danger) && void 0 !== r ? r : 0, c = 0 === s ? 1e5 : 1 === s ? 3e5 : 2 === s ? 5e6 : 5e7, l = e.repairTargets.filter(function(e) {
return e.structureType === STRUCTURE_RAMPART && e.hits < c;
});
if (l.length > 0) {
var u = Na(e.creep, l, "engineer_rampart", 5);
if (u) return {
type: "repair",
target: u
};
}
var f = e.repairTargets.filter(function(e) {
return e.structureType === STRUCTURE_WALL && e.hits < c;
});
if (f.length > 0) {
var m = Na(e.creep, f, "engineer_wall", 5);
if (m) return {
type: "repair",
target: m
};
}
return e.prioritizedSites.length > 0 ? {
type: "build",
target: e.prioritizedSites[0]
} : {
type: "idle"
};
}
if (e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 0) return {
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var p = e.containers.filter(function(e) {
return e.store.getUsedCapacity(RESOURCE_ENERGY) > 100;
});
if (p.length > 0) {
var d = Na(e.creep, p, "engineer_cont", 15);
if (d) return {
type: "withdraw",
target: d,
resourceType: RESOURCE_ENERGY
};
}
return {
type: "idle"
};
},
remoteWorker: function(e) {
var t, r = null !== (t = e.memory.targetRoom) && void 0 !== t ? t : e.homeRoom;
if (e.isEmpty && (e.memory.working = !1), e.isFull && (e.memory.working = !0), e.memory.working) {
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
if (e.storage) return {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
var o = e.spawnStructures.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
});
if (o.length > 0) {
var n = Na(e.creep, o, "remoteWorker_spawn", 5);
if (n) return {
type: "transfer",
target: n,
resourceType: RESOURCE_ENERGY
};
}
return {
type: "idle"
};
}
if (e.room.name !== r) return {
type: "moveToRoom",
roomName: r
};
var a = e.creep.pos.findClosestByRange(FIND_SOURCES_ACTIVE);
return a ? {
type: "harvest",
target: a
} : {
type: "idle"
};
},
linkManager: function(e) {
var t = e.room.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LINK;
}
});
if (t.length < 2 || !e.storage) return {
type: "idle"
};
var r = t.find(function(t) {
return t.pos.getRangeTo(e.storage) <= 2;
});
return r ? r.store.getUsedCapacity(RESOURCE_ENERGY) > 400 ? e.creep.store.getFreeCapacity() > 0 ? {
type: "withdraw",
target: r,
resourceType: RESOURCE_ENERGY
} : {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
} : e.creep.pos.getRangeTo(e.storage) > 2 ? {
type: "moveTo",
target: e.storage
} : {
type: "idle"
} : {
type: "idle"
};
},
terminalManager: function(e) {
var t, o;
if (!e.terminal || !e.storage) return {
type: "idle"
};
var n = e.terminal.store.getUsedCapacity(RESOURCE_ENERGY), a = e.storage.store.getUsedCapacity(RESOURCE_ENERGY);
if (e.creep.store.getUsedCapacity() > 0) return (c = Object.keys(e.creep.store)[0]) === RESOURCE_ENERGY ? n < 5e4 ? {
type: "transfer",
target: e.terminal,
resourceType: RESOURCE_ENERGY
} : {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_ENERGY
} : {
type: "transfer",
target: e.terminal,
resourceType: c
};
if (n < 4e4 && a > 2e4) return {
type: "withdraw",
target: e.storage,
resourceType: RESOURCE_ENERGY
};
if (n > 6e4) return {
type: "withdraw",
target: e.terminal,
resourceType: RESOURCE_ENERGY
};
try {
for (var i = r(Object.keys(e.storage.store)), s = i.next(); !s.done; s = i.next()) {
var c;
if ((c = s.value) !== RESOURCE_ENERGY && e.storage.store.getUsedCapacity(c) > 5e3) return {
type: "withdraw",
target: e.storage,
resourceType: c
};
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return e.creep.pos.getRangeTo(e.storage) > 2 ? {
type: "moveTo",
target: e.storage
} : {
type: "idle"
};
}
};

function Mf(e) {
var t;
return (null !== (t = Uf[e.memory.role]) && void 0 !== t ? t : xf)(e);
}

function Af(e, t) {
var r = e.effects;
return void 0 !== r && Array.isArray(r) && r.some(function(e) {
return e.effect === t;
});
}

function kf(e) {
var t = e.memory.targetRoom;
if (!t) return {
type: "idle"
};
if (e.room.name !== t) return {
type: "moveToRoom",
roomName: t
};
var r = Oa(e.room, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_BANK;
},
filterKey: "powerBank"
})[0];
if (!r) return delete e.memory.targetRoom, {
type: "moveToRoom",
roomName: e.homeRoom
};
if (e.creep.hits < .5 * e.creep.hitsMax) {
var o = Oa(e.room, FIND_MY_CREEPS, {
filter: function(e) {
return "healer" === e.memory.role && e.memory.targetRoom === t;
},
filterKey: "healer_".concat(t)
});
if (o.length > 0) {
var n = e.creep.pos.findClosestByRange(o);
if (n && e.creep.pos.getRangeTo(n) > 1) return {
type: "moveTo",
target: n
};
}
}
return e.creep.attack(r) === ERR_NOT_IN_RANGE ? {
type: "moveTo",
target: r
} : {
type: "idle"
};
}

var Nf = {
powerHarvester: kf,
powerCarrier: function(e) {
var t = e.memory.targetRoom;
if (e.creep.store.getUsedCapacity(RESOURCE_POWER) > 0) {
if (e.room.name !== e.homeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
var r = Game.rooms[e.homeRoom];
if (r) {
var o = xa(r, STRUCTURE_POWER_SPAWN)[0];
if (o && o.store.getFreeCapacity(RESOURCE_POWER) > 0) return {
type: "transfer",
target: o,
resourceType: RESOURCE_POWER
};
if (e.storage) return {
type: "transfer",
target: e.storage,
resourceType: RESOURCE_POWER
};
}
return {
type: "idle"
};
}
if (!t) return {
type: "idle"
};
if (e.room.name !== t) return {
type: "moveToRoom",
roomName: t
};
var n = Ma(e.room, RESOURCE_POWER)[0];
if (n) return {
type: "pickup",
target: n
};
var a = Oa(e.room, FIND_RUINS, {
filter: function(e) {
return e.store.getUsedCapacity(RESOURCE_POWER) > 0;
},
filterKey: "powerRuin"
})[0];
if (a) return {
type: "withdraw",
target: a,
resourceType: RESOURCE_POWER
};
var i = Oa(e.room, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_BANK;
},
filterKey: "powerBank"
})[0];
return i ? e.creep.pos.getRangeTo(i) > 3 ? {
type: "moveTo",
target: i
} : {
type: "idle"
} : (delete e.memory.targetRoom, {
type: "moveToRoom",
roomName: e.homeRoom
});
}
};

function Pf(e) {
var t;
return (null !== (t = Nf[e.memory.role]) && void 0 !== t ? t : kf)(e);
}

var If = jr("StateMachine");

function Gf(t, r) {
var o, n = t.memory.state, a = function(e) {
if (!e) return {
valid: !1,
reason: "noState"
};
var t = Game.time - e.startTick;
return t > e.timeout ? {
valid: !1,
reason: "expired",
meta: {
age: t,
timeout: e.timeout
}
} : e.targetId && !Game.getObjectById(e.targetId) ? {
valid: !1,
reason: "missingTarget",
meta: {
targetId: e.targetId
}
} : {
valid: !0
};
}(n);
if (n && a.valid) if (function(e, t) {
if (!e) return !0;
switch (e.action) {
case "harvest":
case "harvestMineral":
case "pickup":
case "withdraw":
return !!t.isFull || !(!e.targetId || (r = Game.getObjectById(e.targetId)));

case "harvestDeposit":
if (t.isFull) return !0;
if (e.targetId) {
if (!(r = Game.getObjectById(e.targetId))) return !0;
if ("object" == typeof r && "cooldown" in r && r.cooldown > 100) return !0;
}
return !1;

case "transfer":
case "build":
return !!t.isEmpty || !(!e.targetId || (r = Game.getObjectById(e.targetId)));

case "repair":
if (t.isEmpty) return !0;
if (e.targetId) {
if (!(r = Game.getObjectById(e.targetId))) return !0;
if ("object" == typeof (a = r) && null !== a && "hits" in a && "hitsMax" in a && r.hits >= r.hitsMax) return !0;
}
return !1;

case "upgrade":
return t.isEmpty;

case "moveToRoom":
return void 0 !== e.targetRoom && t.room.name === e.targetRoom;

case "moveTo":
var r;
if (e.targetId && (r = Game.getObjectById(e.targetId)) && "object" == typeof r && "pos" in r) {
var o = r;
return t.creep.pos.inRangeTo(o.pos, 1);
}
if (e.targetPos) {
var n = new RoomPosition(e.targetPos.x, e.targetPos.y, e.targetPos.roomName);
return t.creep.pos.inRangeTo(n, 1);
}
return !1;

case "idle":
return !0;

default:
return !1;
}
var a;
}(n, t)) If.info("State completed, evaluating new action", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: {
action: n.action,
role: t.memory.role
}
}), delete t.memory.state; else {
var i = function(e) {
var t, r, o = null;
if (e.targetId) {
var n = Game.getObjectById(e.targetId);
if (!n) return null;
if ("object" != typeof n || !("pos" in n) || !("room" in n)) return null;
o = n;
}
switch (e.action) {
case "harvest":
return o ? {
type: "harvest",
target: o
} : null;

case "harvestMineral":
return o ? {
type: "harvestMineral",
target: o
} : null;

case "harvestDeposit":
return o ? {
type: "harvestDeposit",
target: o
} : null;

case "pickup":
return o ? {
type: "pickup",
target: o
} : null;

case "withdraw":
return o && (null === (t = e.data) || void 0 === t ? void 0 : t.resourceType) ? {
type: "withdraw",
target: o,
resourceType: e.data.resourceType
} : null;

case "transfer":
return o && (null === (r = e.data) || void 0 === r ? void 0 : r.resourceType) ? {
type: "transfer",
target: o,
resourceType: e.data.resourceType
} : null;

case "build":
return o ? {
type: "build",
target: o
} : null;

case "repair":
return o ? {
type: "repair",
target: o
} : null;

case "upgrade":
return o ? {
type: "upgrade",
target: o
} : null;

case "moveTo":
return o ? {
type: "moveTo",
target: o
} : e.targetPos ? {
type: "moveTo",
target: new RoomPosition(e.targetPos.x, e.targetPos.y, e.targetPos.roomName)
} : null;

case "moveToRoom":
return e.targetRoom ? {
type: "moveToRoom",
roomName: e.targetRoom
} : null;

case "idle":
return {
type: "idle"
};

default:
return null;
}
}(n);
if (i) return i;
If.info("State reconstruction failed, re-evaluating behavior", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: {
action: n.action,
role: t.memory.role
}
}), delete t.memory.state;
} else n && (If.info("State invalid, re-evaluating behavior", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: e({
action: n.action,
role: t.memory.role,
invalidReason: a.reason
}, a.meta)
}), delete t.memory.state);
var s = r(t);
return s && s.type ? ("idle" !== s.type ? (t.memory.state = function(e) {
var t = {
action: e.type,
startTick: Game.time,
timeout: 25
};
if ("target" in e && e.target && "id" in e.target && (t.targetId = e.target.id), 
"moveToRoom" === e.type && (t.targetRoom = e.roomName), "moveTo" === e.type) {
var r = "pos" in e.target ? e.target.pos : e.target;
t.targetPos = {
x: r.x,
y: r.y,
roomName: r.roomName
};
}
return "withdraw" !== e.type && "transfer" !== e.type || (t.data = {
resourceType: e.resourceType
}), t;
}(s), If.info("Committed new state action", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: {
action: s.type,
role: t.memory.role,
targetId: null === (o = t.memory.state) || void 0 === o ? void 0 : o.targetId
}
})) : If.info("Behavior returned idle action", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: {
role: t.memory.role
}
}), s) : (If.warn("Behavior returned invalid action, defaulting to idle", {
room: t.creep.pos.roomName,
creep: t.creep.name,
meta: {
role: t.memory.role
}
}), {
type: "idle"
});
}

function Lf(e) {
var t = function(e) {
var t, o, n;
if (!e.room) return null;
var a = e.room, i = null !== (n = e.memory.homeRoom) && void 0 !== n ? n : a.name, s = xa(a, STRUCTURE_LAB), c = xa(a, STRUCTURE_SPAWN), l = xa(a, STRUCTURE_EXTENSION), u = xa(a, STRUCTURE_FACTORY)[0], f = xa(a, STRUCTURE_POWER_SPAWN)[0], m = [];
try {
for (var p = r(Object.keys(e.powers)), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = e.powers[y];
g && 0 === g.cooldown && m.push(y);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
d && !d.done && (o = p.return) && o.call(p);
} finally {
if (t) throw t.error;
}
}
return {
powerCreep: e,
room: a,
homeRoom: i,
isInHomeRoom: a.name === i,
storage: a.storage,
terminal: a.terminal,
factory: u,
labs: s,
spawns: c,
extensions: l,
powerSpawn: f,
availablePowers: m,
ops: e.store.getUsedCapacity(RESOURCE_OPS)
};
}(e);
t && function(e, t) {
var r;
switch (t.type) {
case "usePower":
(t.target ? e.usePower(t.power, t.target) : e.usePower(t.power)) === ERR_NOT_IN_RANGE && t.target && Es.moveTo(e, t.target);
break;

case "moveTo":
Es.moveTo(e, t.target);
break;

case "moveToRoom":
var o = new RoomPosition(25, 25, t.roomName);
Es.moveTo(e, {
pos: o,
range: 20
}, {
maxRooms: 16
});
break;

case "renewSelf":
e.renew(t.spawn) === ERR_NOT_IN_RANGE && Es.moveTo(e, t.spawn);
break;

case "enableRoom":
(null === (r = e.room) || void 0 === r ? void 0 : r.controller) && e.enableRoom(e.room.controller) === ERR_NOT_IN_RANGE && Es.moveTo(e, e.room.controller);
}
}(e, function(e) {
return "powerWarrior" === e.powerCreep.memory.role ? function(e) {
var t, a;
if (void 0 !== e.powerCreep.ticksToLive && e.powerCreep.ticksToLive < 1e3 && e.powerSpawn) return {
type: "renewSelf",
spawn: e.powerSpawn
};
var i = e.availablePowers, s = qn.safeFind(e.room, FIND_HOSTILE_CREEPS), c = qn.safeFind(e.room, FIND_HOSTILE_STRUCTURES);
if (e.room.controller && !e.room.controller.isPowerEnabled) return {
type: "enableRoom"
};
if (i.includes(PWR_GENERATE_OPS) && e.ops < 20) return {
type: "usePower",
power: PWR_GENERATE_OPS
};
if (i.includes(PWR_SHIELD) && e.ops >= 10 && s.length > 0) {
var l = Oa(e.room, FIND_MY_CREEPS, {
filter: function(e) {
return "military" === e.memory.family && e.hits < .7 * e.hitsMax;
},
filterKey: "damagedMilitary"
})[0];
if (l) return {
type: "usePower",
power: PWR_SHIELD,
target: l
};
}
if (i.includes(PWR_DISRUPT_SPAWN) && e.ops >= 10) {
var u = qn.safeFind(e.room, FIND_HOSTILE_SPAWNS, {
filter: function(e) {
return !Af(e, PWR_DISRUPT_SPAWN);
}
})[0];
if (u) return {
type: "usePower",
power: PWR_DISRUPT_SPAWN,
target: u
};
}
if (i.includes(PWR_DISRUPT_TOWER) && e.ops >= 10) {
var f = qn.safeFind(e.room, FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER && !Af(e, PWR_DISRUPT_TOWER);
}
})[0];
if (f) return {
type: "usePower",
power: PWR_DISRUPT_TOWER,
target: f
};
}
if (i.includes(PWR_OPERATE_TOWER) && e.ops >= 10 && s.length > 0) {
var m = Oa(e.room, FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER && !Af(e, PWR_OPERATE_TOWER);
},
filterKey: "towerNoEffect"
})[0];
if (m) return {
type: "usePower",
power: PWR_OPERATE_TOWER,
target: m
};
}
if (i.includes(PWR_FORTIFY) && e.ops >= 5 && s.length > 0) {
var p = n(n([], o(e.spawns), !1), [ e.storage, e.terminal ], !1).filter(function(e) {
return void 0 !== e;
});
try {
for (var d = r(p), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
if (g) {
var h = e.room.lookForAt(LOOK_STRUCTURES, g.pos).find(function(e) {
return e.structureType === STRUCTURE_RAMPART;
});
if (h && h.hits < .5 * h.hitsMax) return {
type: "usePower",
power: PWR_FORTIFY,
target: h
};
}
}
} catch (e) {
t = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (t) throw t.error;
}
}
var v = Oa(e.room, FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_RAMPART && e.hits < 5e5;
},
filterKey: "lowRampart"
})[0];
if (v) return {
type: "usePower",
power: PWR_FORTIFY,
target: v
};
}
if (i.includes(PWR_DISRUPT_TERMINAL) && e.ops >= 50) {
var R = c.find(function(e) {
return e.structureType === STRUCTURE_TERMINAL && !Af(e, PWR_DISRUPT_TERMINAL);
});
if (R) return {
type: "usePower",
power: PWR_DISRUPT_TERMINAL,
target: R
};
}
if (i.includes(PWR_GENERATE_OPS) && e.ops < 100) return {
type: "usePower",
power: PWR_GENERATE_OPS
};
if (!e.isInHomeRoom) return {
type: "moveToRoom",
roomName: e.homeRoom
};
if (s.length > 0) {
var E = e.powerCreep.pos.findClosestByRange(s);
if (E && e.powerCreep.pos.getRangeTo(E) > 5) return {
type: "moveTo",
target: E
};
}
return {
type: "idle"
};
}(e) : function(e) {
if (void 0 !== e.powerCreep.ticksToLive && e.powerCreep.ticksToLive < 1e3 && e.powerSpawn) return {
type: "renewSelf",
spawn: e.powerSpawn
};
var t = e.availablePowers;
if (e.room.controller && !e.room.controller.isPowerEnabled) return {
type: "enableRoom"
};
if (t.includes(PWR_GENERATE_OPS) && e.ops < 20) return {
type: "usePower",
power: PWR_GENERATE_OPS
};
if (t.includes(PWR_OPERATE_SPAWN) && e.ops >= 100) {
var r = e.spawns.find(function(e) {
var t = e;
return null !== t.spawning && !Af(t, PWR_OPERATE_SPAWN);
});
if (r) return {
type: "usePower",
power: PWR_OPERATE_SPAWN,
target: r
};
}
if (t.includes(PWR_OPERATE_EXTENSION) && e.ops >= 2 && e.extensions.reduce(function(e, t) {
return e + t.store.getFreeCapacity(RESOURCE_ENERGY);
}, 0) > 1e3 && e.storage && e.storage.store.getUsedCapacity(RESOURCE_ENERGY) > 1e4 && !Af(e.storage, PWR_OPERATE_EXTENSION)) return {
type: "usePower",
power: PWR_OPERATE_EXTENSION,
target: e.storage
};
if (t.includes(PWR_OPERATE_TOWER) && e.ops >= 10 && Oa(e.room, FIND_HOSTILE_CREEPS).length > 0) {
var o = Oa(e.room, FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER && !Af(e, PWR_OPERATE_TOWER);
},
filterKey: "towerNoEffect"
});
if (o.length > 0) return {
type: "usePower",
power: PWR_OPERATE_TOWER,
target: o[0]
};
}
if (t.includes(PWR_OPERATE_LAB) && e.ops >= 10) {
var n = e.labs.find(function(e) {
return 0 === e.cooldown && e.mineralType && !Af(e, PWR_OPERATE_LAB);
});
if (n) return {
type: "usePower",
power: PWR_OPERATE_LAB,
target: n
};
}
if (t.includes(PWR_OPERATE_FACTORY) && e.ops >= 100 && e.factory && 0 === e.factory.cooldown && !Af(e.factory, PWR_OPERATE_FACTORY)) return {
type: "usePower",
power: PWR_OPERATE_FACTORY,
target: e.factory
};
if (t.includes(PWR_OPERATE_STORAGE) && e.ops >= 100 && e.storage && e.storage.store.getUsedCapacity() > .85 * e.storage.store.getCapacity() && !Af(e.storage, PWR_OPERATE_STORAGE)) return {
type: "usePower",
power: PWR_OPERATE_STORAGE,
target: e.storage
};
if (t.includes(PWR_REGEN_SOURCE) && e.ops >= 100) {
var a = Oa(e.room, FIND_SOURCES, {
filter: function(e) {
return 0 === e.energy && e.ticksToRegeneration > 100;
},
filterKey: "depletedSource"
})[0];
if (a) return {
type: "usePower",
power: PWR_REGEN_SOURCE,
target: a
};
}
return t.includes(PWR_GENERATE_OPS) && e.ops < 100 ? {
type: "usePower",
power: PWR_GENERATE_OPS
} : e.isInHomeRoom ? e.storage && e.powerCreep.pos.getRangeTo(e.storage) > 3 ? {
type: "moveTo",
target: e.storage
} : {
type: "idle"
} : {
type: "moveToRoom",
roomName: e.homeRoom
};
}(e);
}(t));
}

function Df(e) {
return null !== e && "object" == typeof e && "pos" in e && e.pos instanceof RoomPosition && "room" in e && e.room instanceof Room;
}

var Ff = new Set([ "harvester", "upgrader", "mineralHarvester", "depositHarvester", "factoryWorker", "labTech", "builder" ]), Bf = {
harvester: Ao.CRITICAL,
queenCarrier: Ao.CRITICAL,
hauler: Ao.HIGH,
guard: Ao.HIGH,
healer: Ao.HIGH,
soldier: Ao.HIGH,
ranger: Ao.HIGH,
siegeUnit: Ao.HIGH,
harasser: Ao.HIGH,
powerQueen: Ao.HIGH,
powerWarrior: Ao.HIGH,
larvaWorker: Ao.HIGH,
builder: Ao.MEDIUM,
upgrader: Ao.MEDIUM,
interRoomCarrier: Ao.MEDIUM,
scout: Ao.MEDIUM,
claimer: Ao.MEDIUM,
engineer: Ao.MEDIUM,
remoteHarvester: Ao.MEDIUM,
powerHarvester: Ao.MEDIUM,
powerCarrier: Ao.MEDIUM,
remoteHauler: Ao.LOW,
remoteWorker: Ao.LOW,
linkManager: Ao.LOW,
terminalManager: Ao.LOW,
mineralHarvester: Ao.LOW,
labTech: Ao.IDLE,
factoryWorker: Ao.IDLE
};

function jf(e) {
var t;
return null !== (t = Bf[e]) && void 0 !== t ? t : Ao.MEDIUM;
}

var Hf = function() {
function e() {
this.registeredCreeps = new Set, this.lastSyncTick = -1;
}
return e.prototype.syncCreepProcesses = function() {
var e, t;
if (this.lastSyncTick !== Game.time) {
this.lastSyncTick = Game.time;
var o = new Set, n = 0, a = 0, i = 0, s = Object.keys(Game.creeps).length;
for (var c in Game.creeps) {
var l = Game.creeps[c];
l.spawning ? i++ : (o.add(c), this.registeredCreeps.has(c) || (this.registerCreepProcess(l), 
n++));
}
try {
for (var u = r(this.registeredCreeps), f = u.next(); !f.done; f = u.next()) c = f.value, 
o.has(c) || (this.unregisterCreepProcess(c), a++);
} catch (t) {
e = {
error: t
};
} finally {
try {
f && !f.done && (t = u.return) && t.call(u);
} finally {
if (e) throw e.error;
}
}
var m = s < 5;
(n > 0 || a > 0 || Game.time % 10 == 0 || m) && Hr.info("CreepProcessManager: ".concat(o.size, " active, ").concat(i, " spawning, ").concat(s, " total (registered: ").concat(n, ", unregistered: ").concat(a, ")"), {
subsystem: "CreepProcessManager",
meta: {
activeCreeps: o.size,
spawningCreeps: i,
totalCreeps: s,
registeredThisTick: n,
unregisteredThisTick: a
}
});
}
}, e.prototype.registerCreepProcess = function(e) {
var t = e.memory.role, r = jf(t), o = "creep:".concat(e.name);
Ko.registerProcess({
id: o,
name: "Creep ".concat(e.name, " (").concat(t, ")"),
priority: r,
frequency: "high",
interval: 1,
minBucket: this.getMinBucketForPriority(r),
cpuBudget: this.getCpuBudgetForPriority(r),
execute: function() {
var t = Game.creeps[e.name];
t && !t.spawning && function(e) {
var t = e.memory;
if (!(e.spawning || "military" !== t.family && void 0 !== e.ticksToLive && e.ticksToLive < 50 && 0 === e.store.getUsedCapacity())) {
var r = Game.rooms[t.homeRoom], o = r && function(e) {
return Object.values(Game.creeps).filter(function(t) {
return t.memory.homeRoom === e.name;
}).length < 5;
}(r);
if ((Game.time % 10 == 0 || o) && Hr.info("Executing role for creep ".concat(e.name, " (").concat(t.role, ")"), {
subsystem: "CreepProcessManager",
creep: e.name
}), function(e) {
var t = e.memory;
if (!Ff.has(t.role)) return !1;
var r = t.state;
if (!r || !r.startTick) return !1;
if (Game.time - r.startTick < 3) return !1;
switch (t.role) {
case "harvester":
return function(e, t) {
if ("harvest" !== t.action && "transfer" !== t.action) return !1;
if (!t.targetId) return !1;
var r = Game.getObjectById(t.targetId);
if (!r || !Df(r)) return !1;
if (!e.pos.isNearTo(r.pos)) return !1;
if ("harvest" === t.action) {
var o = e.store.getCapacity();
if (null !== o && o > 0 && 0 === e.store.getFreeCapacity()) return !1;
}
return !("transfer" === t.action && e.store.getUsedCapacity(RESOURCE_ENERGY) < 40);
}(e, r);

case "upgrader":
return function(e, t) {
if ("upgrade" !== t.action && "withdraw" !== t.action) return !1;
if (!t.targetId) return !1;
var r = Game.getObjectById(t.targetId);
return !(!r || !Df(r) || !e.pos.inRangeTo(r.pos, 3) || "upgrade" === t.action && 0 === e.store.getUsedCapacity(RESOURCE_ENERGY) || "withdraw" === t.action && 0 === e.store.getFreeCapacity(RESOURCE_ENERGY));
}(e, r);

case "mineralHarvester":
return function(e, t) {
if ("harvestMineral" !== t.action) return !1;
if (!t.targetId) return !1;
var r = Game.getObjectById(t.targetId);
return !(!r || !Df(r) || !e.pos.isNearTo(r.pos) || 0 === e.store.getFreeCapacity());
}(e, r);

case "builder":
return function(e, t) {
if ("build" !== t.action) return !1;
if (!t.targetId) return !1;
var r = Game.getObjectById(t.targetId);
return !(!r || !Df(r) || !e.pos.inRangeTo(r.pos, 3) || 0 === e.store.getUsedCapacity(RESOURCE_ENERGY));
}(e, r);

case "depositHarvester":
case "factoryWorker":
case "labTech":
return !0;

default:
return !1;
}
}(e)) {
var n = function(e) {
var t = e.memory.state;
if (!t || !t.targetId) return !1;
var r = Game.getObjectById(t.targetId);
if (!r || !Df(r)) return !1;
switch (t.action) {
case "harvest":
return "energy" in r && "energyCapacity" in r && "ticksToRegeneration" in r && e.harvest(r) === OK;

case "harvestMineral":
return "mineralType" in r && "mineralAmount" in r && "ticksToRegeneration" in r && e.harvest(r) === OK;

case "transfer":
return !(!("store" in r) || !r.store || "object" != typeof r.store) && e.transfer(r, RESOURCE_ENERGY) === OK;

case "withdraw":
return !(!("store" in r) || !r.store || "object" != typeof r.store) && e.withdraw(r, RESOURCE_ENERGY) === OK;

case "upgrade":
return "level" in r && "progress" in r && "my" in r && e.upgradeController(r) === OK;

case "build":
return "progressTotal" in r && "progress" in r && e.build(r) === OK;

case "repair":
return "hits" in r && "hitsMax" in r && e.repair(r) === OK;

default:
return !1;
}
}(e);
if (n) return;
delete t.state;
}
var a = function(e) {
var t;
return null !== (t = e.memory.family) && void 0 !== t ? t : "economy";
}(e), i = t.role;
try {
Io.unifiedStats.measureSubsystem("role:".concat(i), function() {
switch (a) {
case "economy":
default:
!function(e) {
var t = hs(e);
qu(e, Gf(t, lf), t);
}(e);
break;

case "military":
!function(e) {
var t = hs(e);
qu(e, Gf(t, _f), t);
}(e);
break;

case "utility":
!function(e) {
var t = hs(e);
qu(e, Gf(t, Mf), t);
}(e);
break;

case "power":
!function(e) {
var t = hs(e);
qu(e, Gf(t, Pf), t);
}(e);
}
});
} catch (t) {
Hr.error("EXCEPTION in role execution for ".concat(e.name, " (").concat(i, "/").concat(a, "): ").concat(t), {
subsystem: "CreepProcessManager",
creep: e.name,
meta: {
error: String(t),
stack: t instanceof Error ? t.stack : void 0,
role: i,
family: a,
pos: "".concat(e.pos.x, ",").concat(e.pos.y, " in ").concat(e.room.name)
}
});
}
}
}(t);
}
}), this.registeredCreeps.add(e.name), Hr.info("Registered creep process: ".concat(e.name, " (").concat(t, ") with priority ").concat(r), {
subsystem: "CreepProcessManager"
});
}, e.prototype.unregisterCreepProcess = function(e) {
var t = "creep:".concat(e);
Ko.unregisterProcess(t), this.registeredCreeps.delete(e), Hr.info("Unregistered creep process: ".concat(e), {
subsystem: "CreepProcessManager"
});
}, e.prototype.getMinBucketForPriority = function(e) {
return 0;
}, e.prototype.getCpuBudgetForPriority = function(e) {
return e >= Ao.CRITICAL ? .012 : e >= Ao.HIGH ? .01 : e >= Ao.MEDIUM ? .008 : .006;
}, e.prototype.getStats = function() {
var e, t, o, n, a = {};
try {
for (var i = r(this.registeredCreeps), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = Game.creeps[c];
if (l) {
var u = jf(l.memory.role), f = null !== (o = Ao[u]) && void 0 !== o ? o : "UNKNOWN";
a[f] = (null !== (n = a[f]) && void 0 !== n ? n : 0) + 1;
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return {
totalCreeps: Object.keys(Game.creeps).length,
registeredCreeps: this.registeredCreeps.size,
creepsByPriority: a
};
}, e.prototype.forceResync = function() {
this.lastSyncTick = -1, this.syncCreepProcesses();
}, e.prototype.reset = function() {
this.registeredCreeps.clear(), this.lastSyncTick = -1;
}, e;
}(), Wf = new Hf, Yf = {
seedNest: {
rcl: 1
},
foragingExpansion: {
rcl: 3,
minRooms: 1,
minRemoteRooms: 1,
minTowerCount: 1
},
matureColony: {
rcl: 4,
requiresStorage: !0,
requiresTerminal: !0,
requiresLabs: !0,
minLabCount: 3,
minTowerCount: 2
},
fortifiedHive: {
rcl: 7,
requiresTerminal: !0,
requiresLabs: !0,
minLabCount: 6,
requiresFactory: !0,
requiresPowerSpawn: !0,
minTowerCount: 4
},
empireDominance: {
rcl: 8,
requiresNuker: !0,
requiresObserver: !0,
requiresTerminal: !0,
requiresLabs: !0,
minLabCount: 8,
requiresFactory: !0,
requiresPowerSpawn: !0,
minGcl: 10,
minRooms: 3,
minRemoteRooms: 2,
minTowerCount: 6
}
}, Kf = {
eco: {
economy: .75,
military: .05,
utility: .15,
power: .05
},
expand: {
economy: .55,
military: .15,
utility: .25,
power: .05
},
defensive: {
economy: .45,
military: .35,
utility: .15,
power: .05
},
war: {
economy: .3,
military: .5,
utility: .1,
power: .1
},
siege: {
economy: .2,
military: .6,
utility: .1,
power: .1
},
evacuate: {
economy: .1,
military: .1,
utility: .8,
power: 0
},
nukePrep: {
economy: .4,
military: .3,
utility: .2,
power: .1
}
}, Vf = {
eco: {
upgrade: 80,
build: 60,
repair: 40,
spawn: 70,
terminal: 50,
labs: 30
},
expand: {
upgrade: 60,
build: 80,
repair: 50,
spawn: 75,
terminal: 60,
labs: 40
},
defensive: {
upgrade: 30,
build: 50,
repair: 80,
spawn: 90,
terminal: 40,
labs: 60
},
war: {
upgrade: 10,
build: 30,
repair: 70,
spawn: 95,
terminal: 70,
labs: 80
},
siege: {
upgrade: 5,
build: 20,
repair: 90,
spawn: 100,
terminal: 50,
labs: 90
},
evacuate: {
upgrade: 0,
build: 5,
repair: 10,
spawn: 50,
terminal: 80,
labs: 10
},
nukePrep: {
upgrade: 20,
build: 40,
repair: 95,
spawn: 80,
terminal: 30,
labs: 70
}
}, zf = function() {
function e() {
this.STRUCTURE_CACHE_NAMESPACE = "evolution:structures", this.structureCacheTtl = 20;
}
return e.prototype.determineEvolutionStage = function(e, t, r) {
var o, n, a, i, s = null !== (n = null === (o = t.controller) || void 0 === o ? void 0 : o.level) && void 0 !== n ? n : 0, c = Game.gcl.level, l = this.getStructureCounts(t), u = null !== (i = null === (a = e.remoteAssignments) || void 0 === a ? void 0 : a.length) && void 0 !== i ? i : 0;
return this.meetsThreshold("empireDominance", s, r, c, l, u) ? "empireDominance" : this.meetsThreshold("fortifiedHive", s, r, c, l, u) ? "fortifiedHive" : this.meetsThreshold("matureColony", s, r, c, l, u) ? "matureColony" : this.meetsThreshold("foragingExpansion", s, r, c, l, u) ? "foragingExpansion" : "seedNest";
}, e.prototype.meetsThreshold = function(e, t, r, o, n, a) {
var i, s, c = Yf[e], l = null !== (i = n[STRUCTURE_TOWER]) && void 0 !== i ? i : 0, u = null !== (s = n[STRUCTURE_LAB]) && void 0 !== s ? s : 0;
return !(t < c.rcl || c.minRooms && r < c.minRooms || c.minGcl && o < c.minGcl || c.minRemoteRooms && a < c.minRemoteRooms || c.minTowerCount && l < c.minTowerCount || c.requiresStorage && !n[STRUCTURE_STORAGE] || c.requiresTerminal && t >= 6 && !n[STRUCTURE_TERMINAL] || c.requiresLabs && 0 === u || c.minLabCount && t >= 6 && u < c.minLabCount || c.requiresFactory && t >= 7 && !n[STRUCTURE_FACTORY] || c.requiresPowerSpawn && t >= 7 && !n[STRUCTURE_POWER_SPAWN] || c.requiresObserver && t >= 8 && !n[STRUCTURE_OBSERVER] || c.requiresNuker && t >= 8 && !n[STRUCTURE_NUKER]);
}, e.prototype.getStructureCounts = function(e) {
var t, o, n, a = va.get(e.name, {
namespace: this.STRUCTURE_CACHE_NAMESPACE,
ttl: this.structureCacheTtl
});
if (a) return a;
var i = {}, s = e.find(FIND_MY_STRUCTURES);
try {
for (var c = r(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value.structureType;
i[u] = (null !== (n = i[u]) && void 0 !== n ? n : 0) + 1;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (t) throw t.error;
}
}
return va.set(e.name, i, {
namespace: this.STRUCTURE_CACHE_NAMESPACE,
ttl: this.structureCacheTtl
}), i;
}, e.prototype.updateEvolutionStage = function(e, t, r) {
var o = this.determineEvolutionStage(e, t, r);
return o !== e.colonyLevel && (Hr.info("Room evolution: ".concat(e.colonyLevel, " -> ").concat(o), {
room: t.name,
subsystem: "Evolution"
}), e.colonyLevel = o, !0);
}, e.prototype.updateMissingStructures = function(e, t) {
var r, o, n, a, i, s, c, l, u, f, m, p, d = this.getStructureCounts(t), y = null !== (o = null === (r = t.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0, g = Yf[e.colonyLevel], h = g.requiresLabs && y >= 6, v = h ? null !== (n = g.minLabCount) && void 0 !== n ? n : 3 : 0, R = g.requiresFactory && y >= 7, E = g.requiresTerminal && y >= 6, T = g.requiresStorage && y >= 4, S = g.requiresPowerSpawn && y >= 7, C = g.requiresObserver && y >= 8, b = g.requiresNuker && y >= 8;
e.missingStructures = {
spawn: 0 === (null !== (a = d[STRUCTURE_SPAWN]) && void 0 !== a ? a : 0),
storage: !!T && 0 === (null !== (i = d[STRUCTURE_STORAGE]) && void 0 !== i ? i : 0),
terminal: !!E && 0 === (null !== (s = d[STRUCTURE_TERMINAL]) && void 0 !== s ? s : 0),
labs: !!h && (null !== (c = d[STRUCTURE_LAB]) && void 0 !== c ? c : 0) < v,
nuker: !!b && 0 === (null !== (l = d[STRUCTURE_NUKER]) && void 0 !== l ? l : 0),
factory: !!R && 0 === (null !== (u = d[STRUCTURE_FACTORY]) && void 0 !== u ? u : 0),
extractor: y >= 6 && 0 === (null !== (f = d[STRUCTURE_EXTRACTOR]) && void 0 !== f ? f : 0),
powerSpawn: !!S && 0 === (null !== (m = d[STRUCTURE_POWER_SPAWN]) && void 0 !== m ? m : 0),
observer: !!C && 0 === (null !== (p = d[STRUCTURE_OBSERVER]) && void 0 !== p ? p : 0)
};
}, e;
}(), qf = function() {
function e() {}
return e.prototype.determinePosture = function(e, t) {
if (t) return t;
var r = e.pheromones, o = e.danger;
return o >= 3 ? "siege" : o >= 2 ? "war" : r.siege > 30 ? "siege" : r.war > 25 ? "war" : r.defense > 20 ? "defensive" : r.nukeTarget > 40 ? "nukePrep" : r.expand > 30 && 0 === o ? "expand" : o >= 1 ? "defensive" : "eco";
}, e.prototype.updatePosture = function(e, t, r) {
var o = this.determinePosture(e, t);
if (o !== e.posture) {
var n = e.posture, a = null != r ? r : e.role;
return Hr.info("Posture change: ".concat(n, " -> ").concat(o), {
room: a,
subsystem: "Posture"
}), e.posture = o, Ko.emit("posture.change", {
roomName: a,
oldPosture: n,
newPosture: o,
source: "PostureManager"
}), !0;
}
return !1;
}, e.prototype.getSpawnProfile = function(e) {
return Kf[e];
}, e.prototype.getResourcePriorities = function(e) {
return Vf[e];
}, e.prototype.allowsBuilding = function(e) {
return "evacuate" !== e && "siege" !== e;
}, e.prototype.allowsUpgrading = function(e) {
return "evacuate" !== e && "siege" !== e && "war" !== e;
}, e.prototype.isCombatPosture = function(e) {
return "defensive" === e || "war" === e || "siege" === e;
}, e.prototype.allowsExpansion = function(e) {
return "eco" === e || "expand" === e;
}, e;
}(), Xf = new zf, Qf = new qf;

function Zf(e) {
var t, r = {
1: {
spawn: 1,
extension: 0,
road: 2500,
constructedWall: 0
},
2: {
spawn: 1,
extension: 5,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5
},
3: {
spawn: 1,
extension: 10,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 1
},
4: {
spawn: 1,
extension: 20,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 1,
storage: 1
},
5: {
spawn: 1,
extension: 30,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 2,
storage: 1,
link: 2
},
6: {
spawn: 1,
extension: 40,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 2,
storage: 1,
link: 3,
terminal: 1,
extractor: 1,
lab: 3
},
7: {
spawn: 2,
extension: 50,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 3,
storage: 1,
link: 4,
terminal: 1,
extractor: 1,
lab: 6,
factory: 1
},
8: {
spawn: 3,
extension: 60,
road: 2500,
constructedWall: 2500,
rampart: 2500,
container: 5,
tower: 6,
storage: 1,
link: 6,
terminal: 1,
extractor: 1,
lab: 10,
factory: 1,
nuker: 1,
observer: 1,
powerSpawn: 1
}
};
return null !== (t = r[e]) && void 0 !== t ? t : r[1];
}

var Jf = {
name: "seedNest",
rcl: 1,
type: "spread",
minSpaceRadius: 3,
anchor: {
x: 25,
y: 25
},
structures: [ {
x: 0,
y: 0,
structureType: STRUCTURE_SPAWN
}, {
x: -2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -2,
structureType: STRUCTURE_EXTENSION
} ],
roads: [ {
x: -1,
y: -1
}, {
x: 0,
y: -1
}, {
x: 1,
y: -1
}, {
x: -1,
y: 0
}, {
x: 1,
y: 0
}, {
x: -1,
y: 1
}, {
x: 0,
y: 1
}, {
x: 1,
y: 1
} ],
ramparts: []
}, $f = {
name: "foragingExpansion",
rcl: 3,
type: "spread",
minSpaceRadius: 4,
anchor: {
x: 25,
y: 25
},
structures: [ {
x: 0,
y: 0,
structureType: STRUCTURE_SPAWN
}, {
x: 0,
y: -4,
structureType: STRUCTURE_TOWER
}, {
x: 4,
y: 4,
structureType: STRUCTURE_STORAGE
}, {
x: -2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 4,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -3,
structureType: STRUCTURE_EXTENSION
} ],
roads: [ {
x: -1,
y: -1
}, {
x: 0,
y: -1
}, {
x: 1,
y: -1
}, {
x: -1,
y: 0
}, {
x: 1,
y: 0
}, {
x: -1,
y: 1
}, {
x: 0,
y: 1
}, {
x: 1,
y: 1
}, {
x: -2,
y: -1
}, {
x: 2,
y: -1
}, {
x: -2,
y: 1
}, {
x: 2,
y: 1
}, {
x: -1,
y: -2
}, {
x: 1,
y: -2
}, {
x: -1,
y: 2
}, {
x: 1,
y: 2
}, {
x: 0,
y: -3
}, {
x: 0,
y: 3
}, {
x: -3,
y: 0
}, {
x: 3,
y: 0
}, {
x: 3,
y: 3
}, {
x: 4,
y: 3
}, {
x: 3,
y: 4
} ],
ramparts: []
}, em = {
name: "matureColony",
rcl: 5,
type: "spread",
minSpaceRadius: 6,
anchor: {
x: 25,
y: 25
},
structures: [ {
x: 0,
y: 0,
structureType: STRUCTURE_SPAWN
}, {
x: 4,
y: 0,
structureType: STRUCTURE_SPAWN
}, {
x: 0,
y: 4,
structureType: STRUCTURE_STORAGE
}, {
x: 2,
y: 4,
structureType: STRUCTURE_TERMINAL
}, {
x: 0,
y: -4,
structureType: STRUCTURE_TOWER
}, {
x: -4,
y: 0,
structureType: STRUCTURE_TOWER
}, {
x: 4,
y: -4,
structureType: STRUCTURE_TOWER
}, {
x: -2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: 5,
structureType: STRUCTURE_LAB
}, {
x: -4,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: -5,
y: 5,
structureType: STRUCTURE_LAB
}, {
x: -2,
y: 4,
structureType: STRUCTURE_LINK
} ],
roads: [ {
x: -1,
y: -1
}, {
x: 0,
y: -1
}, {
x: 1,
y: -1
}, {
x: -1,
y: 0
}, {
x: 1,
y: 0
}, {
x: -1,
y: 1
}, {
x: 0,
y: 1
}, {
x: 1,
y: 1
}, {
x: 3,
y: -1
}, {
x: 3,
y: 0
}, {
x: 3,
y: 1
}, {
x: 4,
y: -1
}, {
x: 4,
y: 1
}, {
x: 5,
y: -1
}, {
x: 5,
y: 0
}, {
x: 5,
y: 1
}, {
x: -2,
y: -1
}, {
x: 2,
y: -1
}, {
x: -2,
y: 1
}, {
x: 2,
y: 1
}, {
x: -1,
y: -2
}, {
x: 1,
y: -2
}, {
x: -1,
y: 2
}, {
x: 1,
y: 2
}, {
x: 0,
y: -3
}, {
x: 0,
y: 3
}, {
x: -3,
y: 0
}, {
x: 3,
y: 0
} ],
ramparts: [ {
x: 0,
y: 0
}, {
x: 4,
y: 0
}, {
x: 0,
y: 4
}, {
x: 1,
y: 4
} ]
}, tm = {
name: "fortifiedHive",
rcl: 7,
type: "spread",
minSpaceRadius: 7,
anchor: {
x: 25,
y: 25
},
structures: [ {
x: 0,
y: 0,
structureType: STRUCTURE_SPAWN
}, {
x: -5,
y: -1,
structureType: STRUCTURE_SPAWN
}, {
x: 5,
y: -1,
structureType: STRUCTURE_SPAWN
}, {
x: 0,
y: 4,
structureType: STRUCTURE_STORAGE
}, {
x: 2,
y: 4,
structureType: STRUCTURE_TERMINAL
}, {
x: 0,
y: -4,
structureType: STRUCTURE_TOWER
}, {
x: -4,
y: -2,
structureType: STRUCTURE_TOWER
}, {
x: 4,
y: -2,
structureType: STRUCTURE_TOWER
}, {
x: -4,
y: 2,
structureType: STRUCTURE_TOWER
}, {
x: 4,
y: 2,
structureType: STRUCTURE_TOWER
}, {
x: 0,
y: 6,
structureType: STRUCTURE_TOWER
}, {
x: -2,
y: 4,
structureType: STRUCTURE_FACTORY
}, {
x: -4,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: -3,
y: 5,
structureType: STRUCTURE_LAB
}, {
x: -4,
y: 6,
structureType: STRUCTURE_LAB
}, {
x: -5,
y: 5,
structureType: STRUCTURE_LAB
}, {
x: -6,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: -6,
y: 6,
structureType: STRUCTURE_LAB
}, {
x: -2,
y: 6,
structureType: STRUCTURE_LAB
}, {
x: -5,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: -7,
y: 5,
structureType: STRUCTURE_LAB
}, {
x: -3,
y: 7,
structureType: STRUCTURE_LAB
}, {
x: 4,
y: 4,
structureType: STRUCTURE_NUKER
}, {
x: 6,
y: 0,
structureType: STRUCTURE_OBSERVER
}, {
x: -1,
y: 5,
structureType: STRUCTURE_POWER_SPAWN
}, {
x: 1,
y: 5,
structureType: STRUCTURE_LINK
}, {
x: 5,
y: -3,
structureType: STRUCTURE_LINK
}, {
x: -5,
y: -3,
structureType: STRUCTURE_LINK
}, {
x: -2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: -1,
structureType: STRUCTURE_EXTENSION
} ],
roads: [ {
x: -1,
y: -1
}, {
x: 0,
y: -1
}, {
x: 1,
y: -1
}, {
x: -1,
y: 0
}, {
x: 1,
y: 0
}, {
x: -1,
y: 1
}, {
x: 0,
y: 1
}, {
x: 1,
y: 1
}, {
x: -6,
y: -2
}, {
x: -5,
y: -2
}, {
x: -4,
y: -2
}, {
x: -6,
y: -1
}, {
x: -4,
y: -1
}, {
x: -6,
y: 0
}, {
x: -5,
y: 0
}, {
x: -4,
y: 0
}, {
x: 4,
y: -2
}, {
x: 5,
y: -2
}, {
x: 6,
y: -2
}, {
x: 4,
y: -1
}, {
x: 6,
y: -1
}, {
x: 4,
y: 0
}, {
x: 5,
y: 0
}, {
x: 6,
y: 0
}, {
x: -3,
y: 0
}, {
x: 3,
y: 0
}, {
x: 0,
y: -3
}, {
x: 0,
y: 3
}, {
x: -2,
y: -1
}, {
x: 2,
y: -1
}, {
x: -2,
y: 1
}, {
x: 2,
y: 1
}, {
x: -1,
y: -2
}, {
x: 1,
y: -2
}, {
x: -1,
y: 2
}, {
x: 1,
y: 2
} ],
ramparts: [ {
x: 0,
y: 0
}, {
x: -5,
y: -1
}, {
x: 5,
y: -1
}, {
x: 0,
y: 4
}, {
x: 2,
y: 4
}, {
x: 0,
y: -4
}, {
x: -4,
y: -2
}, {
x: 4,
y: -2
}, {
x: -4,
y: 2
}, {
x: 4,
y: 2
}, {
x: 0,
y: 6
}, {
x: 4,
y: 4
}, {
x: -1,
y: 5
} ]
}, rm = {
name: "compactBunker",
rcl: 8,
type: "bunker",
minSpaceRadius: 6,
anchor: {
x: 25,
y: 25
},
structures: [ {
x: 0,
y: 0,
structureType: STRUCTURE_STORAGE
}, {
x: -1,
y: 1,
structureType: STRUCTURE_TERMINAL
}, {
x: 1,
y: 1,
structureType: STRUCTURE_FACTORY
}, {
x: 0,
y: -2,
structureType: STRUCTURE_SPAWN
}, {
x: -2,
y: 1,
structureType: STRUCTURE_SPAWN
}, {
x: 2,
y: 1,
structureType: STRUCTURE_SPAWN
}, {
x: 0,
y: 2,
structureType: STRUCTURE_POWER_SPAWN
}, {
x: -2,
y: -1,
structureType: STRUCTURE_NUKER
}, {
x: -3,
y: -2,
structureType: STRUCTURE_TOWER
}, {
x: 3,
y: -2,
structureType: STRUCTURE_TOWER
}, {
x: -4,
y: 0,
structureType: STRUCTURE_TOWER
}, {
x: 4,
y: 0,
structureType: STRUCTURE_TOWER
}, {
x: -3,
y: 3,
structureType: STRUCTURE_TOWER
}, {
x: 3,
y: 3,
structureType: STRUCTURE_TOWER
}, {
x: -2,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: -1,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: -3,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: -2,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: -1,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: 0,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: 0,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: 1,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: 1,
y: 4,
structureType: STRUCTURE_LAB
}, {
x: 2,
y: 3,
structureType: STRUCTURE_LAB
}, {
x: 2,
y: -1,
structureType: STRUCTURE_OBSERVER
}, {
x: -1,
y: -1,
structureType: STRUCTURE_LINK
}, {
x: 1,
y: -1,
structureType: STRUCTURE_LINK
}, {
x: -3,
y: 1,
structureType: STRUCTURE_LINK
}, {
x: 3,
y: 1,
structureType: STRUCTURE_LINK
}, {
x: -1,
y: -3,
structureType: STRUCTURE_LINK
}, {
x: 1,
y: -3,
structureType: STRUCTURE_LINK
}, {
x: -2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: -2,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 0,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 2,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: 4,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: 4,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: -6,
structureType: STRUCTURE_EXTENSION
}, {
x: -2,
y: -6,
structureType: STRUCTURE_EXTENSION
}, {
x: 0,
y: -6,
structureType: STRUCTURE_EXTENSION
}, {
x: 2,
y: -6,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: -6,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: -4,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: 4,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 4,
structureType: STRUCTURE_EXTENSION
}, {
x: -6,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: -4,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: 4,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: 6,
y: 6,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: -5,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: -3,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: -1,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: 1,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: 3,
structureType: STRUCTURE_EXTENSION
}, {
x: -5,
y: 5,
structureType: STRUCTURE_EXTENSION
}, {
x: -3,
y: 5,
structureType: STRUCTURE_EXTENSION
}, {
x: -1,
y: 5,
structureType: STRUCTURE_EXTENSION
}, {
x: 1,
y: 5,
structureType: STRUCTURE_EXTENSION
}, {
x: 3,
y: 5,
structureType: STRUCTURE_EXTENSION
}, {
x: 5,
y: 5,
structureType: STRUCTURE_EXTENSION
} ],
roads: [ {
x: -1,
y: 0
}, {
x: 1,
y: 0
}, {
x: 0,
y: -1
}, {
x: 0,
y: 1
}, {
x: -1,
y: -2
}, {
x: 1,
y: -2
}, {
x: -2,
y: 0
}, {
x: 2,
y: 0
}, {
x: -2,
y: 2
}, {
x: 2,
y: 2
}, {
x: 0,
y: -3
}, {
x: 0,
y: 3
}, {
x: -3,
y: 0
}, {
x: 3,
y: 0
}, {
x: -1,
y: 2
}, {
x: 1,
y: 2
}, {
x: -3,
y: -1
}, {
x: 3,
y: -1
}, {
x: -4,
y: -1
}, {
x: 4,
y: -1
}, {
x: -4,
y: 1
}, {
x: 4,
y: 1
}, {
x: -3,
y: 2
}, {
x: 3,
y: 2
}, {
x: -3,
y: 3
}, {
x: 3,
y: 3
} ],
ramparts: [ {
x: 0,
y: 0
}, {
x: -1,
y: 1
}, {
x: 1,
y: 1
}, {
x: 0,
y: -2
}, {
x: -2,
y: 1
}, {
x: 2,
y: 1
}, {
x: 0,
y: 2
}, {
x: -2,
y: -1
}, {
x: 2,
y: -1
}, {
x: -3,
y: -2
}, {
x: 3,
y: -2
}, {
x: -4,
y: 0
}, {
x: 4,
y: 0
}, {
x: -3,
y: 3
}, {
x: 3,
y: 3
}, {
x: -2,
y: 3
}, {
x: -1,
y: 3
}, {
x: -4,
y: -2
}, {
x: 4,
y: -2
}, {
x: -4,
y: 2
}, {
x: 4,
y: 2
}, {
x: -2,
y: -2
}, {
x: 2,
y: -2
} ]
};

function om(e, t, r) {
for (var o = e.getTerrain(), n = -1; n <= 1; n++) for (var a = -1; a <= 1; a++) {
var i = t + n, s = r + a;
if (i < 1 || i > 48 || s < 1 || s > 48) return !1;
if (o.get(i, s) === TERRAIN_MASK_WALL) return !1;
}
return !0;
}

function nm(e, t, o) {
var n, a, i, s, c, l = e.getTerrain(), u = null !== (c = o.minSpaceRadius) && void 0 !== c ? c : 7, f = 0, m = 0;
if (t.x < u || t.x > 49 - u || t.y < u || t.y > 49 - u) return {
fits: !1,
reason: "Anchor too close to room edge (needs ".concat(u, " tile margin)")
};
try {
for (var p = r(o.structures), d = p.next(); !d.done; d = p.next()) {
var y = d.value, g = t.x + y.x, h = t.y + y.y;
if (g < 1 || g > 48 || h < 1 || h > 48) return {
fits: !1,
reason: "Structure ".concat(y.structureType, " at (").concat(y.x, ",").concat(y.y, ") would be outside room bounds")
};
m++, l.get(g, h) === TERRAIN_MASK_WALL && f++;
}
} catch (e) {
n = {
error: e
};
} finally {
try {
d && !d.done && (a = p.return) && a.call(p);
} finally {
if (n) throw n.error;
}
}
try {
for (var v = r(o.roads), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
g = t.x + E.x, h = t.y + E.y, g < 1 || g > 48 || h < 1 || h > 48 || (m++, l.get(g, h) === TERRAIN_MASK_WALL && f++);
}
} catch (e) {
i = {
error: e
};
} finally {
try {
R && !R.done && (s = v.return) && s.call(v);
} finally {
if (i) throw i.error;
}
}
var T = m > 0 ? f / m * 100 : 0;
return "bunker" === o.type && T > 10 ? {
fits: !1,
reason: "Too many walls in blueprint area (".concat(T.toFixed(1), "% walls, max ").concat(10, "% for bunker)"),
wallCount: f,
totalTiles: m
} : "spread" === o.type && T > 25 ? {
fits: !1,
reason: "Too many walls in blueprint area (".concat(T.toFixed(1), "% walls, max ").concat(25, "% for spread layout)"),
wallCount: f,
totalTiles: m
} : {
fits: !0,
wallCount: f,
totalTiles: m
};
}

function am(e, t) {
var o, n, a, i, s, c = e.controller;
if (!c) return null;
var l = e.find(FIND_SOURCES), u = c.pos.x, f = c.pos.y;
try {
for (var m = r(l), p = m.next(); !p.done; p = m.next()) u += (M = p.value).pos.x, 
f += M.pos.y;
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
for (var d = Math.round(u / (l.length + 1)), y = Math.round(f / (l.length + 1)), g = null !== (s = t.minSpaceRadius) && void 0 !== s ? s : 7, h = [], v = 0; v <= 15; v++) {
for (var R = -v; R <= v; R++) for (var E = -v; E <= v; E++) if (!(Math.abs(R) !== v && Math.abs(E) !== v && v > 0)) {
var T = d + R, S = y + E;
if (!(T < g || T > 49 - g || S < g || S > 49 - g)) {
var C = new RoomPosition(T, S, e.name), b = nm(e, C, t);
if (b.fits) {
var _ = 1e3, O = C.getRangeTo(c);
O >= 4 && O <= 8 ? _ += 100 : O < 4 ? _ -= 50 : O > 12 && (_ -= 30);
var w = 0;
try {
for (var x = (a = void 0, r(l)), U = x.next(); !U.done; U = x.next()) {
var M = U.value;
w += C.getRangeTo(M);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
U && !U.done && (i = x.return) && i.call(x);
} finally {
if (a) throw a.error;
}
}
var A = w / l.length;
A >= 5 && A <= 10 ? _ += 80 : A < 5 && (_ -= 20);
var k = Math.abs(T - 25) + Math.abs(S - 25);
if (k < 10 ? _ += 50 : k > 20 && (_ -= 30), void 0 !== b.wallCount && void 0 !== b.totalTiles) {
var N = b.wallCount / b.totalTiles * 100;
_ += Math.max(0, 50 - 2 * N);
}
h.push({
pos: C,
score: _
});
}
}
}
if (h.length > 0) return h.sort(function(e, t) {
return t.score - e.score;
}), h[0].pos;
}
return null;
}

function im(e, t) {
var r, a = Zf(t), i = {}, s = e.structures.filter(function(e) {
var t, r, o = e.structureType, n = null !== (t = a[o]) && void 0 !== t ? t : 0, s = null !== (r = i[o]) && void 0 !== r ? r : 0;
return !(s >= n || (i[o] = s + 1, 0));
}), c = null !== (r = a[STRUCTURE_EXTENSION]) && void 0 !== r ? r : 0;
return c > 0 && (s = function(e, t) {
var r = t - e.filter(function(e) {
return e.structureType === STRUCTURE_EXTENSION;
}).length;
if (r <= 0) return e;
var a = function() {
for (var e = [], t = [ {
x: -2,
y: 0
}, {
x: 2,
y: 0
}, {
x: 0,
y: -2
}, {
x: 0,
y: 2
}, {
x: -2,
y: -2
}, {
x: 2,
y: -2
}, {
x: -2,
y: 2
}, {
x: 2,
y: 2
}, {
x: -1,
y: -3
}, {
x: 1,
y: -3
}, {
x: -1,
y: 3
}, {
x: 1,
y: 3
}, {
x: -3,
y: -1
}, {
x: 3,
y: -1
}, {
x: -3,
y: 1
}, {
x: 3,
y: 1
}, {
x: -4,
y: 0
}, {
x: 4,
y: 0
}, {
x: 0,
y: -4
}, {
x: 0,
y: 4
}, {
x: -3,
y: -3
}, {
x: 3,
y: -3
}, {
x: -3,
y: 3
}, {
x: 3,
y: 3
}, {
x: -4,
y: -2
}, {
x: 4,
y: -2
}, {
x: -4,
y: 2
}, {
x: 4,
y: 2
}, {
x: -2,
y: -4
}, {
x: 2,
y: -4
}, {
x: -2,
y: 4
}, {
x: 2,
y: 4
}, {
x: -1,
y: -5
}, {
x: 1,
y: -5
}, {
x: -1,
y: 5
}, {
x: 1,
y: 5
}, {
x: -5,
y: -1
}, {
x: 5,
y: -1
}, {
x: -5,
y: 1
}, {
x: 5,
y: 1
}, {
x: -4,
y: -4
}, {
x: 4,
y: -4
}, {
x: -4,
y: 4
}, {
x: 4,
y: 4
}, {
x: -3,
y: -5
}, {
x: 3,
y: -5
}, {
x: -3,
y: 5
}, {
x: 3,
y: 5
}, {
x: -5,
y: -3
}, {
x: 5,
y: -3
}, {
x: -5,
y: 3
}, {
x: 5,
y: 3
}, {
x: -6,
y: 0
}, {
x: 6,
y: 0
}, {
x: 0,
y: -6
}, {
x: 0,
y: 6
}, {
x: -6,
y: -2
}, {
x: 6,
y: -2
}, {
x: -6,
y: 2
}, {
x: 6,
y: 2
}, {
x: -2,
y: -6
}, {
x: 2,
y: -6
}, {
x: -2,
y: 6
}, {
x: 2,
y: 6
}, {
x: -5,
y: -5
}, {
x: 5,
y: -5
}, {
x: -5,
y: 5
}, {
x: 5,
y: 5
}, {
x: -4,
y: -6
}, {
x: 4,
y: -6
}, {
x: -4,
y: 6
}, {
x: 4,
y: 6
}, {
x: -6,
y: -4
}, {
x: 6,
y: -4
}, {
x: -6,
y: 4
}, {
x: 6,
y: 4
} ], r = 0; r < Math.min(80, t.length); r++) e.push({
x: t[r].x,
y: t[r].y,
structureType: STRUCTURE_EXTENSION
});
return e;
}(), i = new Set(e.map(function(e) {
return "".concat(e.x, ",").concat(e.y);
})), s = a.filter(function(e) {
return !i.has("".concat(e.x, ",").concat(e.y));
}).slice(0, r);
return n(n([], o(e), !1), o(s), !1);
}(s, c)), s;
}

function sm(e) {
return function(e) {
return e >= 7 ? tm : e >= 5 ? em : e >= 3 ? $f : Jf;
}(e);
}

function cm(e, t) {
if (t >= 8) {
var o = am(e, rm);
if (o) return {
blueprint: rm,
anchor: o
};
if (n = am(e, tm)) return {
blueprint: tm,
anchor: n
};
}
var n;
if (t >= 7 && (n = am(e, tm))) return {
blueprint: tm,
anchor: n
};
if (t >= 5) {
var a = am(e, em);
if (a) return {
blueprint: em,
anchor: a
};
}
if (t >= 3) {
var i = am(e, $f);
if (i) return {
blueprint: $f,
anchor: i
};
}
var s = am(e, Jf);
if (s) return {
blueprint: Jf,
anchor: s
};
var c = function(e) {
var t, o, n = e.controller;
if (!n) return null;
var a = e.find(FIND_SOURCES), i = e.getTerrain(), s = n.pos.x, c = n.pos.y;
try {
for (var l = r(a), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
s += f.pos.x, c += f.pos.y;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (o = l.return) && o.call(l);
} finally {
if (t) throw t.error;
}
}
for (var m = Math.round(s / (a.length + 1)), p = Math.round(c / (a.length + 1)), d = 0; d < 15; d++) for (var y = -d; y <= d; y++) for (var g = -d; g <= d; g++) if (Math.abs(y) === d || Math.abs(g) === d) {
var h = m + y, v = p + g;
if (!(h < 3 || h > 46 || v < 3 || v > 46) && om(e, h, v)) {
if (Math.max(Math.abs(h - n.pos.x), Math.abs(v - n.pos.y)) > 20) continue;
if (i.get(h, v) === TERRAIN_MASK_WALL) continue;
return new RoomPosition(h, v, e.name);
}
}
return null;
}(e);
return c ? {
blueprint: Jf,
anchor: c
} : null;
}

var lm, um = [ STRUCTURE_EXTENSION, STRUCTURE_ROAD, STRUCTURE_TOWER, STRUCTURE_LAB, STRUCTURE_LINK, STRUCTURE_FACTORY, STRUCTURE_OBSERVER, STRUCTURE_NUKER, STRUCTURE_POWER_SPAWN, STRUCTURE_EXTRACTOR ], fm = new Set(um), mm = {}, pm = {};

function dm() {
return lm || (lm = 1, Object.defineProperty(pm, "__esModule", {
value: !0
}), pm.noopLogger = void 0, pm.noopLogger = {
info: function() {},
warn: function() {},
error: function() {},
debug: function() {}
}), pm;
}

var ym, gm = {};

function hm() {
return ym || (ym = 1, function(e) {
var t;
Object.defineProperty(e, "__esModule", {
value: !0
}), e.REACTIONS = void 0, e.getReaction = function(t) {
return e.REACTIONS[t];
}, e.calculateReactionChain = function(t, r) {
var o = [], n = new Set, a = function(t) {
var i, s, c;
if (n.has(t)) return !0;
n.add(t);
var l = e.REACTIONS[t];
return l ? !((null !== (s = r[l.input1]) && void 0 !== s ? s : 0) < 100 && !a(l.input1) || (null !== (c = r[l.input2]) && void 0 !== c ? c : 0) < 100 && !a(l.input2) || (o.push(l), 
0)) : (null !== (i = r[t]) && void 0 !== i ? i : 0) > 0;
};
return a(t), o;
}, e.hasResourcesForReaction = function(e, t, r) {
var o, n;
void 0 === r && (r = 100);
var a = null !== (o = e.store[t.input1]) && void 0 !== o ? o : 0, i = null !== (n = e.store[t.input2]) && void 0 !== n ? n : 0;
return a >= r && i >= r;
}, e.REACTIONS = ((t = {})[RESOURCE_HYDROXIDE] = {
product: RESOURCE_HYDROXIDE,
input1: RESOURCE_HYDROGEN,
input2: RESOURCE_OXYGEN,
priority: 10
}, t[RESOURCE_ZYNTHIUM_KEANITE] = {
product: RESOURCE_ZYNTHIUM_KEANITE,
input1: RESOURCE_ZYNTHIUM,
input2: RESOURCE_KEANIUM,
priority: 10
}, t[RESOURCE_UTRIUM_LEMERGITE] = {
product: RESOURCE_UTRIUM_LEMERGITE,
input1: RESOURCE_UTRIUM,
input2: RESOURCE_LEMERGIUM,
priority: 10
}, t[RESOURCE_GHODIUM] = {
product: RESOURCE_GHODIUM,
input1: RESOURCE_ZYNTHIUM_KEANITE,
input2: RESOURCE_UTRIUM_LEMERGITE,
priority: 15
}, t[RESOURCE_UTRIUM_HYDRIDE] = {
product: RESOURCE_UTRIUM_HYDRIDE,
input1: RESOURCE_UTRIUM,
input2: RESOURCE_HYDROGEN,
priority: 20
}, t[RESOURCE_UTRIUM_OXIDE] = {
product: RESOURCE_UTRIUM_OXIDE,
input1: RESOURCE_UTRIUM,
input2: RESOURCE_OXYGEN,
priority: 20
}, t[RESOURCE_KEANIUM_HYDRIDE] = {
product: RESOURCE_KEANIUM_HYDRIDE,
input1: RESOURCE_KEANIUM,
input2: RESOURCE_HYDROGEN,
priority: 20
}, t[RESOURCE_KEANIUM_OXIDE] = {
product: RESOURCE_KEANIUM_OXIDE,
input1: RESOURCE_KEANIUM,
input2: RESOURCE_OXYGEN,
priority: 20
}, t[RESOURCE_LEMERGIUM_HYDRIDE] = {
product: RESOURCE_LEMERGIUM_HYDRIDE,
input1: RESOURCE_LEMERGIUM,
input2: RESOURCE_HYDROGEN,
priority: 20
}, t[RESOURCE_LEMERGIUM_OXIDE] = {
product: RESOURCE_LEMERGIUM_OXIDE,
input1: RESOURCE_LEMERGIUM,
input2: RESOURCE_OXYGEN,
priority: 20
}, t[RESOURCE_ZYNTHIUM_HYDRIDE] = {
product: RESOURCE_ZYNTHIUM_HYDRIDE,
input1: RESOURCE_ZYNTHIUM,
input2: RESOURCE_HYDROGEN,
priority: 20
}, t[RESOURCE_ZYNTHIUM_OXIDE] = {
product: RESOURCE_ZYNTHIUM_OXIDE,
input1: RESOURCE_ZYNTHIUM,
input2: RESOURCE_OXYGEN,
priority: 20
}, t[RESOURCE_GHODIUM_HYDRIDE] = {
product: RESOURCE_GHODIUM_HYDRIDE,
input1: RESOURCE_GHODIUM,
input2: RESOURCE_HYDROGEN,
priority: 20
}, t[RESOURCE_GHODIUM_OXIDE] = {
product: RESOURCE_GHODIUM_OXIDE,
input1: RESOURCE_GHODIUM,
input2: RESOURCE_OXYGEN,
priority: 20
}, t[RESOURCE_UTRIUM_ACID] = {
product: RESOURCE_UTRIUM_ACID,
input1: RESOURCE_UTRIUM_HYDRIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_UTRIUM_ALKALIDE] = {
product: RESOURCE_UTRIUM_ALKALIDE,
input1: RESOURCE_UTRIUM_OXIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_KEANIUM_ACID] = {
product: RESOURCE_KEANIUM_ACID,
input1: RESOURCE_KEANIUM_HYDRIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_KEANIUM_ALKALIDE] = {
product: RESOURCE_KEANIUM_ALKALIDE,
input1: RESOURCE_KEANIUM_OXIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_LEMERGIUM_ACID] = {
product: RESOURCE_LEMERGIUM_ACID,
input1: RESOURCE_LEMERGIUM_HYDRIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_LEMERGIUM_ALKALIDE] = {
product: RESOURCE_LEMERGIUM_ALKALIDE,
input1: RESOURCE_LEMERGIUM_OXIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_ZYNTHIUM_ACID] = {
product: RESOURCE_ZYNTHIUM_ACID,
input1: RESOURCE_ZYNTHIUM_HYDRIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_ZYNTHIUM_ALKALIDE] = {
product: RESOURCE_ZYNTHIUM_ALKALIDE,
input1: RESOURCE_ZYNTHIUM_OXIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_GHODIUM_ACID] = {
product: RESOURCE_GHODIUM_ACID,
input1: RESOURCE_GHODIUM_HYDRIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_GHODIUM_ALKALIDE] = {
product: RESOURCE_GHODIUM_ALKALIDE,
input1: RESOURCE_GHODIUM_OXIDE,
input2: RESOURCE_HYDROXIDE,
priority: 30
}, t[RESOURCE_CATALYZED_UTRIUM_ACID] = {
product: RESOURCE_CATALYZED_UTRIUM_ACID,
input1: RESOURCE_UTRIUM_ACID,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_UTRIUM_ALKALIDE] = {
product: RESOURCE_CATALYZED_UTRIUM_ALKALIDE,
input1: RESOURCE_UTRIUM_ALKALIDE,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_KEANIUM_ACID] = {
product: RESOURCE_CATALYZED_KEANIUM_ACID,
input1: RESOURCE_KEANIUM_ACID,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] = {
product: RESOURCE_CATALYZED_KEANIUM_ALKALIDE,
input1: RESOURCE_KEANIUM_ALKALIDE,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_LEMERGIUM_ACID] = {
product: RESOURCE_CATALYZED_LEMERGIUM_ACID,
input1: RESOURCE_LEMERGIUM_ACID,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] = {
product: RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE,
input1: RESOURCE_LEMERGIUM_ALKALIDE,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_ZYNTHIUM_ACID] = {
product: RESOURCE_CATALYZED_ZYNTHIUM_ACID,
input1: RESOURCE_ZYNTHIUM_ACID,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE] = {
product: RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE,
input1: RESOURCE_ZYNTHIUM_ALKALIDE,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_GHODIUM_ACID] = {
product: RESOURCE_CATALYZED_GHODIUM_ACID,
input1: RESOURCE_GHODIUM_ACID,
input2: RESOURCE_CATALYST,
priority: 40
}, t[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] = {
product: RESOURCE_CATALYZED_GHODIUM_ALKALIDE,
input1: RESOURCE_GHODIUM_ALKALIDE,
input2: RESOURCE_CATALYST,
priority: 40
}, t);
}(gm)), gm;
}

var vm, Rm, Em = {}, Tm = {};

function Sm() {
return vm || (vm = 1, function(e) {
var t;
Object.defineProperty(e, "__esModule", {
value: !0
}), e.BASE_STOCKPILE_TARGETS = void 0, e.getStockpileTarget = function(t, r) {
var o, n, a, i = null !== (o = e.BASE_STOCKPILE_TARGETS[t]) && void 0 !== o ? o : 1e3, s = null !== (n = r.pheromones.war) && void 0 !== n ? n : 0, c = null !== (a = r.pheromones.siege) && void 0 !== a ? a : 0, l = Math.max(s, c), u = l > 50 ? 1 + l / 100 * .5 : 1;
return !("war" === r.posture || "siege" === r.posture || l > 50) || t !== RESOURCE_CATALYZED_UTRIUM_ACID && t !== RESOURCE_CATALYZED_KEANIUM_ALKALIDE && t !== RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE && t !== RESOURCE_CATALYZED_GHODIUM_ACID ? "war" !== r.posture && "siege" !== r.posture || t !== RESOURCE_CATALYZED_GHODIUM_ALKALIDE && t !== RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE ? i : .5 * i : i * Math.min(1.5 * u, 1.75);
}, e.getTargetCompounds = function(e) {
var t = [];
return t.push(RESOURCE_GHODIUM, RESOURCE_HYDROXIDE), "war" === e.posture || "siege" === e.posture || e.danger >= 2 ? t.push(RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_KEANIUM_ALKALIDE, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE, RESOURCE_CATALYZED_GHODIUM_ACID) : t.push(RESOURCE_CATALYZED_GHODIUM_ALKALIDE, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE), 
t;
}, e.BASE_STOCKPILE_TARGETS = ((t = {})[RESOURCE_CATALYZED_UTRIUM_ACID] = 3e3, t[RESOURCE_CATALYZED_KEANIUM_ALKALIDE] = 3e3, 
t[RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE] = 3e3, t[RESOURCE_CATALYZED_GHODIUM_ACID] = 3e3, 
t[RESOURCE_CATALYZED_GHODIUM_ALKALIDE] = 2e3, t[RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE] = 2e3, 
t[RESOURCE_GHODIUM] = 5e3, t[RESOURCE_HYDROXIDE] = 5e3, t);
}(Tm)), Tm;
}

var Cm, bm, _m, Om = {}, wm = {}, xm = (_m || (_m = 1, function(e) {
Object.defineProperty(e, "__esModule", {
value: !0
}), e.LabConfigManager = e.calculateBoostCost = e.getBoostConfig = e.BOOST_CONFIGS = e.getTargetCompounds = e.getStockpileTarget = e.BASE_STOCKPILE_TARGETS = e.ChemistryManager = e.hasResourcesForReaction = e.calculateReactionChain = e.getReaction = e.REACTIONS = e.noopLogger = void 0;
var t = dm();
Object.defineProperty(e, "noopLogger", {
enumerable: !0,
get: function() {
return t.noopLogger;
}
});
var r = hm();
Object.defineProperty(e, "REACTIONS", {
enumerable: !0,
get: function() {
return r.REACTIONS;
}
}), Object.defineProperty(e, "getReaction", {
enumerable: !0,
get: function() {
return r.getReaction;
}
}), Object.defineProperty(e, "calculateReactionChain", {
enumerable: !0,
get: function() {
return r.calculateReactionChain;
}
}), Object.defineProperty(e, "hasResourcesForReaction", {
enumerable: !0,
get: function() {
return r.hasResourcesForReaction;
}
});
var o = function() {
if (Rm) return Em;
Rm = 1, Object.defineProperty(Em, "__esModule", {
value: !0
}), Em.ChemistryManager = void 0;
var e = dm(), t = hm(), r = Sm(), o = function() {
function o(t) {
var r;
void 0 === t && (t = {}), this.logger = null !== (r = t.logger) && void 0 !== r ? r : e.noopLogger;
}
return o.prototype.getReaction = function(e) {
return t.REACTIONS[e];
}, o.prototype.calculateReactionChain = function(e, r) {
return (0, t.calculateReactionChain)(e, r);
}, o.prototype.hasResourcesForReaction = function(e, r, o) {
return void 0 === o && (o = 100), (0, t.hasResourcesForReaction)(e, r, o);
}, o.prototype.planReactions = function(e, o) {
var n;
if (e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
}).length < 3) return null;
var a = e.terminal;
if (!a) return null;
for (var i = 0, s = (0, r.getTargetCompounds)(o); i < s.length; i++) {
var c = s[i];
if (t.REACTIONS[c] && (null !== (n = a.store[c]) && void 0 !== n ? n : 0) < (0, 
r.getStockpileTarget)(c, o)) {
for (var l = {}, u = 0, f = Object.entries(a.store); u < f.length; u++) {
var m = f[u], p = m[0], d = m[1];
l[p] = d;
}
for (var y = this.calculateReactionChain(c, l), g = 0, h = y; g < h.length; g++) {
var v = h[g];
if (this.hasResourcesForReaction(a, v, 1e3)) return v;
}
y.length > 0 && this.logger.debug("Cannot produce ".concat(c, ": missing inputs in reaction chain"), {
subsystem: "Chemistry",
room: e.name
});
}
}
return null;
}, o.prototype.scheduleCompoundProduction = function(e, o) {
for (var n, a = [], i = 0, s = e; i < s.length; i++) {
var c = s[i], l = c.terminal;
if (l) for (var u = 0, f = (0, r.getTargetCompounds)(o); u < f.length; u++) {
var m = f[u], p = t.REACTIONS[m];
if (p) {
var d = null !== (n = l.store[m]) && void 0 !== n ? n : 0, y = (0, r.getStockpileTarget)(m, o), g = y - d;
if (g > 0) {
for (var h = g / y, v = p.priority * (1 + Math.min(h, .5)), R = {}, E = 0, T = Object.entries(l.store); E < T.length; E++) {
var S = T[E], C = S[0], b = S[1];
R[C] = b;
}
for (var _ = 0, O = this.calculateReactionChain(m, R); _ < O.length; _++) {
var w = O[_];
if (this.hasResourcesForReaction(l, w, 1e3)) {
a.push({
room: c,
reaction: w,
priority: v
});
break;
}
}
}
}
}
}
return a.sort(function(e, t) {
return t.priority - e.priority;
}), a;
}, o.prototype.executeReaction = function(e, t) {
var r = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
if (!(r.length < 3)) {
var o = r[0], n = r[1];
if (o && n) {
var a = r.slice(2);
(o.mineralType !== t.input1 || o.store[t.input1] < 500) && this.logger.debug("Lab ".concat(o.id, " needs ").concat(t.input1), {
subsystem: "Chemistry"
}), (n.mineralType !== t.input2 || n.store[t.input2] < 500) && this.logger.debug("Lab ".concat(n.id, " needs ").concat(t.input2), {
subsystem: "Chemistry"
});
for (var i = 0, s = a; i < s.length; i++) {
var c = s[i];
if (!(c.cooldown > 0)) {
var l = c.store.getFreeCapacity();
null !== l && l < 100 ? this.logger.debug("Lab ".concat(c.id, " is full, needs unloading"), {
subsystem: "Chemistry"
}) : c.runReaction(o, n) === OK && this.logger.debug("Produced ".concat(t.product, " in lab ").concat(c.id), {
subsystem: "Chemistry"
});
}
}
}
}
}, o;
}();
return Em.ChemistryManager = o, Em;
}();
Object.defineProperty(e, "ChemistryManager", {
enumerable: !0,
get: function() {
return o.ChemistryManager;
}
});
var n = Sm();
Object.defineProperty(e, "BASE_STOCKPILE_TARGETS", {
enumerable: !0,
get: function() {
return n.BASE_STOCKPILE_TARGETS;
}
}), Object.defineProperty(e, "getStockpileTarget", {
enumerable: !0,
get: function() {
return n.getStockpileTarget;
}
}), Object.defineProperty(e, "getTargetCompounds", {
enumerable: !0,
get: function() {
return n.getTargetCompounds;
}
});
var a = (Cm || (Cm = 1, function(e) {
function t(t) {
return e.BOOST_CONFIGS.find(function(e) {
return e.role === t;
});
}
Object.defineProperty(e, "__esModule", {
value: !0
}), e.BOOST_CONFIGS = void 0, e.getBoostConfig = t, e.calculateBoostCost = function(e, r) {
var o = t(e);
return o ? {
mineral: 30 * r * o.boosts.length,
energy: 20 * r * o.boosts.length
} : {
mineral: 0,
energy: 0
};
}, e.BOOST_CONFIGS = [ {
role: "soldier",
boosts: [ RESOURCE_CATALYZED_UTRIUM_ACID, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE ],
minDanger: 2
}, {
role: "ranger",
boosts: [ RESOURCE_CATALYZED_KEANIUM_ALKALIDE, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE ],
minDanger: 2
}, {
role: "healer",
boosts: [ RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE, RESOURCE_CATALYZED_ZYNTHIUM_ALKALIDE ],
minDanger: 2
}, {
role: "siegeUnit",
boosts: [ RESOURCE_CATALYZED_GHODIUM_ACID, RESOURCE_CATALYZED_LEMERGIUM_ALKALIDE ],
minDanger: 1
} ];
}(Om)), Om);
Object.defineProperty(e, "BOOST_CONFIGS", {
enumerable: !0,
get: function() {
return a.BOOST_CONFIGS;
}
}), Object.defineProperty(e, "getBoostConfig", {
enumerable: !0,
get: function() {
return a.getBoostConfig;
}
}), Object.defineProperty(e, "calculateBoostCost", {
enumerable: !0,
get: function() {
return a.calculateBoostCost;
}
});
var i = function() {
if (bm) return wm;
bm = 1, Object.defineProperty(wm, "__esModule", {
value: !0
}), wm.LabConfigManager = void 0;
var e = dm(), t = function() {
function t(t) {
var r;
void 0 === t && (t = {}), this.configs = new Map, this.logger = null !== (r = t.logger) && void 0 !== r ? r : e.noopLogger;
}
return t.prototype.initialize = function(e) {
var t, r = Game.rooms[e];
if (r && (null === (t = r.controller) || void 0 === t ? void 0 : t.my)) {
var o = r.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
if (0 !== o.length) {
var n = this.configs.get(e);
n || (n = {
roomName: e,
labs: [],
lastUpdate: Game.time,
isValid: !1
}, this.configs.set(e, n)), this.updateLabEntries(n, o), n.isValid || this.autoAssignRoles(n, o);
} else this.configs.delete(e);
}
}, t.prototype.updateLabEntries = function(e, t) {
e.labs = e.labs.filter(function(e) {
return t.some(function(t) {
return t.id === e.labId;
});
});
for (var r = function(t) {
e.labs.find(function(e) {
return e.labId === t.id;
}) || e.labs.push({
labId: t.id,
role: "unassigned",
pos: {
x: t.pos.x,
y: t.pos.y
},
lastConfigured: Game.time
});
}, o = 0, n = t; o < n.length; o++) r(n[o]);
e.lastUpdate = Game.time;
}, t.prototype.autoAssignRoles = function(e, t) {
var r, o, n, a;
if (t.length < 3) e.isValid = !1; else {
for (var i = new Map, s = 0, c = t; s < c.length; s++) {
for (var l = c[s], u = [], f = 0, m = t; f < m.length; f++) {
var p = m[f];
l.id !== p.id && l.pos.getRangeTo(p) <= 2 && u.push(p.id);
}
i.set(l.id, u);
}
var d = t.map(function(e) {
var t, r;
return {
lab: e,
reach: null !== (r = null === (t = i.get(e.id)) || void 0 === t ? void 0 : t.length) && void 0 !== r ? r : 0
};
}).sort(function(e, t) {
return t.reach - e.reach;
});
if (d.length < 3 || (null !== (o = null === (r = d[0]) || void 0 === r ? void 0 : r.reach) && void 0 !== o ? o : 0) < 2) return e.isValid = !1, 
void this.logger.warn("Lab layout in ".concat(e.roomName, " is not optimal for reactions"), {
subsystem: "Labs"
});
var y = null === (n = d[0]) || void 0 === n ? void 0 : n.lab, g = null === (a = d[1]) || void 0 === a ? void 0 : a.lab;
if (y && g) {
for (var h = 0, v = e.labs; h < v.length; h++) {
var R = v[h];
if (R.labId === y.id) R.role = "input1", R.lastConfigured = Game.time; else if (R.labId === g.id) R.role = "input2", 
R.lastConfigured = Game.time; else {
var E = y.pos.getRangeTo(Game.getObjectById(R.labId)) <= 2, T = g.pos.getRangeTo(Game.getObjectById(R.labId)) <= 2;
R.role = E && T ? "output" : "boost", R.lastConfigured = Game.time;
}
}
e.isValid = !0, e.lastUpdate = Game.time, this.logger.info("Auto-assigned lab roles in ".concat(e.roomName, ": ") + "".concat(e.labs.filter(function(e) {
return "input1" === e.role;
}).length, " input1, ") + "".concat(e.labs.filter(function(e) {
return "input2" === e.role;
}).length, " input2, ") + "".concat(e.labs.filter(function(e) {
return "output" === e.role;
}).length, " output, ") + "".concat(e.labs.filter(function(e) {
return "boost" === e.role;
}).length, " boost"), {
subsystem: "Labs"
});
} else e.isValid = !1;
}
}, t.prototype.getConfig = function(e) {
return this.configs.get(e);
}, t.prototype.getLabsByRole = function(e, t) {
var r = this.configs.get(e);
return r ? r.labs.filter(function(e) {
return e.role === t;
}).map(function(e) {
return Game.getObjectById(e.labId);
}).filter(function(e) {
return null !== e;
}) : [];
}, t.prototype.getInputLabs = function(e) {
var t, r, o = this.configs.get(e);
if (!o) return {};
var n = o.labs.find(function(e) {
return "input1" === e.role;
}), a = o.labs.find(function(e) {
return "input2" === e.role;
});
return {
input1: n && null !== (t = Game.getObjectById(n.labId)) && void 0 !== t ? t : void 0,
input2: a && null !== (r = Game.getObjectById(a.labId)) && void 0 !== r ? r : void 0
};
}, t.prototype.getOutputLabs = function(e) {
return this.getLabsByRole(e, "output");
}, t.prototype.getBoostLabs = function(e) {
return this.getLabsByRole(e, "boost");
}, t.prototype.setActiveReaction = function(e, t, r, o) {
var n = this.configs.get(e);
if (!n || !n.isValid) return !1;
n.activeReaction = {
input1: t,
input2: r,
output: o
};
var a = n.labs.find(function(e) {
return "input1" === e.role;
}), i = n.labs.find(function(e) {
return "input2" === e.role;
});
a && (a.resourceType = t), i && (i.resourceType = r);
for (var s = 0, c = n.labs.filter(function(e) {
return "output" === e.role;
}); s < c.length; s++) c[s].resourceType = o;
return n.lastUpdate = Game.time, this.logger.info("Set active reaction in ".concat(e, ": ").concat(t, " + ").concat(r, " -> ").concat(o), {
subsystem: "Labs"
}), !0;
}, t.prototype.clearActiveReaction = function(e) {
var t = this.configs.get(e);
if (t) {
delete t.activeReaction;
for (var r = 0, o = t.labs; r < o.length; r++) delete o[r].resourceType;
t.lastUpdate = Game.time;
}
}, t.prototype.runReactions = function(e) {
var t = this.configs.get(e);
if (!t || !t.isValid || !t.activeReaction) return 0;
var r = this.getInputLabs(e), o = r.input1, n = r.input2;
if (!o || !n) return 0;
for (var a = 0, i = 0, s = this.getOutputLabs(e); i < s.length; i++) {
var c = s[i];
0 === c.cooldown && c.runReaction(o, n) === OK && a++;
}
return a;
}, t.prototype.hasValidConfig = function(e) {
var t, r = this.configs.get(e);
return null !== (t = null == r ? void 0 : r.isValid) && void 0 !== t && t;
}, t.prototype.exportConfig = function(e) {
return this.configs.get(e);
}, t.prototype.importConfig = function(e) {
this.configs.set(e.roomName, e);
}, t;
}();
return wm.LabConfigManager = t, wm;
}();
Object.defineProperty(e, "LabConfigManager", {
enumerable: !0,
get: function() {
return i.LabConfigManager;
}
});
}(mm)), mm);

function Um(e) {
var t;
switch (e.posture) {
case "defensive":
case "nukePrep":
t = "defense";
break;

default:
t = e.posture;
}
return {
currentTick: Game.time,
danger: e.danger,
posture: t,
pheromones: {
war: e.pheromones.war,
siege: e.pheromones.siege
}
};
}

var Mm = {
info: function(e, t) {
return Hr.info(e, t);
},
warn: function(e, t) {
return Hr.warn(e, t);
},
error: function(e, t) {
return Hr.error(e, t);
},
debug: function(e, t) {
return Hr.debug(e, t);
}
}, Am = new (function() {
function e() {
this.manager = new xm.ChemistryManager({
logger: Mm
});
}
return e.prototype.getReaction = function(e) {
return this.manager.getReaction(e);
}, e.prototype.calculateReactionChain = function(e, t) {
return this.manager.calculateReactionChain(e, t);
}, e.prototype.hasResourcesForReaction = function(e, t, r) {
return void 0 === r && (r = 100), this.manager.hasResourcesForReaction(e, t, r);
}, e.prototype.planReactions = function(e, t) {
var r = Um(t);
return this.manager.planReactions(e, r);
}, e.prototype.scheduleCompoundProduction = function(e, t) {
var r = Um(t);
return this.manager.scheduleCompoundProduction(e, r);
}, e.prototype.executeReaction = function(e, t) {
this.manager.executeReaction(e, t);
}, e;
}()), km = function() {
function e() {}
return e.prototype.shouldBoost = function(e, t) {
var r, o = e.memory;
if (o.boosted) return !1;
var n = xm.getBoostConfig(o.role);
if (!n) return !1;
var a = !0 === (null !== (r = Memory.boostDefensePriority) && void 0 !== r ? r : {})[e.room.name] ? Math.max(1, n.minDanger - 1) : n.minDanger;
return !(t.danger < a || t.missingStructures.labs);
}, e.prototype.boostCreep = function(e, t) {
var o, n, a = e.memory, i = xm.getBoostConfig(a.role);
if (!i) return !1;
var s = t.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
}), c = [], l = function(t) {
if (e.body.some(function(e) {
return e.boost === t;
})) return "continue";
c.push(t);
var r = s.find(function(e) {
return e.mineralType === t && e.store[t] >= 30;
});
if (!r) return Hr.debug("Lab not ready with ".concat(t, " for ").concat(e.name), {
subsystem: "Boost"
}), {
value: !1
};
if (!e.pos.isNearTo(r)) return e.moveTo(r, {
visualizePathStyle: {
stroke: "#ffaa00"
}
}), {
value: !1
};
var o = r.boostCreep(e);
if (o === OK) Hr.info("Boosted ".concat(e.name, " with ").concat(t), {
subsystem: "Boost"
}); else if (o !== ERR_NOT_FOUND) return Hr.error("Failed to boost ".concat(e.name, ": ").concat(function(e) {
switch (e) {
case ERR_NOT_OWNER:
return "not owner of lab";

case ERR_NOT_FOUND:
return "no suitable body parts";

case ERR_NOT_ENOUGH_RESOURCES:
return "not enough compound";

case ERR_INVALID_TARGET:
return "invalid creep target";

case ERR_NOT_IN_RANGE:
return "creep not in range";

case ERR_RCL_NOT_ENOUGH:
return "RCL too low";

default:
return "error code ".concat(e);
}
}(o)), {
subsystem: "Boost"
}), {
value: !1
};
};
try {
for (var u = r(i.boosts), f = u.next(); !f.done; f = u.next()) {
var m = l(f.value);
if ("object" == typeof m) return m.value;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
f && !f.done && (n = u.return) && n.call(u);
} finally {
if (o) throw o.error;
}
}
return 0 === c.length && (a.boosted = !0, Hr.info("".concat(e.name, " fully boosted (all ").concat(i.boosts.length, " boosts applied)"), {
subsystem: "Boost"
}), !0);
}, e.prototype.areBoostLabsReady = function(e, t) {
var o, n, a = xm.getBoostConfig(t);
if (!a) return !0;
var i = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
}), s = function(e) {
if (!i.find(function(t) {
return t.mineralType === e && t.store[e] >= 30;
})) return {
value: !1
};
};
try {
for (var c = r(a.boosts), l = c.next(); !l.done; l = c.next()) {
var u = s(l.value);
if ("object" == typeof u) return u.value;
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
return !0;
}, e.prototype.getMissingBoosts = function(e, t) {
var o, n, a = xm.getBoostConfig(t);
if (!a) return [];
var i = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
}), s = [], c = function(e) {
i.find(function(t) {
return t.mineralType === e && t.store[e] >= 30;
}) || s.push(e);
};
try {
for (var l = r(a.boosts), u = l.next(); !u.done; u = l.next()) c(u.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (o) throw o.error;
}
}
return s;
}, e.prototype.prepareLabs = function(e, t) {
var o, n, a, i, s, c;
if (!(t.danger < 2)) {
var l = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_LAB;
}
});
if (!(l.length < 3)) {
var u = l.slice(2), f = new Set, m = [ xm.getBoostConfig("soldier"), xm.getBoostConfig("ranger"), xm.getBoostConfig("healer"), xm.getBoostConfig("siegeUnit") ].filter(function(e) {
return void 0 !== e && t.danger >= e.minDanger;
});
try {
for (var p = r(m), d = p.next(); !d.done; d = p.next()) {
var y = d.value;
try {
for (var g = (a = void 0, r(y.boosts)), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
f.add(v);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
h && !h.done && (i = g.return) && i.call(g);
} finally {
if (a) throw a.error;
}
}
}
} catch (e) {
o = {
error: e
};
} finally {
try {
d && !d.done && (n = p.return) && n.call(p);
} finally {
if (o) throw o.error;
}
}
var R = 0;
try {
for (var E = r(f), T = E.next(); !(T.done || (v = T.value, R >= u.length)); T = E.next()) {
var S = u[R];
(S.mineralType !== v || S.store[v] < 1e3) && Hr.debug("Lab ".concat(S.id, " needs ").concat(v, " for boosting"), {
subsystem: "Boost"
}), R++;
}
} catch (e) {
s = {
error: e
};
} finally {
try {
T && !T.done && (c = E.return) && c.call(E);
} finally {
if (s) throw s.error;
}
}
}
}
}, e.prototype.calculateBoostCost = function(e, t) {
return xm.calculateBoostCost(e, t);
}, e.prototype.analyzeBoostROI = function(e, t, r, o) {
if (!xm.getBoostConfig(e)) return {
worthwhile: !1,
roi: 0,
reasoning: "No boost config for role"
};
var n = this.calculateBoostCost(e, t), a = n.mineral + .1 * n.energy, i = 0;
switch (e) {
case "soldier":
i = 30 * Math.floor(t / 3) * 4 * r;
break;

case "ranger":
i = 10 * Math.floor(t / 3) * 4 * r;
break;

case "healer":
i = 12 * Math.floor(t / 3) * 4 * r;
break;

case "siegeUnit":
i = 50 * Math.floor(t / 3) * 4 * r;
break;

default:
i = 10 * t * r;
}
var s = (i *= 1 + .5 * o) / a, c = s > 1.5, l = c ? "High ROI: ".concat(s.toFixed(2), "x (gain: ").concat(i.toFixed(0), ", cost: ").concat(a.toFixed(0), ")") : "Low ROI: ".concat(s.toFixed(2), "x (gain: ").concat(i.toFixed(0), ", cost: ").concat(a.toFixed(0), ")");
return {
worthwhile: c,
roi: s,
reasoning: l
};
}, e;
}(), Nm = new km;

function Pm(e) {
return e >= 2 && e <= 3;
}

var Im = {
enablePheromones: !0,
enableEvolution: !0,
enableSpawning: !0,
enableConstruction: !0,
enableTowers: !0,
enableProcessing: !0
}, Gm = new Map, Lm = new Map;

function Dm(e) {
var t = Gm.get(e.name);
if (t && t.tick === Game.time) return t;
var r = e.find(FIND_MY_STRUCTURES), o = {
tick: Game.time,
towers: r.filter(function(e) {
return e.structureType === STRUCTURE_TOWER;
}),
spawns: r.filter(function(e) {
return e.structureType === STRUCTURE_SPAWN;
}),
links: r.filter(function(e) {
return e.structureType === STRUCTURE_LINK;
}),
factory: r.find(function(e) {
return e.structureType === STRUCTURE_FACTORY;
}),
powerSpawn: r.find(function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}),
sources: e.find(FIND_SOURCES),
constructionSites: e.find(FIND_MY_CONSTRUCTION_SITES)
};
return Gm.set(e.name, o), o;
}

var Fm = function() {
function t(t, r) {
void 0 === r && (r = {}), this.roomName = t, this.config = e(e({}, Im), r);
}
return t.prototype.run = function(e) {
var t, o, n, a = Io.unifiedStats.startRoom(this.roomName), i = Game.rooms[this.roomName];
if (i && (null === (t = i.controller) || void 0 === t ? void 0 : t.my)) {
!function(e) {
var t, o, n;
if (null === (n = e.controller) || void 0 === n ? void 0 : n.my) {
e.storage && va.set(e.storage.id, e.storage, {
namespace: Ea,
ttl: 10
}), e.terminal && va.set(e.terminal.id, e.terminal, {
namespace: Ea,
ttl: 10
}), e.controller && va.set(e.controller.id, e.controller, {
namespace: Ea,
ttl: 10
});
var a = e.find(FIND_SOURCES);
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
va.set(c.id, c, {
namespace: Ea,
ttl: 5
});
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
}
}(i);
var s = fi.getOrInitSwarmState(this.roomName);
if (this.config.enablePheromones && Game.time % 5 == 0 && xu.updateMetrics(i, s), 
this.updateThreatAssessment(i, s), qc.emergencyResponseManager.assess(i, s), qc.safeModeManager.checkSafeMode(i, s), 
this.config.enableEvolution && (Xf.updateEvolutionStage(s, i, e), Xf.updateMissingStructures(s, i)), 
Qf.updatePosture(s), this.config.enablePheromones && xu.updatePheromones(s, i), 
this.config.enableTowers && this.runTowerControl(i, s), this.config.enableConstruction && Qf.allowsBuilding(s.posture)) {
var c = Pm(null !== (n = null === (o = i.controller) || void 0 === o ? void 0 : o.level) && void 0 !== n ? n : 1) ? 5 : 10;
Game.time % c === 0 && this.runConstruction(i, s);
}
this.config.enableProcessing && Game.time % 5 == 0 && this.runResourceProcessing(i, s);
var l = Game.cpu.getUsed() - a;
Io.unifiedStats.recordRoom(i, l), Io.unifiedStats.endRoom(this.roomName, a);
} else Io.unifiedStats.endRoom(this.roomName, a);
}, t.prototype.updateThreatAssessment = function(e, t) {
var a, i, s, c, l, u, f, m, p, d;
if (Game.time % 5 == 0) {
var y = Dm(e), g = y.spawns.length + y.towers.length, h = Lm.get(this.roomName);
h && h.lastTick < Game.time && g < h.lastStructureCount && (y.spawns.length < h.lastSpawns.length && Ko.emit("structure.destroyed", {
roomName: this.roomName,
structureType: STRUCTURE_SPAWN,
structureId: "unknown",
source: this.roomName
}), y.towers.length < h.lastTowers.length && Ko.emit("structure.destroyed", {
roomName: this.roomName,
structureType: STRUCTURE_TOWER,
structureId: "unknown",
source: this.roomName
})), Lm.set(this.roomName, {
lastStructureCount: g,
lastSpawns: n([], o(y.spawns), !1),
lastTowers: n([], o(y.towers), !1),
lastTick: Game.time
});
}
var v = qn.safeFind(e, FIND_HOSTILE_CREEPS);
!(v.length > 0 || t.danger > 0) || qn.safeFind(e, FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType !== STRUCTURE_CONTROLLER;
}
});
try {
for (var R = r(v), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
try {
for (var S = (s = void 0, r(T.body)), C = S.next(); !C.done; C = S.next()) {
var b = C.value;
b.hits > 0 && (b.type === ATTACK || (b.type, RANGED_ATTACK));
}
} catch (e) {
s = {
error: e
};
} finally {
try {
C && !C.done && (c = S.return) && c.call(S);
} finally {
if (s) throw s.error;
}
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
E && !E.done && (i = R.return) && i.call(R);
} finally {
if (a) throw a.error;
}
}
if (v.length > 0) {
var _ = qc.assessThreat(e), O = _.dangerLevel;
if (O > t.danger) {
if (xu.updateDangerFromThreat(t, _.threatScore, _.dangerLevel), t.clusterId) {
var w = fi.getCluster(t.clusterId);
w && xu.diffuseDangerToCluster(e.name, _.threatScore, w.memberRooms);
}
fi.addRoomEvent(this.roomName, "hostileDetected", "".concat(v.length, " hostiles, danger=").concat(O, ", score=").concat(_.threatScore));
try {
for (var x = r(v), U = x.next(); !U.done; U = x.next()) T = U.value, Ko.emit("hostile.detected", {
roomName: this.roomName,
hostileId: T.id,
hostileOwner: T.owner.username,
bodyParts: T.body.length,
threatLevel: O,
source: this.roomName
});
} catch (e) {
l = {
error: e
};
} finally {
try {
U && !U.done && (u = x.return) && u.call(x);
} finally {
if (l) throw l.error;
}
}
}
t.danger = O;
} else t.danger > 0 && (Ko.emit("hostile.cleared", {
roomName: this.roomName,
source: this.roomName
}), t.danger = 0);
if (Game.time % 10 == 0) {
var M = e.find(FIND_NUKES);
if (M.length > 0) {
if (!t.nukeDetected) {
xu.onNukeDetected(t);
var A = null !== (d = null === (p = M[0]) || void 0 === p ? void 0 : p.launchRoomName) && void 0 !== d ? d : "unidentified source";
fi.addRoomEvent(this.roomName, "nukeDetected", "".concat(M.length, " nuke(s) incoming from ").concat(A)), 
t.nukeDetected = !0;
try {
for (var k = r(M), N = k.next(); !N.done; N = k.next()) {
var P = N.value;
Ko.emit("nuke.detected", {
roomName: this.roomName,
nukeId: P.id,
landingTick: Game.time + P.timeToLand,
launchRoomName: P.launchRoomName,
source: this.roomName
});
}
} catch (e) {
f = {
error: e
};
} finally {
try {
N && !N.done && (m = k.return) && m.call(k);
} finally {
if (f) throw f.error;
}
}
}
} else t.nukeDetected = !1;
}
}, t.prototype.runTowerControl = function(e, t) {
var o, n, a, i, s = Dm(e).towers;
if (0 !== s.length) {
var c = qn.safeFind(e, FIND_HOSTILE_CREEPS), l = c.length > 0 ? this.selectTowerTarget(c) : null, u = function(r) {
if (r.store.getUsedCapacity(RESOURCE_ENERGY) < 10) return "continue";
if (l) return r.attack(l), "continue";
var o;
if ("siege" !== t.posture && (o = r.pos.findClosestByRange(FIND_MY_CREEPS, {
filter: function(e) {
return e.hits < e.hitsMax;
}
}))) return r.heal(o), "continue";
if (!Qf.isCombatPosture(t.posture) && (o = r.pos.findClosestByRange(FIND_STRUCTURES, {
filter: function(e) {
return e.hits < .8 * e.hitsMax && e.structureType !== STRUCTURE_WALL && e.structureType !== STRUCTURE_RAMPART;
}
}))) return r.repair(o), "continue";
if (!Qf.isCombatPosture(t.posture) && 0 === c.length) {
var n = null !== (i = null === (a = e.controller) || void 0 === a ? void 0 : a.level) && void 0 !== i ? i : 1, s = qc.calculateWallRepairTarget(n, t.danger), u = r.pos.findClosestByRange(FIND_STRUCTURES, {
filter: function(e) {
return (e.structureType === STRUCTURE_WALL || e.structureType === STRUCTURE_RAMPART) && e.hits < s;
}
});
u && r.repair(u);
}
};
try {
for (var f = r(s), m = f.next(); !m.done; m = f.next()) u(m.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
m && !m.done && (n = f.return) && n.call(f);
} finally {
if (o) throw o.error;
}
}
}
}, t.prototype.selectTowerTarget = function(e) {
var t, r = this;
return null !== (t = e.sort(function(e, t) {
var o = r.getHostilePriority(e);
return r.getHostilePriority(t) - o;
})[0]) && void 0 !== t ? t : null;
}, t.prototype.getHostilePriority = function(e) {
var t, o, n = 0;
if (n += 100 * e.getActiveBodyparts(HEAL), n += 50 * e.getActiveBodyparts(RANGED_ATTACK), 
n += 40 * e.getActiveBodyparts(ATTACK), n += 60 * e.getActiveBodyparts(CLAIM), (n += 30 * e.getActiveBodyparts(WORK)) > 0) try {
for (var a = r(e.body), i = a.next(); !i.done; i = a.next()) if (i.value.boost) {
n += 20;
break;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (t) throw t.error;
}
}
return n;
}, t.prototype.runConstruction = function(e, t) {
var a, i, s, c = Dm(e), l = c.constructionSites;
if (!(l.length >= 10)) {
var u = null !== (i = null === (a = e.controller) || void 0 === a ? void 0 : a.level) && void 0 !== i ? i : 1, f = c.spawns[0], m = null == f ? void 0 : f.pos;
if (f) {
var p = cm(e, u);
if (p) m = p.anchor; else {
if (!sm(u)) return;
m = f.pos;
}
var d = null !== (s = null == p ? void 0 : p.blueprint) && void 0 !== s ? s : sm(u);
if (d && m) {
if (!Qf.isCombatPosture(t.posture)) {
var y = function(e, t, o, n, a) {
var i, s;
void 0 === a && (a = []);
var c = function(e, t, o, n) {
var a, i, s, c, l, u, f;
void 0 === n && (n = []);
var m = null !== (u = null === (l = e.controller) || void 0 === l ? void 0 : l.level) && void 0 !== u ? u : 1, p = im(o, m), d = e.getTerrain(), y = [], g = new Map;
try {
for (var h = r(p), v = h.next(); !v.done; v = h.next()) {
var R = v.value, E = t.x + R.x, T = t.y + R.y;
if (!(E < 1 || E > 48 || T < 1 || T > 48) && d.get(E, T) !== TERRAIN_MASK_WALL) {
var S = "".concat(E, ",").concat(T);
g.has(R.structureType) || g.set(R.structureType, new Set), null === (f = g.get(R.structureType)) || void 0 === f || f.add(S);
}
}
} catch (e) {
a = {
error: e
};
} finally {
try {
v && !v.done && (i = h.return) && i.call(h);
} finally {
if (a) throw a.error;
}
}
var C = _c(e, t, o.roads, n);
if (g.set(STRUCTURE_ROAD, C), m >= 6) {
var b = e.find(FIND_MINERALS);
if (b.length > 0) {
var _ = b[0], O = new Set;
O.add("".concat(_.pos.x, ",").concat(_.pos.y)), g.set(STRUCTURE_EXTRACTOR, O);
}
}
var w = e.find(FIND_STRUCTURES, {
filter: function(e) {
return fm.has(e.structureType) && (!0 === e.my || e.structureType === STRUCTURE_ROAD);
}
});
try {
for (var x = r(w), U = x.next(); !U.done; U = x.next()) {
var M = U.value, A = (S = "".concat(M.pos.x, ",").concat(M.pos.y), M.structureType), k = g.get(A);
k && k.has(S) || y.push({
structure: M,
reason: "".concat(M.structureType, " at ").concat(S, " is not in blueprint")
});
}
} catch (e) {
s = {
error: e
};
} finally {
try {
U && !U.done && (c = x.return) && c.call(x);
} finally {
if (s) throw s.error;
}
}
return y;
}(e, t, o, a), l = 0;
try {
for (var u = r(c), f = u.next(); !f.done; f = u.next()) {
var m = f.value, p = m.structure, d = m.reason;
if (l >= 1) break;
p.destroy() === OK && (l++, Hr.info("Destroyed misplaced structure: ".concat(d), {
subsystem: "Blueprint",
room: p.room.name,
meta: {
structureType: p.structureType,
pos: p.pos.toString(),
reason: d
}
}));
}
} catch (e) {
i = {
error: e
};
} finally {
try {
f && !f.done && (s = u.return) && s.call(u);
} finally {
if (i) throw i.error;
}
}
return l;
}(e, m, d, 0, t.remoteAssignments);
if (y > 0) {
var g = 1 === y ? "structure" : "structures";
fi.addRoomEvent(this.roomName, "structureDestroyed", "".concat(y, " misplaced ").concat(g, " destroyed for blueprint compliance"));
}
}
var h = {
sitesPlaced: 0,
wallsRemoved: 0
};
if (u >= 2 && l.length < 8) {
var v = Pm(u) ? 5 : 3;
(h = qc.placeRoadAwarePerimeterDefense(e, m, d.roads, u, v, t.remoteAssignments)).wallsRemoved > 0 && fi.addRoomEvent(this.roomName, "wallRemoved", "".concat(h.wallsRemoved, " wall(s) removed to allow road passage"));
}
var R = function(e, t, a) {
var i, s, c, l, u, f, m, p, d, y, g, h, v, R, E = null !== (y = null === (d = e.controller) || void 0 === d ? void 0 : d.level) && void 0 !== y ? y : 1, T = im(a, E), S = e.getTerrain(), C = [];
if (E >= 6) {
var b = e.find(FIND_MINERALS);
if (b.length > 0) {
var _ = b[0];
C.push({
x: _.pos.x - t.x,
y: _.pos.y - t.y,
structureType: STRUCTURE_EXTRACTOR
});
}
}
var O = n(n([], o(T), !1), o(C), !1), w = 0, x = e.find(FIND_MY_CONSTRUCTION_SITES), U = e.find(FIND_STRUCTURES);
if (x.length >= 10) return 0;
var M = {};
try {
for (var A = r(U), k = A.next(); !k.done; k = A.next()) {
var N = k.value.structureType;
M[N] = (null !== (g = M[N]) && void 0 !== g ? g : 0) + 1;
}
} catch (e) {
i = {
error: e
};
} finally {
try {
k && !k.done && (s = A.return) && s.call(A);
} finally {
if (i) throw i.error;
}
}
try {
for (var P = r(x), I = P.next(); !I.done; I = P.next()) N = I.value.structureType, 
M[N] = (null !== (h = M[N]) && void 0 !== h ? h : 0) + 1;
} catch (e) {
c = {
error: e
};
} finally {
try {
I && !I.done && (l = P.return) && l.call(P);
} finally {
if (c) throw c.error;
}
}
var G = Zf(E), L = function(r) {
var o = null !== (v = M[r.structureType]) && void 0 !== v ? v : 0;
if (o >= (null !== (R = G[r.structureType]) && void 0 !== R ? R : 0)) return "continue";
var n = t.x + r.x, a = t.y + r.y;
return n < 1 || n > 48 || a < 1 || a > 48 || S.get(n, a) === TERRAIN_MASK_WALL || U.some(function(e) {
return e.pos.x === n && e.pos.y === a && e.structureType === r.structureType;
}) || x.some(function(e) {
return e.pos.x === n && e.pos.y === a && e.structureType === r.structureType;
}) ? "continue" : e.createConstructionSite(n, a, r.structureType) === OK && (w++, 
M[r.structureType] = o + 1, w >= 3 || x.length + w >= 10) ? "break" : void 0;
};
try {
for (var D = r(O), F = D.next(); !F.done && "break" !== L(F.value); F = D.next()) ;
} catch (e) {
u = {
error: e
};
} finally {
try {
F && !F.done && (f = D.return) && f.call(D);
} finally {
if (u) throw u.error;
}
}
if (w < 3 && x.length + w < 10) {
var B = function(r) {
var o = t.x + r.x, n = t.y + r.y;
return o < 1 || o > 48 || n < 1 || n > 48 || S.get(o, n) === TERRAIN_MASK_WALL || U.some(function(e) {
return e.pos.x === o && e.pos.y === n && e.structureType === STRUCTURE_ROAD;
}) || x.some(function(e) {
return e.pos.x === o && e.pos.y === n && e.structureType === STRUCTURE_ROAD;
}) ? "continue" : e.createConstructionSite(o, n, STRUCTURE_ROAD) === OK && (++w >= 3 || x.length + w >= 10) ? "break" : void 0;
};
try {
for (var j = r(a.roads), H = j.next(); !H.done && "break" !== B(H.value); H = j.next()) ;
} catch (e) {
m = {
error: e
};
} finally {
try {
H && !H.done && (p = j.return) && p.call(j);
} finally {
if (m) throw m.error;
}
}
}
return w;
}(e, m, d), E = Oc(e, m, 2), T = {
placed: 0
};
if (u >= 2 && l.length < 9) {
var S = t.danger >= 2 ? 3 : 2;
(T = qc.placeRampartsOnCriticalStructures(e, u, t.danger, S)).placed > 0 && fi.addRoomEvent(this.roomName, "rampartPlaced", "".concat(T.placed, " rampart(s) placed on critical structures"));
}
t.metrics.constructionSites = l.length + R + E + h.sitesPlaced + T.placed;
}
} else if (1 === u && 0 === l.length) {
var C = cm(e, u);
C && e.createConstructionSite(C.anchor.x, C.anchor.y, STRUCTURE_SPAWN);
}
}
}, t.prototype.runResourceProcessing = function(e, t) {
var r, o, n = null !== (o = null === (r = e.controller) || void 0 === r ? void 0 : r.level) && void 0 !== o ? o : 0;
n >= 6 && this.runLabs(e), n >= 7 && this.runFactory(e), n >= 8 && this.runPowerSpawn(e), 
this.runLinks(e);
}, t.prototype.runLabs = function(e) {
var t = fi.getSwarmState(e.name);
if (t) {
sf.initialize(e.name), Nm.prepareLabs(e, t);
var r = Am.planReactions(e, t);
if (r) {
var o = {
product: r.product,
input1: r.input1,
input2: r.input2,
amountNeeded: 1e3,
priority: r.priority
};
if (sf.areLabsReady(e.name, o)) {
var n = Mu.getConfig(e.name), a = null == n ? void 0 : n.activeReaction;
a && a.input1 === r.input1 && a.input2 === r.input2 && a.output === r.product || sf.setActiveReaction(e.name, r.input1, r.input2, r.product), 
Am.executeReaction(e, r);
} else Hr.debug("Labs not ready for reaction: ".concat(r.input1, " + ").concat(r.input2, " -> ").concat(r.product), {
subsystem: "Labs",
room: e.name
});
}
sf.save(e.name);
}
}, t.prototype.runFactory = function(e) {
var t, o, n = Dm(e).factory;
if (n && !(n.cooldown > 0)) {
var a = [ RESOURCE_UTRIUM, RESOURCE_LEMERGIUM, RESOURCE_KEANIUM, RESOURCE_ZYNTHIUM, RESOURCE_HYDROGEN, RESOURCE_OXYGEN ];
try {
for (var i = r(a), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if (n.store.getUsedCapacity(c) >= 500 && n.store.getUsedCapacity(RESOURCE_ENERGY) >= 200 && n.produce(RESOURCE_UTRIUM_BAR) === OK) break;
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
}
}, t.prototype.runPowerSpawn = function(e) {
var t = Dm(e).powerSpawn;
t && t.store.getUsedCapacity(RESOURCE_POWER) >= 1 && t.store.getUsedCapacity(RESOURCE_ENERGY) >= 50 && t.processPower();
}, t.prototype.runLinks = function(e) {
var t, o, n = Dm(e), a = n.links;
if (!(a.length < 2)) {
var i = e.storage;
if (i) {
var s = a.find(function(e) {
return e.pos.getRangeTo(i) <= 2;
});
if (s) {
var c = n.sources, l = a.filter(function(e) {
return c.some(function(t) {
return e.pos.getRangeTo(t) <= 2;
});
}), u = e.controller, f = u ? a.find(function(e) {
return e.pos.getRangeTo(u) <= 3 && e.id !== s.id;
}) : void 0;
try {
for (var m = r(l), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
if (d.store.getUsedCapacity(RESOURCE_ENERGY) >= 400 && 0 === d.cooldown && s.store.getFreeCapacity(RESOURCE_ENERGY) >= 400) return void d.transferEnergy(s);
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (t) throw t.error;
}
}
if (f && 0 === s.cooldown) {
var y = f.store.getUsedCapacity(RESOURCE_ENERGY) < 400, g = s.store.getUsedCapacity(RESOURCE_ENERGY) >= 400;
y && g && s.transferEnergy(f);
}
}
}
}
}, t;
}(), Bm = function() {
function e() {
this.nodes = new Map;
}
return e.prototype.run = function() {
var e, t, n, a, i, s, c, l, u = global, f = u._ownedRooms, m = u._ownedRoomsTick;
l = f && m === Game.time ? f : Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
var p = l.length;
try {
for (var d = r(l), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
this.nodes.has(g.name) || this.nodes.set(g.name, new Fm(g.name));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
y && !y.done && (t = d.return) && t.call(d);
} finally {
if (e) throw e.error;
}
}
try {
for (var h = r(this.nodes), v = h.next(); !v.done; v = h.next()) {
var R = o(v.value, 1)[0];
(g = Game.rooms[R]) && (null === (c = g.controller) || void 0 === c ? void 0 : c.my) || this.nodes.delete(R);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
v && !v.done && (a = h.return) && a.call(h);
} finally {
if (n) throw n.error;
}
}
try {
for (var E = r(this.nodes.values()), T = E.next(); !T.done; T = E.next()) {
var S = T.value;
try {
S.run(p);
} catch (e) {
var C = e instanceof Error ? e.message : String(e), b = e instanceof Error && e.stack ? e.stack : void 0;
Hr.error("Error in room ".concat(S.roomName, ": ").concat(C), {
subsystem: "RoomManager",
room: S.roomName,
meta: {
stack: b
}
});
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
T && !T.done && (s = E.return) && s.call(E);
} finally {
if (i) throw i.error;
}
}
}, e.prototype.getNode = function(e) {
return this.nodes.get(e);
}, e.prototype.getAllNodes = function() {
return Array.from(this.nodes.values());
}, e.prototype.runRoom = function(e) {
var t;
if (null === (t = e.controller) || void 0 === t ? void 0 : t.my) {
this.nodes.has(e.name) || this.nodes.set(e.name, new Fm(e.name));
var r, o = global, n = o._ownedRooms, a = o._ownedRoomsTick;
r = n && a === Game.time ? n.length : Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}).length;
var i = this.nodes.get(e.name);
try {
i.run(r);
} catch (t) {
var s = t instanceof Error ? t.message : String(t), c = t instanceof Error && t.stack ? t.stack : void 0;
Hr.error("Error in room ".concat(e.name, ": ").concat(s), {
subsystem: "RoomManager",
room: e.name,
meta: {
stack: c
}
});
}
}
}, e;
}(), jm = new Bm;

function Hm(e) {
var t, r, o;
return e.find(FIND_HOSTILE_CREEPS).length > 0 ? Ao.CRITICAL : (null === (t = e.controller) || void 0 === t ? void 0 : t.my) ? Ao.HIGH : "ralphschuler" === (null === (o = null === (r = e.controller) || void 0 === r ? void 0 : r.reservation) || void 0 === o ? void 0 : o.username) ? Ao.MEDIUM : Ao.LOW;
}

function Wm(e) {
var t;
if (!(null === (t = e.controller) || void 0 === t ? void 0 : t.my)) return .02;
var r = e.controller.level;
return e.find(FIND_HOSTILE_CREEPS).length > 0 ? .12 : r <= 3 ? .04 : r <= 6 ? .06 : .08;
}

function Ym(e, t, r) {
var o;
return t === Ao.CRITICAL ? {
tickModulo: void 0,
tickOffset: void 0
} : t === Ao.HIGH && (null === (o = e.controller) || void 0 === o ? void 0 : o.my) ? {
tickModulo: 5,
tickOffset: r % 5
} : t === Ao.MEDIUM ? {
tickModulo: 10,
tickOffset: r % 10
} : t === Ao.LOW ? {
tickModulo: 20,
tickOffset: r % 20
} : {
tickModulo: void 0,
tickOffset: void 0
};
}

var Km, Vm, zm, qm, Xm, Qm = function() {
function e() {
this.registeredRooms = new Set, this.lastSyncTick = -1, this.roomIndices = new Map, 
this.nextRoomIndex = 0;
}
return e.prototype.getRoomIndex = function(e) {
var t = this.roomIndices.get(e);
return void 0 === t && (t = this.nextRoomIndex++, this.roomIndices.set(e, t)), t;
}, e.prototype.syncRoomProcesses = function() {
var e, t;
if (this.lastSyncTick !== Game.time) {
this.lastSyncTick = Game.time;
var o = new Set;
for (var n in Game.rooms) {
var a = Game.rooms[n];
o.add(n);
var i = "room:".concat(n), s = Ko.getProcess(i), c = Hm(a), l = Wm(a);
this.registeredRooms.has(n) ? s && (s.priority !== c || Math.abs(s.cpuBudget - l) > 1e-4) && this.updateRoomProcess(a, c, l) : this.registerRoomProcess(a);
}
try {
for (var u = r(this.registeredRooms), f = u.next(); !f.done; f = u.next()) n = f.value, 
o.has(n) || this.unregisterRoomProcess(n);
} catch (t) {
e = {
error: t
};
} finally {
try {
f && !f.done && (t = u.return) && t.call(u);
} finally {
if (e) throw e.error;
}
}
}
}, e.prototype.registerRoomProcess = function(e) {
var t, r = Hm(e), o = Wm(e), n = "room:".concat(e.name), a = this.getRoomIndex(e.name), i = Ym(e, r, a);
Ko.registerProcess({
id: n,
name: "Room ".concat(e.name).concat((null === (t = e.controller) || void 0 === t ? void 0 : t.my) ? " (owned)" : ""),
priority: r,
frequency: "high",
interval: 1,
tickModulo: i.tickModulo,
tickOffset: i.tickOffset,
minBucket: this.getMinBucketForPriority(r),
cpuBudget: o,
execute: function() {
var t = Game.rooms[e.name];
t && jm.runRoom(t);
}
}), this.registeredRooms.add(e.name);
var s = i.tickModulo ? "(mod=".concat(i.tickModulo, ", offset=").concat(i.tickOffset, ")") : "(every tick)";
Hr.debug("Registered room process: ".concat(e.name, " with priority ").concat(r, " ").concat(s), {
subsystem: "RoomProcessManager"
});
}, e.prototype.updateRoomProcess = function(e, t, r) {
var o, n = "room:".concat(e.name), a = this.getRoomIndex(e.name), i = Ym(e, t, a);
Ko.unregisterProcess(n), Ko.registerProcess({
id: n,
name: "Room ".concat(e.name).concat((null === (o = e.controller) || void 0 === o ? void 0 : o.my) ? " (owned)" : ""),
priority: t,
frequency: "high",
interval: 1,
tickModulo: i.tickModulo,
tickOffset: i.tickOffset,
minBucket: this.getMinBucketForPriority(t),
cpuBudget: r,
execute: function() {
var t = Game.rooms[e.name];
t && jm.runRoom(t);
}
});
var s = i.tickModulo ? "mod=".concat(i.tickModulo, ", offset=").concat(i.tickOffset) : "every tick";
Hr.debug("Updated room process: ".concat(e.name, " priority=").concat(t, " budget=").concat(r, " (").concat(s, ")"), {
subsystem: "RoomProcessManager"
});
}, e.prototype.unregisterRoomProcess = function(e) {
var t = "room:".concat(e);
Ko.unregisterProcess(t), this.registeredRooms.delete(e), this.roomIndices.delete(e), 
Hr.debug("Unregistered room process: ".concat(e), {
subsystem: "RoomProcessManager"
});
}, e.prototype.getMinBucketForPriority = function(e) {
return 0;
}, e.prototype.getStats = function() {
var e, t, o, n, a, i = {}, s = 0;
try {
for (var c = r(this.registeredRooms), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = Game.rooms[u];
if (f) {
var m = Hm(f), p = null !== (o = Ao[m]) && void 0 !== o ? o : "UNKNOWN";
i[p] = (null !== (n = i[p]) && void 0 !== n ? n : 0) + 1, (null === (a = f.controller) || void 0 === a ? void 0 : a.my) && s++;
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return {
totalRooms: Object.keys(Game.rooms).length,
registeredRooms: this.registeredRooms.size,
roomsByPriority: i,
ownedRooms: s
};
}, e.prototype.forceResync = function() {
this.lastSyncTick = -1, this.syncRoomProcesses();
}, e.prototype.reset = function() {
this.registeredRooms.clear(), this.roomIndices.clear(), this.nextRoomIndex = 0, 
this.lastSyncTick = -1;
}, e;
}(), Zm = new Qm, Jm = {}, $m = {}, ep = {}, tp = (zm || (zm = 1, function(e) {
Object.defineProperty(e, "__esModule", {
value: !0
}), e.PathCacheEventManager = e.PortalManager = void 0;
var t = function() {
if (Km) return $m;
Km = 1;
var e = $m && $m.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty($m, "__esModule", {
value: !0
}), $m.PortalManager = void 0;
var t = 1e3, r = "portals:", o = function() {
function o(e, t) {
this.cache = e, this.logger = t;
}
return o.prototype.discoverPortalsInRoom = function(t) {
var r, o, n, a = "portals:room:".concat(t), i = this.cache.get(a);
if (void 0 !== i) return this.logger.debug("Using cached portal data for room ".concat(t), {
subsystem: "PortalManager",
room: t,
meta: {
portalCount: null !== (n = null == i ? void 0 : i.length) && void 0 !== n ? n : 0
}
}), i;
var s = Game.rooms[t];
if (!s) return this.cache.set(a, null, 500), null;
var c = s.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_PORTAL;
}
}), l = [];
try {
for (var u = e(c), f = u.next(); !f.done; f = u.next()) {
var m = f.value;
if (m.destination) {
var p = void 0;
if ("shard" in m.destination && "room" in m.destination) p = {
shard: m.destination.shard,
room: m.destination.room
}; else {
if (!("x" in m.destination && "y" in m.destination && "roomName" in m.destination)) continue;
p = {
room: m.destination.roomName
};
}
l.push({
pos: m.pos,
destination: p,
lastSeen: Game.time
});
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (r) throw r.error;
}
}
return this.cache.set(a, l, 500), l.length > 0 && this.logger.info("Discovered ".concat(l.length, " portal(s) in room ").concat(t), {
subsystem: "PortalManager",
room: t,
meta: {
portalCount: l.length,
destinations: l.map(function(e) {
return e.destination.shard ? "".concat(e.destination.shard, ":").concat(e.destination.room) : e.destination.room;
})
}
}), l;
}, o.prototype.getPortalsToShard = function(t) {
var r, o, n = [];
for (var a in Game.rooms) {
var i = this.discoverPortalsInRoom(a);
if (i) try {
for (var s = (r = void 0, e(i)), c = s.next(); !c.done; c = s.next()) {
var l = c.value;
l.destination.shard === t && n.push(l);
}
} catch (e) {
r = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (r) throw r.error;
}
}
}
return n;
}, o.prototype.findClosestPortalToShard = function(t, r) {
var o, n, a = this.getPortalsToShard(r);
if (0 === a.length) return null;
var i = null, s = 1 / 0;
try {
for (var c = e(a), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = Game.map.getRoomLinearDistance(t.roomName, u.pos.roomName);
f < s && (s = f, i = u);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (o) throw o.error;
}
}
return i;
}, o.prototype.publishPortalsToInterShardMemory = function() {
var e;
try {
var t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name;
if (!t) return !1;
var o = {};
for (var n in Game.rooms) {
var a = this.discoverPortalsInRoom(n);
if (a && 0 !== a.length) {
var i = a.filter(function(e) {
return Game.time - e.lastSeen < 1e4;
});
0 !== i.length && (o[n] = i.map(function(e) {
return e.destination;
}));
}
}
var s = {
shard: t,
portals: o,
lastUpdate: Game.time
}, c = {};
try {
var l = InterShardMemory.getLocal();
l && (c = JSON.parse(l));
} catch (e) {
c = {};
}
return c[r] = s, InterShardMemory.setLocal(JSON.stringify(c)), this.logger.debug("Published portal data to InterShardMemory", {
subsystem: "PortalManager",
meta: {
portalCount: Object.keys(s.portals).length
}
}), !0;
} catch (e) {
return this.logger.error("Failed to publish to InterShardMemory: ".concat(String(e)), {
subsystem: "PortalManager"
}), !1;
}
}, o.prototype.isValidPortalData = function(t) {
var r, o;
if ("object" != typeof t || null === t) return !1;
var n = t;
if ("string" != typeof n.shard) return !1;
if ("number" != typeof n.lastUpdate) return !1;
if ("object" != typeof n.portals || null === n.portals) return !1;
var a = n.portals;
for (var i in a) {
var s = a[i];
if (!Array.isArray(s)) return !1;
try {
for (var c = (r = void 0, e(s)), l = c.next(); !l.done; l = c.next()) {
var u = l.value;
if ("object" != typeof u || null === u) return !1;
var f = u;
if ("string" != typeof f.room) return !1;
if (void 0 !== f.shard && "string" != typeof f.shard) return !1;
}
} catch (e) {
r = {
error: e
};
} finally {
try {
l && !l.done && (o = c.return) && o.call(c);
} finally {
if (r) throw r.error;
}
}
}
return !0;
}, o.prototype.getPortalDataFromInterShardMemory = function(e) {
try {
var t = InterShardMemory.getRemote(e);
if (!t) return null;
var o = void 0;
try {
o = JSON.parse(t);
} catch (t) {
return this.logger.warn("Invalid JSON from shard ".concat(e), {
subsystem: "PortalManager",
meta: {
shard: e
}
}), null;
}
var n = o[r];
return this.isValidPortalData(n) ? (this.logger.debug("Retrieved portal data from shard ".concat(e), {
subsystem: "PortalManager",
meta: {
shard: e,
portalCount: Object.keys(n.portals).length
}
}), n) : (this.logger.warn("Invalid portal data structure from shard ".concat(e), {
subsystem: "PortalManager",
meta: {
shard: e
}
}), null);
} catch (t) {
return this.logger.error("Failed to read from InterShardMemory: ".concat(String(t)), {
subsystem: "PortalManager",
meta: {
shard: e
}
}), null;
}
}, o.prototype.findRouteToPortal = function(r, o) {
var n, a, i = "portal:route:".concat(r, ":").concat(o), s = this.cache.get(i);
if (void 0 !== s) return s;
var c = new RoomPosition(25, 25, r), l = this.findClosestPortalToShard(c, o);
if (!l) return this.cache.set(i, null, t), null;
var u = Game.map.findRoute(r, l.pos.roomName);
if (u === ERR_NO_PATH) return this.cache.set(i, null, t), null;
var f = [ r ];
try {
for (var m = e(u), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
f.push(d.room);
}
} catch (e) {
n = {
error: e
};
} finally {
try {
p && !p.done && (a = m.return) && a.call(m);
} finally {
if (n) throw n.error;
}
}
var y = {
rooms: f,
portals: [ l.pos ],
distance: f.length,
calculatedAt: Game.time
};
return this.cache.set(i, y, t), y;
}, o.prototype.findInterShardRoute = function(t, r, o, n) {
var a, i;
if (r === n) {
var s = Game.map.findRoute(t, o);
if (s === ERR_NO_PATH) return null;
var c = [ t ];
try {
for (var l = e(s), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
c.push(f.room);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
u && !u.done && (i = l.return) && i.call(l);
} finally {
if (a) throw a.error;
}
}
return {
rooms: c,
portals: [],
distance: c.length,
calculatedAt: Game.time
};
}
return this.findRouteToPortal(t, n);
}, o.prototype.maintainPortalCache = function() {
var e = 0;
return this.publishPortalsToInterShardMemory() && e++, e;
}, o;
}();
return $m.PortalManager = o, $m;
}();
Object.defineProperty(e, "PortalManager", {
enumerable: !0,
get: function() {
return t.PortalManager;
}
});
var r = function() {
if (Vm) return ep;
Vm = 1, Object.defineProperty(ep, "__esModule", {
value: !0
}), ep.PathCacheEventManager = void 0;
var e = function() {
function e(e, t, r, o) {
this.initialized = !1, this.logger = e, this.eventBus = t, this.pathCache = r, this.remoteMining = o;
}
return e.prototype.initializePathCacheEvents = function() {
var e = this;
this.initialized ? this.logger.warn("Path cache event handlers already initialized", {
subsystem: "PathCacheEvents"
}) : (this.eventBus.on("construction.complete", function(t) {
var r = t.roomName, o = t.structureType;
if (e.logger.debug("Construction completed in ".concat(r, ": ").concat(o), {
room: r,
meta: {
structureType: o
}
}), e.pathCache.invalidateRoom(r), o === STRUCTURE_STORAGE) {
var n = Game.rooms[r];
if (n) {
e.pathCache.cacheCommonRoutes(n);
var a = e.remoteMining.getRemoteRoomsForRoom(n);
a.length > 0 && (e.remoteMining.precacheRemoteRoutes(n, a), e.logger.info("Cached remote routes after storage construction in ".concat(r), {
room: r,
meta: {
remoteRooms: a.length
}
})), e.logger.info("Cached common routes after storage construction in ".concat(r), {
room: r
});
}
}
}), this.eventBus.on("structure.destroyed", function(t) {
var r = t.roomName, o = t.structureType;
e.logger.debug("Structure destroyed in ".concat(r, ": ").concat(o), {
room: r,
meta: {
structureType: o
}
}), e.pathCache.invalidateRoom(r);
}), this.initialized = !0, this.logger.info("Path cache event handlers initialized", {
subsystem: "PathCacheEvents"
}));
}, e;
}();
return ep.PathCacheEventManager = e, ep;
}();
Object.defineProperty(e, "PathCacheEventManager", {
enumerable: !0,
get: function() {
return r.PathCacheEventManager;
}
});
}(Jm)), Jm), rp = {}, op = {}, np = {};

function ap() {
if (Xm) return np;
Xm = 1;
var e = np && np.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
return Object.defineProperty(np, "__esModule", {
value: !0
}), np.getRemoteRoomsForRoom = function(t) {
var r, o, n = new Set;
try {
for (var a = e(Object.values(Game.creeps)), i = a.next(); !i.done; i = a.next()) {
var s = i.value.memory;
"remoteHarvester" !== s.role && "remoteHauler" !== s.role || s.homeRoom !== t.name || !s.targetRoom || s.targetRoom === t.name || n.add(s.targetRoom);
}
} catch (e) {
r = {
error: e
};
} finally {
try {
i && !i.done && (o = a.return) && o.call(a);
} finally {
if (r) throw r.error;
}
}
return Array.from(n);
}, np.getRemoteMiningRoomCallback = function(t, r) {
var o, n, a, i, s = Game.rooms[t];
if (!s) return !0;
var c = t.match(/\d+/g);
if (!/^[WE]\d+[NS]\d+$/.test(t) || null === c || 2 !== c.length || parseInt(c[0], 10) % 10 != 0 && parseInt(c[1], 10) % 10 != 0) {
var l = s.find(FIND_HOSTILE_STRUCTURES, {
filter: function(e) {
return e.structureType !== STRUCTURE_CONTROLLER && e.structureType !== STRUCTURE_KEEPER_LAIR;
}
});
if (l.length > 0) return r && r.debug("Avoiding room ".concat(t, " with hostile structures"), {
meta: {
hostileCount: l.length
}
}), !1;
}
var u = new PathFinder.CostMatrix, f = s.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_ROAD;
}
});
try {
for (var m = e(f), p = m.next(); !p.done; p = m.next()) {
var d = p.value;
u.set(d.pos.x, d.pos.y, 1);
}
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
var y = s.find(FIND_CREEPS);
try {
for (var g = e(y), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
u.set(v.pos.x, v.pos.y, 255);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
h && !h.done && (i = g.return) && i.call(g);
} finally {
if (a) throw a.error;
}
}
return u;
}, np;
}

var ip, sp, cp, lp, up = {}, fp = {}, mp = {}, pp = (lp || (lp = 1, function(e) {
Object.defineProperty(e, "__esModule", {
value: !0
}), e.RemoteMiningMovement = e.RemotePathScheduler = e.RemotePathCache = e.getRemoteMiningRoomCallback = e.getRemoteRoomsForRoom = e.TaskPriority = void 0;
var t, r = (qm || (qm = 1, Object.defineProperty(op, "__esModule", {
value: !0
}), op.TaskPriority = void 0, function(e) {
e[e.CRITICAL = 0] = "CRITICAL", e[e.HIGH = 1] = "HIGH", e[e.MEDIUM = 2] = "MEDIUM", 
e[e.LOW = 3] = "LOW";
}(t || (op.TaskPriority = t = {}))), op);
Object.defineProperty(e, "TaskPriority", {
enumerable: !0,
get: function() {
return r.TaskPriority;
}
});
var o = ap();
Object.defineProperty(e, "getRemoteRoomsForRoom", {
enumerable: !0,
get: function() {
return o.getRemoteRoomsForRoom;
}
}), Object.defineProperty(e, "getRemoteMiningRoomCallback", {
enumerable: !0,
get: function() {
return o.getRemoteMiningRoomCallback;
}
});
var n = function() {
if (ip) return up;
ip = 1;
var e = up && up.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(up, "__esModule", {
value: !0
}), up.RemotePathCache = void 0;
var t = ap(), r = function() {
function r(e, t) {
this.pathCache = e, this.logger = t;
}
return r.prototype.getRemoteMiningPath = function(e, t, r) {
var o = this.pathCache.getCachedPath(e, t);
return o ? this.logger.debug("Remote path cache hit: ".concat(e.roomName, "  ").concat(t.roomName, " (").concat(r, ")"), {
meta: {
pathLength: o.length
}
}) : this.logger.debug("Remote path cache miss: ".concat(e.roomName, "  ").concat(t.roomName, " (").concat(r, ")")), 
o;
}, r.prototype.cacheRemoteMiningPath = function(e, t, r, o) {
this.pathCache.cachePath(e, t, r, {
ttl: 500
}), this.logger.info("Cached remote path: ".concat(e.roomName, "  ").concat(t.roomName, " (").concat(o, ")"), {
meta: {
pathLength: r.length,
ttl: 500
}
});
}, r.prototype.precacheRemoteRoutes = function(r, o) {
var n, a, i, s, c, l, u = this, f = r.storage, m = r.find(FIND_MY_SPAWNS);
if (f || 0 !== m.length) {
var p = 0;
try {
for (var d = e(o), y = d.next(); !y.done; y = d.next()) {
var g = y.value, h = Game.rooms[g];
if (h) {
var v = h.find(FIND_SOURCES), R = h.find(FIND_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}
});
if (m.length > 0) {
var E = m[0];
try {
for (var T = (i = void 0, e(v)), S = T.next(); !S.done; S = T.next()) {
var C = S.value, b = PathFinder.search(E.pos, {
pos: C.pos,
range: 1
}, {
plainCost: 2,
swampCost: 10,
maxRooms: 16,
roomCallback: function(e) {
return (0, t.getRemoteMiningRoomCallback)(e, u.logger);
}
});
if (!b.incomplete && b.path.length > 0) {
var _ = this.pathCache.convertRoomPositionsToPathSteps(b.path);
this.cacheRemoteMiningPath(E.pos, C.pos, _, "harvester"), p++;
}
}
} catch (e) {
i = {
error: e
};
} finally {
try {
S && !S.done && (s = T.return) && s.call(T);
} finally {
if (i) throw i.error;
}
}
}
if (f) {
var O = R.filter(function(e) {
return e.structureType === STRUCTURE_CONTAINER;
}), w = O.length > 0 ? O.map(function(e) {
return e.pos;
}) : v.map(function(e) {
return e.pos;
});
try {
for (var x = (c = void 0, e(w)), U = x.next(); !U.done; U = x.next()) {
var M = U.value, A = PathFinder.search(M, {
pos: f.pos,
range: 1
}, {
plainCost: 2,
swampCost: 10,
maxRooms: 16,
roomCallback: function(e) {
return (0, t.getRemoteMiningRoomCallback)(e, u.logger);
}
});
!A.incomplete && A.path.length > 0 && (_ = this.pathCache.convertRoomPositionsToPathSteps(A.path), 
this.cacheRemoteMiningPath(M, f.pos, _, "hauler"), p++);
}
} catch (e) {
c = {
error: e
};
} finally {
try {
U && !U.done && (l = x.return) && l.call(x);
} finally {
if (c) throw c.error;
}
}
}
} else this.logger.debug("Cannot precache routes to ".concat(g, ": room not visible"));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
p > 0 && this.logger.info("Precached ".concat(p, " remote mining routes for ").concat(r.name), {
room: r.name,
meta: {
remoteRooms: o.length,
routesCached: p
}
});
} else this.logger.warn("Cannot precache remote routes for ".concat(r.name, ": no storage or spawns"));
}, r.prototype.getOrCalculateRemotePath = function(e, r, o) {
var n = this, a = this.getRemoteMiningPath(e, r, o);
if (a) return a;
var i = PathFinder.search(e, {
pos: r,
range: 1
}, {
plainCost: 2,
swampCost: 10,
maxRooms: 16,
roomCallback: function(e) {
return (0, t.getRemoteMiningRoomCallback)(e, n.logger);
}
});
if (!i.incomplete && i.path.length > 0) {
var s = this.pathCache.convertRoomPositionsToPathSteps(i.path);
return this.cacheRemoteMiningPath(e, r, s, o), s;
}
return this.logger.warn("Failed to calculate remote path: ".concat(e.roomName, "  ").concat(r.roomName), {
meta: {
incomplete: i.incomplete
}
}), null;
}, r;
}();
return up.RemotePathCache = r, up;
}();
Object.defineProperty(e, "RemotePathCache", {
enumerable: !0,
get: function() {
return n.RemotePathCache;
}
});
var a = function() {
if (sp) return fp;
sp = 1;
var e = fp && fp.__values || function(e) {
var t = "function" == typeof Symbol && Symbol.iterator, r = t && e[t], o = 0;
if (r) return r.call(e);
if (e && "number" == typeof e.length) return {
next: function() {
return e && o >= e.length && (e = void 0), {
value: e && e[o++],
done: !e
};
}
};
throw new TypeError(t ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
Object.defineProperty(fp, "__esModule", {
value: !0
}), fp.RemotePathScheduler = void 0;
var t = ap(), r = function() {
function r(e, t, r) {
this.logger = e, this.scheduler = t, this.pathCache = r;
}
return r.prototype.precacheAllRemoteRoutes = function() {
var r, o, n, a = 0;
try {
for (var i = e(Object.values(Game.rooms)), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if ((null === (n = c.controller) || void 0 === n ? void 0 : n.my) && (c.storage || 0 !== c.find(FIND_MY_SPAWNS).length)) {
var l = (0, t.getRemoteRoomsForRoom)(c);
0 !== l.length && (this.pathCache.precacheRemoteRoutes(c, l), a += l.length);
}
}
} catch (e) {
r = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (r) throw r.error;
}
}
a > 0 && this.logger.info("Precached remote routes for ".concat(a, " remote rooms"), {
meta: {
routesCached: a
}
});
}, r.prototype.initialize = function(e) {
var t = this;
void 0 === e && (e = 2), this.scheduler.scheduleTask("precache-remote-paths", 500, function() {
return t.precacheAllRemoteRoutes();
}, e, 5), this.logger.info("Remote path cache scheduler initialized");
}, r;
}();
return fp.RemotePathScheduler = r, fp;
}();
Object.defineProperty(e, "RemotePathScheduler", {
enumerable: !0,
get: function() {
return a.RemotePathScheduler;
}
});
var i = function() {
if (cp) return mp;
cp = 1;
var e = mp && mp.__assign || function() {
return e = Object.assign || function(e) {
for (var t, r = 1, o = arguments.length; r < o; r++) for (var n in t = arguments[r]) Object.prototype.hasOwnProperty.call(t, n) && (e[n] = t[n]);
return e;
}, e.apply(this, arguments);
};
Object.defineProperty(mp, "__esModule", {
value: !0
}), mp.RemoteMiningMovement = void 0;
var t = ap(), r = function() {
function r(e, t, r, o) {
this.logger = e, this.pathCache = t, this.remotePaths = r, this.moveTo = o;
}
return r.prototype.moveToWithRemoteCache = function(t, r, o, n) {
void 0 === n && (n = {});
var a = r instanceof RoomPosition ? r : r.pos, i = this.remotePaths.getRemoteMiningPath(t.pos, a, o);
if (i && i.length > 0) {
this.logger.debug("Using cached path for ".concat(t.name, " (").concat(o, ")"), {
meta: {
pathLength: i.length
}
});
var s = i[0], c = t.pos.x === s.x && t.pos.y === s.y, l = !c && Math.abs(t.pos.x - s.x) <= 1 && Math.abs(t.pos.y - s.y) <= 1;
if (c || l) {
var u = t.moveByPath(i);
if (u === OK || u === ERR_TIRED) return u;
this.logger.debug("moveByPath failed for ".concat(t.name, ", falling back to moveTo"), {
meta: {
result: u,
atFirstStep: c,
adjacentToPath: l
}
});
}
}
var f = this.moveTo(t, r, e(e({}, n), {
maxRooms: 16
}));
return f !== OK && f !== ERR_TIRED || i || this.cachePathAfterMovement(t, a, o), 
f;
}, r.prototype.cachePathAfterMovement = function(e, r, o) {
var n = this;
if (e.pos.roomName !== r.roomName) {
var a = PathFinder.search(e.pos, {
pos: r,
range: 1
}, {
plainCost: 2,
swampCost: 10,
maxRooms: 16,
roomCallback: function(e) {
return (0, t.getRemoteMiningRoomCallback)(e, n.logger);
}
});
if (!a.incomplete && a.path.length > 0) {
var i = this.pathCache.convertRoomPositionsToPathSteps(a.path);
this.remotePaths.cacheRemoteMiningPath(e.pos, r, i, o), this.logger.debug("Cached new remote path for ".concat(e.name, " (").concat(o, ")"), {
meta: {
pathLength: a.path.length
}
});
}
}
}, r.prototype.moveRemoteHarvesterToSource = function(e, t) {
return this.moveToWithRemoteCache(e, t, "harvester", {
visualizePathStyle: {
stroke: "#ffaa00"
}
});
}, r.prototype.moveRemoteHaulerToStorage = function(e, t) {
return this.moveToWithRemoteCache(e, t, "hauler", {
visualizePathStyle: {
stroke: "#ffffff"
}
});
}, r.prototype.moveRemoteHaulerToRemote = function(e, t) {
var r = new RoomPosition(25, 25, t);
return this.moveToWithRemoteCache(e, r, "hauler", {
visualizePathStyle: {
stroke: "#ffffff"
}
});
}, r;
}();
return mp.RemoteMiningMovement = r, mp;
}();
Object.defineProperty(e, "RemoteMiningMovement", {
enumerable: !0,
get: function() {
return i.RemoteMiningMovement;
}
});
}(rp)), rp), dp = {
debug: function(e, t) {
return jr("RemoteMining").debug(e, t);
},
info: function(e, t) {
return jr("RemoteMining").info(e, t);
},
warn: function(e, t) {
return jr("RemoteMining").warn(e, t);
},
error: function(e, t) {
return jr("RemoteMining").error(e, t);
}
}, yp = {
getCachedPath: function(e, t) {
var r = Sa(e, t), o = va.get(r, {
namespace: Ta
});
if (!o) return null;
try {
return Room.deserializePath(o);
} catch (e) {
return va.invalidate(r, Ta), null;
}
},
cachePath: Ca,
convertRoomPositionsToPathSteps: function(e) {
for (var t = [], r = 0; r < e.length; r++) {
var o = e[r], n = r > 0 ? e[r - 1] : null, a = TOP, i = 0, s = 0;
n && n.roomName === o.roomName && (i = o.x - n.x, -1 === (s = o.y - n.y) && 0 === i ? a = TOP : -1 === s && 1 === i ? a = TOP_RIGHT : 0 === s && 1 === i ? a = RIGHT : 1 === s && 1 === i ? a = BOTTOM_RIGHT : 1 === s && 0 === i ? a = BOTTOM : 1 === s && -1 === i ? a = BOTTOM_LEFT : 0 === s && -1 === i ? a = LEFT : -1 === s && -1 === i && (a = TOP_LEFT)), 
t.push({
x: o.x,
y: o.y,
dx: i,
dy: s,
direction: a
});
}
return t;
}
}, gp = {
scheduleTask: function(e, t, r, o, n) {
qn.scheduleTask(e, t, r, o, n);
}
}, hp = new pp.RemotePathCache(yp, dp), vp = new pp.RemotePathScheduler(dp, gp, hp);

new pp.RemoteMiningMovement(dp, yp, hp, Es.moveTo);

var Rp = function() {
function e() {}
return e.prototype.get = function(e) {
return fi.getHeapCache().get(e);
}, e.prototype.set = function(e, t, r) {
fi.getHeapCache().set(e, t, r);
}, e;
}(), Ep = function() {
function e() {
this.logger = jr("Pathfinding");
}
return e.prototype.debug = function(e, t) {
this.logger.debug(e, t);
}, e.prototype.info = function(e, t) {
this.logger.info(e, t);
}, e.prototype.warn = function(e, t) {
this.logger.warn(e, t);
}, e.prototype.error = function(e, t) {
this.logger.error(e, t);
}, e;
}(), Tp = function() {
function e() {}
return e.prototype.on = function(e, t) {
lo.on(e, t);
}, e;
}(), Sp = function() {
function e() {}
return e.prototype.invalidateRoom = function(e) {
!function(e) {
var t = e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), r = new RegExp("^".concat(t, ":|:").concat(t, ":|:").concat(t, "$"));
va.invalidatePattern(r, Ta);
}(e);
}, e.prototype.cacheCommonRoutes = function(e) {
!function(e) {
var t, o, n;
if (null === (n = e.controller) || void 0 === n ? void 0 : n.my) {
var a = e.storage;
if (a) {
var i = e.find(FIND_SOURCES);
try {
for (var s = r(i), c = s.next(); !c.done; c = s.next()) {
var l = c.value, u = e.findPath(a.pos, l.pos, {
ignoreCreeps: !0,
serialize: !1
});
u.length > 0 && (Ca(a.pos, l.pos, u), Ca(l.pos, a.pos, u));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
c && !c.done && (o = s.return) && o.call(s);
} finally {
if (t) throw t.error;
}
}
if (e.controller) {
var f = e.findPath(a.pos, e.controller.pos, {
ignoreCreeps: !0,
range: 3,
serialize: !1
});
f.length > 0 && Ca(a.pos, e.controller.pos, f);
}
}
}
}(e);
}, e;
}(), Cp = function() {
function e() {}
return e.prototype.getRemoteRoomsForRoom = function(e) {
return function(e) {
return pp.getRemoteRoomsForRoom(e);
}(e);
}, e.prototype.precacheRemoteRoutes = function(e, t) {
!function(e, t) {
hp.precacheRemoteRoutes(e, t);
}(e, t);
}, e;
}();

new tp.PortalManager(new Rp, new Ep);

var bp, _p = new tp.PathCacheEventManager(new Ep, new Tp, new Sp, new Cp), Op = jr("SS2TerminalComms"), wp = function() {
function e() {}
return e.parseTransaction = function(e) {
var t = e.match(/^([\da-zA-Z]{1,3})\|([\d]{1,2})\|(.+)$/);
if (!t) return null;
var r, o = t[1], n = parseInt(t[2], 10), a = t[3];
if (0 === n) {
var i = a.match(/^(\d{1,2})\|(.+)$/);
i && (r = parseInt(i[1], 10), a = i[2]);
}
return {
msgId: o,
packetId: n,
finalPacket: r,
messageChunk: a
};
}, e.processIncomingTransactions = function() {
var e, t, o = [];
if (this.cleanupExpiredBuffers(), !Game.market.incomingTransactions) return o;
try {
for (var n = r(Game.market.incomingTransactions), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
if (!i.order && i.description && i.sender) {
var s = this.parseTransaction(i.description);
if (s) {
var c = "".concat(i.sender.username, ":").concat(s.msgId), l = this.messageBuffers.get(c);
if (!l) {
if (void 0 === s.finalPacket) continue;
l = {
msgId: s.msgId,
sender: i.sender.username,
finalPacket: s.finalPacket,
packets: new Map,
receivedAt: Game.time
}, this.messageBuffers.set(c, l);
}
if (l.packets.set(s.packetId, s.messageChunk), l.packets.size === l.finalPacket + 1) {
for (var u = [], f = 0; f <= l.finalPacket; f++) {
var m = l.packets.get(f);
if (!m) {
Op.warn("Missing packet in multi-packet message", {
meta: {
packetId: f,
messageId: s.msgId,
sender: i.sender.username
}
});
break;
}
u.push(m);
}
if (u.length === l.finalPacket + 1) {
var p = u.join("");
o.push({
sender: i.sender.username,
message: p
}), this.messageBuffers.delete(c), Op.info("Received complete multi-packet message from ".concat(i.sender.username), {
meta: {
messageId: s.msgId,
packets: u.length,
totalSize: p.length,
sender: i.sender.username
}
});
}
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
return o.length > 0 && Op.debug("Processed ".concat(Game.market.incomingTransactions.length, " terminal transactions, completed ").concat(o.length, " messages")), 
o;
}, e.splitMessage = function(e) {
if (e.length <= this.MAX_DESCRIPTION_LENGTH) return [ e ];
for (var t = this.generateMessageId(), r = [], o = this.chunkMessage(e, this.MESSAGE_CHUNK_SIZE), n = o.length - 1, a = 0; a < o.length; a++) {
var i;
i = 0 === a ? "".concat(t, "|").concat(a, "|").concat(n, "|").concat(o[a]) : "".concat(t, "|").concat(a, "|").concat(o[a]), 
r.push(i);
}
return r;
}, e.sendMessage = function(e, t, r, o, n) {
var a = this.splitMessage(n);
if (1 === a.length) return e.send(r, o, t, a[0]);
var i = this.extractMessageId(a[0]);
return i ? (this.queuePackets(e.id, t, r, o, a, i), Op.info("Queued ".concat(a.length, " packets for multi-packet message"), {
meta: {
terminalId: e.id,
messageId: i,
packets: a.length,
targetRoom: t
}
}), OK) : (Op.error("Failed to extract message ID from first packet"), ERR_INVALID_ARGS);
}, e.extractMessageId = function(e) {
var t = e.match(/^([\da-zA-Z]{1,3})\|/);
return t ? t[1] : null;
}, e.queuePackets = function(e, t, r, o, n, a) {
Memory.ss2PacketQueue || (Memory.ss2PacketQueue = {});
var i = "".concat(e, ":").concat(a);
Memory.ss2PacketQueue[i] = {
terminalId: e,
targetRoom: t,
resourceType: r,
amount: o,
packets: n,
nextPacketIndex: 0,
queuedAt: Game.time
};
}, e.processQueue = function() {
var e, t, n, a;
if (!Memory.ss2PacketQueue) return 0;
this.cleanupExpiredQueue();
var i = 0, s = [], c = Game.cpu.getUsed();
try {
for (var l = r(Object.entries(Memory.ss2PacketQueue)), u = l.next(); !u.done; u = l.next()) {
var f = o(u.value, 2), m = f[0], p = f[1];
if (Game.cpu.getUsed() - c > 5) {
Op.debug("Queue processing stopped due to CPU budget limit (".concat(5, " CPU)"));
break;
}
var d = Game.getObjectById(p.terminalId);
if (d) {
if (!(d.cooldown > 0)) {
var y = p.packets[p.nextPacketIndex];
if (y) {
var g = d.send(p.resourceType, p.amount, p.targetRoom, y);
if (g === OK) {
if (Memory.ss2PacketQueue[m].nextPacketIndex = p.nextPacketIndex + 1, i++, Memory.ss2PacketQueue[m].nextPacketIndex >= p.packets.length) {
var h = this.extractMessageId(y);
Op.info("Completed sending multi-packet message", {
meta: {
messageId: h,
packets: p.packets.length,
targetRoom: p.targetRoom
}
}), s.push(m);
}
} else g === ERR_NOT_ENOUGH_RESOURCES ? Op.warn("Not enough resources to send packet, will retry next tick", {
meta: {
queueKey: m,
resource: p.resourceType,
amount: p.amount
}
}) : (Op.error("Failed to send packet: ".concat(g, ", removing queue item"), {
meta: {
queueKey: m,
result: g
}
}), s.push(m));
} else Op.warn("No packet at index ".concat(p.nextPacketIndex, ", removing queue item"), {
meta: {
queueKey: m
}
}), s.push(m);
}
} else Op.warn("Terminal not found for queue item, removing from queue", {
meta: {
queueKey: m,
terminalId: p.terminalId
}
}), s.push(m);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
try {
for (var v = r(s), R = v.next(); !R.done; R = v.next()) {
var E = R.value;
delete Memory.ss2PacketQueue[E];
}
} catch (e) {
n = {
error: e
};
} finally {
try {
R && !R.done && (a = v.return) && a.call(v);
} finally {
if (n) throw n.error;
}
}
return i > 0 && Op.debug("Sent ".concat(i, " queued packets this tick")), i;
}, e.cleanupExpiredQueue = function() {
var e, t, n, a;
if (Memory.ss2PacketQueue) {
var i = Game.time, s = [];
try {
for (var c = r(Object.entries(Memory.ss2PacketQueue)), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = u[0], m = u[1];
if (i - m.queuedAt > this.QUEUE_TIMEOUT) {
var p = this.extractMessageId(m.packets[0]);
Op.warn("Queue item timed out after ".concat(i - m.queuedAt, " ticks"), {
meta: {
messageId: p,
queueKey: f,
sentPackets: m.nextPacketIndex,
totalPackets: m.packets.length
}
}), s.push(f);
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
try {
for (var d = r(s), y = d.next(); !y.done; y = d.next()) {
var g = y.value;
delete Memory.ss2PacketQueue[g];
}
} catch (e) {
n = {
error: e
};
} finally {
try {
y && !y.done && (a = d.return) && a.call(d);
} finally {
if (n) throw n.error;
}
}
}
}, e.generateMessageId = function() {
var e = this.MESSAGE_ID_CHARS, t = "", r = this.nextMessageId++;
this.nextMessageId >= Math.pow(e.length, 3) && (this.nextMessageId = 0);
for (var o = 0; o < 3; o++) t = e[r % e.length] + t, r = Math.floor(r / e.length);
return t;
}, e.chunkMessage = function(e, t) {
for (var r = [], o = 0; o < e.length; o += t) r.push(e.substring(o, o + t));
return r;
}, e.cleanupExpiredBuffers = function() {
var e, t, n = Game.time;
try {
for (var a = r(this.messageBuffers.entries()), i = a.next(); !i.done; i = a.next()) {
var s = o(i.value, 2), c = s[0], l = s[1];
n - l.receivedAt > this.MESSAGE_TIMEOUT && (Op.warn("Message timed out", {
meta: {
messageId: l.msgId,
sender: l.sender
}
}), this.messageBuffers.delete(c));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
}, e.parseJSON = function(e) {
try {
return e.startsWith("{") || e.startsWith("[") ? JSON.parse(e) : null;
} catch (e) {
return Op.error("Error parsing JSON", {
meta: {
error: String(e)
}
}), null;
}
}, e.formatJSON = function(e) {
return JSON.stringify(e);
}, e.MAX_DESCRIPTION_LENGTH = 100, e.MESSAGE_CHUNK_SIZE = 91, e.MESSAGE_TIMEOUT = 1e3, 
e.QUEUE_TIMEOUT = 1e3, e.MESSAGE_ID_CHARS = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 
e.messageBuffers = new Map, e.nextMessageId = 0, e;
}(), xp = {
lowBucketThreshold: 2e3,
highBucketThreshold: 9e3,
targetCpuUsage: .8,
highFrequencyInterval: 1,
mediumFrequencyInterval: 5,
lowFrequencyInterval: 20
}, Up = function() {
function t(t) {
void 0 === t && (t = {}), this.tasks = new Map, this.currentMode = "normal", this.tickCpuUsed = 0, 
this.config = e(e({}, xp), t);
}
return t.prototype.registerTask = function(t) {
this.tasks.set(t.name, e(e({}, t), {
lastRun: 0
}));
}, t.prototype.unregisterTask = function(e) {
this.tasks.delete(e);
}, t.prototype.getBucketMode = function() {
var e = Ko.getBucketMode();
return "critical" === e || "low" === e ? "low" : "high" === e ? "high" : "normal";
}, t.prototype.updateBucketMode = function() {
var e = this.getBucketMode();
e !== this.currentMode && (Hr.info("Bucket mode changed: ".concat(this.currentMode, " -> ").concat(e), {
subsystem: "Scheduler"
}), this.currentMode = e);
}, t.prototype.getCpuLimit = function() {
var e = Game.cpu.limit;
return "low" === this.currentMode ? .5 * e : e * this.config.targetCpuUsage;
}, t.prototype.hasCpuBudget = function() {
return Game.cpu.getUsed() < this.getCpuLimit();
}, t.prototype.getRemainingCpu = function() {
return Math.max(0, this.getCpuLimit() - Game.cpu.getUsed());
}, t.prototype.shouldRunTask = function(e) {
return !(Game.time - e.lastRun < this.getIntervalForFrequency(e.frequency) || "low" === this.currentMode && "high" !== e.frequency);
}, t.prototype.getIntervalForFrequency = function(e) {
switch (e) {
case "high":
return this.config.highFrequencyInterval;

case "medium":
return this.config.mediumFrequencyInterval;

case "low":
return this.config.lowFrequencyInterval;
}
}, t.prototype.run = function() {
var e, t;
this.updateBucketMode(), this.tickCpuUsed = 0;
var o = Array.from(this.tasks.values()).sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
if (this.shouldRunTask(i)) {
var s = Game.cpu.getUsed();
if (!(s + this.getCpuLimit() * i.cpuBudget > this.getCpuLimit() && "high" !== i.frequency)) {
try {
i.execute(), i.lastRun = Game.time;
} catch (e) {
var c = e instanceof Error ? e.message : String(e);
Hr.error("Task ".concat(i.name, " failed: ").concat(c), {
subsystem: "Scheduler"
});
}
var l = Game.cpu.getUsed() - s;
if (this.tickCpuUsed += l, !this.hasCpuBudget()) {
Hr.warn("CPU budget exhausted, skipping remaining tasks", {
subsystem: "Scheduler"
});
break;
}
}
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}, t.prototype.getTickCpuUsed = function() {
return this.tickCpuUsed;
}, t.prototype.getCurrentMode = function() {
return this.currentMode;
}, t.prototype.getTasks = function() {
return Array.from(this.tasks.values());
}, t;
}();

new Up, (bp = {})[FIND_STRUCTURES] = {
lowBucket: 100,
normal: 50,
highBucket: 20
}, bp[FIND_MY_STRUCTURES] = {
lowBucket: 100,
normal: 50,
highBucket: 20
}, bp[FIND_HOSTILE_STRUCTURES] = {
lowBucket: 50,
normal: 20,
highBucket: 10
}, bp[FIND_SOURCES_ACTIVE] = {
lowBucket: 1e4,
normal: 5e3,
highBucket: 1e3
}, bp[FIND_SOURCES] = {
lowBucket: 1e4,
normal: 5e3,
highBucket: 1e3
}, bp[FIND_MINERALS] = {
lowBucket: 1e4,
normal: 5e3,
highBucket: 1e3
}, bp[FIND_DEPOSITS] = {
lowBucket: 200,
normal: 100,
highBucket: 50
}, bp[FIND_MY_CONSTRUCTION_SITES] = {
lowBucket: 50,
normal: 20,
highBucket: 10
}, bp[FIND_CONSTRUCTION_SITES] = {
lowBucket: 50,
normal: 20,
highBucket: 10
}, bp[FIND_CREEPS] = {
lowBucket: 10,
normal: 5,
highBucket: 3
}, bp[FIND_MY_CREEPS] = {
lowBucket: 10,
normal: 5,
highBucket: 3
}, bp[FIND_HOSTILE_CREEPS] = {
lowBucket: 10,
normal: 3,
highBucket: 1
}, bp[FIND_DROPPED_RESOURCES] = {
lowBucket: 20,
normal: 5,
highBucket: 3
}, bp[FIND_TOMBSTONES] = {
lowBucket: 30,
normal: 10,
highBucket: 5
}, bp[FIND_RUINS] = {
lowBucket: 30,
normal: 10,
highBucket: 5
}, bp[FIND_FLAGS] = {
lowBucket: 100,
normal: 50,
highBucket: 20
}, bp[FIND_MY_SPAWNS] = {
lowBucket: 200,
normal: 100,
highBucket: 50
}, bp[FIND_HOSTILE_SPAWNS] = {
lowBucket: 100,
normal: 50,
highBucket: 20
}, bp[FIND_HOSTILE_CONSTRUCTION_SITES] = {
lowBucket: 50,
normal: 20,
highBucket: 10
}, bp[FIND_NUKES] = {
lowBucket: 50,
normal: 20,
highBucket: 10
}, bp[FIND_POWER_CREEPS] = {
lowBucket: 20,
normal: 10,
highBucket: 5
}, bp[FIND_MY_POWER_CREEPS] = {
lowBucket: 20,
normal: 10,
highBucket: 5
}, bp[FIND_HOSTILE_POWER_CREEPS] = {
lowBucket: 20,
normal: 10,
highBucket: 5
}, bp[FIND_EXIT_TOP] = {
lowBucket: 1e3,
normal: 500,
highBucket: 100
}, bp[FIND_EXIT_RIGHT] = {
lowBucket: 1e3,
normal: 500,
highBucket: 100
}, bp[FIND_EXIT_BOTTOM] = {
lowBucket: 1e3,
normal: 500,
highBucket: 100
}, bp[FIND_EXIT_LEFT] = {
lowBucket: 1e3,
normal: 500,
highBucket: 100
}, bp[FIND_EXIT] = {
lowBucket: 1e3,
normal: 500,
highBucket: 100
};

var Mp = new da.RoomVisualizer({}, fi), Ap = new da.MapVisualizer({}, fi), kp = !1, Np = !1;

function Pp() {
var e, t;
if (mo().visualizations) {
var o = function() {
var e;
return null !== (e = va.get("ownedRooms", {
namespace: "game",
ttl: 1,
compute: function() {
return Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
});
}
})) && void 0 !== e ? e : [];
}();
try {
for (var n = r(o), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
try {
Mp.draw(i);
} catch (e) {
var s = e instanceof Error ? e.message : String(e);
Hr.error("Visualization error in ".concat(i.name, ": ").concat(s), {
subsystem: "visualizations",
room: i.name
});
}
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
try {
Ap.draw();
} catch (e) {
s = e instanceof Error ? e.message : String(e), Hr.error("Map visualization error: ".concat(s), {
subsystem: "visualizations"
});
}
}
}

var Ip = function() {
function e() {}
return e.prototype.status = function(e) {
var t, o, n, a, i, s, c, l, u = Mu.getConfig(e);
if (!u) return "No lab configuration for ".concat(e);
var f = "=== Lab Status: ".concat(e, " ===\n");
f += "Valid: ".concat(u.isValid, "\n"), f += "Labs: ".concat(u.labs.length, "\n"), 
f += "Last Update: ".concat(Game.time - u.lastUpdate, " ticks ago\n\n"), u.activeReaction && (f += "Active Reaction:\n", 
f += "  ".concat(u.activeReaction.input1, " + ").concat(u.activeReaction.input2, "  ").concat(u.activeReaction.output, "\n\n")), 
f += "Lab Assignments:\n";
try {
for (var m = r(u.labs), p = m.next(); !p.done; p = m.next()) {
var d = p.value, y = Game.getObjectById(d.labId), g = null !== (c = null == y ? void 0 : y.mineralType) && void 0 !== c ? c : "empty", h = null !== (l = null == y ? void 0 : y.store[g]) && void 0 !== l ? l : 0;
f += "  ".concat(d.role, ": ").concat(g, " (").concat(h, ") @ (").concat(d.pos.x, ",").concat(d.pos.y, ")\n");
}
} catch (e) {
t = {
error: e
};
} finally {
try {
p && !p.done && (o = m.return) && o.call(m);
} finally {
if (t) throw t.error;
}
}
var v = sf.getLabResourceNeeds(e);
if (v.length > 0) {
f += "\nResource Needs:\n";
try {
for (var R = r(v), E = R.next(); !E.done; E = R.next()) {
var T = E.value;
f += "  ".concat(T.resourceType, ": ").concat(T.amount, " (priority ").concat(T.priority, ")\n");
}
} catch (e) {
n = {
error: e
};
} finally {
try {
E && !E.done && (a = R.return) && a.call(R);
} finally {
if (n) throw n.error;
}
}
}
var S = sf.getLabOverflow(e);
if (S.length > 0) {
f += "\nOverflow (needs emptying):\n";
try {
for (var C = r(S), b = C.next(); !b.done; b = C.next()) {
var _ = b.value;
f += "  ".concat(_.resourceType, ": ").concat(_.amount, " (priority ").concat(_.priority, ")\n");
}
} catch (e) {
i = {
error: e
};
} finally {
try {
b && !b.done && (s = C.return) && s.call(C);
} finally {
if (i) throw i.error;
}
}
}
return f;
}, e.prototype.setReaction = function(e, t, r, o) {
return sf.setActiveReaction(e, t, r, o) ? "Set active reaction: ".concat(t, " + ").concat(r, "  ").concat(o) : "Failed to set reaction (check lab configuration)";
}, e.prototype.clear = function(e) {
return sf.clearReactions(e), "Cleared active reactions in ".concat(e);
}, e.prototype.boost = function(e, t) {
var o, n, a = Game.rooms[e];
if (!a) return "Room ".concat(e, " not visible");
var i = Nm.areBoostLabsReady(a, t), s = Nm.getMissingBoosts(a, t), c = "=== Boost Status: ".concat(e, " / ").concat(t, " ===\n");
if (c += "Ready: ".concat(i, "\n"), s.length > 0) {
c += "\nMissing Boosts:\n";
try {
for (var l = r(s), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
c += "  - ".concat(f, "\n");
}
} catch (e) {
o = {
error: e
};
} finally {
try {
u && !u.done && (n = l.return) && n.call(l);
} finally {
if (o) throw o.error;
}
}
} else c += "\nAll boosts ready!";
return c;
}, t([ ro({
name: "labs.status",
description: "Get lab status for a room",
usage: "labs.status(roomName)",
examples: [ "labs.status('E1S1')" ],
category: "Labs"
}) ], e.prototype, "status", null), t([ ro({
name: "labs.setReaction",
description: "Set active reaction for a room",
usage: "labs.setReaction(roomName, input1, input2, output)",
examples: [ "labs.setReaction('E1S1', RESOURCE_HYDROGEN, RESOURCE_OXYGEN, RESOURCE_HYDROXIDE)" ],
category: "Labs"
}) ], e.prototype, "setReaction", null), t([ ro({
name: "labs.clear",
description: "Clear active reaction for a room",
usage: "labs.clear(roomName)",
examples: [ "labs.clear('E1S1')" ],
category: "Labs"
}) ], e.prototype, "clear", null), t([ ro({
name: "labs.boost",
description: "Check boost lab readiness for a role",
usage: "labs.boost(roomName, role)",
examples: [ "labs.boost('E1S1', 'soldier')" ],
category: "Labs"
}) ], e.prototype, "boost", null), e;
}(), Gp = function() {
function e() {}
return e.prototype.data = function(e) {
var t = Game.market.getHistory(e);
if (!t || 0 === t.length) return "No market history for ".concat(e);
var r = t[t.length - 1], o = "=== Market Data: ".concat(e, " ===\n");
if (o += "Current Price: ".concat(r.avgPrice.toFixed(3), " credits\n"), o += "Volume: ".concat(r.volume, "\n"), 
o += "Transactions: ".concat(r.transactions, "\n"), o += "Date: ".concat(r.date, "\n"), 
t.length >= 5) {
var n = t[t.length - 5], a = (r.avgPrice - n.avgPrice) / n.avgPrice * 100;
o += "\nTrend (5 days): ".concat(a > 5 ? " Rising" : a < -5 ? " Falling" : " Stable", " (").concat(a >= 0 ? "+" : "").concat(a.toFixed(1), "%)\n");
}
return o;
}, e.prototype.orders = function() {
var e, t, o, n, a, i = Object.values(Game.market.orders);
if (0 === i.length) return "No active market orders";
var s = "=== Active Market Orders (".concat(i.length, ") ===\n");
s += "Type | Resource | Price | Remaining | Room\n", s += "-".repeat(70) + "\n";
try {
for (var c = r(i), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = u.type === ORDER_BUY ? "BUY " : "SELL", m = u.price.toFixed(3), p = null !== (n = null === (o = u.remainingAmount) || void 0 === o ? void 0 : o.toString()) && void 0 !== n ? n : "?";
s += "".concat(f, " | ").concat(u.resourceType, " | ").concat(m, " | ").concat(p, " | ").concat(null !== (a = u.roomName) && void 0 !== a ? a : "N/A", "\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return s;
}, e.prototype.profit = function() {
var e = "=== Market Profit ===\n";
return (e += "Credits: ".concat(Game.market.credits.toLocaleString(), "\n")) + "\nNote: Detailed profit tracking requires memory access\n";
}, t([ ro({
name: "market.data",
description: "Get market data for a resource",
usage: "market.data(resource)",
examples: [ "market.data(RESOURCE_ENERGY)", "market.data(RESOURCE_GHODIUM)" ],
category: "Market"
}) ], e.prototype, "data", null), t([ ro({
name: "market.orders",
description: "List your active market orders",
usage: "market.orders()",
examples: [ "market.orders()" ],
category: "Market"
}) ], e.prototype, "orders", null), t([ ro({
name: "market.profit",
description: "Show market trading profit statistics",
usage: "market.profit()",
examples: [ "market.profit()" ],
category: "Market"
}) ], e.prototype, "profit", null), e;
}(), Lp = function() {
function e() {}
return e.prototype.gpl = function() {
var e = Jl.getGPLState();
if (!e) return "GPL tracking not available (no power unlocked)";
var t = "=== GPL Status ===\n";
t += "Level: ".concat(e.currentLevel, "\n"), t += "Progress: ".concat(e.currentProgress, " / ").concat(e.progressNeeded, "\n"), 
t += "Completion: ".concat((e.currentProgress / e.progressNeeded * 100).toFixed(1), "%\n"), 
t += "Target Milestone: ".concat(e.targetMilestone, "\n");
var r = e.ticksToNextLevel === 1 / 0 ? "N/A (no progress yet)" : "".concat(e.ticksToNextLevel.toLocaleString(), " ticks");
return (t += "Estimated Time: ".concat(r, "\n")) + "\nTotal Power Processed: ".concat(e.totalPowerProcessed.toLocaleString(), "\n");
}, e.prototype.creeps = function() {
var e, t, o = Jl.getAssignments();
if (0 === o.length) return "No power creeps created yet";
var n = "=== Power Creeps (".concat(o.length, ") ===\n");
n += "Name | Role | Room | Level | Spawned\n", n += "-".repeat(70) + "\n";
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = s.spawned ? "" : "";
n += "".concat(s.name, " | ").concat(s.role, " | ").concat(s.assignedRoom, " | ").concat(s.level, " | ").concat(c, "\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return n;
}, e.prototype.operations = function() {
var e, t, o = zl.getActiveOperations();
if (0 === o.length) return "No active power bank operations";
var n = "=== Power Bank Operations (".concat(o.length, ") ===\n");
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
n += "\nRoom: ".concat(s.roomName, "\n"), n += "Power: ".concat(s.power, "\n"), 
n += "State: ".concat(s.state, "\n"), n += "Home: ".concat(s.homeRoom, "\n"), n += "Attackers: ".concat(s.assignedCreeps.attackers.length, "\n"), 
n += "Healers: ".concat(s.assignedCreeps.healers.length, "\n"), n += "Carriers: ".concat(s.assignedCreeps.carriers.length, "\n"), 
n += "Damage: ".concat(Math.round(s.damageDealt / 1e3), "k / 2000k\n"), n += "Collected: ".concat(s.powerCollected, "\n"), 
n += "Decay: ".concat(s.decayTick - Game.time, " ticks\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return n;
}, e.prototype.assign = function(e, t) {
return Jl.reassignPowerCreep(e, t) ? "Reassigned ".concat(e, " to ").concat(t) : "Failed to reassign ".concat(e, " (not found)");
}, e.prototype.create = function(e, t) {
var r = "string" == typeof t && "operator" === t.toLowerCase() ? POWER_CLASS.OPERATOR : t;
if (Game.powerCreeps[e]) return 'Power creep "'.concat(e, '" already exists');
if (!Game.gpl || Game.gpl.level < 1) return "GPL level too low (need GPL 1+)";
var o = Object.keys(Game.powerCreeps).length;
if (o >= Game.gpl.level) return "Cannot create power creep: ".concat(o, "/").concat(Game.gpl.level, " already created");
var n = PowerCreep.create(e, r);
return n === OK ? 'Created power creep "'.concat(e, '" (').concat(r, ")") : "Failed to create power creep: ".concat(n);
}, e.prototype.spawn = function(e, t) {
var r, o = Game.powerCreeps[e];
if (!o) return 'Power creep "'.concat(e, '" not found');
if (void 0 !== o.ticksToLive) return 'Power creep "'.concat(e, '" is already spawned (TTL: ').concat(o.ticksToLive, ")");
var n = o.memory, a = null !== (r = null != t ? t : n.homeRoom) && void 0 !== r ? r : Object.keys(Game.rooms)[0], i = Game.rooms[a];
if (!i) return 'Room "'.concat(a, '" not visible');
var s = i.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_POWER_SPAWN;
}
})[0];
if (!s) return "No power spawn found in ".concat(a);
var c = o.spawn(s);
return c === OK ? 'Spawned power creep "'.concat(e, '" at ').concat(a) : "Failed to spawn power creep: ".concat(c);
}, e.prototype.upgrade = function(e, t) {
var r = Game.powerCreeps[e];
if (!r) return 'Power creep "'.concat(e, '" not found');
if (r.powers[t]) return 'Power creep "'.concat(e, '" already has ').concat(t);
if (!POWER_INFO[t]) return "Invalid power: ".concat(t);
if (r.level >= Game.gpl.level) return "Power creep is already at max level (".concat(r.level, "/").concat(Game.gpl.level, ")");
var o = r.upgrade(t);
return o === OK ? "Upgraded ".concat(e, " to level ").concat(r.level, " with ").concat(t) : "Failed to upgrade: ".concat(o);
}, t([ ro({
name: "power.gpl",
description: "Show GPL (Global Power Level) status",
usage: "power.gpl()",
examples: [ "power.gpl()" ],
category: "Power"
}) ], e.prototype, "gpl", null), t([ ro({
name: "power.creeps",
description: "List power creeps and their assignments",
usage: "power.creeps()",
examples: [ "power.creeps()" ],
category: "Power"
}) ], e.prototype, "creeps", null), t([ ro({
name: "power.operations",
description: "List active power bank operations",
usage: "power.operations()",
examples: [ "power.operations()" ],
category: "Power"
}) ], e.prototype, "operations", null), t([ ro({
name: "power.assign",
description: "Reassign a power creep to a different room",
usage: "power.assign(powerCreepName, roomName)",
examples: [ "power.assign('operator_eco', 'E2S2')" ],
category: "Power"
}) ], e.prototype, "assign", null), t([ ro({
name: "power.create",
description: "Manually create a new power creep (automatic creation is also enabled)",
usage: "power.create(name, className)",
examples: [ "power.create('operator_eco', POWER_CLASS.OPERATOR)", "power.create('my_operator', 'operator')" ],
category: "Power"
}) ], e.prototype, "create", null), t([ ro({
name: "power.spawn",
description: "Manually spawn a power creep at a power spawn",
usage: "power.spawn(powerCreepName, roomName?)",
examples: [ "power.spawn('operator_eco')", "power.spawn('operator_eco', 'E2S2')" ],
category: "Power"
}) ], e.prototype, "spawn", null), t([ ro({
name: "power.upgrade",
description: "Manually upgrade a power creep with a specific power",
usage: "power.upgrade(powerCreepName, power)",
examples: [ "power.upgrade('operator_eco', PWR_OPERATE_SPAWN)", "power.upgrade('operator_eco', PWR_OPERATE_TOWER)" ],
category: "Power"
}) ], e.prototype, "upgrade", null), e;
}(), Dp = new Ip, Fp = new Gp, Bp = new Lp, jp = function() {
function e() {}
return e.prototype.status = function() {
var e, t, r = null !== (t = null === (e = Game.shard) || void 0 === e ? void 0 : e.name) && void 0 !== t ? t : "shard0", o = qi.getCurrentShardState();
if (!o) return "No shard state found for ".concat(r);
var n = o.health, a = [ "=== Shard Status: ".concat(r, " ==="), "Role: ".concat(o.role.toUpperCase()), "Rooms: ".concat(n.roomCount, " (Avg RCL: ").concat(n.avgRCL, ")"), "Creeps: ".concat(n.creepCount), "CPU: ".concat(n.cpuCategory.toUpperCase(), " (").concat(Math.round(100 * n.cpuUsage), "%)"), "Bucket: ".concat(n.bucketLevel), "Economy Index: ".concat(n.economyIndex, "%"), "War Index: ".concat(n.warIndex, "%"), "Portals: ".concat(o.portals.length), "Active Tasks: ".concat(o.activeTasks.length), "Last Update: ".concat(n.lastUpdate) ];
return o.cpuLimit && a.push("CPU Limit: ".concat(o.cpuLimit)), a.join("\n");
}, e.prototype.all = function() {
var e, t, o = qi.getAllShards();
if (0 === o.length) return "No shards tracked yet";
var n = [ "=== All Shards ===" ];
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = s.health;
n.push("".concat(s.name, " [").concat(s.role, "]: ").concat(c.roomCount, " rooms, RCL ").concat(c.avgRCL, ", ") + "CPU ".concat(c.cpuCategory, " (").concat(Math.round(100 * c.cpuUsage), "%), ") + "Eco ".concat(c.economyIndex, "%, War ").concat(c.warIndex, "%"));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return n.join("\n");
}, e.prototype.setRole = function(e) {
var t = [ "core", "frontier", "resource", "backup", "war" ];
return t.includes(e) ? (qi.setShardRole(e), "Shard role set to: ".concat(e.toUpperCase())) : "Invalid role: ".concat(e, ". Valid roles: ").concat(t.join(", "));
}, e.prototype.portals = function(e) {
var t, o, n, a, i, s = null !== (a = null === (n = Game.shard) || void 0 === n ? void 0 : n.name) && void 0 !== a ? a : "shard0", c = qi.getCurrentShardState();
if (!c) return "No shard state found for ".concat(s);
var l = c.portals;
if (e && (l = l.filter(function(t) {
return t.targetShard === e;
})), 0 === l.length) return e ? "No portals to ".concat(e) : "No portals discovered yet";
var u = [ e ? "=== Portals to ".concat(e, " ===") : "=== All Portals ===" ];
try {
for (var f = r(l), m = f.next(); !m.done; m = f.next()) {
var p = m.value, d = p.isStable ? "" : "", y = "".repeat(p.threatRating), g = null !== (i = p.traversalCount) && void 0 !== i ? i : 0, h = Game.time - p.lastScouted;
u.push("".concat(p.sourceRoom, "  ").concat(p.targetShard, "/").concat(p.targetRoom, " ") + "[".concat(d, "] ").concat(y || "", " (").concat(g, " uses, ").concat(h, "t ago)"));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
m && !m.done && (o = f.return) && o.call(f);
} finally {
if (t) throw t.error;
}
}
return u.join("\n");
}, e.prototype.bestPortal = function(e, t) {
var r, o = qi.getOptimalPortalRoute(e, t);
if (!o) return "No portal found to ".concat(e);
var n = o.isStable ? "Stable" : "Unstable", a = o.threatRating > 0 ? " (Threat: ".concat(o.threatRating, ")") : "";
return "Best portal to ".concat(e, ":\n") + "  Source: ".concat(o.sourceRoom, " (").concat(o.sourcePos.x, ",").concat(o.sourcePos.y, ")\n") + "  Target: ".concat(o.targetShard, "/").concat(o.targetRoom, "\n") + "  Status: ".concat(n).concat(a, "\n") + "  Traversals: ".concat(null !== (r = o.traversalCount) && void 0 !== r ? r : 0, "\n") + "  Last Scouted: ".concat(Game.time - o.lastScouted, " ticks ago");
}, e.prototype.createTask = function(e, t, r, o) {
void 0 === o && (o = 50);
var n = [ "colonize", "reinforce", "transfer", "evacuate" ];
return n.includes(e) ? (qi.createTask(e, t, r, o), "Created ".concat(e, " task to ").concat(t).concat(r ? "/".concat(r) : "", " (priority: ").concat(o, ")")) : "Invalid task type: ".concat(e, ". Valid types: ").concat(n.join(", "));
}, e.prototype.transferResource = function(e, t, r, o, n) {
return void 0 === n && (n = 50), qi.createResourceTransferTask(e, t, r, o, n), "Created resource transfer task:\n" + "  ".concat(o, " ").concat(r, "  ").concat(e, "/").concat(t, "\n") + "  Priority: ".concat(n);
}, e.prototype.transfers = function() {
var e, t, o = Qi.getActiveRequests();
if (0 === o.length) return "No active resource transfers";
var n = [ "=== Active Resource Transfers ===" ];
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = Math.round(s.transferred / s.amount * 100), l = s.assignedCreeps.length;
n.push("".concat(s.taskId, ": ").concat(s.amount, " ").concat(s.resourceType, "\n") + "  ".concat(s.sourceRoom, "  ").concat(s.targetShard, "/").concat(s.targetRoom, "\n") + "  Status: ".concat(s.status.toUpperCase(), " (").concat(c, "%)\n") + "  Creeps: ".concat(l, ", Priority: ").concat(s.priority));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return n.join("\n");
}, e.prototype.cpuHistory = function() {
var e, t, o = qi.getCurrentShardState();
if (!o || !o.cpuHistory || 0 === o.cpuHistory.length) return "No CPU history available";
var n = [ "=== CPU Allocation History ===" ];
try {
for (var a = r(o.cpuHistory.slice(-10)), i = a.next(); !i.done; i = a.next()) {
var s = i.value, c = Math.round(s.cpuUsed / s.cpuLimit * 100);
n.push("Tick ".concat(s.tick, ": ").concat(s.cpuUsed.toFixed(2), "/").concat(s.cpuLimit, " (").concat(c, "%) ") + "Bucket: ".concat(s.bucketLevel));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return n.join("\n");
}, e.prototype.tasks = function() {
var e, t, o, n = qi.getActiveTransferTasks();
if (0 === n.length) return "No active inter-shard tasks";
var a = [ "=== Inter-Shard Tasks ===" ];
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) {
var c = s.value, l = null !== (o = c.progress) && void 0 !== o ? o : 0;
a.push("".concat(c.id, " [").concat(c.type.toUpperCase(), "]\n") + "  ".concat(c.sourceShard, "  ").concat(c.targetShard).concat(c.targetRoom ? "/".concat(c.targetRoom) : "", "\n") + "  Status: ".concat(c.status.toUpperCase(), " (").concat(l, "%)\n") + "  Priority: ".concat(c.priority));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return a.join("\n");
}, e.prototype.syncStatus = function() {
var e = qi.getSyncStatus(), t = e.isHealthy ? " HEALTHY" : " DEGRADED";
return "=== InterShardMemory Sync Status ===\n" + "Status: ".concat(t, "\n") + "Last Sync: ".concat(e.lastSync, " (").concat(e.ticksSinceSync, " ticks ago)\n") + "Memory Usage: ".concat(e.memorySize, " / ").concat(Ni, " bytes (").concat(e.sizePercent, "%)\n") + "Shards Tracked: ".concat(e.shardsTracked, "\n") + "Active Tasks: ".concat(e.activeTasks, "\n") + "Total Portals: ".concat(e.totalPortals);
}, e.prototype.memoryStats = function() {
var e = qi.getMemoryStats();
return "=== InterShardMemory Usage ===\n" + "Total: ".concat(e.size, " / ").concat(e.limit, " bytes (").concat(e.percent, "%)\n") + "\nBreakdown:\n" + "  Shards: ".concat(e.breakdown.shards, " bytes\n") + "  Tasks: ".concat(e.breakdown.tasks, " bytes\n") + "  Portals: ".concat(e.breakdown.portals, " bytes\n") + "  Other: ".concat(e.breakdown.other, " bytes");
}, e.prototype.forceSync = function() {
return qi.forceSync(), "InterShardMemory sync forced. Check logs for results.";
}, t([ ro({
name: "shard.status",
description: "Display current shard status and metrics",
usage: "shard.status()",
examples: [ "shard.status()" ],
category: "Shard"
}) ], e.prototype, "status", null), t([ ro({
name: "shard.all",
description: "List all known shards with summary info",
usage: "shard.all()",
examples: [ "shard.all()" ],
category: "Shard"
}) ], e.prototype, "all", null), t([ ro({
name: "shard.setRole",
description: "Manually set the role for the current shard",
usage: "shard.setRole(role)",
examples: [ "shard.setRole('core')", "shard.setRole('frontier')", "shard.setRole('resource')", "shard.setRole('backup')", "shard.setRole('war')" ],
category: "Shard"
}) ], e.prototype, "setRole", null), t([ ro({
name: "shard.portals",
description: "List all known portals from the current shard",
usage: "shard.portals(targetShard?)",
examples: [ "shard.portals()", "shard.portals('shard1')" ],
category: "Shard"
}) ], e.prototype, "portals", null), t([ ro({
name: "shard.bestPortal",
description: "Find the optimal portal route to a target shard",
usage: "shard.bestPortal(targetShard, fromRoom?)",
examples: [ "shard.bestPortal('shard1')", "shard.bestPortal('shard2', 'E1N1')" ],
category: "Shard"
}) ], e.prototype, "bestPortal", null), t([ ro({
name: "shard.createTask",
description: "Create a cross-shard task",
usage: "shard.createTask(type, targetShard, targetRoom?, priority?)",
examples: [ "shard.createTask('colonize', 'shard1', 'E5N5', 80)", "shard.createTask('reinforce', 'shard2', 'W1N1', 90)", "shard.createTask('evacuate', 'shard0', 'E1N1', 100)" ],
category: "Shard"
}) ], e.prototype, "createTask", null), t([ ro({
name: "shard.transferResource",
description: "Create a cross-shard resource transfer task",
usage: "shard.transferResource(targetShard, targetRoom, resourceType, amount, priority?)",
examples: [ "shard.transferResource('shard1', 'E5N5', 'energy', 50000, 70)", "shard.transferResource('shard2', 'W1N1', 'U', 5000, 80)" ],
category: "Shard"
}) ], e.prototype, "transferResource", null), t([ ro({
name: "shard.transfers",
description: "List active cross-shard resource transfers",
usage: "shard.transfers()",
examples: [ "shard.transfers()" ],
category: "Shard"
}) ], e.prototype, "transfers", null), t([ ro({
name: "shard.cpuHistory",
description: "Display CPU allocation history for the current shard",
usage: "shard.cpuHistory()",
examples: [ "shard.cpuHistory()" ],
category: "Shard"
}) ], e.prototype, "cpuHistory", null), t([ ro({
name: "shard.tasks",
description: "List all inter-shard tasks",
usage: "shard.tasks()",
examples: [ "shard.tasks()" ],
category: "Shard"
}) ], e.prototype, "tasks", null), t([ ro({
name: "shard.syncStatus",
description: "Display InterShardMemory sync status and health",
usage: "shard.syncStatus()",
examples: [ "shard.syncStatus()" ],
category: "Shard"
}) ], e.prototype, "syncStatus", null), t([ ro({
name: "shard.memoryStats",
description: "Display InterShardMemory size breakdown",
usage: "shard.memoryStats()",
examples: [ "shard.memoryStats()" ],
category: "Shard"
}) ], e.prototype, "memoryStats", null), t([ ro({
name: "shard.forceSync",
description: "Force a full InterShardMemory sync with validation",
usage: "shard.forceSync()",
examples: [ "shard.forceSync()" ],
category: "Shard"
}) ], e.prototype, "forceSync", null), e;
}(), Hp = new jp, Wp = {
maxPredictionTicks: 100,
safetyMargin: .9,
enableLogging: !1
}, Yp = function() {
function t(t) {
void 0 === t && (t = {}), this.config = e(e({}, Wp), t);
}
return t.prototype.predictEnergyInTicks = function(e, t) {
if (t < 0) throw new Error("Cannot predict negative ticks");
t > this.config.maxPredictionTicks && (Hr.warn("Prediction horizon ".concat(t, " exceeds max ").concat(this.config.maxPredictionTicks, ", clamping"), {
subsystem: "EnergyFlowPredictor"
}), t = this.config.maxPredictionTicks);
var r = this.calculateEnergyIncome(e), o = this.calculateEnergyConsumption(e), n = e.energyAvailable, a = r.total * this.config.safetyMargin - o.total, i = Math.max(0, n + a * t), s = {
current: n,
predicted: i,
income: r,
consumption: o,
netFlow: a,
ticks: t
};
return this.config.enableLogging && Hr.debug("Energy prediction for ".concat(e.name, ": ").concat(n, "  ").concat(i, " (").concat(t, " ticks, ").concat(a.toFixed(2), "/tick)"), {
subsystem: "EnergyFlowPredictor"
}), s;
}, t.prototype.calculateEnergyIncome = function(e) {
var t = this.calculateHarvesterIncome(e), r = this.calculateMinerIncome(e), o = this.calculateLinkIncome(e);
return {
harvesters: t,
miners: r,
links: o,
total: t + r + o
};
}, t.prototype.calculateEnergyConsumption = function(e) {
var t = this.calculateUpgraderConsumption(e), r = this.calculateBuilderConsumption(e), o = this.calculateTowerConsumption(e), n = this.calculateSpawningConsumption(e), a = this.calculateRepairConsumption(e);
return {
upgraders: t,
builders: r,
towers: o,
spawning: n,
repairs: a,
total: t + r + o + n + a
};
}, t.prototype.calculateHarvesterIncome = function(e) {
var t, o, n = e.find(FIND_MY_CREEPS, {
filter: function(e) {
return "harvester" === e.memory.role || "larvaWorker" === e.memory.role;
}
}), a = 0;
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) a += s.value.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length;
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return 2 * a * .5;
}, t.prototype.calculateMinerIncome = function(e) {
var t, o, n = e.find(FIND_MY_CREEPS, {
filter: function(e) {
return "staticMiner" === e.memory.role || "miner" === e.memory.role;
}
}), a = 0;
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) a += s.value.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length;
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return 2 * a * .9;
}, t.prototype.calculateLinkIncome = function(e) {
return 0;
}, t.prototype.calculateUpgraderConsumption = function(e) {
var t, o, n = e.find(FIND_MY_CREEPS, {
filter: function(e) {
return "upgrader" === e.memory.role;
}
}), a = 0;
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) a += s.value.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length;
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return 1 * a * .7;
}, t.prototype.calculateBuilderConsumption = function(e) {
var t, o, n = e.find(FIND_MY_CREEPS, {
filter: function(e) {
return "builder" === e.memory.role || "repairer" === e.memory.role;
}
});
if (0 === e.find(FIND_MY_CONSTRUCTION_SITES).length) return .1;
var a = 0;
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) a += s.value.body.filter(function(e) {
return e.type === WORK && e.hits > 0;
}).length;
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
return 5 * a * .5;
}, t.prototype.calculateTowerConsumption = function(e) {
var t = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_TOWER;
}
});
return 0 === t.length ? 0 : .3 * t.length * 10 * 2;
}, t.prototype.calculateSpawningConsumption = function(e) {
var t = e.find(FIND_MY_STRUCTURES, {
filter: function(e) {
return e.structureType === STRUCTURE_SPAWN;
}
});
if (0 === t.length) return 0;
var r = e.controller, o = 500;
if (r && r.my) {
var n = r.level;
o = n <= 3 ? 300 : n <= 6 ? 750 : 1500;
}
var a = o / 20;
return t.length * a * .8;
}, t.prototype.calculateRepairConsumption = function(e) {
return .5;
}, t.prototype.getRecommendedSpawnDelay = function(e, t) {
var r = e.energyAvailable;
if (r >= t) return 0;
var o = this.predictEnergyInTicks(e, 1);
if (o.netFlow <= 0) return 999;
var n = t - r, a = Math.ceil(n / o.netFlow);
return Math.min(a, this.config.maxPredictionTicks);
}, t.prototype.canAffordInTicks = function(e, t, r) {
return this.predictEnergyInTicks(e, r).predicted >= t;
}, t.prototype.getMaxAffordableInTicks = function(e, t) {
var r = this.predictEnergyInTicks(e, t);
return Math.min(r.predicted, e.energyCapacityAvailable);
}, t.prototype.setConfig = function(t) {
this.config = e(e({}, this.config), t);
}, t.prototype.getConfig = function() {
return e({}, this.config);
}, t;
}(), Kp = new Yp, Vp = new (function() {
function e() {}
return e.prototype.predictEnergy = function(e, t) {
void 0 === t && (t = 50);
var r = Game.rooms[e];
if (!r) return "Room ".concat(e, " is not visible");
if (!r.controller || !r.controller.my) return "Room ".concat(e, " is not owned by you");
var o = Kp.predictEnergyInTicks(r, t), n = "=== Energy Prediction: ".concat(e, " ===\n");
return n += "Current Energy: ".concat(o.current, "\n"), n += "Predicted (".concat(t, " ticks): ").concat(Math.round(o.predicted), "\n"), 
n += "Net Flow: ".concat(o.netFlow.toFixed(2), " energy/tick\n\n"), n += "Income Breakdown (per tick):\n", 
n += "  Harvesters: ".concat(o.income.harvesters.toFixed(2), "\n"), n += "  Static Miners: ".concat(o.income.miners.toFixed(2), "\n"), 
n += "  Links: ".concat(o.income.links.toFixed(2), "\n"), n += "  Total: ".concat(o.income.total.toFixed(2), "\n\n"), 
n += "Consumption Breakdown (per tick):\n", n += "  Upgraders: ".concat(o.consumption.upgraders.toFixed(2), "\n"), 
n += "  Builders: ".concat(o.consumption.builders.toFixed(2), "\n"), n += "  Towers: ".concat(o.consumption.towers.toFixed(2), "\n"), 
n += "  Spawning: ".concat(o.consumption.spawning.toFixed(2), "\n"), (n += "  Repairs: ".concat(o.consumption.repairs.toFixed(2), "\n")) + "  Total: ".concat(o.consumption.total.toFixed(2), "\n");
}, e.prototype.showIncome = function(e) {
var t = Game.rooms[e];
if (!t) return "Room ".concat(e, " is not visible");
var r = Kp.calculateEnergyIncome(t), o = "=== Energy Income: ".concat(e, " ===\n");
return o += "Harvesters: ".concat(r.harvesters.toFixed(2), " energy/tick\n"), o += "Static Miners: ".concat(r.miners.toFixed(2), " energy/tick\n"), 
(o += "Links: ".concat(r.links.toFixed(2), " energy/tick\n")) + "Total: ".concat(r.total.toFixed(2), " energy/tick\n");
}, e.prototype.showConsumption = function(e) {
var t = Game.rooms[e];
if (!t) return "Room ".concat(e, " is not visible");
var r = Kp.calculateEnergyConsumption(t), o = "=== Energy Consumption: ".concat(e, " ===\n");
return o += "Upgraders: ".concat(r.upgraders.toFixed(2), " energy/tick\n"), o += "Builders: ".concat(r.builders.toFixed(2), " energy/tick\n"), 
o += "Towers: ".concat(r.towers.toFixed(2), " energy/tick\n"), o += "Spawning: ".concat(r.spawning.toFixed(2), " energy/tick\n"), 
(o += "Repairs: ".concat(r.repairs.toFixed(2), " energy/tick\n")) + "Total: ".concat(r.total.toFixed(2), " energy/tick\n");
}, e.prototype.canAfford = function(e, t, r) {
void 0 === r && (r = 50);
var o = Game.rooms[e];
if (!o) return "Room ".concat(e, " is not visible");
var n = Kp.canAffordInTicks(o, t, r), a = Kp.predictEnergyInTicks(o, r);
if (n) return " Room ".concat(e, " CAN afford ").concat(t, " energy within ").concat(r, " ticks (predicted: ").concat(Math.round(a.predicted), ")");
var i = Kp.getRecommendedSpawnDelay(o, t);
return i >= 999 ? " Room ".concat(e, " CANNOT afford ").concat(t, " energy (negative energy flow)") : " Room ".concat(e, " CANNOT afford ").concat(t, " energy within ").concat(r, " ticks (would need ").concat(i, " ticks)");
}, e.prototype.getSpawnDelay = function(e, t) {
var r = Game.rooms[e];
if (!r) return "Room ".concat(e, " is not visible");
var o = Kp.getRecommendedSpawnDelay(r, t), n = r.energyAvailable;
if (0 === o) return " Room ".concat(e, " can spawn ").concat(t, " energy body NOW (current: ").concat(n, ")");
if (o >= 999) return " Room ".concat(e, " has negative energy flow, cannot spawn ").concat(t, " energy body");
var a = Kp.predictEnergyInTicks(r, o);
return "Room ".concat(e, " needs to wait ").concat(o, " ticks to spawn ").concat(t, " energy body (current: ").concat(n, ", predicted: ").concat(Math.round(a.predicted), ")");
}, t([ ro({
name: "economy.energy.predict",
description: "Predict energy availability for a room in N ticks",
usage: "economy.energy.predict(roomName, ticks)",
examples: [ "economy.energy.predict('W1N1', 50)", "economy.energy.predict('E1S1', 100)" ],
category: "Economy"
}) ], e.prototype, "predictEnergy", null), t([ ro({
name: "economy.energy.income",
description: "Show energy income breakdown for a room",
usage: "economy.energy.income(roomName)",
examples: [ "economy.energy.income('W1N1')" ],
category: "Economy"
}) ], e.prototype, "showIncome", null), t([ ro({
name: "economy.energy.consumption",
description: "Show energy consumption breakdown for a room",
usage: "economy.energy.consumption(roomName)",
examples: [ "economy.energy.consumption('W1N1')" ],
category: "Economy"
}) ], e.prototype, "showConsumption", null), t([ ro({
name: "economy.energy.canAfford",
description: "Check if a room can afford a certain energy cost within N ticks",
usage: "economy.energy.canAfford(roomName, cost, ticks)",
examples: [ "economy.energy.canAfford('W1N1', 1000, 50)", "economy.energy.canAfford('E1S1', 500, 25)" ],
category: "Economy"
}) ], e.prototype, "canAfford", null), t([ ro({
name: "economy.energy.spawnDelay",
description: "Get recommended spawn delay for a body cost",
usage: "economy.energy.spawnDelay(roomName, cost)",
examples: [ "economy.energy.spawnDelay('W1N1', 1000)", "economy.energy.spawnDelay('E1S1', 500)" ],
category: "Economy"
}) ], e.prototype, "getSpawnDelay", null), e;
}()), zp = function() {
function e() {}
return e.prototype.status = function() {
var e, t, o, n, a, i, s, c, l, u, f = fi.getEmpire(), m = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), p = (Game.gcl.progress / Game.gcl.progressTotal * 100).toFixed(1), d = Game.gcl.level - m.length, y = d > 0, g = f.objectives.expansionPaused, h = f.claimQueue.length, v = f.claimQueue.filter(function(e) {
return !e.claimed;
}).length, R = f.claimQueue.filter(function(e) {
return e.claimed;
}).length, E = Object.values(Game.creeps).filter(function(e) {
var t = e.memory;
return "claimer" === t.role && "claim" === t.task;
}), T = "=== Expansion System Status ===\n\nGCL: Level ".concat(Game.gcl.level, " (").concat(p, "% to next)\nOwned Rooms: ").concat(m.length, "/").concat(Game.gcl.level, "\nAvailable Room Slots: ").concat(d, "\n\nExpansion Status: ").concat(g ? "PAUSED " : y ? "READY " : "AT GCL LIMIT", "\nClaim Queue: ").concat(h, " total (").concat(v, " unclaimed, ").concat(R, " in progress)\nActive Claimers: ").concat(E.length, "\n\n");
if (v > 0) {
T += "=== Top Expansion Candidates ===\n";
var S = f.claimQueue.filter(function(e) {
return !e.claimed;
}).slice(0, 5);
try {
for (var C = r(S), b = C.next(); !b.done; b = C.next()) {
var _ = b.value, O = Game.time - _.lastEvaluated;
T += "  ".concat(_.roomName, ": Score ").concat(_.score.toFixed(0), ", Distance ").concat(_.distance, ", Age ").concat(O, " ticks\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
b && !b.done && (t = C.return) && t.call(C);
} finally {
if (e) throw e.error;
}
}
T += "\n";
}
if (R > 0) {
T += "=== Active Expansion Attempts ===\n";
var w = f.claimQueue.filter(function(e) {
return e.claimed;
}), x = function(e) {
var t = Game.time - e.lastEvaluated, r = E.find(function(t) {
return t.memory.targetRoom === e.roomName;
}), o = r ? "".concat(r.name, " en route") : "No claimer assigned";
T += "  ".concat(e.roomName, ": ").concat(o, ", Age ").concat(t, " ticks\n");
};
try {
for (var U = r(w), M = U.next(); !M.done; M = U.next()) x(_ = M.value);
} catch (e) {
o = {
error: e
};
} finally {
try {
M && !M.done && (n = U.return) && n.call(U);
} finally {
if (o) throw o.error;
}
}
T += "\n";
}
T += "=== Owned Room Distribution ===\n";
var A = new Map;
try {
for (var k = r(m), N = k.next(); !N.done; N = k.next()) {
var P = null !== (c = null === (s = N.value.controller) || void 0 === s ? void 0 : s.level) && void 0 !== c ? c : 0;
A.set(P, (null !== (l = A.get(P)) && void 0 !== l ? l : 0) + 1);
}
} catch (e) {
a = {
error: e
};
} finally {
try {
N && !N.done && (i = k.return) && i.call(k);
} finally {
if (a) throw a.error;
}
}
for (P = 8; P >= 1; P--) {
var I = null !== (u = A.get(P)) && void 0 !== u ? u : 0;
if (I > 0) {
var G = "".repeat(I);
T += "  RCL ".concat(P, ": ").concat(G, " (").concat(I, ")\n");
}
}
return T;
}, e.prototype.pause = function() {
return fi.getEmpire().objectives.expansionPaused = !0, "Expansion paused. Use expansion.resume() to re-enable.";
}, e.prototype.resume = function() {
return fi.getEmpire().objectives.expansionPaused = !1, "Expansion resumed.";
}, e.prototype.addRemote = function(e, t) {
return kl.addRemoteRoom(e, t) ? "Added remote ".concat(t, " to ").concat(e) : "Failed to add remote (check logs for details)";
}, e.prototype.removeRemote = function(e, t) {
return kl.removeRemoteRoom(e, t) ? "Removed remote ".concat(t, " from ").concat(e) : "Remote ".concat(t, " not found in ").concat(e);
}, e.prototype.clearQueue = function() {
var e = fi.getEmpire(), t = e.claimQueue.length;
return e.claimQueue = [], "Cleared ".concat(t, " candidates from claim queue. Queue will repopulate on next empire tick.");
}, t([ ro({
name: "expansion.status",
description: "Show expansion system status, GCL progress, and claim queue",
usage: "expansion.status()",
examples: [ "expansion.status()" ],
category: "Empire"
}) ], e.prototype, "status", null), t([ ro({
name: "expansion.pause",
description: "Pause autonomous expansion",
usage: "expansion.pause()",
examples: [ "expansion.pause()" ],
category: "Empire"
}) ], e.prototype, "pause", null), t([ ro({
name: "expansion.resume",
description: "Resume autonomous expansion",
usage: "expansion.resume()",
examples: [ "expansion.resume()" ],
category: "Empire"
}) ], e.prototype, "resume", null), t([ ro({
name: "expansion.addRemote",
description: "Manually add a remote room assignment",
usage: "expansion.addRemote(homeRoom, remoteRoom)",
examples: [ "expansion.addRemote('W1N1', 'W2N1')" ],
category: "Empire"
}) ], e.prototype, "addRemote", null), t([ ro({
name: "expansion.removeRemote",
description: "Manually remove a remote room assignment",
usage: "expansion.removeRemote(homeRoom, remoteRoom)",
examples: [ "expansion.removeRemote('W1N1', 'W2N1')" ],
category: "Empire"
}) ], e.prototype, "removeRemote", null), t([ ro({
name: "expansion.clearQueue",
description: "Clear the expansion claim queue",
usage: "expansion.clearQueue()",
examples: [ "expansion.clearQueue()" ],
category: "Empire"
}) ], e.prototype, "clearQueue", null), e;
}(), qp = new zp, Xp = {
status: function() {
return bu.getStatus();
},
enable: function() {
return bu.enable(), "TooAngel integration enabled";
},
disable: function() {
return bu.disable(), "TooAngel integration disabled";
},
reputation: function() {
var e = mu();
return "Current TooAngel reputation: ".concat(e);
},
requestReputation: function(e) {
return du(e) ? "Reputation request sent".concat(e ? " from ".concat(e) : "") : "Failed to send reputation request (check logs for details)";
},
quests: function() {
var e, t = hu(), r = [ "Active Quests:" ];
if (0 === Object.keys(t).length) r.push("  No active quests"); else for (var o in t) {
var n = t[o], a = n.deadline - Game.time, i = (null === (e = n.assignedCreeps) || void 0 === e ? void 0 : e.length) || 0;
r.push("  ".concat(o, ":")), r.push("    Type: ".concat(n.type)), r.push("    Target: ".concat(n.targetRoom)), 
r.push("    Status: ".concat(n.status)), r.push("    Time left: ".concat(a, " ticks")), 
r.push("    Assigned creeps: ".concat(i));
}
return r.join("\n");
},
npcs: function() {
var e = lu(), t = [ "TooAngel NPC Rooms:" ];
if (0 === Object.keys(e).length) t.push("  No NPC rooms discovered"); else for (var r in e) {
var o = e[r];
t.push("  ".concat(r, ":")), t.push("    Has terminal: ".concat(o.hasTerminal)), 
t.push("    Available quests: ".concat(o.availableQuests.length)), t.push("    Last seen: ".concat(Game.time - o.lastSeen, " ticks ago"));
}
return t.join("\n");
},
apply: function(e, t, r) {
return Eu(e, t, r) ? "Applied for quest ".concat(e).concat(r ? " from ".concat(r) : "") : "Failed to apply for quest (check logs for details)";
},
help: function() {
return [ "TooAngel Console Commands:", "", "  tooangel.status()                    - Show current status", "  tooangel.enable()                    - Enable integration", "  tooangel.disable()                   - Disable integration", "  tooangel.reputation()                - Get current reputation", "  tooangel.requestReputation(fromRoom) - Request reputation update", "  tooangel.quests()                    - List active quests", "  tooangel.npcs()                      - List discovered NPC rooms", "  tooangel.apply(id, origin, fromRoom) - Apply for a quest", "  tooangel.help()                      - Show this help" ].join("\n");
}
}, Qp = function() {
function e() {}
return e.prototype.status = function() {
var e = qa.checkMemoryUsage(), t = e.breakdown, r = "Memory Status: ".concat(e.status.toUpperCase(), "\n");
return r += "Usage: ".concat(qa.formatBytes(e.used), " / ").concat(qa.formatBytes(e.limit), " (").concat((100 * e.percentage).toFixed(1), "%)\n\n"), 
r += "Breakdown:\n", r += "  Empire:        ".concat(qa.formatBytes(t.empire), " (").concat((t.empire / t.total * 100).toFixed(1), "%)\n"), 
r += "  Rooms:         ".concat(qa.formatBytes(t.rooms), " (").concat((t.rooms / t.total * 100).toFixed(1), "%)\n"), 
r += "  Creeps:        ".concat(qa.formatBytes(t.creeps), " (").concat((t.creeps / t.total * 100).toFixed(1), "%)\n"), 
r += "  Clusters:      ".concat(qa.formatBytes(t.clusters), " (").concat((t.clusters / t.total * 100).toFixed(1), "%)\n"), 
(r += "  SS2 Queue:     ".concat(qa.formatBytes(t.ss2PacketQueue), " (").concat((t.ss2PacketQueue / t.total * 100).toFixed(1), "%)\n")) + "  Other:         ".concat(qa.formatBytes(t.other), " (").concat((t.other / t.total * 100).toFixed(1), "%)\n");
}, e.prototype.analyze = function(e) {
void 0 === e && (e = 10);
var t = qa.getLargestConsumers(e), r = Za.getRecommendations(), o = "Top ".concat(e, " Memory Consumers:\n");
return t.forEach(function(e, t) {
o += "".concat(t + 1, ". ").concat(e.type, ":").concat(e.name, " - ").concat(qa.formatBytes(e.size), "\n");
}), r.length > 0 ? (o += "\nRecommendations:\n", r.forEach(function(e) {
o += "- ".concat(e, "\n");
})) : o += "\nNo recommendations at this time.\n", o;
}, e.prototype.prune = function() {
var e = Za.pruneAll(), t = "Memory Pruning Complete:\n";
return t += "  Dead creeps removed:        ".concat(e.deadCreeps, "\n"), t += "  Event log entries removed:  ".concat(e.eventLogs, "\n"), 
t += "  Stale intel removed:        ".concat(e.staleIntel, "\n"), (t += "  Market history removed:     ".concat(e.marketHistory, "\n")) + "  Total bytes saved:          ".concat(qa.formatBytes(e.bytesSaved), "\n");
}, e.prototype.segments = function() {
var e, t, n = ei.getActiveSegments(), a = "Memory Segments:\n\n";
a += "Active segments: ".concat(n.length, "/10\n"), n.length > 0 && (a += "  Loaded: [".concat(n.join(", "), "]\n\n")), 
a += "Allocation Strategy:\n";
var i = function(e, t) {
a += "  ".concat(e.padEnd(20), " ").concat(t.start.toString().padStart(2), "-").concat(t.end.toString().padEnd(2));
var r = n.filter(function(e) {
return e >= t.start && e <= t.end;
});
if (r.length > 0) {
var o = r.map(function(e) {
var t = ei.getSegmentSize(e);
return "".concat(e, ":").concat(qa.formatBytes(t));
});
a += " [".concat(o.join(", "), "]");
}
a += "\n";
};
try {
for (var s = r(Object.entries(Ja)), c = s.next(); !c.done; c = s.next()) {
var l = o(c.value, 2);
i(l[0], l[1]);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
return a;
}, e.prototype.compress = function(e) {
var t, o, n = e.split("."), a = Memory;
try {
for (var i = r(n), s = i.next(); !s.done; s = i.next()) {
var c = s.value;
if (!a || "object" != typeof a || !(c in a)) return "Path not found: ".concat(e);
a = a[c];
}
} catch (e) {
t = {
error: e
};
} finally {
try {
s && !s.done && (o = i.return) && o.call(i);
} finally {
if (t) throw t.error;
}
}
if (!a) return "No data at path: ".concat(e);
var l = ni.getCompressionStats(a), u = "Compression Test for: ".concat(e, "\n");
return u += "  Original size:    ".concat(qa.formatBytes(l.originalSize), "\n"), 
u += "  Compressed size:  ".concat(qa.formatBytes(l.compressedSize), "\n"), u += "  Bytes saved:      ".concat(qa.formatBytes(l.bytesSaved), "\n"), 
(u += "  Compression ratio: ".concat((100 * l.ratio).toFixed(1), "%\n")) + "  Worth compressing: ".concat(l.ratio < .9 ? "YES" : "NO", "\n");
}, e.prototype.migrations = function() {
var e = si.getCurrentVersion(), t = si.getLatestVersion(), r = si.getPendingMigrations(), o = "Memory Migration Status:\n";
return o += "  Current version: ".concat(e, "\n"), o += "  Latest version:  ".concat(t, "\n"), 
o += "  Status: ".concat(r.length > 0 ? "PENDING" : "UP TO DATE", "\n\n"), r.length > 0 && (o += "Pending Migrations:\n", 
r.forEach(function(e) {
o += "  v".concat(e.version, ": ").concat(e.description, "\n");
}), o += "\nMigrations will run automatically on next tick.\n"), o;
}, e.prototype.migrate = function() {
var e = si.getCurrentVersion();
si.runMigrations();
var t = si.getCurrentVersion();
return t > e ? "Migrated from v".concat(e, " to v").concat(t) : "No migrations needed (current: v".concat(t, ")");
}, e.prototype.reset = function(e) {
if ("CONFIRM" !== e) return "WARNING: This will clear ALL memory!\nTo confirm, use: memory.reset('CONFIRM')";
var t = Memory;
for (var r in t) delete t[r];
for (var o = 0; o < 100; o++) RawMemory.segments[o] = "";
return fi.initialize(), "Memory reset complete. All data cleared (main memory + 100 segments).";
}, t([ ro({
name: "memory.status",
description: "Show current memory usage and status",
usage: "memory.status()",
examples: [ "memory.status()" ],
category: "Memory"
}) ], e.prototype, "status", null), t([ ro({
name: "memory.analyze",
description: "Analyze memory usage and show largest consumers",
usage: "memory.analyze([topN])",
examples: [ "memory.analyze()", "memory.analyze(20)" ],
category: "Memory"
}) ], e.prototype, "analyze", null), t([ ro({
name: "memory.prune",
description: "Manually trigger memory pruning to clean stale data",
usage: "memory.prune()",
examples: [ "memory.prune()" ],
category: "Memory"
}) ], e.prototype, "prune", null), t([ ro({
name: "memory.segments",
description: "Show memory segment allocation and usage",
usage: "memory.segments()",
examples: [ "memory.segments()" ],
category: "Memory"
}) ], e.prototype, "segments", null), t([ ro({
name: "memory.compress",
description: "Test compression on a memory path",
usage: "memory.compress(path)",
examples: [ "memory.compress('empire.knownRooms')" ],
category: "Memory"
}) ], e.prototype, "compress", null), t([ ro({
name: "memory.migrations",
description: "Show migration status and pending migrations",
usage: "memory.migrations()",
examples: [ "memory.migrations()" ],
category: "Memory"
}) ], e.prototype, "migrations", null), t([ ro({
name: "memory.migrate",
description: "Manually trigger memory migrations",
usage: "memory.migrate()",
examples: [ "memory.migrate()" ],
category: "Memory"
}) ], e.prototype, "migrate", null), t([ ro({
name: "memory.reset",
description: "Clear all memory (DANGEROUS - requires confirmation)",
usage: "memory.reset('CONFIRM')",
examples: [ "memory.reset('CONFIRM')" ],
category: "Memory"
}) ], e.prototype, "reset", null), e;
}(), Zp = new Qp;

function Jp(e) {
var t = e.match(/\((.*?)\)/);
if (t && t[1]) {
var r = t[1].split(",").map(function(e) {
return e.trim();
}).filter(function(e) {
return e;
});
if (0 !== r.length) return r.map(function(e) {
return {
name: e,
desc: "Parameter: ".concat(e)
};
});
}
}

!function() {
function e() {}
e.prototype.uiHelp = function(e) {
return e ? function(e) {
var t = to.getCommandsByCategory(), r = t.get(e);
if (!r || 0 === r.length) return 'Category "'.concat(e, '" not found. Available categories: ').concat(Array.from(t.keys()).join(", "));
var o = r.map(function(e) {
var t, r;
return {
title: e.metadata.description,
describe: null === (t = e.metadata.examples) || void 0 === t ? void 0 : t[0],
functionName: e.metadata.name,
commandType: !(null === (r = e.metadata.usage) || void 0 === r ? void 0 : r.includes("(")),
params: e.metadata.usage ? Jp(e.metadata.usage) : void 0
};
});
return qn.createHelp({
name: e,
describe: "".concat(e, " commands"),
api: o
});
}(e) : function() {
var e, t, a = to.getCommandsByCategory(), i = [];
try {
for (var s = r(a), c = s.next(); !c.done; c = s.next()) {
var l = o(c.value, 2), u = l[0], f = l[1].map(function(e) {
var t, r = {
title: e.metadata.description,
functionName: e.metadata.name,
commandType: !(null === (t = e.metadata.usage) || void 0 === t ? void 0 : t.includes("("))
};
if (e.metadata.examples && e.metadata.examples.length > 0 && (r.describe = e.metadata.examples[0]), 
e.metadata.usage) {
var o = e.metadata.usage.match(/\((.*?)\)/);
if (o && o[1]) {
var n = o[1].split(",").map(function(e) {
return e.trim();
}).filter(function(e) {
return e;
});
n.length > 0 && (r.params = n.map(function(e) {
return {
name: e,
desc: "Parameter: ".concat(e)
};
}));
}
}
return r;
});
i.push({
name: u,
describe: "".concat(u, " commands for bot management"),
api: f
});
}
} catch (t) {
e = {
error: t
};
} finally {
try {
c && !c.done && (t = s.return) && t.call(s);
} finally {
if (e) throw e.error;
}
}
return qn.createHelp.apply(void 0, n([], o(i), !1));
}();
}, e.prototype.spawnForm = function(e) {
return Game.rooms[e] ? qn.createElement.form("spawnCreep", [ {
type: "select",
name: "role",
label: "Role:",
options: [ {
value: "harvester",
label: "Harvester"
}, {
value: "upgrader",
label: "Upgrader"
}, {
value: "builder",
label: "Builder"
}, {
value: "hauler",
label: "Hauler"
}, {
value: "repairer",
label: "Repairer"
}, {
value: "defender",
label: "Defender"
} ]
}, {
type: "input",
name: "name",
label: "Name (optional):",
placeholder: "Auto-generated if empty"
} ], {
content: "Spawn Creep",
command: "({role, name}) => {\n        const room = Game.rooms['".concat(e, "'];\n        if (!room) return 'Room not found';\n        const spawns = room.find(FIND_MY_SPAWNS);\n        if (spawns.length === 0) return 'No spawns found';\n        const spawn = spawns[0];\n        const body = [WORK, CARRY, MOVE]; // Basic body\n        const creepName = name || role + '_' + Game.time;\n        const result = spawn.spawnCreep(body, creepName, {memory: {role: role}});\n        return result === OK ? 'Spawning ' + creepName : 'Error: ' + result;\n      }")
}) : qn.colorful("Room ".concat(e, " not found or not visible"), "red", !0);
}, e.prototype.roomControl = function(e) {
var t = Game.rooms[e];
if (!t) return qn.colorful("Room ".concat(e, " not found or not visible"), "red", !0);
var r = '<div style="background: #2b2b2b; padding: 10px; margin: 5px;">';
return r += '<h3 style="color: #c5c599; margin: 0 0 10px 0;">Room Control: '.concat(e, "</h3>"), 
r += '<div style="margin-bottom: 10px;">', r += qn.colorful("Energy: ".concat(t.energyAvailable, "/").concat(t.energyCapacityAvailable), "green") + "<br>", 
t.controller && (r += qn.colorful("Controller Level: ".concat(t.controller.level, " (").concat(t.controller.progress, "/").concat(t.controller.progressTotal, ")"), "blue") + "<br>"), 
r += "</div>", r += qn.createElement.button({
content: " Toggle Visualizations",
command: "() => {\n        const config = global.botConfig.getConfig();\n        global.botConfig.updateConfig({visualizations: !config.visualizations});\n        return 'Visualizations: ' + (!config.visualizations ? 'ON' : 'OFF');\n      }"
}), r += " ", (r += qn.createElement.button({
content: " Room Stats",
command: "() => {\n        const room = Game.rooms['".concat(e, "'];\n        if (!room) return 'Room not found';\n        let stats = '=== Room Stats ===\\n';\n        stats += 'Energy: ' + room.energyAvailable + '/' + room.energyCapacityAvailable + '\\n';\n        stats += 'Creeps: ' + Object.values(Game.creeps).filter(c => c.room.name === '").concat(e, "').length + '\\n';\n        if (room.controller) {\n          stats += 'RCL: ' + room.controller.level + '\\n';\n          stats += 'Progress: ' + room.controller.progress + '/' + room.controller.progressTotal + '\\n';\n        }\n        return stats;\n      }")
})) + "</div>";
}, e.prototype.logForm = function() {
return qn.createElement.form("configureLogging", [ {
type: "select",
name: "level",
label: "Log Level:",
options: [ {
value: "debug",
label: "Debug (Verbose)"
}, {
value: "info",
label: "Info (Normal)"
}, {
value: "warn",
label: "Warning (Important)"
}, {
value: "error",
label: "Error (Critical Only)"
}, {
value: "none",
label: "None (Disabled)"
} ]
} ], {
content: "Set Log Level",
command: "({level}) => {\n        const levelMap = {\n          debug: 0,\n          info: 1,\n          warn: 2,\n          error: 3,\n          none: 4\n        };\n        const logLevel = levelMap[level];\n        global.botLogger.configureLogger({level: logLevel});\n        return 'Log level set to: ' + level.toUpperCase();\n      }"
});
}, e.prototype.visForm = function() {
return qn.createElement.form("configureVisualization", [ {
type: "select",
name: "mode",
label: "Visualization Mode:",
options: [ {
value: "debug",
label: "Debug (All layers)"
}, {
value: "presentation",
label: "Presentation (Clean)"
}, {
value: "minimal",
label: "Minimal (Basic only)"
}, {
value: "performance",
label: "Performance (Disabled)"
} ]
} ], {
content: "Set Visualization Mode",
command: "({mode}) => {\n        global.botVisualizationManager.setMode(mode);\n        return 'Visualization mode set to: ' + mode;\n      }"
});
}, e.prototype.quickActions = function() {
var e = '<div style="background: #2b2b2b; padding: 10px; margin: 5px;">';
return e += '<h3 style="color: #c5c599; margin: 0 0 10px 0;">Quick Actions</h3>', 
e += qn.createElement.button({
content: " Emergency Mode",
command: "() => {\n        const config = global.botConfig.getConfig();\n        global.botConfig.updateConfig({emergencyMode: !config.emergencyMode});\n        return 'Emergency Mode: ' + (!config.emergencyMode ? 'ON' : 'OFF');\n      }"
}), e += " ", e += qn.createElement.button({
content: " Toggle Debug",
command: "() => {\n        const config = global.botConfig.getConfig();\n        const newValue = !config.debug;\n        global.botConfig.updateConfig({debug: newValue});\n        global.botLogger.configureLogger({level: newValue ? 0 : 1});\n        return 'Debug mode: ' + (newValue ? 'ON' : 'OFF');\n      }"
}), e += " ", (e += qn.createElement.button({
content: " Clear Cache",
command: "() => {\n        global.botCacheManager.clear();\n        return 'Cache cleared successfully';\n      }"
})) + "</div>";
}, e.prototype.colorDemo = function() {
var e = "=== Console Color Demo ===\n\n";
return e += qn.colorful(" Success message", "green", !0) + "\n", e += qn.colorful(" Warning message", "yellow", !0) + "\n", 
e += qn.colorful(" Error message", "red", !0) + "\n", e += qn.colorful(" Info message", "blue", !0) + "\n", 
(e += "\nNormal text: " + qn.colorful("colored text", "green") + " normal text\n") + "Bold text: " + qn.colorful("important", null, !0) + "\n";
}, t([ ro({
name: "uiHelp",
description: "Show interactive help interface with expandable sections",
usage: "uiHelp()",
examples: [ "uiHelp()", 'uiHelp("Logging")', 'uiHelp("Visualization")' ],
category: "System"
}) ], e.prototype, "uiHelp", null), t([ ro({
name: "spawnForm",
description: "Show interactive form for spawning creeps",
usage: "spawnForm(roomName)",
examples: [ 'spawnForm("W1N1")', 'spawnForm("E2S3")' ],
category: "Spawning"
}) ], e.prototype, "spawnForm", null), t([ ro({
name: "roomControl",
description: "Show interactive room control panel",
usage: "roomControl(roomName)",
examples: [ 'roomControl("W1N1")' ],
category: "Room Management"
}) ], e.prototype, "roomControl", null), t([ ro({
name: "logForm",
description: "Show interactive form for configuring logging",
usage: "logForm()",
examples: [ "logForm()" ],
category: "Logging"
}) ], e.prototype, "logForm", null), t([ ro({
name: "visForm",
description: "Show interactive form for visualization settings",
usage: "visForm()",
examples: [ "visForm()" ],
category: "Visualization"
}) ], e.prototype, "visForm", null), t([ ro({
name: "quickActions",
description: "Show quick action buttons for common operations",
usage: "quickActions()",
examples: [ "quickActions()" ],
category: "System"
}) ], e.prototype, "quickActions", null), t([ ro({
name: "colorDemo",
description: "Show color demonstration for console output",
usage: "colorDemo()",
examples: [ "colorDemo()" ],
category: "System"
}) ], e.prototype, "colorDemo", null);
}();

var $p = jr("VisualizationManager"), ed = function() {
function t() {
this.perfSamples = {}, this.config = this.loadConfig();
}
return t.prototype.loadConfig = function() {
var e = Memory;
return e.visualConfig || (e.visualConfig = this.createDefaultConfig()), e.visualConfig;
}, t.prototype.saveConfig = function() {
Memory.visualConfig = this.config;
}, t.prototype.createDefaultConfig = function() {
return {
enabledLayers: Da.Pheromones | Da.Defense,
mode: "presentation",
layerCosts: {
pheromones: 0,
paths: 0,
traffic: 0,
defense: 0,
economy: 0,
construction: 0
},
totalCost: 0,
cache: {
terrain: {},
structures: {}
},
lastCacheClear: Game.time
};
}, t.prototype.isLayerEnabled = function(e) {
return 0 !== (this.config.enabledLayers & e);
}, t.prototype.enableLayer = function(e) {
this.config.enabledLayers |= e, this.saveConfig();
}, t.prototype.disableLayer = function(e) {
this.config.enabledLayers &= ~e, this.saveConfig();
}, t.prototype.toggleLayer = function(e) {
this.config.enabledLayers ^= e, this.saveConfig();
}, t.prototype.setMode = function(e) {
switch (this.config.mode = e, e) {
case "debug":
this.config.enabledLayers = Da.Pheromones | Da.Paths | Da.Traffic | Da.Defense | Da.Economy | Da.Construction | Da.Performance;
break;

case "presentation":
this.config.enabledLayers = Da.Pheromones | Da.Defense | Da.Economy;
break;

case "minimal":
this.config.enabledLayers = Da.Defense;
break;

case "performance":
this.config.enabledLayers = Da.None;
}
this.saveConfig(), $p.info("Visualization mode set to: ".concat(e));
}, t.prototype.updateFromFlags = function() {
var e, t, n = Game.flags, a = {
viz_pheromones: Da.Pheromones,
viz_paths: Da.Paths,
viz_traffic: Da.Traffic,
viz_defense: Da.Defense,
viz_economy: Da.Economy,
viz_construction: Da.Construction,
viz_performance: Da.Performance
}, i = function(e, t) {
Object.values(n).some(function(t) {
return t.name === e;
}) && !s.isLayerEnabled(t) && (s.enableLayer(t), $p.info("Enabled layer ".concat(Da[t], " via flag")));
}, s = this;
try {
for (var c = r(Object.entries(a)), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2);
i(u[0], u[1]);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
}, t.prototype.trackLayerCost = function(e, t) {
this.perfSamples[e] || (this.perfSamples[e] = []), this.perfSamples[e].push(t), 
this.perfSamples[e].length > 10 && this.perfSamples[e].shift();
var r = this.perfSamples[e], o = r.reduce(function(e, t) {
return e + t;
}, 0) / r.length;
this.config.layerCosts[e] = o, this.config.totalCost = Object.values(this.config.layerCosts).reduce(function(e, t) {
return e + t;
}, 0);
var n = Game.cpu.limit, a = this.config.totalCost / n * 100;
a > 10 && $p.warn("Visualization using ".concat(a.toFixed(1), "% of CPU budget"));
}, t.prototype.getCachedTerrain = function(e) {
var t = this.config.cache.terrain[e];
return !t || Game.time > t.ttl ? null : t.data;
}, t.prototype.cacheTerrain = function(e, t) {
this.config.cache.terrain[e] = {
data: t,
ttl: Game.time + 100
};
}, t.prototype.getCachedStructures = function(e) {
var t = this.config.cache.structures[e];
return !t || Game.time > t.ttl ? null : t.data;
}, t.prototype.cacheStructures = function(e, t) {
this.config.cache.structures[e] = {
data: t,
ttl: Game.time + 100
};
}, t.prototype.clearCache = function(e) {
e ? (delete this.config.cache.terrain[e], delete this.config.cache.structures[e]) : (this.config.cache = {
terrain: {},
structures: {}
}, this.config.lastCacheClear = Game.time), this.saveConfig();
}, t.prototype.getConfig = function() {
return e({}, this.config);
}, t.prototype.getPerformanceMetrics = function() {
var t = Game.cpu.limit;
return {
totalCost: this.config.totalCost,
layerCosts: e({}, this.config.layerCosts),
percentOfBudget: this.config.totalCost / t * 100
};
}, t.prototype.measureCost = function(e) {
var t = Game.cpu.getUsed();
return {
result: e(),
cost: Game.cpu.getUsed() - t
};
}, t;
}(), td = new ed, rd = function() {
function e() {}
return e.prototype.setLogLevel = function(e) {
var t = {
debug: Cr.DEBUG,
info: Cr.INFO,
warn: Cr.WARN,
error: Cr.ERROR,
none: Cr.NONE
}[e.toLowerCase()];
return void 0 === t ? "Invalid log level: ".concat(e, ". Valid levels: debug, info, warn, error, none") : (xr({
level: t
}), "Log level set to: ".concat(e.toUpperCase()));
}, e.prototype.toggleDebug = function() {
var e = !mo().debug;
return po({
debug: e
}), xr({
level: e ? Cr.DEBUG : Cr.INFO
}), "Debug mode: ".concat(e ? "ENABLED" : "DISABLED", " (Log level: ").concat(e ? "DEBUG" : "INFO", ")");
}, t([ ro({
name: "setLogLevel",
description: "Set the log level for the bot",
usage: "setLogLevel(level)",
examples: [ "setLogLevel('debug')", "setLogLevel('info')", "setLogLevel('warn')", "setLogLevel('error')", "setLogLevel('none')" ],
category: "Logging"
}) ], e.prototype, "setLogLevel", null), t([ ro({
name: "toggleDebug",
description: "Toggle debug mode on/off (affects log level and debug features)",
usage: "toggleDebug()",
examples: [ "toggleDebug()" ],
category: "Logging"
}) ], e.prototype, "toggleDebug", null), e;
}(), od = function() {
function e() {}
return e.prototype.toggleVisualizations = function() {
var e = !mo().visualizations;
return po({
visualizations: e
}), "Visualizations: ".concat(e ? "ENABLED" : "DISABLED");
}, e.prototype.toggleVisualization = function(e) {
var t = Mp.getConfig(), r = Object.keys(t).filter(function(e) {
return e.startsWith("show") && "boolean" == typeof t[e];
});
if (!r.includes(e)) return "Invalid key: ".concat(e, ". Valid keys: ").concat(r.join(", "));
var o = e;
Mp.toggle(o);
var n = Mp.getConfig()[o];
return "Room visualization '".concat(e, "': ").concat(n ? "ENABLED" : "DISABLED");
}, e.prototype.toggleMapVisualization = function(e) {
var t = Ap.getConfig(), r = Object.keys(t).filter(function(e) {
return e.startsWith("show") && "boolean" == typeof t[e];
});
if (!r.includes(e)) return "Invalid key: ".concat(e, ". Valid keys: ").concat(r.join(", "));
var o = e;
Ap.toggle(o);
var n = Ap.getConfig()[o];
return "Map visualization '".concat(e, "': ").concat(n ? "ENABLED" : "DISABLED");
}, e.prototype.showMapConfig = function() {
var e = Ap.getConfig();
return Object.entries(e).map(function(e) {
var t = o(e, 2), r = t[0], n = t[1];
return "".concat(r, ": ").concat(String(n));
}).join("\n");
}, e.prototype.setVisMode = function(e) {
var t = [ "debug", "presentation", "minimal", "performance" ];
return t.includes(e) ? (td.setMode(e), "Visualization mode set to: ".concat(e)) : "Invalid mode: ".concat(e, ". Valid modes: ").concat(t.join(", "));
}, e.prototype.toggleVisLayer = function(e) {
var t = {
pheromones: Da.Pheromones,
paths: Da.Paths,
traffic: Da.Traffic,
defense: Da.Defense,
economy: Da.Economy,
construction: Da.Construction,
performance: Da.Performance
}, r = t[e.toLowerCase()];
if (!r) return "Unknown layer: ".concat(e, ". Valid layers: ").concat(Object.keys(t).join(", "));
td.toggleLayer(r);
var o = td.isLayerEnabled(r);
return "Layer ".concat(e, ": ").concat(o ? "enabled" : "disabled");
}, e.prototype.showVisPerf = function() {
var e, t, n = td.getPerformanceMetrics(), a = "=== Visualization Performance ===\n";
a += "Total CPU: ".concat(n.totalCost.toFixed(3), "\n"), a += "% of Budget: ".concat(n.percentOfBudget.toFixed(2), "%\n"), 
a += "\nPer-Layer Costs:\n";
try {
for (var i = r(Object.entries(n.layerCosts)), s = i.next(); !s.done; s = i.next()) {
var c = o(s.value, 2), l = c[0], u = c[1];
u > 0 && (a += "  ".concat(l, ": ").concat(u.toFixed(3), " CPU\n"));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return a;
}, e.prototype.showVisConfig = function() {
var e, t, n, a = td.getConfig(), i = "=== Visualization Configuration ===\n";
i += "Mode: ".concat(a.mode, "\n"), i += "\nEnabled Layers:\n";
var s = ((e = {})[Da.Pheromones] = "Pheromones", e[Da.Paths] = "Paths", e[Da.Traffic] = "Traffic", 
e[Da.Defense] = "Defense", e[Da.Economy] = "Economy", e[Da.Construction] = "Construction", 
e[Da.Performance] = "Performance", e);
try {
for (var c = r(Object.entries(s)), l = c.next(); !l.done; l = c.next()) {
var u = o(l.value, 2), f = u[0], m = u[1], p = parseInt(f, 10), d = 0 !== (a.enabledLayers & p);
i += "  ".concat(m, ": ").concat(d ? "" : "", "\n");
}
} catch (e) {
t = {
error: e
};
} finally {
try {
l && !l.done && (n = c.return) && n.call(c);
} finally {
if (t) throw t.error;
}
}
return i;
}, e.prototype.clearVisCache = function(e) {
return td.clearCache(e), e ? "Visualization cache cleared for room: ".concat(e) : "All visualization caches cleared";
}, t([ ro({
name: "toggleVisualizations",
description: "Toggle all visualizations on/off",
usage: "toggleVisualizations()",
examples: [ "toggleVisualizations()" ],
category: "Visualization"
}) ], e.prototype, "toggleVisualizations", null), t([ ro({
name: "toggleVisualization",
description: "Toggle a specific room visualization feature",
usage: "toggleVisualization(key)",
examples: [ "toggleVisualization('showPheromones')", "toggleVisualization('showPaths')", "toggleVisualization('showCombat')" ],
category: "Visualization"
}) ], e.prototype, "toggleVisualization", null), t([ ro({
name: "toggleMapVisualization",
description: "Toggle a specific map visualization feature",
usage: "toggleMapVisualization(key)",
examples: [ "toggleMapVisualization('showRoomStatus')", "toggleMapVisualization('showConnections')", "toggleMapVisualization('showThreats')", "toggleMapVisualization('showExpansion')" ],
category: "Visualization"
}) ], e.prototype, "toggleMapVisualization", null), t([ ro({
name: "showMapConfig",
description: "Show current map visualization configuration",
usage: "showMapConfig()",
examples: [ "showMapConfig()" ],
category: "Visualization"
}) ], e.prototype, "showMapConfig", null), t([ ro({
name: "setVisMode",
description: "Set visualization mode preset (debug, presentation, minimal, performance)",
usage: "setVisMode(mode)",
examples: [ "setVisMode('debug')", "setVisMode('presentation')", "setVisMode('minimal')", "setVisMode('performance')" ],
category: "Visualization"
}) ], e.prototype, "setVisMode", null), t([ ro({
name: "toggleVisLayer",
description: "Toggle a specific visualization layer",
usage: "toggleVisLayer(layer)",
examples: [ "toggleVisLayer('pheromones')", "toggleVisLayer('paths')", "toggleVisLayer('defense')", "toggleVisLayer('economy')", "toggleVisLayer('performance')" ],
category: "Visualization"
}) ], e.prototype, "toggleVisLayer", null), t([ ro({
name: "showVisPerf",
description: "Show visualization performance metrics",
usage: "showVisPerf()",
examples: [ "showVisPerf()" ],
category: "Visualization"
}) ], e.prototype, "showVisPerf", null), t([ ro({
name: "showVisConfig",
description: "Show current visualization configuration",
usage: "showVisConfig()",
examples: [ "showVisConfig()" ],
category: "Visualization"
}) ], e.prototype, "showVisConfig", null), t([ ro({
name: "clearVisCache",
description: "Clear visualization cache",
usage: "clearVisCache(roomName?)",
examples: [ "clearVisCache()", "clearVisCache('W1N1')" ],
category: "Visualization"
}) ], e.prototype, "clearVisCache", null), e;
}(), nd = function() {
function e() {}
return e.prototype.showStats = function() {
var e = Io.memorySegmentStats.getLatestStats();
return e ? "=== SwarmBot Stats (Tick ".concat(e.tick, ") ===\nCPU: ").concat(e.cpuUsed.toFixed(2), "/").concat(e.cpuLimit, " (Bucket: ").concat(e.cpuBucket, ")\nGCL: ").concat(e.gclLevel, " (").concat((100 * e.gclProgress).toFixed(1), "%)\nGPL: ").concat(e.gplLevel, "\nCreeps: ").concat(e.totalCreeps, "\nRooms: ").concat(e.totalRooms, "\n").concat(e.rooms.map(function(e) {
return "  ".concat(e.roomName, ": RCL").concat(e.rcl, " | ").concat(e.creepCount, " creeps | ").concat(e.storageEnergy, "E");
}).join("\n")) : "No stats available yet. Wait for a few ticks.";
}, e.prototype.cacheStats = function() {
var e, t = va.getCacheStats(Ea);
return "=== Object Cache Statistics ===\nCache Size: ".concat(t.size, " entries\nCache Hits: ").concat(t.hits, "\nCache Misses: ").concat(t.misses, "\nHit Rate: ").concat(t.hitRate.toFixed(2), "%\nEstimated CPU Saved: ").concat((null !== (e = t.cpuSaved) && void 0 !== e ? e : 0).toFixed(3), " CPU\n\nPerformance: ").concat(t.hitRate >= 80 ? "Excellent" : t.hitRate >= 60 ? "Good" : t.hitRate >= 40 ? "Fair" : "Poor");
}, e.prototype.resetCacheStats = function() {
return va.clear(Ea), "Cache statistics reset";
}, e.prototype.roomFindCacheStats = function() {
var e = function() {
var e = va.getCacheStats(ba);
return {
rooms: 0,
totalEntries: e.size,
hits: e.hits,
misses: e.misses,
invalidations: e.evictions,
hitRate: e.hitRate
};
}(), t = (100 * e.hitRate).toFixed(2), r = e.hits + e.misses, o = (.05 * e.hits).toFixed(3);
return "=== Room.find() Cache Statistics ===\nCached Rooms: ".concat(e.rooms, "\nTotal Entries: ").concat(e.totalEntries, "\nAvg Entries/Room: ").concat("0", "\n\nTotal Queries: ").concat(r, "\nCache Hits: ").concat(e.hits, "\nCache Misses: ").concat(e.misses, "\nHit Rate: ").concat(t, "%\n\nCache Invalidations: ").concat(e.invalidations, "\nEstimated CPU Saved: ~").concat(o, " CPU this tick\n\nPerformance: ").concat(e.hitRate >= .8 ? "Excellent " : e.hitRate >= .6 ? "Good" : e.hitRate >= .5 ? "Fair" : "Poor - Consider more caching");
}, e.prototype.clearRoomFindCache = function() {
return va.clear(ba), "Room.find() cache cleared and statistics reset";
}, e.prototype.toggleProfiling = function() {
var e = !mo().profiling;
return po({
profiling: e
}), Io.unifiedStats.setEnabled(e), xr({
cpuLogging: e
}), "Profiling: ".concat(e ? "ENABLED" : "DISABLED");
}, e.prototype.cpuBreakdown = function(e) {
var t, o, n, a, i, s, c, l, u = Memory.stats;
if (!u) return "No stats available. Stats collection may be disabled.";
var f = !e, m = [ "=== CPU Breakdown ===" ];
if (m.push("Tick: ".concat(u.tick)), m.push("Total CPU: ".concat(u.cpu.used.toFixed(2), "/").concat(u.cpu.limit, " (").concat(u.cpu.percent.toFixed(1), "%)")), 
m.push("Bucket: ".concat(u.cpu.bucket)), m.push(""), f || "process" === e) {
var p = u.processes || {}, d = Object.values(p);
if (d.length > 0) {
m.push("=== Process CPU Usage ===");
var y = d.sort(function(e, t) {
return t.avg_cpu - e.avg_cpu;
});
try {
for (var g = r(y.slice(0, 10)), h = g.next(); !h.done; h = g.next()) {
var v = h.value;
m.push("  ".concat(v.name, ": ").concat(v.avg_cpu.toFixed(3), " CPU (runs: ").concat(v.run_count, ", max: ").concat(v.max_cpu.toFixed(3), ")"));
}
} catch (e) {
t = {
error: e
};
} finally {
try {
h && !h.done && (o = g.return) && o.call(g);
} finally {
if (t) throw t.error;
}
}
m.push("");
}
}
if (f || "room" === e) {
var R = u.rooms || {}, E = Object.values(R);
if (E.length > 0) {
m.push("=== Room CPU Usage ==="), y = E.sort(function(e, t) {
return t.profiler.avg_cpu - e.profiler.avg_cpu;
});
try {
for (var T = r(y), S = T.next(); !S.done; S = T.next()) {
var C = S.value, b = C.name || "unknown";
m.push("  ".concat(b, ": ").concat(C.profiler.avg_cpu.toFixed(3), " CPU (RCL ").concat(C.rcl, ")"));
}
} catch (e) {
n = {
error: e
};
} finally {
try {
S && !S.done && (a = T.return) && a.call(T);
} finally {
if (n) throw n.error;
}
}
m.push("");
}
}
if (f || "subsystem" === e) {
var _ = u.subsystems || {}, O = Object.values(_);
if (O.length > 0) {
m.push("=== Subsystem CPU Usage ==="), y = O.sort(function(e, t) {
return t.avg_cpu - e.avg_cpu;
});
try {
for (var w = r(y.slice(0, 10)), x = w.next(); !x.done; x = w.next()) {
var U = x.value, M = U.name || "unknown";
m.push("  ".concat(M, ": ").concat(U.avg_cpu.toFixed(3), " CPU (calls: ").concat(U.calls, ")"));
}
} catch (e) {
i = {
error: e
};
} finally {
try {
x && !x.done && (s = w.return) && s.call(w);
} finally {
if (i) throw i.error;
}
}
m.push("");
}
}
if (f || "creep" === e) {
var A = u.creeps || {}, k = Object.values(A);
if (k.length > 0) {
m.push("=== Top Creeps by CPU (Top 10) ==="), y = k.sort(function(e, t) {
return t.cpu - e.cpu;
});
try {
for (var N = r(y.slice(0, 10)), P = N.next(); !P.done; P = N.next()) {
var I = P.value;
if (I.cpu > 0) {
var G = I.name || "".concat(I.role, "_unknown");
m.push("  ".concat(G, " (").concat(I.role, "): ").concat(I.cpu.toFixed(3), " CPU in ").concat(I.current_room));
}
}
} catch (e) {
c = {
error: e
};
} finally {
try {
P && !P.done && (l = N.return) && l.call(N);
} finally {
if (c) throw c.error;
}
}
m.push("");
}
}
return m.join("\n");
}, e.prototype.cpuBudget = function() {
var e, t, o, n, a = Io.unifiedStats.validateBudgets(), i = "=== CPU Budget Report (Tick ".concat(a.tick, ") ===\n");
if (i += "Rooms Evaluated: ".concat(a.roomsEvaluated, "\n"), i += "Within Budget: ".concat(a.roomsWithinBudget, "\n"), 
i += "Over Budget: ".concat(a.roomsOverBudget, "\n\n"), 0 === a.alerts.length) i += " All rooms within budget!\n"; else {
i += "Alerts: ".concat(a.alerts.length, "\n");
var s = a.alerts.filter(function(e) {
return "critical" === e.severity;
}), c = a.alerts.filter(function(e) {
return "warning" === e.severity;
});
if (s.length > 0) {
i += "\n CRITICAL (100% of budget):\n";
try {
for (var l = r(s), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
i += "  ".concat(f.target, ": ").concat(f.cpuUsed.toFixed(3), " CPU / ").concat(f.budgetLimit.toFixed(3), " limit (").concat((100 * f.percentUsed).toFixed(1), "%)\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
}
if (c.length > 0) {
i += "\n  WARNING (80% of budget):\n";
try {
for (var m = r(c), p = m.next(); !p.done; p = m.next()) f = p.value, i += "  ".concat(f.target, ": ").concat(f.cpuUsed.toFixed(3), " CPU / ").concat(f.budgetLimit.toFixed(3), " limit (").concat((100 * f.percentUsed).toFixed(1), "%)\n");
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
}
}
return i;
}, e.prototype.cpuAnomalies = function() {
var e, t, o, n, a = Io.unifiedStats.detectAnomalies();
if (0 === a.length) return " No CPU anomalies detected";
var i = "=== CPU Anomalies Detected: ".concat(a.length, " ===\n\n"), s = a.filter(function(e) {
return "spike" === e.type;
}), c = a.filter(function(e) {
return "sustained_high" === e.type;
});
if (s.length > 0) {
i += " CPU Spikes (".concat(s.length, "):\n");
try {
for (var l = r(s), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
i += "  ".concat(f.target, ": ").concat(f.current.toFixed(3), " CPU (").concat(f.multiplier.toFixed(1), "x baseline ").concat(f.baseline.toFixed(3), ")\n"), 
f.context && (i += "    Context: ".concat(f.context, "\n"));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
i += "\n";
}
if (c.length > 0) {
i += " Sustained High Usage (".concat(c.length, "):\n");
try {
for (var m = r(c), p = m.next(); !p.done; p = m.next()) f = p.value, i += "  ".concat(f.target, ": ").concat(f.current.toFixed(3), " CPU (").concat(f.multiplier.toFixed(1), "x budget ").concat(f.baseline.toFixed(3), ")\n"), 
f.context && (i += "    Context: ".concat(f.context, "\n"));
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
}
return i;
}, e.prototype.cpuProfile = function(e) {
var t, o, n, a;
void 0 === e && (e = !1);
var i = Io.unifiedStats.getCurrentSnapshot(), s = "=== CPU Profile (Tick ".concat(i.tick, ") ===\n");
s += "Total: ".concat(i.cpu.used.toFixed(2), " / ").concat(i.cpu.limit, " (").concat(i.cpu.percent.toFixed(1), "%)\n"), 
s += "Bucket: ".concat(i.cpu.bucket, "\n"), s += "Heap: ".concat(i.cpu.heapUsed.toFixed(2), " MB\n\n");
var c = Object.values(i.rooms).sort(function(e, t) {
return t.profiler.avgCpu - e.profiler.avgCpu;
}), l = e ? c : c.slice(0, 10);
s += "Top ".concat(l.length, " Rooms by CPU:\n");
try {
for (var u = r(l), f = u.next(); !f.done; f = u.next()) {
var m = f.value, p = Io.unifiedStats.postureCodeToName(m.brain.postureCode);
s += "  ".concat(m.name, " (RCL").concat(m.rcl, ", ").concat(p, "): avg ").concat(m.profiler.avgCpu.toFixed(3), " | peak ").concat(m.profiler.peakCpu.toFixed(3), " | samples ").concat(m.profiler.samples, "\n");
}
} catch (e) {
t = {
error: e
};
} finally {
try {
f && !f.done && (o = u.return) && o.call(u);
} finally {
if (t) throw t.error;
}
}
s += "\nTop Kernel Processes by CPU:\n";
var d = Object.values(i.processes).filter(function(e) {
return e.avgCpu > .001;
}).sort(function(e, t) {
return t.avgCpu - e.avgCpu;
}).slice(0, e ? 999 : 10);
try {
for (var y = r(d), g = y.next(); !g.done; g = y.next()) {
var h = g.value, v = h.cpuBudget > 0 ? (h.avgCpu / h.cpuBudget * 100).toFixed(0) : "N/A";
s += "  ".concat(h.name, " (").concat(h.frequency, "): avg ").concat(h.avgCpu.toFixed(3), " / budget ").concat(h.cpuBudget.toFixed(3), " (").concat(v, "%)\n");
}
} catch (e) {
n = {
error: e
};
} finally {
try {
g && !g.done && (a = y.return) && a.call(y);
} finally {
if (n) throw n.error;
}
}
return s;
}, t([ ro({
name: "showStats",
description: "Show current bot statistics from memory segment",
usage: "showStats()",
examples: [ "showStats()" ],
category: "Statistics"
}) ], e.prototype, "showStats", null), t([ ro({
name: "cacheStats",
description: "Show object cache statistics (hits, misses, hit rate, CPU savings)",
usage: "cacheStats()",
examples: [ "cacheStats()" ],
category: "Statistics"
}) ], e.prototype, "cacheStats", null), t([ ro({
name: "resetCacheStats",
description: "Reset cache statistics counters (for benchmarking)",
usage: "resetCacheStats()",
examples: [ "resetCacheStats()" ],
category: "Statistics"
}) ], e.prototype, "resetCacheStats", null), t([ ro({
name: "roomFindCacheStats",
description: "Show room.find() cache statistics (hits, misses, hit rate)",
usage: "roomFindCacheStats()",
examples: [ "roomFindCacheStats()" ],
category: "Statistics"
}) ], e.prototype, "roomFindCacheStats", null), t([ ro({
name: "clearRoomFindCache",
description: "Clear all room.find() cache entries and reset stats",
usage: "clearRoomFindCache()",
examples: [ "clearRoomFindCache()" ],
category: "Statistics"
}) ], e.prototype, "clearRoomFindCache", null), t([ ro({
name: "toggleProfiling",
description: "Toggle CPU profiling on/off",
usage: "toggleProfiling()",
examples: [ "toggleProfiling()" ],
category: "Statistics"
}) ], e.prototype, "toggleProfiling", null), t([ ro({
name: "cpuBreakdown",
description: "Show detailed CPU breakdown by process, room, creep, and subsystem",
usage: "cpuBreakdown(type?)",
examples: [ "cpuBreakdown() // Show all breakdowns", "cpuBreakdown('process') // Show only process breakdown", "cpuBreakdown('room') // Show only room breakdown", "cpuBreakdown('creep') // Show only creep breakdown", "cpuBreakdown('subsystem') // Show only subsystem breakdown" ],
category: "Statistics"
}) ], e.prototype, "cpuBreakdown", null), t([ ro({
name: "cpuBudget",
description: "Show CPU budget status and violations for all rooms",
usage: "cpuBudget()",
examples: [ "cpuBudget()" ],
category: "Statistics"
}) ], e.prototype, "cpuBudget", null), t([ ro({
name: "cpuAnomalies",
description: "Detect and show CPU usage anomalies (spikes and sustained high usage)",
usage: "cpuAnomalies()",
examples: [ "cpuAnomalies()" ],
category: "Statistics"
}) ], e.prototype, "cpuAnomalies", null), t([ ro({
name: "cpuProfile",
description: "Show comprehensive CPU profiling breakdown by room and subsystem",
usage: "cpuProfile(showAll?)",
examples: [ "cpuProfile()", "cpuProfile(true)" ],
category: "Statistics"
}) ], e.prototype, "cpuProfile", null), e;
}(), ad = function() {
function e() {}
return e.prototype.showConfig = function() {
var e = mo(), t = Ur();
return "=== SwarmBot Config ===\nDebug: ".concat(String(e.debug), "\nProfiling: ").concat(String(e.profiling), "\nVisualizations: ").concat(String(e.visualizations), "\nLogger Level: ").concat(Cr[t.level], "\nCPU Logging: ").concat(String(t.cpuLogging));
}, t([ ro({
name: "showConfig",
description: "Show current bot configuration",
usage: "showConfig()",
examples: [ "showConfig()" ],
category: "Configuration"
}) ], e.prototype, "showConfig", null), e;
}(), id = function() {
function e() {}
return e.prototype.showKernelStats = function() {
var e, t, o, n, a = Ko.getStatsSummary(), i = Ko.getConfig(), s = Ko.getBucketMode(), c = "=== Kernel Stats ===\nBucket Mode: ".concat(s.toUpperCase(), "\nCPU Bucket: ").concat(Game.cpu.bucket, "\nCPU Limit: ").concat(Ko.getCpuLimit().toFixed(2), " (").concat((100 * i.targetCpuUsage).toFixed(0), "% of ").concat(Game.cpu.limit, ")\nRemaining CPU: ").concat(Ko.getRemainingCpu().toFixed(2), "\n\nProcesses: ").concat(a.totalProcesses, " total (").concat(a.activeProcesses, " active, ").concat(a.suspendedProcesses, " suspended)\nTotal CPU Used: ").concat(a.totalCpuUsed.toFixed(3), "\nAvg CPU/Process: ").concat(a.avgCpuPerProcess.toFixed(4), "\nAvg Health Score: ").concat(a.avgHealthScore.toFixed(1), "/100\n\nTop CPU Consumers:");
try {
for (var l = r(a.topCpuProcesses), u = l.next(); !u.done; u = l.next()) {
var f = u.value;
c += "\n  ".concat(f.name, ": ").concat(f.avgCpu.toFixed(4), " avg CPU");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
u && !u.done && (t = l.return) && t.call(l);
} finally {
if (e) throw e.error;
}
}
if (a.unhealthyProcesses.length > 0) {
c += "\n\nUnhealthy Processes (Health < 50):";
try {
for (var m = r(a.unhealthyProcesses), p = m.next(); !p.done; p = m.next()) f = p.value, 
c += "\n  ".concat(f.name, ": ").concat(f.healthScore.toFixed(1), "/100 (").concat(f.consecutiveErrors, " consecutive errors)");
} catch (e) {
o = {
error: e
};
} finally {
try {
p && !p.done && (n = m.return) && n.call(m);
} finally {
if (o) throw o.error;
}
}
}
return c;
}, e.prototype.listProcesses = function() {
var e, t, a = Ko.getProcesses();
if (0 === a.length) return "No processes registered with kernel.";
var i = "=== Registered Processes ===\n";
i += "ID | Name | Priority | Frequency | State | Runs | Avg CPU | Health | Errors\n", 
i += "-".repeat(100) + "\n";
var s = n([], o(a), !1).sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var c = r(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = u.stats.avgCpu.toFixed(4), m = u.stats.healthScore.toFixed(0), p = u.stats.healthScore >= 80 ? "" : u.stats.healthScore >= 50 ? "" : "";
i += "".concat(u.id, " | ").concat(u.name, " | ").concat(u.priority, " | ").concat(u.frequency, " | ").concat(u.state, " | ").concat(u.stats.runCount, " | ").concat(f, " | ").concat(p).concat(m, " | ").concat(u.stats.errorCount, "(").concat(u.stats.consecutiveErrors, ")\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return i;
}, e.prototype.suspendProcess = function(e) {
var t = Ko.suspendProcess(e);
return 'Process "'.concat(e, t ? '" suspended.' : '" not found.');
}, e.prototype.resumeProcess = function(e) {
var t = Ko.resumeProcess(e);
return 'Process "'.concat(e, t ? '" resumed.' : '" not found or not suspended.');
}, e.prototype.resetKernelStats = function() {
return Ko.resetStats(), "Kernel statistics reset.";
}, e.prototype.showProcessHealth = function() {
var e, t, a = Ko.getProcesses();
if (0 === a.length) return "No processes registered with kernel.";
var i = n([], o(a), !1).sort(function(e, t) {
return e.stats.healthScore - t.stats.healthScore;
}), s = "=== Process Health Status ===\n";
s += "Name | Health | Errors | Consecutive | Status | Last Success\n", s += "-".repeat(80) + "\n";
try {
for (var c = r(i), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = u.stats.healthScore.toFixed(0), m = u.stats.healthScore >= 80 ? "" : u.stats.healthScore >= 50 ? "" : "", p = u.stats.lastSuccessfulRunTick > 0 ? Game.time - u.stats.lastSuccessfulRunTick : "never", d = "suspended" === u.state ? "SUSPENDED (".concat(u.stats.suspensionReason, ")") : u.state.toUpperCase();
s += "".concat(u.name, " | ").concat(m, " ").concat(f, "/100 | ").concat(u.stats.errorCount, " | ").concat(u.stats.consecutiveErrors, " | ").concat(d, " | ").concat(p, "\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
var y = Ko.getStatsSummary();
return (s += "\nAverage Health: ".concat(y.avgHealthScore.toFixed(1), "/100")) + "\nSuspended Processes: ".concat(y.suspendedProcesses);
}, e.prototype.resumeAllProcesses = function() {
var e, t, o = Ko.getProcesses().filter(function(e) {
return "suspended" === e.state;
});
if (0 === o.length) return "No suspended processes to resume.";
var n = 0;
try {
for (var a = r(o), i = a.next(); !i.done; i = a.next()) {
var s = i.value;
Ko.resumeProcess(s.id) && n++;
}
} catch (t) {
e = {
error: t
};
} finally {
try {
i && !i.done && (t = a.return) && t.call(a);
} finally {
if (e) throw e.error;
}
}
return "Resumed ".concat(n, " of ").concat(o.length, " suspended processes.");
}, e.prototype.showCreepStats = function() {
var e, t, n = Wf.getStats(), a = "=== Creep Process Stats ===\nTotal Creeps: ".concat(n.totalCreeps, "\nRegistered Processes: ").concat(n.registeredCreeps, "\n\nCreeps by Priority:");
try {
for (var i = r(Object.entries(n.creepsByPriority)), s = i.next(); !s.done; s = i.next()) {
var c = o(s.value, 2), l = c[0], u = c[1];
a += "\n  ".concat(l, ": ").concat(u);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return a;
}, e.prototype.showRoomStats = function() {
var e, t, n = Zm.getStats(), a = "=== Room Process Stats ===\nTotal Rooms: ".concat(n.totalRooms, "\nRegistered Processes: ").concat(n.registeredRooms, "\nOwned Rooms: ").concat(n.ownedRooms, "\n\nRooms by Priority:");
try {
for (var i = r(Object.entries(n.roomsByPriority)), s = i.next(); !s.done; s = i.next()) {
var c = o(s.value, 2), l = c[0], u = c[1];
a += "\n  ".concat(l, ": ").concat(u);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
s && !s.done && (t = i.return) && t.call(i);
} finally {
if (e) throw e.error;
}
}
return a;
}, e.prototype.listCreepProcesses = function(e) {
var t, a, i = Ko.getProcesses().filter(function(e) {
return e.id.startsWith("creep:");
});
if (e && (i = i.filter(function(t) {
return t.name.includes("(".concat(e, ")"));
})), 0 === i.length) return e ? "No creep processes found with role: ".concat(e) : "No creep processes registered.";
var s = e ? "=== Creep Processes (Role: ".concat(e, ") ===\n") : "=== All Creep Processes ===\n";
s += "Name | Priority | Runs | Avg CPU | Errors\n", s += "-".repeat(70) + "\n";
var c = n([], o(i), !1).sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var l = r(c), u = l.next(); !u.done; u = l.next()) {
var f = u.value, m = f.stats.avgCpu.toFixed(4);
s += "".concat(f.name, " | ").concat(f.priority, " | ").concat(f.stats.runCount, " | ").concat(m, " | ").concat(f.stats.errorCount, "\n");
}
} catch (e) {
t = {
error: e
};
} finally {
try {
u && !u.done && (a = l.return) && a.call(l);
} finally {
if (t) throw t.error;
}
}
return s + "\nTotal: ".concat(i.length, " creep processes");
}, e.prototype.listRoomProcesses = function() {
var e, t, a = Ko.getProcesses().filter(function(e) {
return e.id.startsWith("room:");
});
if (0 === a.length) return "No room processes registered.";
var i = "=== Room Processes ===\n";
i += "Name | Priority | Runs | Avg CPU | Errors\n", i += "-".repeat(70) + "\n";
var s = n([], o(a), !1).sort(function(e, t) {
return t.priority - e.priority;
});
try {
for (var c = r(s), l = c.next(); !l.done; l = c.next()) {
var u = l.value, f = u.stats.avgCpu.toFixed(4);
i += "".concat(u.name, " | ").concat(u.priority, " | ").concat(u.stats.runCount, " | ").concat(f, " | ").concat(u.stats.errorCount, "\n");
}
} catch (t) {
e = {
error: t
};
} finally {
try {
l && !l.done && (t = c.return) && t.call(c);
} finally {
if (e) throw e.error;
}
}
return i + "\nTotal: ".concat(a.length, " room processes");
}, t([ ro({
name: "showKernelStats",
description: "Show kernel statistics including CPU usage and process info",
usage: "showKernelStats()",
examples: [ "showKernelStats()" ],
category: "Kernel"
}) ], e.prototype, "showKernelStats", null), t([ ro({
name: "listProcesses",
description: "List all registered kernel processes",
usage: "listProcesses()",
examples: [ "listProcesses()" ],
category: "Kernel"
}) ], e.prototype, "listProcesses", null), t([ ro({
name: "suspendProcess",
description: "Suspend a kernel process by ID",
usage: "suspendProcess(processId)",
examples: [ "suspendProcess('empire:manager')", "suspendProcess('cluster:manager')" ],
category: "Kernel"
}) ], e.prototype, "suspendProcess", null), t([ ro({
name: "resumeProcess",
description: "Resume a suspended kernel process",
usage: "resumeProcess(processId)",
examples: [ "resumeProcess('empire:manager')" ],
category: "Kernel"
}) ], e.prototype, "resumeProcess", null), t([ ro({
name: "resetKernelStats",
description: "Reset all kernel process statistics",
usage: "resetKernelStats()",
examples: [ "resetKernelStats()" ],
category: "Kernel"
}) ], e.prototype, "resetKernelStats", null), t([ ro({
name: "showProcessHealth",
description: "Show health status of all processes with detailed metrics",
usage: "showProcessHealth()",
examples: [ "showProcessHealth()" ],
category: "Kernel"
}) ], e.prototype, "showProcessHealth", null), t([ ro({
name: "resumeAllProcesses",
description: "Resume all suspended processes (use with caution)",
usage: "resumeAllProcesses()",
examples: [ "resumeAllProcesses()" ],
category: "Kernel"
}) ], e.prototype, "resumeAllProcesses", null), t([ ro({
name: "showCreepStats",
description: "Show statistics about creep processes managed by the kernel",
usage: "showCreepStats()",
examples: [ "showCreepStats()" ],
category: "Kernel"
}) ], e.prototype, "showCreepStats", null), t([ ro({
name: "showRoomStats",
description: "Show statistics about room processes managed by the kernel",
usage: "showRoomStats()",
examples: [ "showRoomStats()" ],
category: "Kernel"
}) ], e.prototype, "showRoomStats", null), t([ ro({
name: "listCreepProcesses",
description: "List all creep processes with their details",
usage: "listCreepProcesses(role?)",
examples: [ "listCreepProcesses()", "listCreepProcesses('harvester')" ],
category: "Kernel"
}) ], e.prototype, "listCreepProcesses", null), t([ ro({
name: "listRoomProcesses",
description: "List all room processes with their details",
usage: "listRoomProcesses()",
examples: [ "listRoomProcesses()" ],
category: "Kernel"
}) ], e.prototype, "listRoomProcesses", null), e;
}(), sd = function() {
function e() {}
return e.prototype.listCommands = function() {
return to.generateHelp();
}, e.prototype.commandHelp = function(e) {
return to.generateCommandHelp(e);
}, t([ ro({
name: "listCommands",
description: "List all available commands (alias for help)",
usage: "listCommands()",
examples: [ "listCommands()" ],
category: "System"
}) ], e.prototype, "listCommands", null), t([ ro({
name: "commandHelp",
description: "Get detailed help for a specific command",
usage: "commandHelp(commandName)",
examples: [ "commandHelp('setLogLevel')", "commandHelp('suspendProcess')" ],
category: "System"
}) ], e.prototype, "commandHelp", null), e;
}(), cd = new rd, ld = new od, ud = new nd, fd = new ad, md = new id, pd = new sd, dd = jr("Main");

!function(e) {
void 0 === e && (e = !1);
var t = function() {
to.initialize(), oo(cd), oo(ld), oo(ud), oo(fd), oo(md), oo(pd), oo(Dp), oo(Fp), 
oo(Bp), oo(Hp), oo(Vp), oo(qp), oo(Zp), global.tooangel = Xp;
var e = global;
e.botConfig = {
getConfig: mo,
updateConfig: po
}, e.botLogger = {
configureLogger: xr
}, e.botVisualizationManager = td, e.botCacheManager = va, to.exposeToGlobal();
};
e ? (to.initialize(), to.enableLazyLoading(t), to.exposeToGlobal()) : t();
}(mo().lazyLoadConsoleCommands);

var yd = Jr.wrapLoop(function() {
try {
!function() {
var e, t;
Np && Game.time % 10 != 0 || Hr.info("SwarmBot loop executing at tick ".concat(Game.time), {
subsystem: "SwarmBot",
meta: {
systemsInitialized: Np
}
}), Np || (xr({
level: (t = mo()).debug ? Cr.DEBUG : Cr.INFO,
cpuLogging: t.profiling,
enableBatching: !0,
maxBatchSize: 50
}), Hr.info("Bot initialized", {
subsystem: "SwarmBot",
meta: {
debug: t.debug,
profiling: t.profiling
}
}), Io.unifiedStats.initialize(), t.profiling && (function() {
if (PathFinder.search && !PathFinder.search.__nativeCallsTrackerWrapped) {
var e = Object.getOwnPropertyDescriptor(PathFinder, "search");
if (e && !1 === e.configurable) Nu.warn("Cannot wrap PathFinder.search - property is not configurable"); else {
var t = PathFinder.search;
try {
var r = function() {
for (var e = [], r = 0; r < arguments.length; r++) e[r] = arguments[r];
return Io.unifiedStats.recordNativeCall("pathfinderSearch"), t.apply(PathFinder, e);
};
r.__nativeCallsTrackerWrapped = !0, Object.defineProperty(PathFinder, "search", {
value: r,
writable: !0,
enumerable: !0,
configurable: !0
});
} catch (e) {
Nu.warn("Failed to wrap PathFinder.search", {
meta: {
error: String(e)
}
});
}
}
}
}(), Pu(e = Creep.prototype, "moveTo", "moveTo"), Pu(e, "move", "move"), Pu(e, "harvest", "harvest"), 
Pu(e, "transfer", "transfer"), Pu(e, "withdraw", "withdraw"), Pu(e, "build", "build"), 
Pu(e, "repair", "repair"), Pu(e, "upgradeController", "upgradeController"), Pu(e, "attack", "attack"), 
Pu(e, "rangedAttack", "rangedAttack"), Pu(e, "heal", "heal"), Pu(e, "dismantle", "dismantle"), 
Pu(e, "say", "say")), Ko.on("structure.destroyed", function(e) {
var t = fi.getSwarmState(e.roomName);
t && (xu.onStructureDestroyed(t, e.structureType), Hr.debug("Pheromone update: structure destroyed in ".concat(e.roomName), {
subsystem: "Pheromone",
room: e.roomName
}));
}), Ko.on("remote.lost", function(e) {
var t = fi.getSwarmState(e.homeRoom);
t && (xu.onRemoteSourceLost(t), Hr.info("Pheromone update: remote source lost for ".concat(e.homeRoom), {
subsystem: "Pheromone",
room: e.homeRoom
}));
}), Hr.info("Pheromone event handlers initialized", {
subsystem: "Pheromone"
}), _p.initializePathCacheEvents(), vp.initialize(qn.TaskPriority.MEDIUM), qr.initialize(), 
qi.initialize(), Np = !0), Ko.updateFromCpuConfig(mo().cpu), kp || (Hr.info("Registering all processes with kernel...", {
subsystem: "ProcessRegistry"
}), Hi(ku, pl.terminalManager, pl.factoryManager, pl.linkManager, Ul, kl, nu, pl.marketManager, jl, Yl, Dl, zl, Jl, qi, su, bu, Zc, qc.evacuationManager, qc.defenseCoordinator), 
Hr.info("Registered ".concat(Ko.getProcesses().length, " processes with kernel"), {
subsystem: "ProcessRegistry"
}), Ko.initialize(), kp = !0), Io.unifiedStats.startTick(), "critical" === Ko.getBucketMode() && Game.time % 10 == 0 && Hr.warn("CRITICAL: CPU bucket at ".concat(Game.cpu.bucket, ", continuing normal processing"), {
subsystem: "SwarmBot"
}), Ss.clear(), ps.clear(), lo.startTick();
var o, n = "_ownedRooms", a = "_ownedRoomsTick", i = global, s = i[n], c = i[a];
s && c === Game.time ? o = s : (o = Object.values(Game.rooms).filter(function(e) {
var t;
return null === (t = e.controller) || void 0 === t ? void 0 : t.my;
}), i[n] = o, i[a] = Game.time), Es.preTick(), fi.initialize(), Io.unifiedStats.measureSubsystem("processSync", function() {
Wf.syncCreepProcesses(), Zm.syncRoomProcesses();
}), Io.unifiedStats.measureSubsystem("kernel", function() {
Ko.run();
}), Io.unifiedStats.measureSubsystem("eventQueue", function() {
lo.processQueue();
}), Io.unifiedStats.measureSubsystem("spawns", function() {
!function() {
var e, t, o;
try {
for (var n = r(Object.values(Game.rooms)), a = n.next(); !a.done; a = n.next()) {
var i = a.value;
(null === (o = i.controller) || void 0 === o ? void 0 : o.my) && us(i, fi.getOrInitSwarmState(i.name));
}
} catch (t) {
e = {
error: t
};
} finally {
try {
a && !a.done && (t = n.return) && t.call(n);
} finally {
if (e) throw e.error;
}
}
}();
}), Io.unifiedStats.measureSubsystem("ss2PacketQueue", function() {
wp.processQueue();
}), Ko.hasCpuBudget() && Io.unifiedStats.measureSubsystem("powerCreeps", function() {
!function() {
var e, t;
try {
for (var o = r(Object.values(Game.powerCreeps)), n = o.next(); !n.done; n = o.next()) {
var a = n.value;
void 0 !== a.ticksToLive && Lf(a);
}
} catch (t) {
e = {
error: t
};
} finally {
try {
n && !n.done && (t = o.return) && t.call(o);
} finally {
if (e) throw e.error;
}
}
}();
}), Ko.hasCpuBudget() && Io.unifiedStats.measureSubsystem("visualizations", function() {
Pp();
}), Es.reconcileTraffic(), Ko.hasCpuBudget() && Io.unifiedStats.measureSubsystem("scheduledTasks", function() {
var e = Math.max(0, Game.cpu.limit - Game.cpu.getUsed());
qn.runScheduledTasks(e);
}), fi.persistHeapCache(), Io.unifiedStats.collectProcessStats(Ko.getProcesses().reduce(function(e, t) {
return e.set(t.id, t), e;
}, new Map)), Io.unifiedStats.collectKernelBudgetStats(Ko), Io.unifiedStats.setSkippedProcesses(Ko.getSkippedProcessesThisTick()), 
Io.unifiedStats.finalizeTick(), Hr.flush();
}();
} catch (e) {
throw dd.error("Critical error in main loop: ".concat(String(e)), {
meta: {
stack: e instanceof Error ? e.stack : void 0,
tick: Game.time
}
}), e;
}
});

exports.loop = yd;
